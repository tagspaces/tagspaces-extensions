/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve7) {
      resolve7(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve7, reject) {
    function fulfilled(value) {
      try {
        step3(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step3(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step3(result2) {
      result2.done ? resolve7(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step3((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
const docTypeError = (type) => new Error(`Doc type error, unsupported type: ${JSON.stringify(type)}`);
const contextNotFound = () => new Error("Context not found, do you forget to inject it?");
const timerNotFound = () => new Error("Timer not found, do you forget to record it?");
const ctxCallOutOfScope = () => new Error("Should not call a context out of the plugin.");
const createNodeInParserFail = (...args) => {
  const message2 = args.reduce((msg, arg) => {
    if (!arg) {
      return msg;
    }
    const serialize2 = (x2) => {
      if (Array.isArray(x2)) {
        return x2.map((y2) => serialize2(y2)).join(", ");
      }
      if (x2.toJSON) {
        return JSON.stringify(x2.toJSON());
      }
      if (x2.spec) {
        return JSON.stringify(x2.spec);
      }
      return x2.toString();
    };
    return `${msg}, ${serialize2(arg)}`;
  }, "Create prosemirror node from remark failed in parser");
  return new Error(message2);
};
const stackOverFlow = () => new Error("Stack over flow, cannot pop on an empty stack.");
const parserMatchError = (node5) => new Error(`Cannot match target parser for node: ${JSON.stringify(node5)}.`);
const serializerMatchError = (node5) => new Error(`Cannot match target serializer for node: ${JSON.stringify(node5)}.`);
const callCommandBeforeEditorView = () => new Error(`You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized`);
const createContainer = () => {
  const contextMap = new Map();
  const getCtx = (meta) => {
    const context = contextMap.get(meta.id);
    if (!context) {
      throw contextNotFound();
    }
    return context;
  };
  return { getCtx, contextMap };
};
var freeGlobal$2 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$3 = freeGlobal$2;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal$3 || freeSelf$1 || Function("return this")();
var root$a = root$9;
var Symbol$5 = root$a.Symbol;
var Symbol$6 = Symbol$5;
var objectProto$j = Object.prototype;
var hasOwnProperty$g = objectProto$j.hasOwnProperty;
var nativeObjectToString$3 = objectProto$j.toString;
var symToStringTag$3 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$g.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result2 = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result2;
}
var objectProto$i = Object.prototype;
var nativeObjectToString$2 = objectProto$i.toString;
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function baseGetTag$6(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$2(value) : objectToString$2(value);
}
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var isArray$4 = Array.isArray;
var isArray$5 = isArray$4;
function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag$1 = "[object AsyncFunction]", funcTag$4 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$3(value)) {
    return false;
  }
  var tag = baseGetTag$6(value);
  return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
}
var coreJsData$2 = root$a["__core-js_shared__"];
var coreJsData$3 = coreJsData$2;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$3 && coreJsData$3.keys && coreJsData$3.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$2(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$3 = Function.prototype;
var funcToString$3 = funcProto$3.toString;
function toSource$3(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$2 = Function.prototype, objectProto$h = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$f = objectProto$h.hasOwnProperty;
var reIsNative$1 = RegExp("^" + funcToString$2.call(hasOwnProperty$f).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$2(value) {
  if (!isObject$3(value) || isMasked$2(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$3(value));
}
function getValue$2(object, key2) {
  return object == null ? void 0 : object[key2];
}
function getNative$6(object, key2) {
  var value = getValue$2(object, key2);
  return baseIsNative$2(value) ? value : void 0;
}
var WeakMap$3 = getNative$6(root$a, "WeakMap");
var WeakMap$4 = WeakMap$3;
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$3(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate$1 = baseCreate;
function copyArray$2(source, array) {
  var index3 = -1, length = source.length;
  array || (array = Array(length));
  while (++index3 < length) {
    array[index3] = source[index3];
  }
  return array;
}
var defineProperty$1 = function() {
  try {
    var func = getNative$6(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
var defineProperty$2 = defineProperty$1;
function arrayEach(array, iteratee) {
  var index3 = -1, length = array == null ? 0 : array.length;
  while (++index3 < length) {
    if (iteratee(array[index3], index3, array) === false) {
      break;
    }
  }
  return array;
}
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function baseAssignValue(object, key2, value) {
  if (key2 == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
function assignValue(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$e.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index3 = -1, length = props.length;
  while (++index3 < length) {
    var key2 = props[index3];
    var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object, key2, newValue);
    } else {
      assignValue(object, key2, newValue);
    }
  }
  return object;
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
function isArrayLike$3(value) {
  return value != null && isLength$3(value.length) && !isFunction$3(value);
}
var objectProto$f = Object.prototype;
function isPrototype$2(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$f;
  return value === proto2;
}
function baseTimes$2(n2, iteratee) {
  var index3 = -1, result2 = Array(n2);
  while (++index3 < n2) {
    result2[index3] = iteratee(index3);
  }
  return result2;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments$2(value) {
  return isObjectLike$5(value) && baseGetTag$6(value) == argsTag$4;
}
var objectProto$e = Object.prototype;
var hasOwnProperty$d = objectProto$e.hasOwnProperty;
var propertyIsEnumerable$2 = objectProto$e.propertyIsEnumerable;
var isArguments$2 = baseIsArguments$2(function() {
  return arguments;
}()) ? baseIsArguments$2 : function(value) {
  return isObjectLike$5(value) && hasOwnProperty$d.call(value, "callee") && !propertyIsEnumerable$2.call(value, "callee");
};
var isArguments$3 = isArguments$2;
function stubFalse$1() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$a.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer$3 = nativeIsBuffer || stubFalse$1;
var isBuffer$4 = isBuffer$3;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$3 = "[object Function]", mapTag$7 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$5 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$3] = typedArrayTags$1[arrayTag$2] = typedArrayTags$1[arrayBufferTag$3] = typedArrayTags$1[boolTag$3] = typedArrayTags$1[dataViewTag$5] = typedArrayTags$1[dateTag$3] = typedArrayTags$1[errorTag$2] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$7] = typedArrayTags$1[numberTag$3] = typedArrayTags$1[objectTag$4] = typedArrayTags$1[regexpTag$3] = typedArrayTags$1[setTag$7] = typedArrayTags$1[stringTag$4] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$2(value) {
  return isObjectLike$5(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$6(value)];
}
function baseUnary$2(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$3.process;
var nodeUtil$1 = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e3) {
  }
}();
var nodeUtil$2 = nodeUtil$1;
var nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray$1 ? baseUnary$2(nodeIsTypedArray$1) : baseIsTypedArray$2;
var isTypedArray$3 = isTypedArray$2;
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$5(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$4(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes$2(value.length, String) : [], length = result2.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$c.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex$2(key2, length)))) {
      result2.push(key2);
    }
  }
  return result2;
}
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys$2 = overArg$2(Object.keys, Object);
var nativeKeys$3 = nativeKeys$2;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys$3(object);
  }
  var result2 = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$b.call(object, key2) && key2 != "constructor") {
      result2.push(key2);
    }
  }
  return result2;
}
function keys$5(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$2(object) : baseKeys$2(object);
}
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key2 in Object(object)) {
      result2.push(key2);
    }
  }
  return result2;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$3(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$2(object), result2 = [];
  for (var key2 in object) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$a.call(object, key2)))) {
      result2.push(key2);
    }
  }
  return result2;
}
function keysIn(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$2(object, true) : baseKeysIn(object);
}
var nativeCreate = getNative$6(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result2 = this.has(key2) && delete this.__data__[key2];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result2 = data[key2];
    return result2 === HASH_UNDEFINED$1 ? void 0 : result2;
  }
  return hasOwnProperty$9.call(data, key2) ? data[key2] : void 0;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$8.call(data, key2);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries) {
  var index3 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key2) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice$3 = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index3 = assocIndexOf(data, key2);
  if (index3 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index3 == lastIndex) {
    data.pop();
  } else {
    splice$3.call(data, index3, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index3 = assocIndexOf(data, key2);
  return index3 < 0 ? void 0 : data[index3][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data = this.__data__, index3 = assocIndexOf(data, key2);
  if (index3 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index3][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index3 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$3 = getNative$6(root$a, "Map");
var Map$4 = Map$3;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$4 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map21, key2) {
  var data = map21.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result2 = getMapData(this, key2)["delete"](key2);
  this.size -= result2 ? 1 : 0;
  return result2;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data = getMapData(this, key2), size2 = data.size;
  data.set(key2, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index3 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(array, values2) {
  var index3 = -1, length = values2.length, offset2 = array.length;
  while (++index3 < length) {
    array[offset2 + index3] = values2[index3];
  }
  return array;
}
var getPrototype = overArg$2(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result2 = data["delete"](key2);
  this.size = data.size;
  return result2;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source) {
  return object && copyObject(source, keys$5(source), object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root$a.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  if (isDeep) {
    return buffer2.slice();
  }
  var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
  buffer2.copy(result2);
  return result2;
}
function arrayFilter(array, predicate) {
  var index3 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index3 < length) {
    var value = array[index3];
    if (predicate(value, index3, array)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
function stubArray() {
  return [];
}
var objectProto$8 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result2 = [];
  while (object) {
    arrayPush(result2, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result2;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray$5(object) ? result2 : arrayPush(result2, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$5, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView$2 = getNative$6(root$a, "DataView");
var DataView$3 = DataView$2;
var Promise$3 = getNative$6(root$a, "Promise");
var Promise$4 = Promise$3;
var Set$3 = getNative$6(root$a, "Set");
var Set$4 = Set$3;
var mapTag$6 = "[object Map]", objectTag$3 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$6 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
var dataViewTag$4 = "[object DataView]";
var dataViewCtorString$1 = toSource$3(DataView$3), mapCtorString$1 = toSource$3(Map$4), promiseCtorString$1 = toSource$3(Promise$4), setCtorString$1 = toSource$3(Set$4), weakMapCtorString$1 = toSource$3(WeakMap$4);
var getTag$2 = baseGetTag$6;
if (DataView$3 && getTag$2(new DataView$3(new ArrayBuffer(1))) != dataViewTag$4 || Map$4 && getTag$2(new Map$4()) != mapTag$6 || Promise$4 && getTag$2(Promise$4.resolve()) != promiseTag$1 || Set$4 && getTag$2(new Set$4()) != setTag$6 || WeakMap$4 && getTag$2(new WeakMap$4()) != weakMapTag$3) {
  getTag$2 = function(value) {
    var result2 = baseGetTag$6(value), Ctor = result2 == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource$3(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$4;
        case mapCtorString$1:
          return mapTag$6;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$6;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result2;
  };
}
var getTag$3 = getTag$2;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result2 = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$7.call(array, "index")) {
    result2.index = array.index;
    result2.input = array.input;
  }
  return result2;
}
var Uint8Array = root$a.Uint8Array;
var Uint8Array$1 = Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result2).set(new Uint8Array$1(arrayBuffer));
  return result2;
}
function cloneDataView(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var symbolProto = Symbol$6 ? Symbol$6.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$5 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$3:
      return cloneDataView(object, isDeep);
    case float32Tag$2:
    case float64Tag$2:
    case int8Tag$2:
    case int16Tag$2:
    case int32Tag$2:
    case uint8Tag$2:
    case uint8ClampedTag$2:
    case uint16Tag$2:
    case uint32Tag$2:
      return cloneTypedArray(object, isDeep);
    case mapTag$5:
      return new Ctor();
    case numberTag$2:
    case stringTag$3:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$5:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype$2(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike$5(value) && getTag$3(value) == mapTag$4;
}
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike$5(value) && getTag$3(value) == setTag$4;
}
var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;
var isSet = nodeIsSet ? baseUnary$2(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$3 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$2] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$1] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$3] = cloneableTags[stringTag$2] = cloneableTags[symbolTag] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
function baseClone(value, bitmask, customizer, key2, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result2 = object ? customizer(value, key2, object, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject$3(value)) {
    return value;
  }
  var isArr = isArray$5(value);
  if (isArr) {
    result2 = initCloneArray(value);
    if (!isDeep) {
      return copyArray$2(value, result2);
    }
  } else {
    var tag = getTag$3(value), isFunc = tag == funcTag$2 || tag == genTag$1;
    if (isBuffer$4(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key3) {
      result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$5;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key3) {
    if (props) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
  });
  return result2;
}
var CLONE_SYMBOLS_FLAG = 4;
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}
function fromPairs(pairs) {
  var index3 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index3 < length) {
    var pair = pairs[index3];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
const createCtx = (value) => {
  const id2 = Symbol("Context");
  const factory2 = (container, resetValue = clone(value)) => {
    let inner = resetValue;
    const context = {
      id: id2,
      set: (next) => {
        inner = next;
      },
      get: () => inner,
      update: (updater) => {
        inner = updater(inner);
      }
    };
    container.set(id2, context);
    return context;
  };
  factory2.id = id2;
  factory2._typeInfo = () => {
    throw ctxCallOutOfScope();
  };
  return factory2;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var bail_1 = bail$1;
function bail$1(err2) {
  if (err2) {
    throw err2;
  }
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer$2 = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray$3 = function isArray(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject = function isPlainObject2(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn.call(obj, key2);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name) {
  if (name === "__proto__") {
    if (!hasOwn.call(obj, name)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name).value;
    }
  }
  return obj[name];
};
var extend$1 = function extend() {
  var options, name, src, copy6, copyIsArray, clone2;
  var target = arguments[0];
  var i2 = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i2 = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i2 < length; ++i2) {
    options = arguments[i2];
    if (options != null) {
      for (name in options) {
        src = getProperty(target, name);
        copy6 = getProperty(options, name);
        if (target !== copy6) {
          if (deep && copy6 && (isPlainObject(copy6) || (copyIsArray = isArray$3(copy6)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && isArray$3(src) ? src : [];
            } else {
              clone2 = src && isPlainObject(src) ? src : {};
            }
            setProperty(target, { name, newValue: extend(deep, clone2, copy6) });
          } else if (typeof copy6 !== "undefined") {
            setProperty(target, { name, newValue: copy6 });
          }
        }
      }
    }
  }
  return target;
};
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
var slice$2 = [].slice;
var wrap_1 = wrap$1;
function wrap$1(fn, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = slice$2.call(arguments, 0);
    var callback2 = fn.length > params.length;
    var result2;
    if (callback2) {
      params.push(done3);
    }
    try {
      result2 = fn.apply(null, params);
    } catch (error) {
      if (callback2 && invoked) {
        throw error;
      }
      return done3(error);
    }
    if (!callback2) {
      if (result2 && typeof result2.then === "function") {
        result2.then(then, done3);
      } else if (result2 instanceof Error) {
        done3(result2);
      } else {
        then(result2);
      }
    }
  }
  function done3() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value) {
    done3(null, value);
  }
}
var wrap = wrap_1;
var trough_1 = trough$1;
trough$1.wrap = wrap;
var slice$1 = [].slice;
function trough$1() {
  var fns = [];
  var middleware = {};
  middleware.run = run2;
  middleware.use = use;
  return middleware;
  function run2() {
    var index3 = -1;
    var input2 = slice$1.call(arguments, 0, -1);
    var done3 = arguments[arguments.length - 1];
    if (typeof done3 !== "function") {
      throw new Error("Expected function as last argument, not " + done3);
    }
    next.apply(null, [null].concat(input2));
    function next(err2) {
      var fn = fns[++index3];
      var params = slice$1.call(arguments, 0);
      var values2 = params.slice(1);
      var length = input2.length;
      var pos = -1;
      if (err2) {
        done3(err2);
        return;
      }
      while (++pos < length) {
        if (values2[pos] === null || values2[pos] === void 0) {
          values2[pos] = input2[pos];
        }
      }
      input2 = values2;
      if (fn) {
        wrap(fn, next).apply(null, input2);
      } else {
        done3.apply(null, [null].concat(input2));
      }
    }
  }
  function use(fn) {
    if (typeof fn !== "function") {
      throw new Error("Expected `fn` to be a function, not " + fn);
    }
    fns.push(fn);
    return middleware;
  }
}
var own$7 = {}.hasOwnProperty;
var unistUtilStringifyPosition = stringify$3;
function stringify$3(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if (own$7.call(value, "position") || own$7.call(value, "type")) {
    return position(value.position);
  }
  if (own$7.call(value, "start") || own$7.call(value, "end")) {
    return position(value);
  }
  if (own$7.call(value, "line") || own$7.call(value, "column")) {
    return point(value);
  }
  return "";
}
function point(point2) {
  if (!point2 || typeof point2 !== "object") {
    point2 = {};
  }
  return index(point2.line) + ":" + index(point2.column);
}
function position(pos) {
  if (!pos || typeof pos !== "object") {
    pos = {};
  }
  return point(pos.start) + "-" + point(pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
var stringify$2 = unistUtilStringifyPosition;
var vfileMessage = VMessage$1;
function VMessagePrototype() {
}
VMessagePrototype.prototype = Error.prototype;
VMessage$1.prototype = new VMessagePrototype();
var proto = VMessage$1.prototype;
proto.file = "";
proto.name = "";
proto.reason = "";
proto.message = "";
proto.stack = "";
proto.fatal = null;
proto.column = null;
proto.line = null;
function VMessage$1(reason, position2, origin) {
  var parts;
  var range;
  var location;
  if (typeof position2 === "string") {
    origin = position2;
    position2 = null;
  }
  parts = parseOrigin(origin);
  range = stringify$2(position2) || "1:1";
  location = {
    start: { line: null, column: null },
    end: { line: null, column: null }
  };
  if (position2 && position2.position) {
    position2 = position2.position;
  }
  if (position2) {
    if (position2.start) {
      location = position2;
      position2 = position2.start;
    } else {
      location.start = position2;
    }
  }
  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }
  this.message = reason;
  this.name = range;
  this.reason = reason;
  this.line = position2 ? position2.line : null;
  this.column = position2 ? position2.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}
function parseOrigin(origin) {
  var result2 = [null, null];
  var index3;
  if (typeof origin === "string") {
    index3 = origin.indexOf(":");
    if (index3 === -1) {
      result2[1] = origin;
    } else {
      result2[0] = origin.slice(0, index3);
      result2[1] = origin.slice(index3 + 1);
    }
  }
  return result2;
}
var minpath_browser = {};
minpath_browser.basename = basename;
minpath_browser.dirname = dirname;
minpath_browser.extname = extname;
minpath_browser.join = join$1;
minpath_browser.sep = "/";
function basename(path2, ext) {
  var start4 = 0;
  var end3 = -1;
  var index3;
  var firstNonSlashEnd;
  var seenNonSlash;
  var extIndex;
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  index3 = path2.length;
  if (ext === void 0 || !ext.length || ext.length > path2.length) {
    while (index3--) {
      if (path2.charCodeAt(index3) === 47) {
        if (seenNonSlash) {
          start4 = index3 + 1;
          break;
        }
      } else if (end3 < 0) {
        seenNonSlash = true;
        end3 = index3 + 1;
      }
    }
    return end3 < 0 ? "" : path2.slice(start4, end3);
  }
  if (ext === path2) {
    return "";
  }
  firstNonSlashEnd = -1;
  extIndex = ext.length - 1;
  while (index3--) {
    if (path2.charCodeAt(index3) === 47) {
      if (seenNonSlash) {
        start4 = index3 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index3 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index3) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end3 = index3;
          }
        } else {
          extIndex = -1;
          end3 = firstNonSlashEnd;
        }
      }
    }
  }
  if (start4 === end3) {
    end3 = firstNonSlashEnd;
  } else if (end3 < 0) {
    end3 = path2.length;
  }
  return path2.slice(start4, end3);
}
function dirname(path2) {
  var end3;
  var unmatchedSlash;
  var index3;
  assertPath$1(path2);
  if (!path2.length) {
    return ".";
  }
  end3 = -1;
  index3 = path2.length;
  while (--index3) {
    if (path2.charCodeAt(index3) === 47) {
      if (unmatchedSlash) {
        end3 = index3;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end3 < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end3 === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end3);
}
function extname(path2) {
  var startDot = -1;
  var startPart = 0;
  var end3 = -1;
  var preDotState = 0;
  var unmatchedSlash;
  var code2;
  var index3;
  assertPath$1(path2);
  index3 = path2.length;
  while (index3--) {
    code2 = path2.charCodeAt(index3);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index3 + 1;
        break;
      }
      continue;
    }
    if (end3 < 0) {
      unmatchedSlash = true;
      end3 = index3 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index3;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end3 < 0 || preDotState === 0 || preDotState === 1 && startDot === end3 - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end3);
}
function join$1() {
  var index3 = -1;
  var joined;
  while (++index3 < arguments.length) {
    assertPath$1(arguments[index3]);
    if (arguments[index3]) {
      joined = joined === void 0 ? arguments[index3] : joined + "/" + arguments[index3];
    }
  }
  return joined === void 0 ? "." : normalize$1(joined);
}
function normalize$1(path2) {
  var absolute;
  var value;
  assertPath$1(path2);
  absolute = path2.charCodeAt(0) === 47;
  value = normalizeString(path2, !absolute);
  if (!value.length && !absolute) {
    value = ".";
  }
  if (value.length && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  var result2 = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var index3 = -1;
  var code2;
  var lastSlashIndex;
  while (++index3 <= path2.length) {
    if (index3 < path2.length) {
      code2 = path2.charCodeAt(index3);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index3 - 1 || dots === 1)
        ;
      else if (lastSlash !== index3 - 1 && dots === 2) {
        if (result2.length < 2 || lastSegmentLength !== 2 || result2.charCodeAt(result2.length - 1) !== 46 || result2.charCodeAt(result2.length - 2) !== 46) {
          if (result2.length > 2) {
            lastSlashIndex = result2.lastIndexOf("/");
            if (lastSlashIndex !== result2.length - 1) {
              if (lastSlashIndex < 0) {
                result2 = "";
                lastSegmentLength = 0;
              } else {
                result2 = result2.slice(0, lastSlashIndex);
                lastSegmentLength = result2.length - 1 - result2.lastIndexOf("/");
              }
              lastSlash = index3;
              dots = 0;
              continue;
            }
          } else if (result2.length) {
            result2 = "";
            lastSegmentLength = 0;
            lastSlash = index3;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result2 = result2.length ? result2 + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result2.length) {
          result2 += "/" + path2.slice(lastSlash + 1, index3);
        } else {
          result2 = path2.slice(lastSlash + 1, index3);
        }
        lastSegmentLength = index3 - lastSlash - 1;
      }
      lastSlash = index3;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result2;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
  }
}
var minproc_browser = {};
minproc_browser.cwd = cwd;
function cwd() {
  return "/";
}
var p$1 = minpath_browser;
var proc = minproc_browser;
var buffer$1 = isBuffer$2;
var core = VFile$1;
var own$6 = {}.hasOwnProperty;
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
VFile$1.prototype.toString = toString$4;
Object.defineProperty(VFile$1.prototype, "path", { get: getPath, set: setPath });
Object.defineProperty(VFile$1.prototype, "dirname", {
  get: getDirname,
  set: setDirname
});
Object.defineProperty(VFile$1.prototype, "basename", {
  get: getBasename,
  set: setBasename
});
Object.defineProperty(VFile$1.prototype, "extname", {
  get: getExtname,
  set: setExtname
});
Object.defineProperty(VFile$1.prototype, "stem", { get: getStem, set: setStem });
function VFile$1(options) {
  var prop;
  var index3;
  if (!options) {
    options = {};
  } else if (typeof options === "string" || buffer$1(options)) {
    options = { contents: options };
  } else if ("message" in options && "messages" in options) {
    return options;
  }
  if (!(this instanceof VFile$1)) {
    return new VFile$1(options);
  }
  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = proc.cwd();
  index3 = -1;
  while (++index3 < order.length) {
    prop = order[index3];
    if (own$6.call(options, prop)) {
      this[prop] = options[prop];
    }
  }
  for (prop in options) {
    if (order.indexOf(prop) < 0) {
      this[prop] = options[prop];
    }
  }
}
function getPath() {
  return this.history[this.history.length - 1];
}
function setPath(path2) {
  assertNonEmpty(path2, "path");
  if (this.path !== path2) {
    this.history.push(path2);
  }
}
function getDirname() {
  return typeof this.path === "string" ? p$1.dirname(this.path) : void 0;
}
function setDirname(dirname2) {
  assertPath(this.path, "dirname");
  this.path = p$1.join(dirname2 || "", this.basename);
}
function getBasename() {
  return typeof this.path === "string" ? p$1.basename(this.path) : void 0;
}
function setBasename(basename2) {
  assertNonEmpty(basename2, "basename");
  assertPart(basename2, "basename");
  this.path = p$1.join(this.dirname || "", basename2);
}
function getExtname() {
  return typeof this.path === "string" ? p$1.extname(this.path) : void 0;
}
function setExtname(extname2) {
  assertPart(extname2, "extname");
  assertPath(this.path, "extname");
  if (extname2) {
    if (extname2.charCodeAt(0) !== 46) {
      throw new Error("`extname` must start with `.`");
    }
    if (extname2.indexOf(".", 1) > -1) {
      throw new Error("`extname` cannot contain multiple dots");
    }
  }
  this.path = p$1.join(this.dirname, this.stem + (extname2 || ""));
}
function getStem() {
  return typeof this.path === "string" ? p$1.basename(this.path, this.extname) : void 0;
}
function setStem(stem) {
  assertNonEmpty(stem, "stem");
  assertPart(stem, "stem");
  this.path = p$1.join(this.dirname || "", stem + (this.extname || ""));
}
function toString$4(encoding) {
  return (this.contents || "").toString(encoding);
}
function assertPart(part2, name) {
  if (part2 && part2.indexOf(p$1.sep) > -1) {
    throw new Error("`" + name + "` cannot be a path: did not expect `" + p$1.sep + "`");
  }
}
function assertNonEmpty(part2, name) {
  if (!part2) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
var VMessage = vfileMessage;
var VFile = core;
var lib$1 = VFile;
VFile.prototype.message = message;
VFile.prototype.info = info;
VFile.prototype.fail = fail;
function message(reason, position2, origin) {
  var message2 = new VMessage(reason, position2, origin);
  if (this.path) {
    message2.name = this.path + ":" + message2.name;
    message2.file = this.path;
  }
  message2.fatal = false;
  this.messages.push(message2);
  return message2;
}
function fail() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = true;
  throw message2;
}
function info() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = null;
  return message2;
}
var vfile$1 = lib$1;
var bail = bail_1;
var buffer = isBuffer$2;
var extend2 = extend$1;
var plain = isPlainObj;
var trough = trough_1;
var vfile = vfile$1;
var unified_1 = unified$1().freeze();
var slice = [].slice;
var own$5 = {}.hasOwnProperty;
var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
function pipelineParse(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun(p2, ctx, next) {
  p2.run(ctx.tree, ctx.file, done3);
  function done3(error, tree, file) {
    if (error) {
      next(error);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function pipelineStringify(p2, ctx) {
  var result2 = p2.stringify(ctx.tree, ctx.file);
  if (result2 === void 0 || result2 === null)
    ;
  else if (typeof result2 === "string" || buffer(result2)) {
    if ("value" in ctx.file) {
      ctx.file.value = result2;
    }
    ctx.file.contents = result2;
  } else {
    ctx.file.result = result2;
  }
}
function unified$1() {
  var attachers = [];
  var transformers = trough();
  var namespace = {};
  var freezeIndex = -1;
  var frozen;
  processor.data = data;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse4;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified$1();
    var index3 = -1;
    while (++index3 < attachers.length) {
      destination.use.apply(null, attachers[index3]);
    }
    destination.data(extend2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values2 = attachers[freezeIndex];
      if (values2[1] === false) {
        continue;
      }
      if (values2[1] === true) {
        values2[1] = void 0;
      }
      transformer = values2[0].apply(processor, values2.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key2] = value;
        return processor;
      }
      return own$5.call(namespace, key2) && namespace[key2] || null;
    }
    if (key2) {
      assertUnfrozen("data", frozen);
      namespace = key2;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value === "object") {
      if ("length" in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = extend2(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result2) {
      addList(result2.plugins);
      if (result2.settings) {
        settings = extend2(settings || {}, result2.settings);
      }
    }
    function add3(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if ("length" in value2) {
          addPlugin.apply(null, value2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new Error("Expected usable value, not `" + value2 + "`");
      }
    }
    function addList(plugins) {
      var index3 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        while (++index3 < plugins.length) {
          add3(plugins[index3]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin2, value2) {
      var entry = find4(plugin2);
      if (entry) {
        if (plain(entry[1]) && plain(value2)) {
          value2 = extend2(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push(slice.call(arguments));
      }
    }
  }
  function find4(plugin2) {
    var index3 = -1;
    while (++index3 < attachers.length) {
      if (attachers[index3][0] === plugin2) {
        return attachers[index3];
      }
    }
  }
  function parse4(doc2) {
    var file = vfile(doc2);
    var Parser;
    freeze();
    Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function run2(node5, file, cb) {
    assertNode(node5);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve7, reject) {
      transformers.run(node5, vfile(file), done3);
      function done3(error, tree, file2) {
        tree = tree || node5;
        if (error) {
          reject(error);
        } else if (resolve7) {
          resolve7(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node5, file) {
    var result2;
    var complete;
    run2(node5, file, done3);
    assertDone("runSync", "run", complete);
    return result2;
    function done3(error, tree) {
      complete = true;
      result2 = tree;
      bail(error);
    }
  }
  function stringify2(node5, doc2) {
    var file = vfile(doc2);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node5);
    if (newable(Compiler, "compile")) {
      return new Compiler(node5, file).compile();
    }
    return Compiler(node5, file);
  }
  function process(doc2, cb) {
    freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve7, reject) {
      var file = vfile(doc2);
      pipeline.run(processor, { file }, done3);
      function done3(error) {
        if (error) {
          reject(error);
        } else if (resolve7) {
          resolve7(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc2) {
    var file;
    var complete;
    freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    file = vfile(doc2);
    process(file, done3);
    assertDone("processSync", "process", complete);
    return file;
    function done3(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && value.prototype && (keys$4(value.prototype) || name in value.prototype);
}
function keys$4(value) {
  var key2;
  for (key2 in value) {
    return true;
  }
  return false;
}
function assertParser(name, Parser) {
  if (typeof Parser !== "function") {
    throw new Error("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
  }
}
function assertNode(node5) {
  if (!node5 || typeof node5.type !== "string") {
    throw new Error("Expected node, got `" + node5 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
  }
}
var mdastUtilToString = toString$3;
function toString$3(node5) {
  return node5 && (node5.value || node5.alt || node5.title || "children" in node5 && all(node5.children) || "length" in node5 && all(node5)) || "";
}
function all(values2) {
  var result2 = [];
  var index3 = -1;
  while (++index3 < values2.length) {
    result2[index3] = toString$3(values2[index3]);
  }
  return result2.join("");
}
var assign$5 = Object.assign;
var assign_1 = assign$5;
var own$4 = {}.hasOwnProperty;
var hasOwnProperty$6 = own$4;
function normalizeIdentifier$3(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
var normalizeIdentifier_1 = normalizeIdentifier$3;
var fromCharCode$4 = String.fromCharCode;
var fromCharCode_1 = fromCharCode$4;
var fromCharCode$3 = fromCharCode_1;
function safeFromInt$1(value, base2) {
  var code2 = parseInt(value, base2);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return fromCharCode$3(code2);
}
var safeFromInt_1 = safeFromInt$1;
var content$3 = {};
function markdownLineEnding$k(code2) {
  return code2 < -2;
}
var markdownLineEnding_1 = markdownLineEnding$k;
function markdownSpace$9(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var markdownSpace_1 = markdownSpace$9;
var markdownSpace$8 = markdownSpace_1;
function spaceFactory$1(effects, ok3, type, max2) {
  var limit = max2 ? max2 - 1 : Infinity;
  var size2 = 0;
  return start4;
  function start4(code2) {
    if (markdownSpace$8(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok3(code2);
  }
  function prefix(code2) {
    if (markdownSpace$8(code2) && size2++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok3(code2);
  }
}
var factorySpace$h = spaceFactory$1;
Object.defineProperty(content$3, "__esModule", { value: true });
var markdownLineEnding$j = markdownLineEnding_1;
var factorySpace$g = factorySpace$h;
var tokenize$2 = initializeContent;
function initializeContent(effects) {
  var contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  var previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace$g(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    var token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding$j(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
content$3.tokenize = tokenize$2;
var document$3 = {};
var markdownLineEnding$i = markdownLineEnding_1;
var factorySpace$f = factorySpace$h;
var partialBlankLine$4 = {
  tokenize: tokenizePartialBlankLine,
  partial: true
};
function tokenizePartialBlankLine(effects, ok3, nok) {
  return factorySpace$f(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding$i(code2) ? ok3(code2) : nok(code2);
  }
}
var partialBlankLine_1 = partialBlankLine$4;
Object.defineProperty(document$3, "__esModule", { value: true });
var markdownLineEnding$h = markdownLineEnding_1;
var factorySpace$e = factorySpace$h;
var partialBlankLine$3 = partialBlankLine_1;
var tokenize$1 = initializeDocument;
var containerConstruct = {
  tokenize: tokenizeContainer
};
var lazyFlowConstruct = {
  tokenize: tokenizeLazyFlow
};
function initializeDocument(effects) {
  var self2 = this;
  var stack = [];
  var continued = 0;
  var inspectConstruct = {
    tokenize: tokenizeInspect,
    partial: true
  };
  var inspectResult;
  var childFlow;
  var childToken;
  return start4;
  function start4(code2) {
    if (continued < stack.length) {
      self2.containerState = stack[continued][1];
      return effects.attempt(stack[continued][0].continuation, documentContinue, documentContinued)(code2);
    }
    return documentContinued(code2);
  }
  function documentContinue(code2) {
    continued++;
    return start4(code2);
  }
  function documentContinued(code2) {
    if (inspectResult && inspectResult.flowContinue) {
      return flowStart(code2);
    }
    self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
    self2.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    stack.push([self2.currentConstruct, self2.containerState]);
    self2.containerState = void 0;
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      exitContainers(0, true);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      continueFlow(effects.exit("chunkFlow"));
      return flowStart(code2);
    }
    if (markdownLineEnding$h(code2)) {
      effects.consume(code2);
      continueFlow(effects.exit("chunkFlow"));
      return effects.check(inspectConstruct, documentAfterPeek);
    }
    effects.consume(code2);
    return flowContinue;
  }
  function documentAfterPeek(code2) {
    exitContainers(inspectResult.continued, inspectResult && inspectResult.flowEnd);
    continued = 0;
    return start4(code2);
  }
  function continueFlow(token) {
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.lazy = inspectResult && inspectResult.lazy;
    childFlow.defineSkip(token.start);
    childFlow.write(self2.sliceStream(token));
  }
  function exitContainers(size2, end3) {
    var index3 = stack.length;
    if (childFlow && end3) {
      childFlow.write([null]);
      childToken = childFlow = void 0;
    }
    while (index3-- > size2) {
      self2.containerState = stack[index3][1];
      stack[index3][0].exit.call(self2, effects);
    }
    stack.length = size2;
  }
  function tokenizeInspect(effects2, ok3) {
    var subcontinued = 0;
    inspectResult = {};
    return inspectStart;
    function inspectStart(code2) {
      if (subcontinued < stack.length) {
        self2.containerState = stack[subcontinued][1];
        return effects2.attempt(stack[subcontinued][0].continuation, inspectContinue, inspectLess)(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        inspectResult.flowContinue = true;
        return inspectDone(code2);
      }
      self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
      self2.containerState = {};
      return effects2.attempt(containerConstruct, inspectFlowEnd, inspectDone)(code2);
    }
    function inspectContinue(code2) {
      subcontinued++;
      return self2.containerState._closeFlow ? inspectFlowEnd(code2) : inspectStart(code2);
    }
    function inspectLess(code2) {
      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
        self2.containerState = {};
        return effects2.attempt(containerConstruct, inspectFlowEnd, effects2.attempt(lazyFlowConstruct, inspectFlowEnd, effects2.check(partialBlankLine$3, inspectFlowEnd, inspectLazy)))(code2);
      }
      return inspectFlowEnd(code2);
    }
    function inspectLazy(code2) {
      subcontinued = stack.length;
      inspectResult.lazy = true;
      inspectResult.flowContinue = true;
      return inspectDone(code2);
    }
    function inspectFlowEnd(code2) {
      inspectResult.flowEnd = true;
      return inspectDone(code2);
    }
    function inspectDone(code2) {
      inspectResult.continued = subcontinued;
      self2.interrupt = self2.containerState = void 0;
      return ok3(code2);
    }
  }
}
function tokenizeContainer(effects, ok3, nok) {
  return factorySpace$e(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
}
function tokenizeLazyFlow(effects, ok3, nok) {
  return factorySpace$e(effects, effects.lazy(this.parser.constructs.flow, ok3, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
}
document$3.tokenize = tokenize$1;
var flow$7 = {};
function sizeChunks$2(chunks) {
  var index3 = -1;
  var size2 = 0;
  while (++index3 < chunks.length) {
    size2 += typeof chunks[index3] === "string" ? chunks[index3].length : 1;
  }
  return size2;
}
var sizeChunks_1 = sizeChunks$2;
var sizeChunks$1 = sizeChunks_1;
function prefixSize$6(events, type) {
  var tail = events[events.length - 1];
  if (!tail || tail[1].type !== type)
    return 0;
  return sizeChunks$1(tail[2].sliceStream(tail[1]));
}
var prefixSize_1 = prefixSize$6;
var splice$2 = [].splice;
var splice_1 = splice$2;
var splice$1 = splice_1;
function chunkedSplice$9(list2, start4, remove3, items) {
  var end3 = list2.length;
  var chunkStart = 0;
  var parameters;
  if (start4 < 0) {
    start4 = -start4 > end3 ? 0 : end3 + start4;
  } else {
    start4 = start4 > end3 ? end3 : start4;
  }
  remove3 = remove3 > 0 ? remove3 : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start4, remove3);
    splice$1.apply(list2, parameters);
  } else {
    if (remove3)
      splice$1.apply(list2, [start4, remove3]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start4, 0);
      splice$1.apply(list2, parameters);
      chunkStart += 1e4;
      start4 += 1e4;
    }
  }
}
var chunkedSplice_1 = chunkedSplice$9;
var assign$4 = assign_1;
function shallow$7(object) {
  return assign$4({}, object);
}
var shallow_1 = shallow$7;
var assign$3 = assign_1;
var chunkedSplice$8 = chunkedSplice_1;
var shallow$6 = shallow_1;
function subtokenize$2(events) {
  var jumps = {};
  var index3 = -1;
  var event;
  var lineIndex;
  var otherIndex;
  var otherEvent;
  var parameters;
  var subevents;
  var more;
  while (++index3 < events.length) {
    while (index3 in jumps) {
      index3 = jumps[index3];
    }
    event = events[index3];
    if (index3 && event[1].type === "chunkFlow" && events[index3 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1].isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        assign$3(jumps, subcontent(events, index3));
        index3 = jumps[index3];
        more = true;
      }
    } else if (event[1]._container || event[1]._movePreviousLineEndings) {
      otherIndex = index3;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = shallow$6(events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index3);
        parameters.unshift(event);
        chunkedSplice$8(events, lineIndex, index3 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  var token = events[eventIndex][1];
  var context = events[eventIndex][2];
  var startPosition = eventIndex - 1;
  var startPositions = [];
  var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  var childEvents = tokenizer.events;
  var jumps = [];
  var gaps = {};
  var stream;
  var previous2;
  var index3;
  var entered;
  var end3;
  var adjust;
  while (token) {
    while (events[++startPosition][1] !== token) {
    }
    startPositions.push(startPosition);
    if (!token._tokenizer) {
      stream = context.sliceStream(token);
      if (!token.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(token.start);
      }
      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = token;
    token = token.next;
  }
  token = previous2;
  index3 = childEvents.length;
  while (index3--) {
    if (childEvents[index3][0] === "enter") {
      entered = true;
    } else if (entered && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line) {
      add3(childEvents.slice(index3 + 1, end3));
      token._tokenizer = token.next = void 0;
      token = token.previous;
      end3 = index3 + 1;
    }
  }
  tokenizer.events = token._tokenizer = token.next = void 0;
  add3(childEvents.slice(0, end3));
  index3 = -1;
  adjust = 0;
  while (++index3 < jumps.length) {
    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
    adjust += jumps[index3][1] - jumps[index3][0] - 1;
  }
  return gaps;
  function add3(slice5) {
    var start4 = startPositions.pop();
    jumps.unshift([start4, start4 + slice5.length - 1]);
    chunkedSplice$8(events, start4, 2, slice5);
  }
}
var subtokenize_1 = subtokenize$2;
var markdownLineEnding$g = markdownLineEnding_1;
var prefixSize$5 = prefixSize_1;
var subtokenize$1 = subtokenize_1;
var factorySpace$d = factorySpace$h;
var content$2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent,
  interruptible: true,
  lazy: true
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize$1(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  var previous2;
  return start4;
  function start4(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding$g(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return data;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok3(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2 = previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    return data;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  var self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace$d(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding$g(code2)) {
      return nok(code2);
    }
    if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize$5(self2.events, "linePrefix") < 4) {
      return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code2);
    }
    return ok3(code2);
  }
}
var content_1 = content$2;
Object.defineProperty(flow$7, "__esModule", { value: true });
var content$1 = content_1;
var factorySpace$c = factorySpace$h;
var partialBlankLine$2 = partialBlankLine_1;
var tokenize = initializeFlow;
function initializeFlow(effects) {
  var self2 = this;
  var initial = effects.attempt(partialBlankLine$2, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace$c(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content$1, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
flow$7.tokenize = tokenize;
var text$6 = {};
Object.defineProperty(text$6, "__esModule", { value: true });
var assign$2 = assign_1;
var shallow$5 = shallow_1;
var text$5 = initializeFactory("text");
var string$1 = initializeFactory("string");
var resolver = {
  resolveAll: createResolver()
};
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    var self2 = this;
    var constructs2 = this.parser.constructs[field];
    var text3 = effects.attempt(constructs2, start4, notText);
    return start4;
    function start4(code2) {
      return atBreak(code2) ? text3(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text3(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      var list2 = constructs2[code2];
      var index3 = -1;
      if (code2 === null) {
        return true;
      }
      if (list2) {
        while (++index3 < list2.length) {
          if (!list2[index3].previous || list2[index3].previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    var index3 = -1;
    var enter2;
    while (++index3 <= events.length) {
      if (enter2 === void 0) {
        if (events[index3] && events[index3][1].type === "data") {
          enter2 = index3;
          index3++;
        }
      } else if (!events[index3] || events[index3][1].type !== "data") {
        if (index3 !== enter2 + 2) {
          events[enter2][1].end = events[index3 - 1][1].end;
          events.splice(enter2 + 2, index3 - enter2 - 2);
          index3 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  var eventIndex = -1;
  var chunks;
  var data;
  var chunk;
  var index3;
  var bufferIndex;
  var size2;
  var tabs;
  var token;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      data = events[eventIndex - 1][1];
      chunks = context.sliceStream(data);
      index3 = chunks.length;
      bufferIndex = -1;
      size2 = 0;
      tabs = void 0;
      while (index3--) {
        chunk = chunks[index3];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size2++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size2++;
        } else if (chunk === -1)
          ;
        else {
          index3++;
          break;
        }
      }
      if (size2) {
        token = {
          type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size2,
            offset: data.end.offset - size2,
            _index: data.start._index + index3,
            _bufferIndex: index3 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: shallow$5(data.end)
        };
        data.end = shallow$5(token.start);
        if (data.start.offset === data.end.offset) {
          assign$2(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
text$6.resolver = resolver;
text$6.string = string$1;
text$6.text = text$5;
function miniflat$3(value) {
  return value === null || value === void 0 ? [] : "length" in value ? value : [value];
}
var miniflat_1 = miniflat$3;
var hasOwnProperty$5 = hasOwnProperty$6;
var chunkedSplice$7 = chunkedSplice_1;
var miniflat$2 = miniflat_1;
function combineExtensions$1(extensions) {
  var all2 = {};
  var index3 = -1;
  while (++index3 < extensions.length) {
    extension$2(all2, extensions[index3]);
  }
  return all2;
}
function extension$2(all2, extension2) {
  var hook2;
  var left;
  var right;
  var code2;
  for (hook2 in extension2) {
    left = hasOwnProperty$5.call(all2, hook2) ? all2[hook2] : all2[hook2] = {};
    right = extension2[hook2];
    for (code2 in right) {
      left[code2] = constructs$2(miniflat$2(right[code2]), hasOwnProperty$5.call(left, code2) ? left[code2] : []);
    }
  }
}
function constructs$2(list2, existing) {
  var index3 = -1;
  var before2 = [];
  while (++index3 < list2.length) {
    (list2[index3].add === "after" ? existing : before2).push(list2[index3]);
  }
  chunkedSplice$7(existing, 0, 0, before2);
  return existing;
}
var combineExtensions_1 = combineExtensions$1;
var chunkedSplice$6 = chunkedSplice_1;
function chunkedPush$3(list2, items) {
  if (list2.length) {
    chunkedSplice$6(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
var chunkedPush_1 = chunkedPush$3;
function resolveAll$4(constructs2, events, context) {
  var called = [];
  var index3 = -1;
  var resolve7;
  while (++index3 < constructs2.length) {
    resolve7 = constructs2[index3].resolveAll;
    if (resolve7 && called.indexOf(resolve7) < 0) {
      events = resolve7(events, context);
      called.push(resolve7);
    }
  }
  return events;
}
var resolveAll_1 = resolveAll$4;
var fromCharCode$2 = fromCharCode_1;
function serializeChunks$1(chunks) {
  var index3 = -1;
  var result2 = [];
  var chunk;
  var value;
  var atTab;
  while (++index3 < chunks.length) {
    chunk = chunks[index3];
    if (typeof chunk === "string") {
      value = chunk;
    } else if (chunk === -5) {
      value = "\r";
    } else if (chunk === -4) {
      value = "\n";
    } else if (chunk === -3) {
      value = "\r\n";
    } else if (chunk === -2) {
      value = "	";
    } else if (chunk === -1) {
      if (atTab)
        continue;
      value = " ";
    } else {
      value = fromCharCode$2(chunk);
    }
    atTab = chunk === -2;
    result2.push(value);
  }
  return result2.join("");
}
var serializeChunks_1 = serializeChunks$1;
function sliceChunks$1(chunks, token) {
  var startIndex = token.start._index;
  var startBufferIndex = token.start._bufferIndex;
  var endIndex = token.end._index;
  var endBufferIndex = token.end._bufferIndex;
  var view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
var sliceChunks_1 = sliceChunks$1;
var assign$1 = assign_1;
var markdownLineEnding$f = markdownLineEnding_1;
var chunkedPush$2 = chunkedPush_1;
var chunkedSplice$5 = chunkedSplice_1;
var miniflat$1 = miniflat_1;
var resolveAll$3 = resolveAll_1;
var serializeChunks = serializeChunks_1;
var shallow$4 = shallow_1;
var sliceChunks = sliceChunks_1;
function createTokenizer$1(parser2, initialize, from5) {
  var point2 = from5 ? shallow$4(from5) : {
    line: 1,
    column: 1,
    offset: 0
  };
  var columnStart = {};
  var resolveAllConstructs = [];
  var chunks = [];
  var stack = [];
  var effects = {
    consume,
    enter: enter2,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    }),
    lazy: constructFactory(onsuccessfulcheck, {
      lazy: true
    })
  };
  var context = {
    previous: null,
    events: [],
    parser: parser2,
    sliceStream,
    sliceSerialize,
    now: now3,
    defineSkip: skip,
    write
  };
  var state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  point2._index = 0;
  point2._bufferIndex = -1;
  return context;
  function write(slice5) {
    chunks = chunkedPush$2(chunks, slice5);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll$3(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token) {
    return serializeChunks(sliceStream(token));
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now3() {
    return shallow$4(point2);
  }
  function skip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    var chunkIndex;
    var chunk;
    while (point2._index < chunks.length) {
      chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go2(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go2(chunk);
      }
    }
  }
  function go2(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding$f(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
  }
  function enter2(type, fields) {
    var token = fields || {};
    token.type = type;
    token.start = now3();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    var token = stack.pop();
    token.end = now3();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info2) {
    addResult(construct, info2.from);
  }
  function onsuccessfulcheck(construct, info2) {
    info2.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook2;
    function hook2(constructs2, returnState, bogusState) {
      var listOfConstructs;
      var constructIndex;
      var currentConstruct;
      var info2;
      return constructs2.tokenize || "length" in constructs2 ? handleListOfConstructs(miniflat$1(constructs2)) : handleMapOfConstructs;
      function handleMapOfConstructs(code2) {
        if (code2 in constructs2 || null in constructs2) {
          return handleListOfConstructs(constructs2.null ? miniflat$1(constructs2[code2]).concat(miniflat$1(constructs2.null)) : constructs2[code2])(code2);
        }
        return bogusState(code2);
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start4;
        function start4(code2) {
          info2 = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {
            return nok();
          }
          return construct.tokenize.call(fields ? assign$1({}, context, fields) : context, effects, ok3, nok)(code2);
        }
      }
      function ok3(code2) {
        onreturn(currentConstruct, info2);
        return returnState;
      }
      function nok(code2) {
        info2.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from6) {
    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      chunkedSplice$5(context.events, from6, context.events.length - from6, construct.resolve(context.events.slice(from6), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    var startPoint = now3();
    var startPrevious = context.previous;
    var startCurrentConstruct = context.currentConstruct;
    var startEventsIndex = context.events.length;
    var startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
var createTokenizer_1 = createTokenizer$1;
var constructs$1 = {};
function markdownLineEndingOrSpace$9(code2) {
  return code2 < 0 || code2 === 32;
}
var markdownLineEndingOrSpace_1 = markdownLineEndingOrSpace$9;
var unicodePunctuation$4 = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var unicodePunctuationRegex$1 = unicodePunctuation$4;
var fromCharCode$1 = fromCharCode_1;
function regexCheck$8(regex2) {
  return check2;
  function check2(code2) {
    return regex2.test(fromCharCode$1(code2));
  }
}
var regexCheck_1 = regexCheck$8;
var unicodePunctuationRegex = unicodePunctuationRegex$1;
var regexCheck$7 = regexCheck_1;
var unicodePunctuation$3 = regexCheck$7(unicodePunctuationRegex);
var unicodePunctuation_1 = unicodePunctuation$3;
var regexCheck$6 = regexCheck_1;
var unicodeWhitespace$3 = regexCheck$6(/\s/);
var unicodeWhitespace_1 = unicodeWhitespace$3;
var markdownLineEndingOrSpace$8 = markdownLineEndingOrSpace_1;
var unicodePunctuation$2 = unicodePunctuation_1;
var unicodeWhitespace$2 = unicodeWhitespace_1;
function classifyCharacter$2(code2) {
  if (code2 === null || markdownLineEndingOrSpace$8(code2) || unicodeWhitespace$2(code2)) {
    return 1;
  }
  if (unicodePunctuation$2(code2)) {
    return 2;
  }
}
var classifyCharacter_1 = classifyCharacter$2;
function movePoint$1(point2, offset2) {
  point2.column += offset2;
  point2.offset += offset2;
  point2._bufferIndex += offset2;
  return point2;
}
var movePoint_1 = movePoint$1;
var chunkedPush$1 = chunkedPush_1;
var chunkedSplice$4 = chunkedSplice_1;
var classifyCharacter$1 = classifyCharacter_1;
var movePoint = movePoint_1;
var resolveAll$2 = resolveAll_1;
var shallow$3 = shallow_1;
var attention$1 = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  var index3 = -1;
  var open2;
  var group;
  var text3;
  var openingSequence;
  var closingSequence;
  var use;
  var nextEvents;
  var offset2;
  while (++index3 < events.length) {
    if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
      open2 = index3;
      while (open2--) {
        if (events[open2][0] === "exit" && events[open2][1].type === "attentionSequence" && events[open2][1]._open && context.sliceSerialize(events[open2][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
          if ((events[open2][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open2][1].end.offset - events[open2][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
            continue;
          }
          use = events[open2][1].end.offset - events[open2][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: movePoint(shallow$3(events[open2][1].end), -use),
            end: shallow$3(events[open2][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: shallow$3(events[index3][1].start),
            end: movePoint(shallow$3(events[index3][1].start), use)
          };
          text3 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: shallow$3(events[open2][1].end),
            end: shallow$3(events[index3][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: shallow$3(openingSequence.start),
            end: shallow$3(closingSequence.end)
          };
          events[open2][1].end = shallow$3(openingSequence.start);
          events[index3][1].start = shallow$3(closingSequence.end);
          nextEvents = [];
          if (events[open2][1].end.offset - events[open2][1].start.offset) {
            nextEvents = chunkedPush$1(nextEvents, [
              ["enter", events[open2][1], context],
              ["exit", events[open2][1], context]
            ]);
          }
          nextEvents = chunkedPush$1(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text3, context]
          ]);
          nextEvents = chunkedPush$1(nextEvents, resolveAll$2(context.parser.constructs.insideSpan.null, events.slice(open2 + 1, index3), context));
          nextEvents = chunkedPush$1(nextEvents, [
            ["exit", text3, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index3][1].end.offset - events[index3][1].start.offset) {
            offset2 = 2;
            nextEvents = chunkedPush$1(nextEvents, [
              ["enter", events[index3][1], context],
              ["exit", events[index3][1], context]
            ]);
          } else {
            offset2 = 0;
          }
          chunkedSplice$4(events, open2 - 1, index3 - open2 + 3, nextEvents);
          index3 = open2 + nextEvents.length - offset2 - 2;
          break;
        }
      }
    }
  }
  index3 = -1;
  while (++index3 < events.length) {
    if (events[index3][1].type === "attentionSequence") {
      events[index3][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  var before2 = classifyCharacter$1(this.previous);
  var marker;
  return start4;
  function start4(code2) {
    effects.enter("attentionSequence");
    marker = code2;
    return sequence(code2);
  }
  function sequence(code2) {
    var token;
    var after2;
    var open2;
    var close3;
    if (code2 === marker) {
      effects.consume(code2);
      return sequence;
    }
    token = effects.exit("attentionSequence");
    after2 = classifyCharacter$1(code2);
    open2 = !after2 || after2 === 2 && before2;
    close3 = !before2 || before2 === 2 && after2;
    token._open = marker === 42 ? open2 : open2 && (before2 || !close3);
    token._close = marker === 42 ? close3 : close3 && (after2 || !open2);
    return ok3(code2);
  }
}
var attention_1 = attention$1;
var regexCheck$5 = regexCheck_1;
var asciiAlpha$4 = regexCheck$5(/[A-Za-z]/);
var asciiAlpha_1 = asciiAlpha$4;
var regexCheck$4 = regexCheck_1;
var asciiAlphanumeric$5 = regexCheck$4(/[\dA-Za-z]/);
var asciiAlphanumeric_1 = asciiAlphanumeric$5;
var regexCheck$3 = regexCheck_1;
var asciiAtext$1 = regexCheck$3(/[#-'*+\--9=?A-Z^-~]/);
var asciiAtext_1 = asciiAtext$1;
function asciiControl$3(code2) {
  return code2 < 32 || code2 === 127;
}
var asciiControl_1 = asciiControl$3;
var asciiAlpha$3 = asciiAlpha_1;
var asciiAlphanumeric$4 = asciiAlphanumeric_1;
var asciiAtext = asciiAtext_1;
var asciiControl$2 = asciiControl_1;
var autolink$2 = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok3, nok) {
  var size2 = 1;
  return start4;
  function start4(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open2;
  }
  function open2(code2) {
    if (asciiAlpha$3(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric$4(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric$4(code2)) && size2++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      return end3(code2);
    }
    if (code2 === 32 || code2 === 60 || asciiControl$2(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric$4(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end3(code2);
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric$4(code2)) && size2++ < 63) {
      effects.consume(code2);
      return code2 === 45 ? emailValue : emailLabel;
    }
    return nok(code2);
  }
  function end3(code2) {
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok3;
  }
}
var autolink_1 = autolink$2;
var markdownSpace$7 = markdownSpace_1;
var factorySpace$b = factorySpace$h;
var blockQuote$1 = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$1
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  var self2 = this;
  return start4;
  function start4(code2) {
    if (code2 === 62) {
      if (!self2.containerState.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        self2.containerState.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after2;
    }
    return nok(code2);
  }
  function after2(code2) {
    if (markdownSpace$7(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok3;
    }
    effects.exit("blockQuotePrefix");
    return ok3(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  return factorySpace$b(effects, effects.attempt(blockQuote$1, ok3, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
}
function exit$1(effects) {
  effects.exit("blockQuote");
}
var blockQuote_1 = blockQuote$1;
var regexCheck$2 = regexCheck_1;
var asciiPunctuation$1 = regexCheck$2(/[!-/:-@[-`{-~]/);
var asciiPunctuation_1 = asciiPunctuation$1;
var asciiPunctuation = asciiPunctuation_1;
var characterEscape$2 = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return open2;
  }
  function open2(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok3;
    }
    return nok(code2);
  }
}
var characterEscape_1 = characterEscape$2;
var el;
var semicolon = 59;
var decodeEntity_browser = decodeEntity$1;
function decodeEntity$1(characters) {
  var entity = "&" + characters + ";";
  var char;
  el = el || document.createElement("i");
  el.innerHTML = entity;
  char = el.textContent;
  if (char.charCodeAt(char.length - 1) === semicolon && characters !== "semi") {
    return false;
  }
  return char === entity ? false : char;
}
var regexCheck$1 = regexCheck_1;
var asciiDigit$2 = regexCheck$1(/\d/);
var asciiDigit_1 = asciiDigit$2;
var regexCheck = regexCheck_1;
var asciiHexDigit$1 = regexCheck(/[\dA-Fa-f]/);
var asciiHexDigit_1 = asciiHexDigit$1;
var decodeEntity = decodeEntity_browser;
var asciiAlphanumeric$3 = asciiAlphanumeric_1;
var asciiDigit$1 = asciiDigit_1;
var asciiHexDigit = asciiHexDigit_1;
function _interopDefaultLegacy(e3) {
  return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { default: e3 };
}
var decodeEntity__default = /* @__PURE__ */ _interopDefaultLegacy(decodeEntity);
var characterReference$2 = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  var self2 = this;
  var size2 = 0;
  var max2;
  var test;
  return start4;
  function start4(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open2;
  }
  function open2(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max2 = 31;
    test = asciiAlphanumeric$3;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max2 = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max2 = 7;
    test = asciiDigit$1;
    return value(code2);
  }
  function value(code2) {
    var token;
    if (code2 === 59 && size2) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric$3 && !decodeEntity__default["default"](self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok3;
    }
    if (test(code2) && size2++ < max2) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
var characterReference_1 = characterReference$2;
var markdownLineEnding$e = markdownLineEnding_1;
var markdownLineEndingOrSpace$7 = markdownLineEndingOrSpace_1;
var prefixSize$4 = prefixSize_1;
var factorySpace$a = factorySpace$h;
var codeFenced$1 = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  var self2 = this;
  var closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  var initialPrefix = prefixSize$4(this.events, "linePrefix");
  var sizeOpen = 0;
  var marker;
  return start4;
  function start4(code2) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code2;
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code2) : factorySpace$a(effects, infoOpen, "whitespace")(code2);
  }
  function infoOpen(code2) {
    if (code2 === null || markdownLineEnding$e(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info2(code2);
  }
  function info2(code2) {
    if (code2 === null || markdownLineEndingOrSpace$7(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace$a(effects, infoAfter, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return info2;
  }
  function infoAfter(code2) {
    if (code2 === null || markdownLineEnding$e(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding$e(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("codeFencedFence");
    return self2.interrupt ? ok3(code2) : content3(code2);
  }
  function content3(code2) {
    if (code2 === null) {
      return after2(code2);
    }
    if (markdownLineEnding$e(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt(closingFenceConstruct, after2, initialPrefix ? factorySpace$a(effects, content3, "linePrefix", initialPrefix + 1) : content3);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding$e(code2)) {
      effects.exit("codeFlowValue");
      return content3(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after2(code2) {
    effects.exit("codeFenced");
    return ok3(code2);
  }
  function tokenizeClosingFence(effects2, ok4, nok2) {
    var size2 = 0;
    return factorySpace$a(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
    function closingSequenceStart(code2) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === marker) {
        effects2.consume(code2);
        size2++;
        return closingSequence;
      }
      if (size2 < sizeOpen)
        return nok2(code2);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace$a(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding$e(code2)) {
        effects2.exit("codeFencedFence");
        return ok4(code2);
      }
      return nok2(code2);
    }
  }
}
var codeFenced_1 = codeFenced$1;
var markdownLineEnding$d = markdownLineEnding_1;
var chunkedSplice$3 = chunkedSplice_1;
var prefixSize$3 = prefixSize_1;
var factorySpace$9 = factorySpace$h;
var codeIndented$1 = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented,
  resolve: resolveCodeIndented
};
var indentedContentConstruct = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function resolveCodeIndented(events, context) {
  var code2 = {
    type: "codeIndented",
    start: events[0][1].start,
    end: events[events.length - 1][1].end
  };
  chunkedSplice$3(events, 0, 0, [["enter", code2, context]]);
  chunkedSplice$3(events, events.length, 0, [["exit", code2, context]]);
  return events;
}
function tokenizeCodeIndented(effects, ok3, nok) {
  return effects.attempt(indentedContentConstruct, afterPrefix, nok);
  function afterPrefix(code2) {
    if (code2 === null) {
      return ok3(code2);
    }
    if (markdownLineEnding$d(code2)) {
      return effects.attempt(indentedContentConstruct, afterPrefix, ok3)(code2);
    }
    effects.enter("codeFlowValue");
    return content3(code2);
  }
  function content3(code2) {
    if (code2 === null || markdownLineEnding$d(code2)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code2);
    }
    effects.consume(code2);
    return content3;
  }
}
function tokenizeIndentedContent(effects, ok3, nok) {
  var self2 = this;
  return factorySpace$9(effects, afterPrefix, "linePrefix", 4 + 1);
  function afterPrefix(code2) {
    if (markdownLineEnding$d(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace$9(effects, afterPrefix, "linePrefix", 4 + 1);
    }
    return prefixSize$3(self2.events, "linePrefix") < 4 ? nok(code2) : ok3(code2);
  }
}
var codeIndented_1 = codeIndented$1;
var markdownLineEnding$c = markdownLineEnding_1;
var codeText$1 = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous$3
};
function resolveCodeText(events) {
  var tailExitIndex = events.length - 4;
  var headEnterIndex = 3;
  var index3;
  var enter2;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events[index3][1].type === "codeTextData") {
        events[tailExitIndex][1].type = events[headEnterIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index3 !== tailExitIndex && events[index3][1].type !== "lineEnding") {
        enter2 = index3;
      }
    } else if (index3 === tailExitIndex || events[index3][1].type === "lineEnding") {
      events[enter2][1].type = "codeTextData";
      if (index3 !== enter2 + 2) {
        events[enter2][1].end = events[index3 - 1][1].end;
        events.splice(enter2 + 2, index3 - enter2 - 2);
        tailExitIndex -= index3 - enter2 - 2;
        index3 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous$3(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok3, nok) {
  var sizeOpen = 0;
  var size2;
  var token;
  return start4;
  function start4(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size2 = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding$c(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding$c(code2)) {
      effects.exit("codeTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data;
  }
  function closingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size2++;
      return closingSequence;
    }
    if (size2 === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok3(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}
var codeText_1 = codeText$1;
var asciiControl$1 = asciiControl_1;
var markdownLineEndingOrSpace$6 = markdownLineEndingOrSpace_1;
var markdownLineEnding$b = markdownLineEnding_1;
function destinationFactory(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  var limit = max2 || Infinity;
  var balance = 0;
  return start4;
  function start4(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (asciiControl$1(code2) || code2 === 41) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code2);
  }
  function destinationEnclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code2);
  }
  function destinationEnclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding$b(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return destinationEnclosed;
    }
    return destinationEnclosed(code2);
  }
  function destinationRaw(code2) {
    if (code2 === 40) {
      if (++balance > limit)
        return nok(code2);
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok3(code2);
      }
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === null || markdownLineEndingOrSpace$6(code2)) {
      if (balance)
        return nok(code2);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code2);
    }
    if (asciiControl$1(code2))
      return nok(code2);
    effects.consume(code2);
    return code2 === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return destinationRaw;
    }
    return destinationRaw(code2);
  }
}
var factoryDestination$2 = destinationFactory;
var markdownLineEnding$a = markdownLineEnding_1;
var markdownSpace$6 = markdownSpace_1;
function labelFactory(effects, ok3, nok, type, markerType, stringType) {
  var self2 = this;
  var size2 = 0;
  var data;
  return start4;
  function start4(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 && !data || code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs || size2 > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding$a(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label2(code2);
  }
  function label2(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding$a(code2) || size2++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    data = data || !markdownSpace$6(code2);
    return code2 === 92 ? labelEscape : label2;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size2++;
      return label2;
    }
    return label2(code2);
  }
}
var factoryLabel$2 = labelFactory;
var markdownLineEnding$9 = markdownLineEnding_1;
var markdownSpace$5 = markdownSpace_1;
var factorySpace$8 = factorySpace$h;
function whitespaceFactory(effects, ok3) {
  var seen;
  return start4;
  function start4(code2) {
    if (markdownLineEnding$9(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start4;
    }
    if (markdownSpace$5(code2)) {
      return factorySpace$8(effects, start4, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok3(code2);
  }
}
var factoryWhitespace$2 = whitespaceFactory;
var markdownLineEnding$8 = markdownLineEnding_1;
var factorySpace$7 = factorySpace$h;
function titleFactory(effects, ok3, nok, type, markerType, stringType) {
  var marker;
  return start4;
  function start4(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    marker = code2 === 40 ? 41 : code2;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atTitleBreak(code2);
  }
  function atTitleBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding$8(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace$7(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code2);
  }
  function title(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding$8(code2)) {
      effects.exit("chunkString");
      return atTitleBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? titleEscape : title;
  }
  function titleEscape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return title;
    }
    return title(code2);
  }
}
var factoryTitle$2 = titleFactory;
var markdownLineEnding$7 = markdownLineEnding_1;
var markdownLineEndingOrSpace$5 = markdownLineEndingOrSpace_1;
var normalizeIdentifier$2 = normalizeIdentifier_1;
var factoryDestination$1 = factoryDestination$2;
var factoryLabel$1 = factoryLabel$2;
var factorySpace$6 = factorySpace$h;
var factoryWhitespace$1 = factoryWhitespace$2;
var factoryTitle$1 = factoryTitle$2;
var definition$2 = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok3, nok) {
  var self2 = this;
  var identifier;
  return start4;
  function start4(code2) {
    effects.enter("definition");
    return factoryLabel$1.call(self2, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier$2(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factoryWhitespace$1(effects, factoryDestination$1(effects, effects.attempt(titleConstruct, factorySpace$6(effects, after2, "whitespace"), factorySpace$6(effects, after2, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
    }
    return nok(code2);
  }
  function after2(code2) {
    if (code2 === null || markdownLineEnding$7(code2)) {
      effects.exit("definition");
      if (self2.parser.defined.indexOf(identifier) < 0) {
        self2.parser.defined.push(identifier);
      }
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitle(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    return markdownLineEndingOrSpace$5(code2) ? factoryWhitespace$1(effects, before2)(code2) : nok(code2);
  }
  function before2(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle$1(effects, factorySpace$6(effects, after2, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    return nok(code2);
  }
  function after2(code2) {
    return code2 === null || markdownLineEnding$7(code2) ? ok3(code2) : nok(code2);
  }
}
var definition_1$1 = definition$2;
var markdownLineEnding$6 = markdownLineEnding_1;
var hardBreakEscape$1 = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    return open2;
  }
  function open2(code2) {
    if (markdownLineEnding$6(code2)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok3(code2);
    }
    return nok(code2);
  }
}
var hardBreakEscape_1 = hardBreakEscape$1;
var markdownLineEnding$5 = markdownLineEnding_1;
var markdownLineEndingOrSpace$4 = markdownLineEndingOrSpace_1;
var markdownSpace$4 = markdownSpace_1;
var chunkedSplice$2 = chunkedSplice_1;
var factorySpace$5 = factorySpace$h;
var headingAtx$1 = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  var contentEnd = events.length - 2;
  var contentStart = 3;
  var content3;
  var text3;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text3 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    chunkedSplice$2(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text3, context],
      ["exit", text3, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  var self2 = this;
  var size2 = 0;
  return start4;
  function start4(code2) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code2);
  }
  function fenceOpenInside(code2) {
    if (code2 === 35 && size2++ < 6) {
      effects.consume(code2);
      return fenceOpenInside;
    }
    if (code2 === null || markdownLineEndingOrSpace$4(code2)) {
      effects.exit("atxHeadingSequence");
      return self2.interrupt ? ok3(code2) : headingBreak(code2);
    }
    return nok(code2);
  }
  function headingBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code2);
    }
    if (code2 === null || markdownLineEnding$5(code2)) {
      effects.exit("atxHeading");
      return ok3(code2);
    }
    if (markdownSpace$4(code2)) {
      return factorySpace$5(effects, headingBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequence(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace$4(code2)) {
      effects.exit("atxHeadingText");
      return headingBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
var headingAtx_1 = headingAtx$1;
var basics = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlBlockNames$1 = basics;
var raws = ["pre", "script", "style", "textarea"];
var htmlRawNames$1 = raws;
var asciiAlpha$2 = asciiAlpha_1;
var asciiAlphanumeric$2 = asciiAlphanumeric_1;
var markdownLineEnding$4 = markdownLineEnding_1;
var markdownLineEndingOrSpace$3 = markdownLineEndingOrSpace_1;
var markdownSpace$3 = markdownSpace_1;
var fromCharCode = fromCharCode_1;
var htmlBlockNames = htmlBlockNames$1;
var htmlRawNames = htmlRawNames$1;
var partialBlankLine$1 = partialBlankLine_1;
var htmlFlow$1 = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  var index3 = events.length;
  while (index3--) {
    if (events[index3][0] === "enter" && events[index3][1].type === "htmlFlow") {
      break;
    }
  }
  if (index3 > 1 && events[index3 - 2][1].type === "linePrefix") {
    events[index3][1].start = events[index3 - 2][1].start;
    events[index3 + 1][1].start = events[index3 - 2][1].start;
    events.splice(index3 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  var self2 = this;
  var kind;
  var startTag;
  var buffer2;
  var index3;
  var marker;
  return start4;
  function start4(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open2;
  }
  function open2(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationStart;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      kind = 3;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha$2(code2)) {
      effects.consume(code2);
      buffer2 = fromCharCode(code2);
      startTag = true;
      return tagName;
    }
    return nok(code2);
  }
  function declarationStart(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      kind = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      kind = 5;
      buffer2 = "CDATA[";
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha$2(code2)) {
      effects.consume(code2);
      kind = 4;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    if (code2 === buffer2.charCodeAt(index3++)) {
      effects.consume(code2);
      return index3 === buffer2.length ? self2.interrupt ? ok3 : continuation : cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha$2(code2)) {
      effects.consume(code2);
      buffer2 = fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace$3(code2)) {
      if (code2 !== 47 && startTag && htmlRawNames.indexOf(buffer2.toLowerCase()) > -1) {
        kind = 1;
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      if (htmlBlockNames.indexOf(buffer2.toLowerCase()) > -1) {
        kind = 6;
        if (code2 === 47) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      kind = 7;
      return self2.interrupt ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
    }
    if (code2 === 45 || asciiAlphanumeric$2(code2)) {
      effects.consume(code2);
      buffer2 += fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace$3(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha$2(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace$3(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric$2(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace$3(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace$3(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    marker = void 0;
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding$4(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace$3(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace$3(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (markdownSpace$3(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return code2 === null || markdownLineEnding$4(code2) ? continuation(code2) : nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && kind === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && kind === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && kind === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && kind === 5) {
      effects.consume(code2);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding$4(code2) && (kind === 6 || kind === 7)) {
      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code2);
    }
    if (code2 === null || markdownLineEnding$4(code2)) {
      return continuationAtLineEnding(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationAtLineEnding(code2) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code2);
  }
  function htmlContinueStart(code2) {
    if (code2 === null) {
      return done3(code2);
    }
    if (markdownLineEnding$4(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return htmlContinueStart;
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62 && htmlRawNames.indexOf(buffer2.toLowerCase()) > -1) {
      effects.consume(code2);
      return continuationClose;
    }
    if (asciiAlpha$2(code2) && buffer2.length < 8) {
      effects.consume(code2);
      buffer2 += fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCharacterDataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding$4(code2)) {
      effects.exit("htmlFlowData");
      return done3(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function done3(code2) {
    effects.exit("htmlFlow");
    return ok3(code2);
  }
}
function tokenizeNextBlank(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    return effects.attempt(partialBlankLine$1, ok3, nok);
  }
}
var htmlFlow_1 = htmlFlow$1;
var asciiAlpha$1 = asciiAlpha_1;
var asciiAlphanumeric$1 = asciiAlphanumeric_1;
var markdownLineEnding$3 = markdownLineEnding_1;
var markdownLineEndingOrSpace$2 = markdownLineEndingOrSpace_1;
var markdownSpace$2 = markdownSpace_1;
var factorySpace$4 = factorySpace$h;
var htmlText$1 = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok3, nok) {
  var self2 = this;
  var marker;
  var buffer2;
  var index3;
  var returnState;
  return start4;
  function start4(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open2;
  }
  function open2(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpen;
    }
    if (code2 === 91) {
      effects.consume(code2);
      buffer2 = "CDATA[";
      index3 = 0;
      return cdataOpen;
    }
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentStart;
    }
    return nok(code2);
  }
  function commentStart(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentStartDash;
    }
    return comment(code2);
  }
  function commentStartDash(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    return comment(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding$3(code2)) {
      returnState = comment;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return end3;
    }
    return comment(code2);
  }
  function cdataOpen(code2) {
    if (code2 === buffer2.charCodeAt(index3++)) {
      effects.consume(code2);
      return index3 === buffer2.length ? cdata : cdataOpen;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding$3(code2)) {
      returnState = cdata;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end3(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end3(code2);
    }
    if (markdownLineEnding$3(code2)) {
      returnState = declaration;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding$3(code2)) {
      returnState = instruction;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end3(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha$1(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding$3(code2)) {
      returnState = tagCloseBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace$2(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end3(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace$2(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end3;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha$1(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding$3(code2)) {
      returnState = tagOpenBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace$2(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end3(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric$1(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding$3(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code2);
    }
    if (markdownSpace$2(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding$3(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code2);
    }
    if (markdownSpace$2(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding$3(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace$2(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 62 || markdownLineEndingOrSpace$2(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace$4(effects, afterPrefix, "linePrefix", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
  }
  function afterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
  function end3(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok3;
    }
    return nok(code2);
  }
}
var htmlText_1 = htmlText$1;
var markdownLineEndingOrSpace$1 = markdownLineEndingOrSpace_1;
var chunkedPush = chunkedPush_1;
var chunkedSplice$1 = chunkedSplice_1;
var normalizeIdentifier$1 = normalizeIdentifier_1;
var resolveAll$1 = resolveAll_1;
var shallow$2 = shallow_1;
var factoryDestination = factoryDestination$2;
var factoryLabel = factoryLabel$2;
var factoryTitle = factoryTitle$2;
var factoryWhitespace = factoryWhitespace$2;
var labelEnd$3 = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  var index3 = -1;
  var token;
  while (++index3 < events.length) {
    token = events[index3][1];
    if (!token._used && (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd")) {
      events.splice(index3 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index3++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  var index3 = events.length;
  var offset2 = 0;
  var group;
  var label2;
  var text3;
  var token;
  var open2;
  var close3;
  var media;
  while (index3--) {
    token = events[index3][1];
    if (open2) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index3][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close3) {
      if (events[index3][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open2 = index3;
        if (token.type !== "labelLink") {
          offset2 = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close3 = index3;
    }
  }
  group = {
    type: events[open2][1].type === "labelLink" ? "link" : "image",
    start: shallow$2(events[open2][1].start),
    end: shallow$2(events[events.length - 1][1].end)
  };
  label2 = {
    type: "label",
    start: shallow$2(events[open2][1].start),
    end: shallow$2(events[close3][1].end)
  };
  text3 = {
    type: "labelText",
    start: shallow$2(events[open2 + offset2 + 2][1].end),
    end: shallow$2(events[close3 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label2, context]
  ];
  media = chunkedPush(media, events.slice(open2 + 1, open2 + offset2 + 3));
  media = chunkedPush(media, [["enter", text3, context]]);
  media = chunkedPush(media, resolveAll$1(context.parser.constructs.insideSpan.null, events.slice(open2 + offset2 + 4, close3 - 3), context));
  media = chunkedPush(media, [
    ["exit", text3, context],
    events[close3 - 2],
    events[close3 - 1],
    ["exit", label2, context]
  ]);
  media = chunkedPush(media, events.slice(close3 + 1));
  media = chunkedPush(media, [["exit", group, context]]);
  chunkedSplice$1(events, open2, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  var self2 = this;
  var index3 = self2.events.length;
  var labelStart;
  var defined;
  while (index3--) {
    if ((self2.events[index3][1].type === "labelImage" || self2.events[index3][1].type === "labelLink") && !self2.events[index3][1]._balanced) {
      labelStart = self2.events[index3][1];
      break;
    }
  }
  return start4;
  function start4(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive)
      return balanced(code2);
    defined = self2.parser.defined.indexOf(normalizeIdentifier$1(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    }))) > -1;
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, ok3, defined ? ok3 : balanced)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(fullReferenceConstruct, ok3, defined ? effects.attempt(collapsedReferenceConstruct, ok3, balanced) : balanced)(code2);
    }
    return defined ? ok3(code2) : balanced(code2);
  }
  function balanced(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open2);
  }
  function open2(code2) {
    if (code2 === 41) {
      return end3(code2);
    }
    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 3)(code2);
  }
  function destinationAfter(code2) {
    return markdownLineEndingOrSpace$1(code2) ? factoryWhitespace(effects, between)(code2) : end3(code2);
  }
  function between(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factoryWhitespace(effects, end3), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return end3(code2);
  }
  function end3(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok3;
    }
    return nok(code2);
  }
}
function tokenizeFullReference(effects, ok3, nok) {
  var self2 = this;
  return start4;
  function start4(code2) {
    return factoryLabel.call(self2, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code2);
  }
  function afterLabel(code2) {
    return self2.parser.defined.indexOf(normalizeIdentifier$1(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) < 0 ? nok(code2) : ok3(code2);
  }
}
function tokenizeCollapsedReference(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return open2;
  }
  function open2(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok3;
    }
    return nok(code2);
  }
}
var labelEnd_1 = labelEnd$3;
var labelEnd$2 = labelEnd_1;
var labelStartImage$1 = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd$2.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  var self2 = this;
  return start4;
  function start4(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open2;
  }
  function open2(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after2;
    }
    return nok(code2);
  }
  function after2(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}
var labelStartImage_1 = labelStartImage$1;
var labelEnd$1 = labelEnd_1;
var labelStartLink$1 = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd$1.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  var self2 = this;
  return start4;
  function start4(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after2;
  }
  function after2(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}
var labelStartLink_1 = labelStartLink$1;
var factorySpace$3 = factorySpace$h;
var lineEnding$1 = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok3) {
  return start4;
  function start4(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace$3(effects, ok3, "linePrefix");
  }
}
var lineEnding_1 = lineEnding$1;
var markdownLineEnding$2 = markdownLineEnding_1;
var markdownSpace$1 = markdownSpace_1;
var factorySpace$2 = factorySpace$h;
var thematicBreak$3 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  var size2 = 0;
  var marker;
  return start4;
  function start4(code2) {
    effects.enter("thematicBreak");
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (markdownSpace$1(code2)) {
      return factorySpace$2(effects, atBreak, "whitespace")(code2);
    }
    if (size2 < 3 || code2 !== null && !markdownLineEnding$2(code2)) {
      return nok(code2);
    }
    effects.exit("thematicBreak");
    return ok3(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size2++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code2);
  }
}
var thematicBreak_1$1 = thematicBreak$3;
var asciiDigit = asciiDigit_1;
var markdownSpace = markdownSpace_1;
var prefixSize$2 = prefixSize_1;
var sizeChunks = sizeChunks_1;
var factorySpace$1 = factorySpace$h;
var partialBlankLine = partialBlankLine_1;
var thematicBreak$2 = thematicBreak_1$1;
var list$2 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok3, nok) {
  var self2 = this;
  var initialSize = prefixSize$2(self2.events, "linePrefix");
  var size2 = 0;
  return start4;
  function start4(code2) {
    var kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size2 < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(partialBlankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
    return ok3(code2);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  var self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(partialBlankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace$1(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace$1(effects, effects.attempt(list$2, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  var self2 = this;
  return factorySpace$1(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code2) {
    return prefixSize$2(self2.events, "listItemIndent") === self2.containerState.size ? ok3(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  var self2 = this;
  return factorySpace$1(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    return markdownSpace(code2) || !prefixSize$2(self2.events, "listItemPrefixWhitespace") ? nok(code2) : ok3(code2);
  }
}
var list_1$1 = list$2;
var markdownLineEnding$1 = markdownLineEnding_1;
var shallow$1 = shallow_1;
var factorySpace = factorySpace$h;
var setextUnderline$1 = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  var index3 = events.length;
  var content3;
  var text3;
  var definition2;
  var heading2;
  while (index3--) {
    if (events[index3][0] === "enter") {
      if (events[index3][1].type === "content") {
        content3 = index3;
        break;
      }
      if (events[index3][1].type === "paragraph") {
        text3 = index3;
      }
    } else {
      if (events[index3][1].type === "content") {
        events.splice(index3, 1);
      }
      if (!definition2 && events[index3][1].type === "definition") {
        definition2 = index3;
      }
    }
  }
  heading2 = {
    type: "setextHeading",
    start: shallow$1(events[text3][1].start),
    end: shallow$1(events[events.length - 1][1].end)
  };
  events[text3][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text3, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = shallow$1(events[definition2][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  var self2 = this;
  var index3 = self2.events.length;
  var marker;
  var paragraph2;
  while (index3--) {
    if (self2.events[index3][1].type !== "lineEnding" && self2.events[index3][1].type !== "linePrefix" && self2.events[index3][1].type !== "content") {
      paragraph2 = self2.events[index3][1].type === "paragraph";
      break;
    }
  }
  return start4;
  function start4(code2) {
    if (!self2.lazy && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code2;
      return closingSequence(code2);
    }
    return nok(code2);
  }
  function closingSequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
  }
  function closingSequenceEnd(code2) {
    if (code2 === null || markdownLineEnding$1(code2)) {
      effects.exit("setextHeadingLine");
      return ok3(code2);
    }
    return nok(code2);
  }
}
var setextUnderline_1 = setextUnderline$1;
Object.defineProperty(constructs$1, "__esModule", { value: true });
var text$1$1 = text$6;
var attention = attention_1;
var autolink$1 = autolink_1;
var blockQuote = blockQuote_1;
var characterEscape$1 = characterEscape_1;
var characterReference$1 = characterReference_1;
var codeFenced = codeFenced_1;
var codeIndented = codeIndented_1;
var codeText = codeText_1;
var definition$1 = definition_1$1;
var hardBreakEscape = hardBreakEscape_1;
var headingAtx = headingAtx_1;
var htmlFlow = htmlFlow_1;
var htmlText = htmlText_1;
var labelEnd = labelEnd_1;
var labelStartImage = labelStartImage_1;
var labelStartLink = labelStartLink_1;
var lineEnding = lineEnding_1;
var list$1 = list_1$1;
var setextUnderline = setextUnderline_1;
var thematicBreak$1 = thematicBreak_1$1;
var document$2 = {
  42: list$1,
  43: list$1,
  45: list$1,
  48: list$1,
  49: list$1,
  50: list$1,
  51: list$1,
  52: list$1,
  53: list$1,
  54: list$1,
  55: list$1,
  56: list$1,
  57: list$1,
  62: blockQuote
};
var contentInitial = {
  91: definition$1
};
var flowInitial = {
  "-2": codeIndented,
  "-1": codeIndented,
  32: codeIndented
};
var flow$6 = {
  35: headingAtx,
  42: thematicBreak$1,
  45: [setextUnderline, thematicBreak$1],
  60: htmlFlow,
  61: setextUnderline,
  95: thematicBreak$1,
  96: codeFenced,
  126: codeFenced
};
var string = {
  38: characterReference$1,
  92: characterEscape$1
};
var text$4 = {
  "-5": lineEnding,
  "-4": lineEnding,
  "-3": lineEnding,
  33: labelStartImage,
  38: characterReference$1,
  42: attention,
  60: [autolink$1, htmlText],
  91: labelStartLink,
  92: [hardBreakEscape, characterEscape$1],
  93: labelEnd,
  95: attention,
  96: codeText
};
var insideSpan = {
  null: [attention, text$1$1.resolver]
};
var disable = {
  null: []
};
constructs$1.contentInitial = contentInitial;
constructs$1.disable = disable;
constructs$1.document = document$2;
constructs$1.flow = flow$6;
constructs$1.flowInitial = flowInitial;
constructs$1.insideSpan = insideSpan;
constructs$1.string = string;
constructs$1.text = text$4;
var content = content$3;
var document$1 = document$3;
var flow$5 = flow$7;
var text$3 = text$6;
var combineExtensions = combineExtensions_1;
var createTokenizer = createTokenizer_1;
var miniflat = miniflat_1;
var constructs = constructs$1;
function parse$3(options) {
  var settings = options || {};
  var parser2 = {
    defined: [],
    constructs: combineExtensions([constructs].concat(miniflat(settings.extensions))),
    content: create7(content),
    document: create7(document$1),
    flow: create7(flow$5),
    string: create7(text$3.string),
    text: create7(text$3.text)
  };
  return parser2;
  function create7(initializer) {
    return creator;
    function creator(from5) {
      return createTokenizer(parser2, initializer, from5);
    }
  }
}
var parse_1 = parse$3;
var search$1 = /[\0\t\n\r]/g;
function preprocess() {
  var start4 = true;
  var column = 1;
  var buffer2 = "";
  var atCarriageReturn;
  return preprocessor2;
  function preprocessor2(value, encoding, end3) {
    var chunks = [];
    var match;
    var next;
    var startPosition;
    var endPosition;
    var code2;
    value = buffer2 + value.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start4) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start4 = void 0;
    }
    while (startPosition < value.length) {
      search$1.lastIndex = startPosition;
      match = search$1.exec(value);
      endPosition = match ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        if (code2 === 0) {
          chunks.push(65533);
          column++;
        } else if (code2 === 9) {
          next = Math.ceil(column / 4) * 4;
          chunks.push(-2);
          while (column++ < next)
            chunks.push(-1);
        } else if (code2 === 10) {
          chunks.push(-4);
          column = 1;
        } else {
          atCarriageReturn = true;
          column = 1;
        }
      }
      startPosition = endPosition + 1;
    }
    if (end3) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer2)
        chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}
var preprocess_1 = preprocess;
var subtokenize = subtokenize_1;
function postprocess$1(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
var postprocess_1 = postprocess$1;
var dist = fromMarkdown$9;
var toString$2 = mdastUtilToString;
var assign = assign_1;
var own$3 = hasOwnProperty$6;
var normalizeIdentifier = normalizeIdentifier_1;
var safeFromInt = safeFromInt_1;
var parser$1 = parse_1;
var preprocessor = preprocess_1;
var postprocess = postprocess_1;
var decode$1 = decodeEntity_browser;
var stringifyPosition = unistUtilStringifyPosition;
function fromMarkdown$9(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parser$1(options).document().write(preprocessor()(value, encoding, true))));
}
function compiler(options) {
  var settings = options || {};
  var config2 = configure$4({
    transforms: [],
    canContainEols: [
      "emphasis",
      "fragment",
      "heading",
      "paragraph",
      "strong"
    ],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }, settings.mdastExtensions || []);
  var data = {};
  return compile3;
  function compile3(events) {
    var tree = { type: "root", children: [] };
    var stack = [tree];
    var tokenStack = [];
    var listStack = [];
    var index3 = -1;
    var handler;
    var listStart;
    var context = {
      stack,
      tokenStack,
      config: config2,
      enter: enter2,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    while (++index3 < events.length) {
      if (events[index3][1].type === "listOrdered" || events[index3][1].type === "listUnordered") {
        if (events[index3][0] === "enter") {
          listStack.push(index3);
        } else {
          listStart = listStack.pop(index3);
          index3 = prepareList(events, listStart, index3);
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      handler = config2[events[index3][0]];
      if (own$3.call(handler, events[index3][1].type)) {
        handler[events[index3][1].type].call(assign({ sliceSerialize: events[index3][2].sliceSerialize }, context), events[index3][1]);
      }
    }
    if (tokenStack.length) {
      throw new Error("Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
        start: tokenStack[tokenStack.length - 1].start,
        end: tokenStack[tokenStack.length - 1].end
      }) + ") is still open");
    }
    tree.position = {
      start: point2(events.length ? events[0][1].start : { line: 1, column: 1, offset: 0 }),
      end: point2(events.length ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 })
    };
    index3 = -1;
    while (++index3 < config2.transforms.length) {
      tree = config2.transforms[index3](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start4, length) {
    var index3 = start4 - 1;
    var containerBalance = -1;
    var listSpread = false;
    var listItem3;
    var tailIndex;
    var lineIndex;
    var tailEvent;
    var event;
    var firstBlankLineIndex;
    var atMarker;
    while (++index3 <= length) {
      event = events[index3];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index3;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
        ;
      else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          tailIndex = index3;
          lineIndex = void 0;
          while (tailIndex--) {
            tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
              ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = point2(lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index3, 0, ["exit", listItem3, event[2]]);
          index3++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: point2(event[1].start)
          };
          events.splice(index3, 0, ["enter", listItem3, event[2]]);
          index3++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start4][1]._spread = listSpread;
    return length;
  }
  function setData(key2, value) {
    data[key2] = value;
  }
  function getData(key2) {
    return data[key2];
  }
  function point2(d2) {
    return { line: d2.line, column: d2.column, offset: d2.offset };
  }
  function opener(create7, and) {
    return open2;
    function open2(token) {
      enter2.call(this, create7(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter2(node5, token) {
    this.stack[this.stack.length - 1].children.push(node5);
    this.stack.push(node5);
    this.tokenStack.push(token);
    node5.position = { start: point2(token.start) };
    return node5;
  }
  function closer(and) {
    return close3;
    function close3(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token) {
    var node5 = this.stack.pop();
    var open2 = this.tokenStack.pop();
    if (!open2) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it\u2019s not open");
    } else if (open2.type !== token.type) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): a different token (`" + open2.type + "`, " + stringifyPosition({ start: open2.start, end: open2.end }) + ") is open");
    }
    node5.position.end = point2(token.end);
    return node5;
  }
  function resume() {
    return toString$2(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      this.stack[this.stack.length - 2].start = parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].lang = data2;
  }
  function onexitcodefencedfencemeta() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].value = data2;
  }
  function onexitdefinitionlabelstring(token) {
    var label2 = this.resume();
    this.stack[this.stack.length - 1].label = label2;
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].title = data2;
  }
  function onexitdefinitiondestinationstring() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].url = data2;
  }
  function onexitatxheadingsequence(token) {
    if (!this.stack[this.stack.length - 1].depth) {
      this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).length;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    var siblings = this.stack[this.stack.length - 1].children;
    var tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text3();
      tail.position = { start: point2(token.start) };
      this.stack[this.stack.length - 1].children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    var tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    var context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      context.children[context.children.length - 1].position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config2.canContainEols.indexOf(context.type) > -1) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].value = data2;
  }
  function onexithtmltext() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].value = data2;
  }
  function onexitcodetext() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].value = data2;
  }
  function onexitlink() {
    var context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
      delete context.referenceType;
    }
    setData("referenceType");
  }
  function onexitimage() {
    var context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
      delete context.referenceType;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    this.stack[this.stack.length - 2].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitlabel() {
    var fragment = this.stack[this.stack.length - 1];
    var value = this.resume();
    this.stack[this.stack.length - 1].label = value;
    setData("inReference", true);
    if (this.stack[this.stack.length - 1].type === "link") {
      this.stack[this.stack.length - 1].children = fragment.children;
    } else {
      this.stack[this.stack.length - 1].alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].url = data2;
  }
  function onexitresourcetitlestring() {
    var data2 = this.resume();
    this.stack[this.stack.length - 1].title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    var label2 = this.resume();
    this.stack[this.stack.length - 1].label = label2;
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    var data2 = this.sliceSerialize(token);
    var type = getData("characterReferenceType");
    var value;
    var tail;
    if (type) {
      value = safeFromInt(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      value = decode$1(data2);
    }
    tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    this.stack[this.stack.length - 1].url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return { type: "heading", depth: void 0, children: [] };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html2() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text3() {
    return { type: "text", value: "" };
  }
  function thematicBreak2() {
    return { type: "thematicBreak" };
  }
}
function configure$4(config2, extensions) {
  var index3 = -1;
  while (++index3 < extensions.length) {
    extension$1(config2, extensions[index3]);
  }
  return config2;
}
function extension$1(config2, extension2) {
  var key2;
  var left;
  for (key2 in extension2) {
    left = own$3.call(config2, key2) ? config2[key2] : config2[key2] = {};
    if (key2 === "canContainEols" || key2 === "transforms") {
      config2[key2] = [].concat(left, extension2[key2]);
    } else {
      Object.assign(left, extension2[key2]);
    }
  }
}
var mdastUtilFromMarkdown = dist;
var remarkParse = parse$2;
var fromMarkdown$8 = mdastUtilFromMarkdown;
function parse$2(options) {
  var self2 = this;
  this.Parser = parse4;
  function parse4(doc2) {
    return fromMarkdown$8(doc2, Object.assign({}, self2.data("settings"), options, {
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    }));
  }
}
var zwitch$1 = factory$1;
var noop = Function.prototype;
var own$2 = {}.hasOwnProperty;
function factory$1(key2, options) {
  var settings = options || {};
  function one2(value) {
    var fn = one2.invalid;
    var handlers2 = one2.handlers;
    if (value && own$2.call(value, key2)) {
      fn = own$2.call(handlers2, value[key2]) ? handlers2[value[key2]] : one2.unknown;
    }
    return (fn || noop).apply(this, arguments);
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
var configure_1 = configure$3;
function configure$3(base2, extension2) {
  var index3 = -1;
  var key2;
  if (extension2.extensions) {
    while (++index3 < extension2.extensions.length) {
      configure$3(base2, extension2.extensions[index3]);
    }
  }
  for (key2 in extension2) {
    if (key2 === "extensions")
      ;
    else if (key2 === "unsafe" || key2 === "join") {
      base2[key2] = base2[key2].concat(extension2[key2] || []);
    } else if (key2 === "handlers") {
      base2[key2] = Object.assign(base2[key2], extension2[key2] || {});
    } else {
      base2.options[key2] = extension2[key2];
    }
  }
  return base2;
}
var handle = {};
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var res = "";
var cache$2;
var repeatString = repeat$8;
function repeat$8(str, num) {
  if (typeof str !== "string") {
    throw new TypeError("expected a string");
  }
  if (num === 1)
    return str;
  if (num === 2)
    return str + str;
  var max2 = str.length * num;
  if (cache$2 !== str || typeof cache$2 === "undefined") {
    cache$2 = str;
    res = "";
  } else if (res.length >= max2) {
    return res.substr(0, max2);
  }
  while (max2 > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }
    num >>= 1;
    str += str;
  }
  res += str;
  res = res.substr(0, max2);
  return res;
}
var containerFlow = flow$4;
var repeat$7 = repeatString;
function flow$4(parent, context) {
  var children = parent.children || [];
  var results = [];
  var index3 = -1;
  var child4;
  while (++index3 < children.length) {
    child4 = children[index3];
    results.push(context.handle(child4, parent, context, { before: "\n", after: "\n" }));
    if (index3 + 1 < children.length) {
      results.push(between(child4, children[index3 + 1]));
    }
  }
  return results.join("");
  function between(left, right) {
    var index4 = -1;
    var result2;
    while (++index4 < context.join.length) {
      result2 = context.join[index4](left, right, parent, context);
      if (result2 === true || result2 === 1) {
        break;
      }
      if (typeof result2 === "number") {
        return repeat$7("\n", 1 + Number(result2));
      }
      if (result2 === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
}
var indentLines_1 = indentLines$3;
var eol = /\r?\n|\r/g;
function indentLines$3(value, map21) {
  var result2 = [];
  var start4 = 0;
  var line = 0;
  var match;
  while (match = eol.exec(value)) {
    one2(value.slice(start4, match.index));
    result2.push(match[0]);
    start4 = match.index + match[0].length;
    line++;
  }
  one2(value.slice(start4));
  return result2.join("");
  function one2(value2) {
    result2.push(map21(value2, line, !value2));
  }
}
var blockquote_1 = blockquote$1;
var flow$3 = containerFlow;
var indentLines$2 = indentLines_1;
function blockquote$1(node5, _2, context) {
  var exit2 = context.enter("blockquote");
  var value = indentLines$2(flow$3(node5, context), map$1);
  exit2();
  return value;
}
function map$1(line, index3, blank) {
  return ">" + (blank ? "" : " ") + line;
}
var patternInScope_1 = patternInScope$2;
function patternInScope$2(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct);
}
function listInScope(stack, list2, none2) {
  var index3;
  if (!list2) {
    return none2;
  }
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  index3 = -1;
  while (++index3 < list2.length) {
    if (stack.indexOf(list2[index3]) !== -1) {
      return true;
    }
  }
  return false;
}
var _break = hardBreak;
var patternInScope$1 = patternInScope_1;
function hardBreak(node5, _2, context, safe2) {
  var index3 = -1;
  while (++index3 < context.unsafe.length) {
    if (context.unsafe[index3].character === "\n" && patternInScope$1(context.stack, context.unsafe[index3])) {
      return /[ \t]/.test(safe2.before) ? "" : " ";
    }
  }
  return "\\\n";
}
var longestStreak_1 = longestStreak;
function longestStreak(value, character) {
  var count = 0;
  var maximum = 0;
  var expected;
  var index3;
  if (typeof character !== "string" || character.length !== 1) {
    throw new Error("Expected character");
  }
  value = String(value);
  index3 = value.indexOf(character);
  expected = index3;
  while (index3 !== -1) {
    count++;
    if (index3 === expected) {
      if (count > maximum) {
        maximum = count;
      }
    } else {
      count = 1;
    }
    expected = index3 + 1;
    index3 = value.indexOf(character, expected);
  }
  return maximum;
}
var formatCodeAsIndented_1 = formatCodeAsIndented$2;
function formatCodeAsIndented$2(node5, context) {
  return !context.options.fences && node5.value && !node5.lang && /[^ \r\n]/.test(node5.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node5.value);
}
var checkFence_1 = checkFence$1;
function checkFence$1(context) {
  var marker = context.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
  }
  return marker;
}
var patternCompile_1 = patternCompile$2;
function patternCompile$2(pattern) {
  var before2;
  var after2;
  if (!pattern._compiled) {
    before2 = pattern.before ? "(?:" + pattern.before + ")" : "";
    after2 = pattern.after ? "(?:" + pattern.after + ")" : "";
    if (pattern.atBreak) {
      before2 = "[\\r\\n][\\t ]*" + before2;
    }
    pattern._compiled = new RegExp((before2 ? "(" + before2 + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (after2 || ""), "g");
  }
  return pattern._compiled;
}
var safe_1 = safe$8;
var patternCompile$1 = patternCompile_1;
var patternInScope = patternInScope_1;
function safe$8(context, input2, config2) {
  var value = (config2.before || "") + (input2 || "") + (config2.after || "");
  var positions = [];
  var result2 = [];
  var infos = {};
  var index3 = -1;
  var before2;
  var after2;
  var position2;
  var pattern;
  var expression;
  var match;
  var start4;
  var end3;
  while (++index3 < context.unsafe.length) {
    pattern = context.unsafe[index3];
    if (!patternInScope(context.stack, pattern)) {
      continue;
    }
    expression = patternCompile$1(pattern);
    while (match = expression.exec(value)) {
      before2 = "before" in pattern || pattern.atBreak;
      after2 = "after" in pattern;
      position2 = match.index + (before2 ? match[1].length : 0);
      if (positions.indexOf(position2) === -1) {
        positions.push(position2);
        infos[position2] = { before: before2, after: after2 };
      } else {
        if (infos[position2].before && !before2) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after2) {
          infos[position2].after = false;
        }
      }
    }
  }
  positions.sort(numerical);
  start4 = config2.before ? config2.before.length : 0;
  end3 = value.length - (config2.after ? config2.after.length : 0);
  index3 = -1;
  while (++index3 < positions.length) {
    position2 = positions[index3];
    if (position2 < start4 || position2 >= end3) {
      continue;
    }
    if (position2 + 1 < end3 && positions[index3 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after) {
      continue;
    }
    if (start4 !== position2) {
      result2.push(escapeBackslashes(value.slice(start4, position2), "\\"));
    }
    start4 = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config2.encode || config2.encode.indexOf(value.charAt(position2)) === -1)) {
      result2.push("\\");
    } else {
      result2.push("&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";");
      start4++;
    }
  }
  result2.push(escapeBackslashes(value.slice(start4, end3), config2.after));
  return result2.join("");
}
function numerical(a2, b2) {
  return a2 - b2;
}
function escapeBackslashes(value, after2) {
  var expression = /\\(?=[!-/:-@[-`{-~])/g;
  var positions = [];
  var results = [];
  var index3 = -1;
  var start4 = 0;
  var whole = value + after2;
  var match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index3 < positions.length) {
    if (start4 !== positions[index3]) {
      results.push(value.slice(start4, positions[index3]));
    }
    results.push("\\");
    start4 = positions[index3];
  }
  results.push(value.slice(start4));
  return results.join("");
}
var code_1 = code$2;
var repeat$6 = repeatString;
var streak$1 = longestStreak_1;
var formatCodeAsIndented$1 = formatCodeAsIndented_1;
var checkFence = checkFence_1;
var indentLines$1 = indentLines_1;
var safe$7 = safe_1;
function code$2(node5, _2, context) {
  var marker = checkFence(context);
  var raw = node5.value || "";
  var suffix = marker === "`" ? "GraveAccent" : "Tilde";
  var value;
  var sequence;
  var exit2;
  var subexit;
  if (formatCodeAsIndented$1(node5, context)) {
    exit2 = context.enter("codeIndented");
    value = indentLines$1(raw, map);
  } else {
    sequence = repeat$6(marker, Math.max(streak$1(raw, marker) + 1, 3));
    exit2 = context.enter("codeFenced");
    value = sequence;
    if (node5.lang) {
      subexit = context.enter("codeFencedLang" + suffix);
      value += safe$7(context, node5.lang, {
        before: "`",
        after: " ",
        encode: ["`"]
      });
      subexit();
    }
    if (node5.lang && node5.meta) {
      subexit = context.enter("codeFencedMeta" + suffix);
      value += " " + safe$7(context, node5.meta, {
        before: " ",
        after: "\n",
        encode: ["`"]
      });
      subexit();
    }
    value += "\n";
    if (raw) {
      value += raw + "\n";
    }
    value += sequence;
  }
  exit2();
  return value;
}
function map(line, _2, blank) {
  return (blank ? "" : "    ") + line;
}
var association_1 = association$3;
var decode = decodeEntity_browser;
var characterEscape = /\\([!-/:-@[-`{-~])/g;
var characterReference = /&(#(\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function association$3(node5) {
  if (node5.label || !node5.identifier) {
    return node5.label || "";
  }
  return node5.identifier.replace(characterEscape, "$1").replace(characterReference, decodeIfPossible);
}
function decodeIfPossible($0, $1) {
  return decode($1) || $0;
}
var checkQuote_1 = checkQuote$3;
function checkQuote$3(context) {
  var marker = context.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
  }
  return marker;
}
var definition_1 = definition;
var association$2 = association_1;
var checkQuote$2 = checkQuote_1;
var safe$6 = safe_1;
function definition(node5, _2, context) {
  var marker = checkQuote$2(context);
  var suffix = marker === '"' ? "Quote" : "Apostrophe";
  var exit2 = context.enter("definition");
  var subexit = context.enter("label");
  var value = "[" + safe$6(context, association$2(node5), { before: "[", after: "]" }) + "]: ";
  subexit();
  if (!node5.url || /[ \t\r\n]/.test(node5.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe$6(context, node5.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe$6(context, node5.url, { before: " ", after: " " });
  }
  subexit();
  if (node5.title) {
    subexit = context.enter("title" + suffix);
    value += " " + marker + safe$6(context, node5.title, { before: marker, after: marker }) + marker;
    subexit();
  }
  exit2();
  return value;
}
var checkEmphasis_1 = checkEmphasis$1;
function checkEmphasis$1(context) {
  var marker = context.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
  }
  return marker;
}
var containerPhrasing = phrasing$8;
function phrasing$8(parent, context, safeOptions) {
  var children = parent.children || [];
  var results = [];
  var index3 = -1;
  var before2 = safeOptions.before;
  var after2;
  var handle2;
  var child4;
  while (++index3 < children.length) {
    child4 = children[index3];
    if (index3 + 1 < children.length) {
      handle2 = context.handle.handlers[children[index3 + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after2 = handle2 ? handle2(children[index3 + 1], parent, context, {
        before: "",
        after: ""
      }).charAt(0) : "";
    } else {
      after2 = safeOptions.after;
    }
    if (results.length > 0 && (before2 === "\r" || before2 === "\n") && child4.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before2 = " ";
    }
    results.push(context.handle(child4, parent, context, {
      before: before2,
      after: after2
    }));
    before2 = results[results.length - 1].slice(-1);
  }
  return results.join("");
}
var emphasis_1 = emphasis;
emphasis.peek = emphasisPeek;
var checkEmphasis = checkEmphasis_1;
var phrasing$7 = containerPhrasing;
function emphasis(node5, _2, context) {
  var marker = checkEmphasis(context);
  var exit2 = context.enter("emphasis");
  var value = phrasing$7(node5, context, { before: marker, after: marker });
  exit2();
  return marker + value + marker;
}
function emphasisPeek(node5, _2, context) {
  return context.options.emphasis || "*";
}
var formatHeadingAsSetext_1 = formatHeadingAsSetext$2;
var toString$1 = mdastUtilToString;
function formatHeadingAsSetext$2(node5, context) {
  return context.options.setext && (!node5.depth || node5.depth < 3) && toString$1(node5);
}
var heading_1 = heading$1;
var repeat$5 = repeatString;
var formatHeadingAsSetext$1 = formatHeadingAsSetext_1;
var phrasing$6 = containerPhrasing;
function heading$1(node5, _2, context) {
  var rank = Math.max(Math.min(6, node5.depth || 1), 1);
  var exit2;
  var subexit;
  var value;
  var sequence;
  if (formatHeadingAsSetext$1(node5, context)) {
    exit2 = context.enter("headingSetext");
    subexit = context.enter("phrasing");
    value = phrasing$6(node5, context, { before: "\n", after: "\n" });
    subexit();
    exit2();
    return value + "\n" + repeat$5(rank === 1 ? "=" : "-", value.length - (Math.max(value.lastIndexOf("\r"), value.lastIndexOf("\n")) + 1));
  }
  sequence = repeat$5("#", rank);
  exit2 = context.enter("headingAtx");
  subexit = context.enter("phrasing");
  value = phrasing$6(node5, context, { before: "# ", after: "\n" });
  value = value ? sequence + " " + value : sequence;
  if (context.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}
var html_1 = html;
html.peek = htmlPeek;
function html(node5) {
  return node5.value || "";
}
function htmlPeek() {
  return "<";
}
var image_1 = image$1;
image$1.peek = imagePeek;
var checkQuote$1 = checkQuote_1;
var safe$5 = safe_1;
function image$1(node5, _2, context) {
  var quote = checkQuote$1(context);
  var suffix = quote === '"' ? "Quote" : "Apostrophe";
  var exit2 = context.enter("image");
  var subexit = context.enter("label");
  var value = "![" + safe$5(context, node5.alt, { before: "[", after: "]" }) + "](";
  subexit();
  if (!node5.url && node5.title || /[ \t\r\n]/.test(node5.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe$5(context, node5.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe$5(context, node5.url, {
      before: "(",
      after: node5.title ? " " : ")"
    });
  }
  subexit();
  if (node5.title) {
    subexit = context.enter("title" + suffix);
    value += " " + quote + safe$5(context, node5.title, { before: quote, after: quote }) + quote;
    subexit();
  }
  value += ")";
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}
var imageReference_1 = imageReference;
imageReference.peek = imageReferencePeek;
var association$1 = association_1;
var safe$4 = safe_1;
function imageReference(node5, _2, context) {
  var type = node5.referenceType;
  var exit2 = context.enter("imageReference");
  var subexit = context.enter("label");
  var alt = safe$4(context, node5.alt, { before: "[", after: "]" });
  var value = "![" + alt + "]";
  var reference;
  var stack;
  subexit();
  stack = context.stack;
  context.stack = [];
  subexit = context.enter("reference");
  reference = safe$4(context, association$1(node5), { before: "[", after: "]" });
  subexit();
  context.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += "[" + reference + "]";
  } else if (type !== "shortcut") {
    value += "[]";
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}
var inlineCode_1 = inlineCode;
inlineCode.peek = inlineCodePeek;
var patternCompile = patternCompile_1;
function inlineCode(node5, parent, context) {
  var value = node5.value || "";
  var sequence = "`";
  var index3 = -1;
  var pattern;
  var expression;
  var match;
  var position2;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/[ \r\n`]/.test(value.charAt(0)) || /[ \r\n`]/.test(value.charAt(value.length - 1)))) {
    value = " " + value + " ";
  }
  while (++index3 < context.unsafe.length) {
    pattern = context.unsafe[index3];
    if (!pattern.atBreak)
      continue;
    expression = patternCompile(pattern);
    while (match = expression.exec(value)) {
      position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
var formatLinkAsAutolink_1 = formatLinkAsAutolink$1;
var toString = mdastUtilToString;
function formatLinkAsAutolink$1(node5, context) {
  var raw = toString(node5);
  return !context.options.resourceLink && node5.url && !node5.title && node5.children && node5.children.length === 1 && node5.children[0].type === "text" && (raw === node5.url || "mailto:" + raw === node5.url) && /^[a-z][a-z+.-]+:/i.test(node5.url) && !/[\0- <>\u007F]/.test(node5.url);
}
var link_1 = link$2;
link$2.peek = linkPeek;
var checkQuote = checkQuote_1;
var formatLinkAsAutolink = formatLinkAsAutolink_1;
var phrasing$5 = containerPhrasing;
var safe$3 = safe_1;
function link$2(node5, _2, context) {
  var quote = checkQuote(context);
  var suffix = quote === '"' ? "Quote" : "Apostrophe";
  var exit2;
  var subexit;
  var value;
  var stack;
  if (formatLinkAsAutolink(node5, context)) {
    stack = context.stack;
    context.stack = [];
    exit2 = context.enter("autolink");
    value = "<" + phrasing$5(node5, context, { before: "<", after: ">" }) + ">";
    exit2();
    context.stack = stack;
    return value;
  }
  exit2 = context.enter("link");
  subexit = context.enter("label");
  value = "[" + phrasing$5(node5, context, { before: "[", after: "]" }) + "](";
  subexit();
  if (!node5.url && node5.title || /[ \t\r\n]/.test(node5.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe$3(context, node5.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe$3(context, node5.url, {
      before: "(",
      after: node5.title ? " " : ")"
    });
  }
  subexit();
  if (node5.title) {
    subexit = context.enter("title" + suffix);
    value += " " + quote + safe$3(context, node5.title, { before: quote, after: quote }) + quote;
    subexit();
  }
  value += ")";
  exit2();
  return value;
}
function linkPeek(node5, _2, context) {
  return formatLinkAsAutolink(node5, context) ? "<" : "[";
}
var linkReference_1 = linkReference;
linkReference.peek = linkReferencePeek;
var association = association_1;
var phrasing$4 = containerPhrasing;
var safe$2 = safe_1;
function linkReference(node5, _2, context) {
  var type = node5.referenceType;
  var exit2 = context.enter("linkReference");
  var subexit = context.enter("label");
  var text3 = phrasing$4(node5, context, { before: "[", after: "]" });
  var value = "[" + text3 + "]";
  var reference;
  var stack;
  subexit();
  stack = context.stack;
  context.stack = [];
  subexit = context.enter("reference");
  reference = safe$2(context, association(node5), { before: "[", after: "]" });
  subexit();
  context.stack = stack;
  exit2();
  if (type === "full" || !text3 || text3 !== reference) {
    value += "[" + reference + "]";
  } else if (type !== "shortcut") {
    value += "[]";
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}
var list_1 = list;
var flow$2 = containerFlow;
function list(node5, _2, context) {
  var exit2 = context.enter("list");
  var value = flow$2(node5, context);
  exit2();
  return value;
}
var checkBullet_1 = checkBullet$1;
function checkBullet$1(context) {
  var marker = context.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
  }
  return marker;
}
var checkListItemIndent_1 = checkListItemIndent$1;
function checkListItemIndent$1(context) {
  var style = context.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  }
  return style;
}
var listItem_1 = listItem$1;
var repeat$4 = repeatString;
var checkBullet = checkBullet_1;
var checkListItemIndent = checkListItemIndent_1;
var flow$1 = containerFlow;
var indentLines = indentLines_1;
function listItem$1(node5, parent, context) {
  var bullet = checkBullet(context);
  var listItemIndent = checkListItemIndent(context);
  var size2;
  var value;
  var exit2;
  if (parent && parent.ordered) {
    bullet = (parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node5)) + ".";
  }
  size2 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.spread || node5.spread)) {
    size2 = Math.ceil(size2 / 4) * 4;
  }
  exit2 = context.enter("listItem");
  value = indentLines(flow$1(node5, context), map21);
  exit2();
  return value;
  function map21(line, index3, blank) {
    if (index3) {
      return (blank ? "" : repeat$4(" ", size2)) + line;
    }
    return (blank ? bullet : bullet + repeat$4(" ", size2 - bullet.length)) + line;
  }
}
var paragraph_1 = paragraph$1;
var phrasing$3 = containerPhrasing;
function paragraph$1(node5, _2, context) {
  var exit2 = context.enter("paragraph");
  var subexit = context.enter("phrasing");
  var value = phrasing$3(node5, context, { before: "\n", after: "\n" });
  subexit();
  exit2();
  return value;
}
var root_1 = root$8;
var flow = containerFlow;
function root$8(node5, _2, context) {
  return flow(node5, context);
}
var checkStrong_1 = checkStrong$1;
function checkStrong$1(context) {
  var marker = context.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
  }
  return marker;
}
var strong_1 = strong$1;
strong$1.peek = strongPeek;
var checkStrong = checkStrong_1;
var phrasing$2 = containerPhrasing;
function strong$1(node5, _2, context) {
  var marker = checkStrong(context);
  var exit2 = context.enter("strong");
  var value = phrasing$2(node5, context, { before: marker, after: marker });
  exit2();
  return marker + marker + value + marker + marker;
}
function strongPeek(node5, _2, context) {
  return context.options.strong || "*";
}
var text_1 = text$2;
var safe$1 = safe_1;
function text$2(node5, parent, context, safeOptions) {
  return safe$1(context, node5.value, safeOptions);
}
var checkRuleRepeat = checkRule$2;
function checkRule$2(context) {
  var repetition = context.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
  }
  return repetition;
}
var checkRule_1 = checkRule$1;
function checkRule$1(context) {
  var marker = context.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
  }
  return marker;
}
var thematicBreak_1 = thematicBreak;
var repeat$3 = repeatString;
var checkRepeat = checkRuleRepeat;
var checkRule = checkRule_1;
function thematicBreak(node5, parent, context) {
  var value = repeat$3(checkRule(context) + (context.options.ruleSpaces ? " " : ""), checkRepeat(context));
  return context.options.ruleSpaces ? value.slice(0, -1) : value;
}
handle.blockquote = blockquote_1;
handle.break = _break;
handle.code = code_1;
handle.definition = definition_1;
handle.emphasis = emphasis_1;
handle.hardBreak = _break;
handle.heading = heading_1;
handle.html = html_1;
handle.image = image_1;
handle.imageReference = imageReference_1;
handle.inlineCode = inlineCode_1;
handle.link = link_1;
handle.linkReference = linkReference_1;
handle.list = list_1;
handle.listItem = listItem_1;
handle.paragraph = paragraph_1;
handle.root = root_1;
handle.strong = strong_1;
handle.text = text_1;
handle.thematicBreak = thematicBreak_1;
var join = [joinDefaults];
var formatCodeAsIndented = formatCodeAsIndented_1;
var formatHeadingAsSetext = formatHeadingAsSetext_1;
function joinDefaults(left, right, parent, context) {
  if (right.type === "list" && right.type === left.type && Boolean(left.ordered) === Boolean(right.ordered) || right.type === "code" && formatCodeAsIndented(right, context) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, context))) {
    return false;
  }
  if (typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && (left.type === right.type || right.type === "definition" || right.type === "heading" && formatHeadingAsSetext(right, context))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}
var unsafe = [
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  { character: "!", after: "\\[", inConstruct: "phrasing" },
  { character: '"', inConstruct: "titleQuote" },
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  { character: "'", inConstruct: "titleApostrophe" },
  { character: "(", inConstruct: "destinationRaw" },
  { before: "\\]", character: "(", inConstruct: "phrasing" },
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  { atBreak: true, character: "*" },
  { character: "*", inConstruct: "phrasing" },
  { atBreak: true, character: "+" },
  { atBreak: true, character: "-" },
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing" },
  { character: "<", inConstruct: "destinationLiteral" },
  { atBreak: true, character: "=" },
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: ["phrasing", "label", "reference"] },
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "]",
    inConstruct: ["label", "reference"]
  },
  { atBreak: true, character: "_" },
  { before: "[^A-Za-z]", character: "_", inConstruct: "phrasing" },
  { character: "_", after: "[^A-Za-z]", inConstruct: "phrasing" },
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedMetaGraveAccent",
      "phrasing"
    ]
  },
  { atBreak: true, character: "~" }
];
var lib = toMarkdown$9;
var zwitch = zwitch$1;
var configure$2 = configure_1;
var defaultHandlers = handle;
var defaultJoin = join;
var defaultUnsafe = unsafe;
function toMarkdown$9(tree, options) {
  var settings = options || {};
  var context = {
    enter: enter2,
    stack: [],
    unsafe: [],
    join: [],
    handlers: {},
    options: {}
  };
  var result2;
  configure$2(context, {
    unsafe: defaultUnsafe,
    join: defaultJoin,
    handlers: defaultHandlers
  });
  configure$2(context, settings);
  if (context.options.tightDefinitions) {
    context.join = [joinDefinition].concat(context.join);
  }
  context.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: context.handlers
  });
  result2 = context.handle(tree, null, context, { before: "\n", after: "\n" });
  if (result2 && result2.charCodeAt(result2.length - 1) !== 10 && result2.charCodeAt(result2.length - 1) !== 13) {
    result2 += "\n";
  }
  return result2;
  function enter2(name) {
    context.stack.push(name);
    return exit2;
    function exit2() {
      context.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(node5) {
  throw new Error("Cannot handle unknown node `" + node5.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
var mdastUtilToMarkdown = lib;
var remarkStringify = stringify$1;
var toMarkdown$8 = mdastUtilToMarkdown;
function stringify$1(options) {
  var self2 = this;
  this.Compiler = compile3;
  function compile3(tree) {
    return toMarkdown$8(tree, Object.assign({}, self2.data("settings"), options, {
      extensions: self2.data("toMarkdownExtensions") || []
    }));
  }
}
var unified = unified_1;
var parse$1 = remarkParse;
var stringify = remarkStringify;
var remark = unified().use(parse$1).use(stringify).freeze();
const createTimer = (name, timeout = 3e3) => {
  const id2 = Symbol("Timer");
  const timer = (store) => {
    const data = Symbol(name);
    const timing = () => new Promise((resolve7, reject) => {
      setTimeout(() => {
        reject(`Timing ${name} timeout.`);
      }, timeout);
      addEventListener(name, (e3) => {
        if (!(e3 instanceof CustomEvent)) {
          return;
        }
        if (e3.detail.id === data) {
          resolve7(void 0);
        }
      });
    });
    timing.done = () => {
      const event = new CustomEvent(name, { detail: { id: data } });
      dispatchEvent(event);
    };
    store.set(id2, timing);
    return timing;
  };
  timer.id = id2;
  return timer;
};
const createClock = () => {
  const store = new Map();
  const get5 = (timer) => {
    const meta = store.get(timer.id);
    if (!meta)
      throw timerNotFound();
    return meta;
  };
  return {
    store,
    get: get5
  };
};
const Config = createTimer("Config");
const config$1 = (configure2) => (pre) => {
  pre.record(Config);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield configure2(ctx);
    ctx.done(Config);
  });
};
function OrderedMap(content3) {
  this.content = content3;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key2) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      if (this.content[i2] === key2)
        return i2;
    return -1;
  },
  get: function(key2) {
    var found2 = this.find(key2);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key2, value, newKey) {
    var self2 = newKey && newKey != key2 ? this.remove(newKey) : this;
    var found2 = self2.find(key2), content3 = self2.content.slice();
    if (found2 == -1) {
      content3.push(newKey || key2, value);
    } else {
      content3[found2 + 1] = value;
      if (newKey)
        content3[found2] = newKey;
    }
    return new OrderedMap(content3);
  },
  remove: function(key2) {
    var found2 = this.find(key2);
    if (found2 == -1)
      return this;
    var content3 = this.content.slice();
    content3.splice(found2, 2);
    return new OrderedMap(content3);
  },
  addToStart: function(key2, value) {
    return new OrderedMap([key2, value].concat(this.remove(key2).content));
  },
  addToEnd: function(key2, value) {
    var content3 = this.remove(key2).content.slice();
    content3.push(key2, value);
    return new OrderedMap(content3);
  },
  addBefore: function(place, key2, value) {
    var without = this.remove(key2), content3 = without.content.slice();
    var found2 = without.find(place);
    content3.splice(found2 == -1 ? content3.length : found2, 0, key2, value);
    return new OrderedMap(content3);
  },
  forEach: function(f2) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      f2(this.content[i2], this.content[i2 + 1]);
  },
  prepend: function(map21) {
    map21 = OrderedMap.from(map21);
    if (!map21.size)
      return this;
    return new OrderedMap(map21.content.concat(this.subtract(map21).content));
  },
  append: function(map21) {
    map21 = OrderedMap.from(map21);
    if (!map21.size)
      return this;
    return new OrderedMap(this.subtract(map21).content.concat(map21.content));
  },
  subtract: function(map21) {
    var result2 = this;
    map21 = OrderedMap.from(map21);
    for (var i2 = 0; i2 < map21.content.length; i2 += 2)
      result2 = result2.remove(map21.content[i2]);
    return result2;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content3 = [];
  if (value)
    for (var prop in value)
      content3.push(prop, value[prop]);
  return new OrderedMap(content3);
};
var orderedmap = OrderedMap;
function findDiffStart(a2, b2, pos) {
  for (var i2 = 0; ; i2++) {
    if (i2 == a2.childCount || i2 == b2.childCount) {
      return a2.childCount == b2.childCount ? null : pos;
    }
    var childA = a2.child(i2), childB = b2.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j2 = 0; childA.text[j2] == childB.text[j2]; j2++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b2, posA, posB) {
  for (var iA = a2.childCount, iB = b2.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a2.child(--iA), childB = b2.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size2;
    posB -= size2;
  }
}
var Fragment = function Fragment2(content3, size2) {
  this.content = content3;
  this.size = size2 || 0;
  if (size2 == null) {
    for (var i2 = 0; i2 < content3.length; i2++) {
      this.size += content3[i2].nodeSize;
    }
  }
};
var prototypeAccessors$6 = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
Fragment.prototype.nodesBetween = function nodesBetween(from5, to2, f2, nodeStart, parent) {
  if (nodeStart === void 0)
    nodeStart = 0;
  for (var i2 = 0, pos = 0; pos < to2; i2++) {
    var child4 = this.content[i2], end3 = pos + child4.nodeSize;
    if (end3 > from5 && f2(child4, nodeStart + pos, parent, i2) !== false && child4.content.size) {
      var start4 = pos + 1;
      child4.nodesBetween(Math.max(0, from5 - start4), Math.min(child4.content.size, to2 - start4), f2, nodeStart + start4);
    }
    pos = end3;
  }
};
Fragment.prototype.descendants = function descendants(f2) {
  this.nodesBetween(0, this.size, f2);
};
Fragment.prototype.textBetween = function textBetween(from5, to2, blockSeparator, leafText) {
  var text3 = "", separated = true;
  this.nodesBetween(from5, to2, function(node5, pos) {
    if (node5.isText) {
      text3 += node5.text.slice(Math.max(from5, pos) - pos, to2 - pos);
      separated = !blockSeparator;
    } else if (node5.isLeaf && leafText) {
      text3 += leafText;
      separated = !blockSeparator;
    } else if (!separated && node5.isBlock) {
      text3 += blockSeparator;
      separated = true;
    }
  }, 0);
  return text3;
};
Fragment.prototype.append = function append(other) {
  if (!other.size) {
    return this;
  }
  if (!this.size) {
    return other;
  }
  var last = this.lastChild, first = other.firstChild, content3 = this.content.slice(), i2 = 0;
  if (last.isText && last.sameMarkup(first)) {
    content3[content3.length - 1] = last.withText(last.text + first.text);
    i2 = 1;
  }
  for (; i2 < other.content.length; i2++) {
    content3.push(other.content[i2]);
  }
  return new Fragment(content3, this.size + other.size);
};
Fragment.prototype.cut = function cut(from5, to2) {
  if (to2 == null) {
    to2 = this.size;
  }
  if (from5 == 0 && to2 == this.size) {
    return this;
  }
  var result2 = [], size2 = 0;
  if (to2 > from5) {
    for (var i2 = 0, pos = 0; pos < to2; i2++) {
      var child4 = this.content[i2], end3 = pos + child4.nodeSize;
      if (end3 > from5) {
        if (pos < from5 || end3 > to2) {
          if (child4.isText) {
            child4 = child4.cut(Math.max(0, from5 - pos), Math.min(child4.text.length, to2 - pos));
          } else {
            child4 = child4.cut(Math.max(0, from5 - pos - 1), Math.min(child4.content.size, to2 - pos - 1));
          }
        }
        result2.push(child4);
        size2 += child4.nodeSize;
      }
      pos = end3;
    }
  }
  return new Fragment(result2, size2);
};
Fragment.prototype.cutByIndex = function cutByIndex(from5, to2) {
  if (from5 == to2) {
    return Fragment.empty;
  }
  if (from5 == 0 && to2 == this.content.length) {
    return this;
  }
  return new Fragment(this.content.slice(from5, to2));
};
Fragment.prototype.replaceChild = function replaceChild(index3, node5) {
  var current = this.content[index3];
  if (current == node5) {
    return this;
  }
  var copy6 = this.content.slice();
  var size2 = this.size + node5.nodeSize - current.nodeSize;
  copy6[index3] = node5;
  return new Fragment(copy6, size2);
};
Fragment.prototype.addToStart = function addToStart(node5) {
  return new Fragment([node5].concat(this.content), this.size + node5.nodeSize);
};
Fragment.prototype.addToEnd = function addToEnd(node5) {
  return new Fragment(this.content.concat(node5), this.size + node5.nodeSize);
};
Fragment.prototype.eq = function eq2(other) {
  if (this.content.length != other.content.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.content.length; i2++) {
    if (!this.content[i2].eq(other.content[i2])) {
      return false;
    }
  }
  return true;
};
prototypeAccessors$6.firstChild.get = function() {
  return this.content.length ? this.content[0] : null;
};
prototypeAccessors$6.lastChild.get = function() {
  return this.content.length ? this.content[this.content.length - 1] : null;
};
prototypeAccessors$6.childCount.get = function() {
  return this.content.length;
};
Fragment.prototype.child = function child(index3) {
  var found2 = this.content[index3];
  if (!found2) {
    throw new RangeError("Index " + index3 + " out of range for " + this);
  }
  return found2;
};
Fragment.prototype.maybeChild = function maybeChild(index3) {
  return this.content[index3];
};
Fragment.prototype.forEach = function forEach(f2) {
  for (var i2 = 0, p2 = 0; i2 < this.content.length; i2++) {
    var child4 = this.content[i2];
    f2(child4, p2, i2);
    p2 += child4.nodeSize;
  }
};
Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
  if (pos === void 0)
    pos = 0;
  return findDiffStart(this, other, pos);
};
Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
  if (pos === void 0)
    pos = this.size;
  if (otherPos === void 0)
    otherPos = other.size;
  return findDiffEnd(this, other, pos, otherPos);
};
Fragment.prototype.findIndex = function findIndex(pos, round) {
  if (round === void 0)
    round = -1;
  if (pos == 0) {
    return retIndex(0, pos);
  }
  if (pos == this.size) {
    return retIndex(this.content.length, pos);
  }
  if (pos > this.size || pos < 0) {
    throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
  }
  for (var i2 = 0, curPos = 0; ; i2++) {
    var cur = this.child(i2), end3 = curPos + cur.nodeSize;
    if (end3 >= pos) {
      if (end3 == pos || round > 0) {
        return retIndex(i2 + 1, end3);
      }
      return retIndex(i2, curPos);
    }
    curPos = end3;
  }
};
Fragment.prototype.toString = function toString2() {
  return "<" + this.toStringInner() + ">";
};
Fragment.prototype.toStringInner = function toStringInner() {
  return this.content.join(", ");
};
Fragment.prototype.toJSON = function toJSON() {
  return this.content.length ? this.content.map(function(n2) {
    return n2.toJSON();
  }) : null;
};
Fragment.fromJSON = function fromJSON(schema2, value) {
  if (!value) {
    return Fragment.empty;
  }
  if (!Array.isArray(value)) {
    throw new RangeError("Invalid input for Fragment.fromJSON");
  }
  return new Fragment(value.map(schema2.nodeFromJSON));
};
Fragment.fromArray = function fromArray(array) {
  if (!array.length) {
    return Fragment.empty;
  }
  var joined, size2 = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var node5 = array[i2];
    size2 += node5.nodeSize;
    if (i2 && node5.isText && array[i2 - 1].sameMarkup(node5)) {
      if (!joined) {
        joined = array.slice(0, i2);
      }
      joined[joined.length - 1] = node5.withText(joined[joined.length - 1].text + node5.text);
    } else if (joined) {
      joined.push(node5);
    }
  }
  return new Fragment(joined || array, size2);
};
Fragment.from = function from(nodes2) {
  if (!nodes2) {
    return Fragment.empty;
  }
  if (nodes2 instanceof Fragment) {
    return nodes2;
  }
  if (Array.isArray(nodes2)) {
    return this.fromArray(nodes2);
  }
  if (nodes2.attrs) {
    return new Fragment([nodes2], nodes2.nodeSize);
  }
  throw new RangeError("Can not convert " + nodes2 + " to a Fragment" + (nodes2.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
};
Object.defineProperties(Fragment.prototype, prototypeAccessors$6);
var found = { index: 0, offset: 0 };
function retIndex(index3, offset2) {
  found.index = index3;
  found.offset = offset2;
  return found;
}
Fragment.empty = new Fragment([], 0);
function compareDeep(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (!(a2 && typeof a2 == "object") || !(b2 && typeof b2 == "object")) {
    return false;
  }
  var array = Array.isArray(a2);
  if (Array.isArray(b2) != array) {
    return false;
  }
  if (array) {
    if (a2.length != b2.length) {
      return false;
    }
    for (var i2 = 0; i2 < a2.length; i2++) {
      if (!compareDeep(a2[i2], b2[i2])) {
        return false;
      }
    }
  } else {
    for (var p2 in a2) {
      if (!(p2 in b2) || !compareDeep(a2[p2], b2[p2])) {
        return false;
      }
    }
    for (var p$12 in b2) {
      if (!(p$12 in a2)) {
        return false;
      }
    }
  }
  return true;
}
var Mark = function Mark2(type, attrs) {
  this.type = type;
  this.attrs = attrs;
};
Mark.prototype.addToSet = function addToSet(set3) {
  var copy6, placed = false;
  for (var i2 = 0; i2 < set3.length; i2++) {
    var other = set3[i2];
    if (this.eq(other)) {
      return set3;
    }
    if (this.type.excludes(other.type)) {
      if (!copy6) {
        copy6 = set3.slice(0, i2);
      }
    } else if (other.type.excludes(this.type)) {
      return set3;
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy6) {
          copy6 = set3.slice(0, i2);
        }
        copy6.push(this);
        placed = true;
      }
      if (copy6) {
        copy6.push(other);
      }
    }
  }
  if (!copy6) {
    copy6 = set3.slice();
  }
  if (!placed) {
    copy6.push(this);
  }
  return copy6;
};
Mark.prototype.removeFromSet = function removeFromSet(set3) {
  for (var i2 = 0; i2 < set3.length; i2++) {
    if (this.eq(set3[i2])) {
      return set3.slice(0, i2).concat(set3.slice(i2 + 1));
    }
  }
  return set3;
};
Mark.prototype.isInSet = function isInSet(set3) {
  for (var i2 = 0; i2 < set3.length; i2++) {
    if (this.eq(set3[i2])) {
      return true;
    }
  }
  return false;
};
Mark.prototype.eq = function eq3(other) {
  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
};
Mark.prototype.toJSON = function toJSON2() {
  var obj = { type: this.type.name };
  for (var _2 in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  return obj;
};
Mark.fromJSON = function fromJSON2(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Mark.fromJSON");
  }
  var type = schema2.marks[json.type];
  if (!type) {
    throw new RangeError("There is no mark type " + json.type + " in this schema");
  }
  return type.create(json.attrs);
};
Mark.sameSet = function sameSet(a2, b2) {
  if (a2 == b2) {
    return true;
  }
  if (a2.length != b2.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].eq(b2[i2])) {
      return false;
    }
  }
  return true;
};
Mark.setFrom = function setFrom(marks3) {
  if (!marks3 || marks3.length == 0) {
    return Mark.none;
  }
  if (marks3 instanceof Mark) {
    return [marks3];
  }
  var copy6 = marks3.slice();
  copy6.sort(function(a2, b2) {
    return a2.type.rank - b2.type.rank;
  });
  return copy6;
};
Mark.none = [];
function ReplaceError(message2) {
  var err2 = Error.call(this, message2);
  err2.__proto__ = ReplaceError.prototype;
  return err2;
}
ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";
var Slice = function Slice2(content3, openStart, openEnd) {
  this.content = content3;
  this.openStart = openStart;
  this.openEnd = openEnd;
};
var prototypeAccessors$1$4 = { size: { configurable: true } };
prototypeAccessors$1$4.size.get = function() {
  return this.content.size - this.openStart - this.openEnd;
};
Slice.prototype.insertAt = function insertAt(pos, fragment) {
  var content3 = insertInto(this.content, pos + this.openStart, fragment, null);
  return content3 && new Slice(content3, this.openStart, this.openEnd);
};
Slice.prototype.removeBetween = function removeBetween(from5, to2) {
  return new Slice(removeRange(this.content, from5 + this.openStart, to2 + this.openStart), this.openStart, this.openEnd);
};
Slice.prototype.eq = function eq4(other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
};
Slice.prototype.toString = function toString3() {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")";
};
Slice.prototype.toJSON = function toJSON3() {
  if (!this.content.size) {
    return null;
  }
  var json = { content: this.content.toJSON() };
  if (this.openStart > 0) {
    json.openStart = this.openStart;
  }
  if (this.openEnd > 0) {
    json.openEnd = this.openEnd;
  }
  return json;
};
Slice.fromJSON = function fromJSON3(schema2, json) {
  if (!json) {
    return Slice.empty;
  }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number") {
    throw new RangeError("Invalid input for Slice.fromJSON");
  }
  return new Slice(Fragment.fromJSON(schema2, json.content), openStart, openEnd);
};
Slice.maxOpen = function maxOpen(fragment, openIsolating) {
  if (openIsolating === void 0)
    openIsolating = true;
  var openStart = 0, openEnd = 0;
  for (var n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild) {
    openStart++;
  }
  for (var n$12 = fragment.lastChild; n$12 && !n$12.isLeaf && (openIsolating || !n$12.type.spec.isolating); n$12 = n$12.lastChild) {
    openEnd++;
  }
  return new Slice(fragment, openStart, openEnd);
};
Object.defineProperties(Slice.prototype, prototypeAccessors$1$4);
function removeRange(content3, from5, to2) {
  var ref = content3.findIndex(from5);
  var index3 = ref.index;
  var offset2 = ref.offset;
  var child4 = content3.maybeChild(index3);
  var ref$1 = content3.findIndex(to2);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from5 || child4.isText) {
    if (offsetTo != to2 && !content3.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content3.cut(0, from5).append(content3.cut(to2));
  }
  if (index3 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content3.replaceChild(index3, child4.copy(removeRange(child4.content, from5 - offset2 - 1, to2 - offset2 - 1)));
}
function insertInto(content3, dist2, insert, parent) {
  var ref = content3.findIndex(dist2);
  var index3 = ref.index;
  var offset2 = ref.offset;
  var child4 = content3.maybeChild(index3);
  if (offset2 == dist2 || child4.isText) {
    if (parent && !parent.canReplace(index3, index3, insert)) {
      return null;
    }
    return content3.cut(0, dist2).append(insert).append(content3.cut(dist2));
  }
  var inner = insertInto(child4.content, dist2 - offset2 - 1, insert);
  return inner && content3.replaceChild(index3, child4.copy(inner));
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function replace$1($from, $to, slice5) {
  if (slice5.openStart > $from.depth) {
    throw new ReplaceError("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice5.openStart != $to.depth - slice5.openEnd) {
    throw new ReplaceError("Inconsistent open depths");
  }
  return replaceOuter($from, $to, slice5, 0);
}
function replaceOuter($from, $to, slice5, depth) {
  var index3 = $from.index(depth), node5 = $from.node(depth);
  if (index3 == $to.index(depth) && depth < $from.depth - slice5.openStart) {
    var inner = replaceOuter($from, $to, slice5, depth + 1);
    return node5.copy(node5.content.replaceChild(index3, inner));
  } else if (!slice5.content.size) {
    return close$2(node5, replaceTwoWay($from, $to, depth));
  } else if (!slice5.openStart && !slice5.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content3 = parent.content;
    return close$2(parent, content3.cut(0, $from.parentOffset).append(slice5.content).append(content3.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace(slice5, $from);
    var start4 = ref.start;
    var end3 = ref.end;
    return close$2(node5, replaceThreeWay($from, start4, end3, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type)) {
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
}
function joinable$1($before, $after, depth) {
  var node5 = $before.node(depth);
  checkJoin(node5, $after.node(depth));
  return node5;
}
function addNode$2(child4, target) {
  var last = target.length - 1;
  if (last >= 0 && child4.isText && child4.sameMarkup(target[last])) {
    target[last] = child4.withText(target[last].text + child4.text);
  } else {
    target.push(child4);
  }
}
function addRange($start, $end, depth, target) {
  var node5 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node5.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode$2($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i2 = startIndex; i2 < endIndex; i2++) {
    addNode$2(node5.child(i2), target);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode$2($end.nodeBefore, target);
  }
}
function close$2(node5, content3) {
  if (!node5.type.validContent(content3)) {
    throw new ReplaceError("Invalid content for node " + node5.type.name);
  }
  return node5.copy(content3);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  var content3 = [];
  addRange(null, $from, depth, content3);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode$2(close$2(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content3);
  } else {
    if (openStart) {
      addNode$2(close$2(openStart, replaceTwoWay($from, $start, depth + 1)), content3);
    }
    addRange($start, $end, depth, content3);
    if (openEnd) {
      addNode$2(close$2(openEnd, replaceTwoWay($end, $to, depth + 1)), content3);
    }
  }
  addRange($to, null, depth, content3);
  return new Fragment(content3);
}
function replaceTwoWay($from, $to, depth) {
  var content3 = [];
  addRange(null, $from, depth, content3);
  if ($from.depth > depth) {
    var type = joinable$1($from, $to, depth + 1);
    addNode$2(close$2(type, replaceTwoWay($from, $to, depth + 1)), content3);
  }
  addRange($to, null, depth, content3);
  return new Fragment(content3);
}
function prepareSliceForReplace(slice5, $along) {
  var extra = $along.depth - slice5.openStart, parent = $along.node(extra);
  var node5 = parent.copy(slice5.content);
  for (var i2 = extra - 1; i2 >= 0; i2--) {
    node5 = $along.node(i2).copy(Fragment.from(node5));
  }
  return {
    start: node5.resolveNoCache(slice5.openStart + extra),
    end: node5.resolveNoCache(node5.content.size - slice5.openEnd - extra)
  };
}
var ResolvedPos = function ResolvedPos2(pos, path2, parentOffset) {
  this.pos = pos;
  this.path = path2;
  this.depth = path2.length / 3 - 1;
  this.parentOffset = parentOffset;
};
var prototypeAccessors$2$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
  if (val == null) {
    return this.depth;
  }
  if (val < 0) {
    return this.depth + val;
  }
  return val;
};
prototypeAccessors$2$2.parent.get = function() {
  return this.node(this.depth);
};
prototypeAccessors$2$2.doc.get = function() {
  return this.node(0);
};
ResolvedPos.prototype.node = function node(depth) {
  return this.path[this.resolveDepth(depth) * 3];
};
ResolvedPos.prototype.index = function index2(depth) {
  return this.path[this.resolveDepth(depth) * 3 + 1];
};
ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
};
ResolvedPos.prototype.start = function start(depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
};
ResolvedPos.prototype.end = function end(depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size;
};
ResolvedPos.prototype.before = function before(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position before the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
};
ResolvedPos.prototype.after = function after(depth) {
  depth = this.resolveDepth(depth);
  if (!depth) {
    throw new RangeError("There is no position after the top-level node");
  }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
};
prototypeAccessors$2$2.textOffset.get = function() {
  return this.pos - this.path[this.path.length - 1];
};
prototypeAccessors$2$2.nodeAfter.get = function() {
  var parent = this.parent, index3 = this.index(this.depth);
  if (index3 == parent.childCount) {
    return null;
  }
  var dOff = this.pos - this.path[this.path.length - 1], child4 = parent.child(index3);
  return dOff ? parent.child(index3).cut(dOff) : child4;
};
prototypeAccessors$2$2.nodeBefore.get = function() {
  var index3 = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) {
    return this.parent.child(index3).cut(0, dOff);
  }
  return index3 == 0 ? null : this.parent.child(index3 - 1);
};
ResolvedPos.prototype.posAtIndex = function posAtIndex(index3, depth) {
  depth = this.resolveDepth(depth);
  var node5 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i2 = 0; i2 < index3; i2++) {
    pos += node5.child(i2).nodeSize;
  }
  return pos;
};
ResolvedPos.prototype.marks = function marks() {
  var parent = this.parent, index3 = this.index();
  if (parent.content.size == 0) {
    return Mark.none;
  }
  if (this.textOffset) {
    return parent.child(index3).marks;
  }
  var main = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
  if (!main) {
    var tmp = main;
    main = other;
    other = tmp;
  }
  var marks3 = main.marks;
  for (var i2 = 0; i2 < marks3.length; i2++) {
    if (marks3[i2].type.spec.inclusive === false && (!other || !marks3[i2].isInSet(other.marks))) {
      marks3 = marks3[i2--].removeFromSet(marks3);
    }
  }
  return marks3;
};
ResolvedPos.prototype.marksAcross = function marksAcross($end) {
  var after2 = this.parent.maybeChild(this.index());
  if (!after2 || !after2.isInline) {
    return null;
  }
  var marks3 = after2.marks, next = $end.parent.maybeChild($end.index());
  for (var i2 = 0; i2 < marks3.length; i2++) {
    if (marks3[i2].type.spec.inclusive === false && (!next || !marks3[i2].isInSet(next.marks))) {
      marks3 = marks3[i2--].removeFromSet(marks3);
    }
  }
  return marks3;
};
ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
  for (var depth = this.depth; depth > 0; depth--) {
    if (this.start(depth) <= pos && this.end(depth) >= pos) {
      return depth;
    }
  }
  return 0;
};
ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
  if (other === void 0)
    other = this;
  if (other.pos < this.pos) {
    return other.blockRange(this);
  }
  for (var d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--) {
    if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2)))) {
      return new NodeRange(this, other, d2);
    }
  }
};
ResolvedPos.prototype.sameParent = function sameParent(other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset;
};
ResolvedPos.prototype.max = function max(other) {
  return other.pos > this.pos ? other : this;
};
ResolvedPos.prototype.min = function min(other) {
  return other.pos < this.pos ? other : this;
};
ResolvedPos.prototype.toString = function toString4() {
  var str = "";
  for (var i2 = 1; i2 <= this.depth; i2++) {
    str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
  }
  return str + ":" + this.parentOffset;
};
ResolvedPos.resolve = function resolve(doc2, pos) {
  if (!(pos >= 0 && pos <= doc2.content.size)) {
    throw new RangeError("Position " + pos + " out of range");
  }
  var path2 = [];
  var start4 = 0, parentOffset = pos;
  for (var node5 = doc2; ; ) {
    var ref = node5.content.findIndex(parentOffset);
    var index3 = ref.index;
    var offset2 = ref.offset;
    var rem = parentOffset - offset2;
    path2.push(node5, index3, start4 + offset2);
    if (!rem) {
      break;
    }
    node5 = node5.child(index3);
    if (node5.isText) {
      break;
    }
    parentOffset = rem - 1;
    start4 += offset2 + 1;
  }
  return new ResolvedPos(pos, path2, parentOffset);
};
ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
  for (var i2 = 0; i2 < resolveCache.length; i2++) {
    var cached = resolveCache[i2];
    if (cached.pos == pos && cached.doc == doc2) {
      return cached;
    }
  }
  var result2 = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result2;
};
Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2$2);
var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
var NodeRange = function NodeRange2($from, $to, depth) {
  this.$from = $from;
  this.$to = $to;
  this.depth = depth;
};
var prototypeAccessors$1$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
prototypeAccessors$1$1$1.start.get = function() {
  return this.$from.before(this.depth + 1);
};
prototypeAccessors$1$1$1.end.get = function() {
  return this.$to.after(this.depth + 1);
};
prototypeAccessors$1$1$1.parent.get = function() {
  return this.$from.node(this.depth);
};
prototypeAccessors$1$1$1.startIndex.get = function() {
  return this.$from.index(this.depth);
};
prototypeAccessors$1$1$1.endIndex.get = function() {
  return this.$to.indexAfter(this.depth);
};
Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1$1);
var emptyAttrs = Object.create(null);
var Node = function Node2(type, attrs, content3, marks3) {
  this.type = type;
  this.attrs = attrs;
  this.content = content3 || Fragment.empty;
  this.marks = marks3 || Mark.none;
};
var prototypeAccessors$3$1 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$3$1.nodeSize.get = function() {
  return this.isLeaf ? 1 : 2 + this.content.size;
};
prototypeAccessors$3$1.childCount.get = function() {
  return this.content.childCount;
};
Node.prototype.child = function child2(index3) {
  return this.content.child(index3);
};
Node.prototype.maybeChild = function maybeChild2(index3) {
  return this.content.maybeChild(index3);
};
Node.prototype.forEach = function forEach2(f2) {
  this.content.forEach(f2);
};
Node.prototype.nodesBetween = function nodesBetween2(from5, to2, f2, startPos) {
  if (startPos === void 0)
    startPos = 0;
  this.content.nodesBetween(from5, to2, f2, startPos, this);
};
Node.prototype.descendants = function descendants2(f2) {
  this.nodesBetween(0, this.content.size, f2);
};
prototypeAccessors$3$1.textContent.get = function() {
  return this.textBetween(0, this.content.size, "");
};
Node.prototype.textBetween = function textBetween2(from5, to2, blockSeparator, leafText) {
  return this.content.textBetween(from5, to2, blockSeparator, leafText);
};
prototypeAccessors$3$1.firstChild.get = function() {
  return this.content.firstChild;
};
prototypeAccessors$3$1.lastChild.get = function() {
  return this.content.lastChild;
};
Node.prototype.eq = function eq5(other) {
  return this == other || this.sameMarkup(other) && this.content.eq(other.content);
};
Node.prototype.sameMarkup = function sameMarkup(other) {
  return this.hasMarkup(other.type, other.attrs, other.marks);
};
Node.prototype.hasMarkup = function hasMarkup(type, attrs, marks3) {
  return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks3 || Mark.none);
};
Node.prototype.copy = function copy(content3) {
  if (content3 === void 0)
    content3 = null;
  if (content3 == this.content) {
    return this;
  }
  return new this.constructor(this.type, this.attrs, content3, this.marks);
};
Node.prototype.mark = function mark(marks3) {
  return marks3 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks3);
};
Node.prototype.cut = function cut2(from5, to2) {
  if (from5 == 0 && to2 == this.content.size) {
    return this;
  }
  return this.copy(this.content.cut(from5, to2));
};
Node.prototype.slice = function slice2(from5, to2, includeParents) {
  if (to2 === void 0)
    to2 = this.content.size;
  if (includeParents === void 0)
    includeParents = false;
  if (from5 == to2) {
    return Slice.empty;
  }
  var $from = this.resolve(from5), $to = this.resolve(to2);
  var depth = includeParents ? 0 : $from.sharedDepth(to2);
  var start4 = $from.start(depth), node5 = $from.node(depth);
  var content3 = node5.content.cut($from.pos - start4, $to.pos - start4);
  return new Slice(content3, $from.depth - depth, $to.depth - depth);
};
Node.prototype.replace = function replace$1$1(from5, to2, slice5) {
  return replace$1(this.resolve(from5), this.resolve(to2), slice5);
};
Node.prototype.nodeAt = function nodeAt(pos) {
  for (var node5 = this; ; ) {
    var ref = node5.content.findIndex(pos);
    var index3 = ref.index;
    var offset2 = ref.offset;
    node5 = node5.maybeChild(index3);
    if (!node5) {
      return null;
    }
    if (offset2 == pos || node5.isText) {
      return node5;
    }
    pos -= offset2 + 1;
  }
};
Node.prototype.childAfter = function childAfter(pos) {
  var ref = this.content.findIndex(pos);
  var index3 = ref.index;
  var offset2 = ref.offset;
  return { node: this.content.maybeChild(index3), index: index3, offset: offset2 };
};
Node.prototype.childBefore = function childBefore(pos) {
  if (pos == 0) {
    return { node: null, index: 0, offset: 0 };
  }
  var ref = this.content.findIndex(pos);
  var index3 = ref.index;
  var offset2 = ref.offset;
  if (offset2 < pos) {
    return { node: this.content.child(index3), index: index3, offset: offset2 };
  }
  var node5 = this.content.child(index3 - 1);
  return { node: node5, index: index3 - 1, offset: offset2 - node5.nodeSize };
};
Node.prototype.resolve = function resolve2(pos) {
  return ResolvedPos.resolveCached(this, pos);
};
Node.prototype.resolveNoCache = function resolveNoCache(pos) {
  return ResolvedPos.resolve(this, pos);
};
Node.prototype.rangeHasMark = function rangeHasMark(from5, to2, type) {
  var found2 = false;
  if (to2 > from5) {
    this.nodesBetween(from5, to2, function(node5) {
      if (type.isInSet(node5.marks)) {
        found2 = true;
      }
      return !found2;
    });
  }
  return found2;
};
prototypeAccessors$3$1.isBlock.get = function() {
  return this.type.isBlock;
};
prototypeAccessors$3$1.isTextblock.get = function() {
  return this.type.isTextblock;
};
prototypeAccessors$3$1.inlineContent.get = function() {
  return this.type.inlineContent;
};
prototypeAccessors$3$1.isInline.get = function() {
  return this.type.isInline;
};
prototypeAccessors$3$1.isText.get = function() {
  return this.type.isText;
};
prototypeAccessors$3$1.isLeaf.get = function() {
  return this.type.isLeaf;
};
prototypeAccessors$3$1.isAtom.get = function() {
  return this.type.isAtom;
};
Node.prototype.toString = function toString5() {
  if (this.type.spec.toDebugString) {
    return this.type.spec.toDebugString(this);
  }
  var name = this.type.name;
  if (this.content.size) {
    name += "(" + this.content.toStringInner() + ")";
  }
  return wrapMarks(this.marks, name);
};
Node.prototype.contentMatchAt = function contentMatchAt(index3) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index3);
  if (!match) {
    throw new Error("Called contentMatchAt on a node with invalid content");
  }
  return match;
};
Node.prototype.canReplace = function canReplace(from5, to2, replacement, start4, end3) {
  if (replacement === void 0)
    replacement = Fragment.empty;
  if (start4 === void 0)
    start4 = 0;
  if (end3 === void 0)
    end3 = replacement.childCount;
  var one2 = this.contentMatchAt(from5).matchFragment(replacement, start4, end3);
  var two2 = one2 && one2.matchFragment(this.content, to2);
  if (!two2 || !two2.validEnd) {
    return false;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    if (!this.type.allowsMarks(replacement.child(i2).marks)) {
      return false;
    }
  }
  return true;
};
Node.prototype.canReplaceWith = function canReplaceWith(from5, to2, type, marks3) {
  if (marks3 && !this.type.allowsMarks(marks3)) {
    return false;
  }
  var start4 = this.contentMatchAt(from5).matchType(type);
  var end3 = start4 && start4.matchFragment(this.content, to2);
  return end3 ? end3.validEnd : false;
};
Node.prototype.canAppend = function canAppend(other) {
  if (other.content.size) {
    return this.canReplace(this.childCount, this.childCount, other.content);
  } else {
    return this.type.compatibleContent(other.type);
  }
};
Node.prototype.check = function check() {
  if (!this.type.validContent(this.content)) {
    throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
  }
  var copy6 = Mark.none;
  for (var i2 = 0; i2 < this.marks.length; i2++) {
    copy6 = this.marks[i2].addToSet(copy6);
  }
  if (!Mark.sameSet(copy6, this.marks)) {
    throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m2) {
      return m2.type.name;
    }));
  }
  this.content.forEach(function(node5) {
    return node5.check();
  });
};
Node.prototype.toJSON = function toJSON4() {
  var obj = { type: this.type.name };
  for (var _2 in this.attrs) {
    obj.attrs = this.attrs;
    break;
  }
  if (this.content.size) {
    obj.content = this.content.toJSON();
  }
  if (this.marks.length) {
    obj.marks = this.marks.map(function(n2) {
      return n2.toJSON();
    });
  }
  return obj;
};
Node.fromJSON = function fromJSON4(schema2, json) {
  if (!json) {
    throw new RangeError("Invalid input for Node.fromJSON");
  }
  var marks3 = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) {
      throw new RangeError("Invalid mark data for Node.fromJSON");
    }
    marks3 = json.marks.map(schema2.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") {
      throw new RangeError("Invalid text node in JSON");
    }
    return schema2.text(json.text, marks3);
  }
  var content3 = Fragment.fromJSON(schema2, json.content);
  return schema2.nodeType(json.type).create(json.attrs, content3, marks3);
};
Object.defineProperties(Node.prototype, prototypeAccessors$3$1);
var TextNode = /* @__PURE__ */ function(Node3) {
  function TextNode2(type, attrs, content3, marks3) {
    Node3.call(this, type, attrs, null, marks3);
    if (!content3) {
      throw new RangeError("Empty text nodes are not allowed");
    }
    this.text = content3;
  }
  if (Node3)
    TextNode2.__proto__ = Node3;
  TextNode2.prototype = Object.create(Node3 && Node3.prototype);
  TextNode2.prototype.constructor = TextNode2;
  var prototypeAccessors$12 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
  TextNode2.prototype.toString = function toString8() {
    if (this.type.spec.toDebugString) {
      return this.type.spec.toDebugString(this);
    }
    return wrapMarks(this.marks, JSON.stringify(this.text));
  };
  prototypeAccessors$12.textContent.get = function() {
    return this.text;
  };
  TextNode2.prototype.textBetween = function textBetween3(from5, to2) {
    return this.text.slice(from5, to2);
  };
  prototypeAccessors$12.nodeSize.get = function() {
    return this.text.length;
  };
  TextNode2.prototype.mark = function mark3(marks3) {
    return marks3 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks3);
  };
  TextNode2.prototype.withText = function withText(text3) {
    if (text3 == this.text) {
      return this;
    }
    return new TextNode2(this.type, this.attrs, text3, this.marks);
  };
  TextNode2.prototype.cut = function cut3(from5, to2) {
    if (from5 === void 0)
      from5 = 0;
    if (to2 === void 0)
      to2 = this.text.length;
    if (from5 == 0 && to2 == this.text.length) {
      return this;
    }
    return this.withText(this.text.slice(from5, to2));
  };
  TextNode2.prototype.eq = function eq20(other) {
    return this.sameMarkup(other) && this.text == other.text;
  };
  TextNode2.prototype.toJSON = function toJSON7() {
    var base2 = Node3.prototype.toJSON.call(this);
    base2.text = this.text;
    return base2;
  };
  Object.defineProperties(TextNode2.prototype, prototypeAccessors$12);
  return TextNode2;
}(Node);
function wrapMarks(marks3, str) {
  for (var i2 = marks3.length - 1; i2 >= 0; i2--) {
    str = marks3[i2].type.name + "(" + str + ")";
  }
  return str;
}
var ContentMatch = function ContentMatch2(validEnd) {
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};
var prototypeAccessors$4$1 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
ContentMatch.parse = function parse(string2, nodeTypes) {
  var stream = new TokenStream(string2, nodeTypes);
  if (stream.next == null) {
    return ContentMatch.empty;
  }
  var expr = parseExpr(stream);
  if (stream.next) {
    stream.err("Unexpected trailing text");
  }
  var match = dfa(nfa(expr));
  checkForDeadEnds(match, stream);
  return match;
};
ContentMatch.prototype.matchType = function matchType(type) {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    if (this.next[i2] == type) {
      return this.next[i2 + 1];
    }
  }
  return null;
};
ContentMatch.prototype.matchFragment = function matchFragment(frag, start4, end3) {
  if (start4 === void 0)
    start4 = 0;
  if (end3 === void 0)
    end3 = frag.childCount;
  var cur = this;
  for (var i2 = start4; cur && i2 < end3; i2++) {
    cur = cur.matchType(frag.child(i2).type);
  }
  return cur;
};
prototypeAccessors$4$1.inlineContent.get = function() {
  var first = this.next[0];
  return first ? first.isInline : false;
};
prototypeAccessors$4$1.defaultType.get = function() {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    var type = this.next[i2];
    if (!(type.isText || type.hasRequiredAttrs())) {
      return type;
    }
  }
};
ContentMatch.prototype.compatible = function compatible(other) {
  for (var i2 = 0; i2 < this.next.length; i2 += 2) {
    for (var j2 = 0; j2 < other.next.length; j2 += 2) {
      if (this.next[i2] == other.next[j2]) {
        return true;
      }
    }
  }
  return false;
};
ContentMatch.prototype.fillBefore = function fillBefore(after2, toEnd, startIndex) {
  if (toEnd === void 0)
    toEnd = false;
  if (startIndex === void 0)
    startIndex = 0;
  var seen = [this];
  function search3(match, types) {
    var finished = match.matchFragment(after2, startIndex);
    if (finished && (!toEnd || finished.validEnd)) {
      return Fragment.from(types.map(function(tp) {
        return tp.createAndFill();
      }));
    }
    for (var i2 = 0; i2 < match.next.length; i2 += 2) {
      var type = match.next[i2], next = match.next[i2 + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found2 = search3(next, types.concat(type));
        if (found2) {
          return found2;
        }
      }
    }
  }
  return search3(this, []);
};
ContentMatch.prototype.findWrapping = function findWrapping(target) {
  for (var i2 = 0; i2 < this.wrapCache.length; i2 += 2) {
    if (this.wrapCache[i2] == target) {
      return this.wrapCache[i2 + 1];
    }
  }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed;
};
ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
  var seen = Object.create(null), active = [{ match: this, type: null, via: null }];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result2 = [];
      for (var obj = current; obj.type; obj = obj.via) {
        result2.push(obj.type);
      }
      return result2.reverse();
    }
    for (var i2 = 0; i2 < match.next.length; i2 += 2) {
      var type = match.next[i2];
      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i2 + 1].validEnd)) {
        active.push({ match: type.contentMatch, type, via: current });
        seen[type.name] = true;
      }
    }
  }
};
prototypeAccessors$4$1.edgeCount.get = function() {
  return this.next.length >> 1;
};
ContentMatch.prototype.edge = function edge(n2) {
  var i2 = n2 << 1;
  if (i2 >= this.next.length) {
    throw new RangeError("There's no " + n2 + "th edge in this content match");
  }
  return { type: this.next[i2], next: this.next[i2 + 1] };
};
ContentMatch.prototype.toString = function toString6() {
  var seen = [];
  function scan(m2) {
    seen.push(m2);
    for (var i2 = 1; i2 < m2.next.length; i2 += 2) {
      if (seen.indexOf(m2.next[i2]) == -1) {
        scan(m2.next[i2]);
      }
    }
  }
  scan(this);
  return seen.map(function(m2, i2) {
    var out = i2 + (m2.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m2.next.length; i$1 += 2) {
      out += (i$1 ? ", " : "") + m2.next[i$1].name + "->" + seen.indexOf(m2.next[i$1 + 1]);
    }
    return out;
  }).join("\n");
};
Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4$1);
ContentMatch.empty = new ContentMatch(true);
var TokenStream = function TokenStream2(string2, nodeTypes) {
  this.string = string2;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string2.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") {
    this.tokens.pop();
  }
  if (this.tokens[0] == "") {
    this.tokens.shift();
  }
};
var prototypeAccessors$1$2$1 = { next: { configurable: true } };
prototypeAccessors$1$2$1.next.get = function() {
  return this.tokens[this.pos];
};
TokenStream.prototype.eat = function eat(tok) {
  return this.next == tok && (this.pos++ || true);
};
TokenStream.prototype.err = function err(str) {
  throw new SyntaxError(str + " (in content expression '" + this.string + "')");
};
Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2$1);
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  var min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max2 = parseNum(stream);
    } else {
      max2 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect(compile3(expr, 0), node5());
  return nfa2;
  function node5() {
    return nfa2.push([]) - 1;
  }
  function edge2(from5, to2, term) {
    var edge3 = { term, to: to2 };
    nfa2[from5].push(edge3);
    return edge3;
  }
  function connect(edges, to2) {
    edges.forEach(function(edge3) {
      return edge3.to = to2;
    });
  }
  function compile3(expr2, from5) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile3(expr3, from5));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i2 = 0; ; i2++) {
        var next = compile3(expr2.exprs[i2], from5);
        if (i2 == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from5 = node5());
      }
    } else if (expr2.type == "star") {
      var loop2 = node5();
      edge2(from5, loop2);
      connect(compile3(expr2.expr, loop2), loop2);
      return [edge2(loop2)];
    } else if (expr2.type == "plus") {
      var loop$1 = node5();
      connect(compile3(expr2.expr, from5), loop$1);
      connect(compile3(expr2.expr, loop$1), loop$1);
      return [edge2(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge2(from5)].concat(compile3(expr2.expr, from5));
    } else if (expr2.type == "range") {
      var cur = from5;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node5();
        connect(compile3(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile3(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node5();
          edge2(cur, next$2);
          connect(compile3(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge2(cur)];
    } else if (expr2.type == "name") {
      return [edge2(from5, null, expr2.value)];
    }
  }
}
function cmp(a2, b2) {
  return b2 - a2;
}
function nullFrom(nfa2, node5) {
  var result2 = [];
  scan(node5);
  return result2.sort(cmp);
  function scan(node6) {
    var edges = nfa2[node6];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node6);
    for (var i2 = 0; i2 < edges.length; i2++) {
      var ref = edges[i2];
      var term = ref.term;
      var to2 = ref.to;
      if (!term && result2.indexOf(to2) == -1) {
        scan(to2);
      }
    }
  }
}
function dfa(nfa2) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node5) {
      nfa2[node5].forEach(function(ref) {
        var term = ref.term;
        var to2 = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set3 = known > -1 && out[known + 1];
        nullFrom(nfa2, to2).forEach(function(node6) {
          if (!set3) {
            out.push(term, set3 = []);
          }
          if (set3.indexOf(node6) == -1) {
            set3.push(node6);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (var i2 = 0; i2 < out.length; i2 += 2) {
      var states$1 = out[i2 + 1].sort(cmp);
      state.next.push(out[i2], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (var i2 = 0, work = [match]; i2 < work.length; i2++) {
    var state = work[i2], dead = !state.validEnd, nodes2 = [];
    for (var j2 = 0; j2 < state.next.length; j2 += 2) {
      var node5 = state.next[j2], next = state.next[j2 + 1];
      nodes2.push(node5.name);
      if (dead && !(node5.isText || node5.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs(attrs) {
  var defaults = Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  var built = Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result2 = Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute(attrs[name]);
    }
  }
  return result2;
}
var NodeType$2 = function NodeType(name, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);
  this.defaultAttrs = defaultAttrs(this.attrs);
  this.contentMatch = null;
  this.markSet = null;
  this.inlineContent = null;
  this.isBlock = !(spec.inline || name == "text");
  this.isText = name == "text";
};
var prototypeAccessors$5$1 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
prototypeAccessors$5$1.isInline.get = function() {
  return !this.isBlock;
};
prototypeAccessors$5$1.isTextblock.get = function() {
  return this.isBlock && this.inlineContent;
};
prototypeAccessors$5$1.isLeaf.get = function() {
  return this.contentMatch == ContentMatch.empty;
};
prototypeAccessors$5$1.isAtom.get = function() {
  return this.isLeaf || this.spec.atom;
};
NodeType$2.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
  for (var n2 in this.attrs) {
    if (this.attrs[n2].isRequired) {
      return true;
    }
  }
  return false;
};
NodeType$2.prototype.compatibleContent = function compatibleContent(other) {
  return this == other || this.contentMatch.compatible(other.contentMatch);
};
NodeType$2.prototype.computeAttrs = function computeAttrs$1(attrs) {
  if (!attrs && this.defaultAttrs) {
    return this.defaultAttrs;
  } else {
    return computeAttrs(this.attrs, attrs);
  }
};
NodeType$2.prototype.create = function create(attrs, content3, marks3) {
  if (this.isText) {
    throw new Error("NodeType.create can't construct text nodes");
  }
  return new Node(this, this.computeAttrs(attrs), Fragment.from(content3), Mark.setFrom(marks3));
};
NodeType$2.prototype.createChecked = function createChecked(attrs, content3, marks3) {
  content3 = Fragment.from(content3);
  if (!this.validContent(content3)) {
    throw new RangeError("Invalid content for node " + this.name);
  }
  return new Node(this, this.computeAttrs(attrs), content3, Mark.setFrom(marks3));
};
NodeType$2.prototype.createAndFill = function createAndFill(attrs, content3, marks3) {
  attrs = this.computeAttrs(attrs);
  content3 = Fragment.from(content3);
  if (content3.size) {
    var before2 = this.contentMatch.fillBefore(content3);
    if (!before2) {
      return null;
    }
    content3 = before2.append(content3);
  }
  var after2 = this.contentMatch.matchFragment(content3).fillBefore(Fragment.empty, true);
  if (!after2) {
    return null;
  }
  return new Node(this, attrs, content3.append(after2), Mark.setFrom(marks3));
};
NodeType$2.prototype.validContent = function validContent(content3) {
  var result2 = this.contentMatch.matchFragment(content3);
  if (!result2 || !result2.validEnd) {
    return false;
  }
  for (var i2 = 0; i2 < content3.childCount; i2++) {
    if (!this.allowsMarks(content3.child(i2).marks)) {
      return false;
    }
  }
  return true;
};
NodeType$2.prototype.allowsMarkType = function allowsMarkType(markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1;
};
NodeType$2.prototype.allowsMarks = function allowsMarks(marks3) {
  if (this.markSet == null) {
    return true;
  }
  for (var i2 = 0; i2 < marks3.length; i2++) {
    if (!this.allowsMarkType(marks3[i2].type)) {
      return false;
    }
  }
  return true;
};
NodeType$2.prototype.allowedMarks = function allowedMarks(marks3) {
  if (this.markSet == null) {
    return marks3;
  }
  var copy6;
  for (var i2 = 0; i2 < marks3.length; i2++) {
    if (!this.allowsMarkType(marks3[i2].type)) {
      if (!copy6) {
        copy6 = marks3.slice(0, i2);
      }
    } else if (copy6) {
      copy6.push(marks3[i2]);
    }
  }
  return !copy6 ? marks3 : copy6.length ? copy6 : Mark.empty;
};
NodeType$2.compile = function compile(nodes2, schema2) {
  var result2 = Object.create(null);
  nodes2.forEach(function(name, spec) {
    return result2[name] = new NodeType$2(name, schema2, spec);
  });
  var topType = schema2.spec.topNode || "doc";
  if (!result2[topType]) {
    throw new RangeError("Schema is missing its top node type ('" + topType + "')");
  }
  if (!result2.text) {
    throw new RangeError("Every schema needs a 'text' type");
  }
  for (var _2 in result2.text.attrs) {
    throw new RangeError("The text node type should not have attributes");
  }
  return result2;
};
Object.defineProperties(NodeType$2.prototype, prototypeAccessors$5$1);
var Attribute = function Attribute2(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};
var prototypeAccessors$1$3$1 = { isRequired: { configurable: true } };
prototypeAccessors$1$3$1.isRequired.get = function() {
  return !this.hasDefault;
};
Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3$1);
var MarkType = function MarkType2(name, rank, schema2, spec) {
  this.name = name;
  this.schema = schema2;
  this.spec = spec;
  this.attrs = initAttrs(spec.attrs);
  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs(this.attrs);
  this.instance = defaults && new Mark(this, defaults);
};
MarkType.prototype.create = function create2(attrs) {
  if (!attrs && this.instance) {
    return this.instance;
  }
  return new Mark(this, computeAttrs(this.attrs, attrs));
};
MarkType.compile = function compile2(marks3, schema2) {
  var result2 = Object.create(null), rank = 0;
  marks3.forEach(function(name, spec) {
    return result2[name] = new MarkType(name, rank++, schema2, spec);
  });
  return result2;
};
MarkType.prototype.removeFromSet = function removeFromSet2(set3) {
  for (var i2 = 0; i2 < set3.length; i2++) {
    if (set3[i2].type == this) {
      set3 = set3.slice(0, i2).concat(set3.slice(i2 + 1));
      i2--;
    }
  }
  return set3;
};
MarkType.prototype.isInSet = function isInSet2(set3) {
  for (var i2 = 0; i2 < set3.length; i2++) {
    if (set3[i2].type == this) {
      return set3[i2];
    }
  }
};
MarkType.prototype.excludes = function excludes(other) {
  return this.excluded.indexOf(other) > -1;
};
var Schema = function Schema2(spec) {
  this.spec = {};
  for (var prop in spec) {
    this.spec[prop] = spec[prop];
  }
  this.spec.nodes = orderedmap.from(spec.nodes);
  this.spec.marks = orderedmap.from(spec.marks);
  this.nodes = NodeType$2.compile(this.spec.nodes, this);
  this.marks = MarkType.compile(this.spec.marks, this);
  var contentExprCache = Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks) {
      throw new RangeError(prop$1 + " can not be both a node and a mark");
    }
    var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }
  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];
  this.cached = Object.create(null);
  this.cached.wrappings = Object.create(null);
};
Schema.prototype.node = function node2(type, attrs, content3, marks3) {
  if (typeof type == "string") {
    type = this.nodeType(type);
  } else if (!(type instanceof NodeType$2)) {
    throw new RangeError("Invalid node type: " + type);
  } else if (type.schema != this) {
    throw new RangeError("Node type from different schema used (" + type.name + ")");
  }
  return type.createChecked(attrs, content3, marks3);
};
Schema.prototype.text = function text(text$12, marks3) {
  var type = this.nodes.text;
  return new TextNode(type, type.defaultAttrs, text$12, Mark.setFrom(marks3));
};
Schema.prototype.mark = function mark2(type, attrs) {
  if (typeof type == "string") {
    type = this.marks[type];
  }
  return type.create(attrs);
};
Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
  return Node.fromJSON(this, json);
};
Schema.prototype.markFromJSON = function markFromJSON(json) {
  return Mark.fromJSON(this, json);
};
Schema.prototype.nodeType = function nodeType(name) {
  var found2 = this.nodes[name];
  if (!found2) {
    throw new RangeError("Unknown node type: " + name);
  }
  return found2;
};
function gatherMarks(schema2, marks3) {
  var found2 = [];
  for (var i2 = 0; i2 < marks3.length; i2++) {
    var name = marks3[i2], mark3 = schema2.marks[name], ok3 = mark3;
    if (mark3) {
      found2.push(mark3);
    } else {
      for (var prop in schema2.marks) {
        var mark$1 = schema2.marks[prop];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok3 = mark$1);
        }
      }
    }
    if (!ok3) {
      throw new SyntaxError("Unknown mark type: '" + marks3[i2] + "'");
    }
  }
  return found2;
}
var DOMParser = function DOMParser2(schema2, rules) {
  var this$1$1 = this;
  this.schema = schema2;
  this.rules = rules;
  this.tags = [];
  this.styles = [];
  rules.forEach(function(rule) {
    if (rule.tag) {
      this$1$1.tags.push(rule);
    } else if (rule.style) {
      this$1$1.styles.push(rule);
    }
  });
  this.normalizeLists = !this.tags.some(function(r2) {
    if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node) {
      return false;
    }
    var node5 = schema2.nodes[r2.node];
    return node5.contentMatch.matchType(node5);
  });
};
DOMParser.prototype.parse = function parse2(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish();
};
DOMParser.prototype.parseSlice = function parseSlice(dom, options) {
  if (options === void 0)
    options = {};
  var context = new ParseContext(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice.maxOpen(context.finish());
};
DOMParser.prototype.matchTag = function matchTag(dom, context, after2) {
  for (var i2 = after2 ? this.tags.indexOf(after2) + 1 : 0; i2 < this.tags.length; i2++) {
    var rule = this.tags[i2];
    if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result2 = rule.getAttrs(dom);
        if (result2 === false) {
          continue;
        }
        rule.attrs = result2;
      }
      return rule;
    }
  }
};
DOMParser.prototype.matchStyle = function matchStyle(prop, value, context, after2) {
  for (var i2 = after2 ? this.styles.indexOf(after2) + 1 : 0; i2 < this.styles.length; i2++) {
    var rule = this.styles[i2];
    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
      continue;
    }
    if (rule.getAttrs) {
      var result2 = rule.getAttrs(value);
      if (result2 === false) {
        continue;
      }
      rule.attrs = result2;
    }
    return rule;
  }
};
DOMParser.schemaRules = function schemaRules(schema2) {
  var result2 = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
    for (; i2 < result2.length; i2++) {
      var next = result2[i2], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) {
        break;
      }
    }
    result2.splice(i2, 0, rule);
  }
  var loop2 = function(name2) {
    var rules = schema2.marks[name2].spec.parseDOM;
    if (rules) {
      rules.forEach(function(rule) {
        insert(rule = copy2(rule));
        rule.mark = name2;
      });
    }
  };
  for (var name in schema2.marks)
    loop2(name);
  var loop$1 = function(name2) {
    var rules$1 = schema2.nodes[name$1].spec.parseDOM;
    if (rules$1) {
      rules$1.forEach(function(rule) {
        insert(rule = copy2(rule));
        rule.node = name$1;
      });
    }
  };
  for (var name$1 in schema2.nodes)
    loop$1();
  return result2;
};
DOMParser.fromSchema = function fromSchema(schema2) {
  return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser(schema2, DOMParser.schemaRules(schema2)));
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
}
var NodeContext = function NodeContext2(type, attrs, marks3, pendingMarks, solid, match, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  this.marks = marks3;
  this.activeMarks = Mark.none;
  this.pendingMarks = pendingMarks;
  this.stashMarks = [];
};
NodeContext.prototype.findWrapping = function findWrapping2(node5) {
  if (!this.match) {
    if (!this.type) {
      return [];
    }
    var fill = this.type.contentMatch.fillBefore(Fragment.from(node5));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start4 = this.type.contentMatch, wrap2;
      if (wrap2 = start4.findWrapping(node5.type)) {
        this.match = start4;
        return wrap2;
      } else {
        return null;
      }
    }
  }
  return this.match.findWrapping(node5.type);
};
NodeContext.prototype.finish = function finish(openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) {
    var last = this.content[this.content.length - 1], m2;
    if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m2[0].length) {
        this.content.pop();
      } else {
        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m2[0].length));
      }
    }
  }
  var content3 = Fragment.from(this.content);
  if (!openEnd && this.match) {
    content3 = content3.append(this.match.fillBefore(Fragment.empty, true));
  }
  return this.type ? this.type.create(this.attrs, content3, this.marks) : content3;
};
NodeContext.prototype.popFromStashMark = function popFromStashMark(mark3) {
  for (var i2 = this.stashMarks.length - 1; i2 >= 0; i2--) {
    if (mark3.eq(this.stashMarks[i2])) {
      return this.stashMarks.splice(i2, 1)[0];
    }
  }
};
NodeContext.prototype.applyPending = function applyPending(nextType) {
  for (var i2 = 0, pending = this.pendingMarks; i2 < pending.length; i2++) {
    var mark3 = pending[i2];
    if ((this.type ? this.type.allowsMarkType(mark3.type) : markMayApply(mark3.type, nextType)) && !mark3.isInSet(this.activeMarks)) {
      this.activeMarks = mark3.addToSet(this.activeMarks);
      this.pendingMarks = mark3.removeFromSet(this.pendingMarks);
    }
  }
};
NodeContext.prototype.inlineContext = function inlineContext(node5) {
  if (this.type) {
    return this.type.inlineContent;
  }
  if (this.content.length) {
    return this.content[0].isInline;
  }
  return node5.parentNode && !blockTags.hasOwnProperty(node5.parentNode.nodeName.toLowerCase());
};
var ParseContext = function ParseContext2(parser2, options, open2) {
  this.parser = parser2;
  this.options = options;
  this.isOpen = open2;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open2 ? OPT_OPEN_LEFT : 0);
  if (topNode) {
    topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
  } else if (open2) {
    topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
  } else {
    topContext = new NodeContext(parser2.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
  }
  this.nodes = [topContext];
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};
var prototypeAccessors$6$1 = { top: { configurable: true }, currentPos: { configurable: true } };
prototypeAccessors$6$1.top.get = function() {
  return this.nodes[this.open];
};
ParseContext.prototype.addDOM = function addDOM(dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style = dom.getAttribute("style");
    var marks3 = style ? this.readStyles(parseStyles(style)) : null, top2 = this.top;
    if (marks3 != null) {
      for (var i2 = 0; i2 < marks3.length; i2++) {
        this.addPendingMark(marks3[i2]);
      }
    }
    this.addElement(dom);
    if (marks3 != null) {
      for (var i$1 = 0; i$1 < marks3.length; i$1++) {
        this.removePendingMark(marks3[i$1], top2);
      }
    }
  }
};
ParseContext.prototype.addTextNode = function addTextNode(dom) {
  var value = dom.nodeValue;
  var top2 = this.top;
  if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top2.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top2.content[top2.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
          value = value.slice(1);
        }
      }
    } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) {
      this.insertNode(this.parser.schema.text(value));
    }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};
ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
    normalizeList(dom);
  }
  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) {
      this.open = Math.max(0, this.open - 1);
    } else if (rule && rule.skip.nodeType) {
      dom = rule.skip;
    }
    var sync2, top2 = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync2 = true;
      if (!top2.type) {
        this.needsBlock = true;
      }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return;
    }
    this.addAll(dom);
    if (sync2) {
      this.sync(top2);
    }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};
ParseContext.prototype.leafFallback = function leafFallback(dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
    this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
};
ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
    this.findPlace(this.parser.schema.text("-"));
  }
};
ParseContext.prototype.readStyles = function readStyles(styles) {
  var marks3 = Mark.none;
  style:
    for (var i2 = 0; i2 < styles.length; i2 += 2) {
      for (var after2 = null; ; ) {
        var rule = this.parser.matchStyle(styles[i2], styles[i2 + 1], this, after2);
        if (!rule) {
          continue style;
        }
        if (rule.ignore) {
          return null;
        }
        marks3 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks3);
        if (rule.consuming === false) {
          after2 = rule;
        } else {
          break;
        }
      }
    }
  return marks3;
};
ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
  var this$1$1 = this;
  var sync2, nodeType2, markType, mark3;
  if (rule.node) {
    nodeType2 = this.parser.schema.nodes[rule.node];
    if (!nodeType2.isLeaf) {
      sync2 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark3 = markType.create(rule.attrs);
    this.addPendingMark(mark3);
  }
  var startIn = this.top;
  if (nodeType2 && nodeType2.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function(node5) {
      return this$1$1.insertNode(node5);
    });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") {
      contentDOM = dom.querySelector(contentDOM);
    } else if (typeof contentDOM == "function") {
      contentDOM = contentDOM(dom);
    }
    if (!contentDOM) {
      contentDOM = dom;
    }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync2);
  }
  if (sync2) {
    this.sync(startIn);
    this.open--;
  }
  if (mark3) {
    this.removePendingMark(mark3, startIn);
  }
};
ParseContext.prototype.addAll = function addAll(parent, sync2, startIndex, endIndex) {
  var index3 = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end3 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end3; dom = dom.nextSibling, ++index3) {
    this.findAtPoint(parent, index3);
    this.addDOM(dom);
    if (sync2 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
      this.sync(sync2);
    }
  }
  this.findAtPoint(parent, index3);
};
ParseContext.prototype.findPlace = function findPlace(node5) {
  var route, sync2;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found2 = cx.findWrapping(node5);
    if (found2 && (!route || route.length > found2.length)) {
      route = found2;
      sync2 = cx;
      if (!found2.length) {
        break;
      }
    }
    if (cx.solid) {
      break;
    }
  }
  if (!route) {
    return false;
  }
  this.sync(sync2);
  for (var i2 = 0; i2 < route.length; i2++) {
    this.enterInner(route[i2], null, false);
  }
  return true;
};
ParseContext.prototype.insertNode = function insertNode(node5) {
  if (node5.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) {
      this.enterInner(block);
    }
  }
  if (this.findPlace(node5)) {
    this.closeExtra();
    var top2 = this.top;
    top2.applyPending(node5.type);
    if (top2.match) {
      top2.match = top2.match.matchType(node5.type);
    }
    var marks3 = top2.activeMarks;
    for (var i2 = 0; i2 < node5.marks.length; i2++) {
      if (!top2.type || top2.type.allowsMarkType(node5.marks[i2].type)) {
        marks3 = node5.marks[i2].addToSet(marks3);
      }
    }
    top2.content.push(node5.mark(marks3));
    return true;
  }
  return false;
};
ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
  var ok3 = this.findPlace(type.create(attrs));
  if (ok3) {
    this.enterInner(type, attrs, true, preserveWS);
  }
  return ok3;
};
ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top2 = this.top;
  top2.applyPending(type);
  top2.match = top2.match && top2.match.matchType(type, attrs);
  var options = preserveWS == null ? top2.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
  if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0) {
    options |= OPT_OPEN_LEFT;
  }
  this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
  this.open++;
};
ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
  var i2 = this.nodes.length - 1;
  if (i2 > this.open) {
    for (; i2 > this.open; i2--) {
      this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
    }
    this.nodes.length = this.open + 1;
  }
};
ParseContext.prototype.finish = function finish2() {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen);
};
ParseContext.prototype.sync = function sync(to2) {
  for (var i2 = this.open; i2 >= 0; i2--) {
    if (this.nodes[i2] == to2) {
      this.open = i2;
      return;
    }
  }
};
prototypeAccessors$6$1.currentPos.get = function() {
  this.closeExtra();
  var pos = 0;
  for (var i2 = this.open; i2 >= 0; i2--) {
    var content3 = this.nodes[i2].content;
    for (var j2 = content3.length - 1; j2 >= 0; j2--) {
      pos += content3[j2].nodeSize;
    }
    if (i2) {
      pos++;
    }
  }
  return pos;
};
ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset2) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].node == parent && this.find[i2].offset == offset2) {
        this.find[i2].pos = this.currentPos;
      }
    }
  }
};
ParseContext.prototype.findInside = function findInside(parent) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
        this.find[i2].pos = this.currentPos;
      }
    }
  }
};
ParseContext.prototype.findAround = function findAround(parent, content3, before2) {
  if (parent != content3 && this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
        var pos = content3.compareDocumentPosition(this.find[i2].node);
        if (pos & (before2 ? 2 : 4)) {
          this.find[i2].pos = this.currentPos;
        }
      }
    }
  }
};
ParseContext.prototype.findInText = function findInText(textNode) {
  if (this.find) {
    for (var i2 = 0; i2 < this.find.length; i2++) {
      if (this.find[i2].node == textNode) {
        this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
      }
    }
  }
};
ParseContext.prototype.matchesContext = function matchesContext(context) {
  var this$1$1 = this;
  if (context.indexOf("|") > -1) {
    return context.split(/\s*\|\s*/).some(this.matchesContext, this);
  }
  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function(i2, depth) {
    for (; i2 >= 0; i2--) {
      var part2 = parts[i2];
      if (part2 == "") {
        if (i2 == parts.length - 1 || i2 == 0) {
          continue;
        }
        for (; depth >= minDepth; depth--) {
          if (match(i2 - 1, depth)) {
            return true;
          }
        }
        return false;
      } else {
        var next = depth > 0 || depth == 0 && useRoot ? this$1$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
        if (!next || next.name != part2 && next.groups.indexOf(part2) == -1) {
          return false;
        }
        depth--;
      }
    }
    return true;
  };
  return match(parts.length - 1, this.open);
};
ParseContext.prototype.textblockFromContext = function textblockFromContext() {
  var $context = this.options.context;
  if ($context) {
    for (var d2 = $context.depth; d2 >= 0; d2--) {
      var deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
        return deflt;
      }
    }
  }
  for (var name in this.parser.schema.nodes) {
    var type = this.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) {
      return type;
    }
  }
};
ParseContext.prototype.addPendingMark = function addPendingMark(mark3) {
  var found2 = findSameMarkInSet(mark3, this.top.pendingMarks);
  if (found2) {
    this.top.stashMarks.push(found2);
  }
  this.top.pendingMarks = mark3.addToSet(this.top.pendingMarks);
};
ParseContext.prototype.removePendingMark = function removePendingMark(mark3, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found2 = level.pendingMarks.lastIndexOf(mark3);
    if (found2 > -1) {
      level.pendingMarks = mark3.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark3.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark3);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
        level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
    }
    if (level == upto) {
      break;
    }
  }
};
Object.defineProperties(ParseContext.prototype, prototypeAccessors$6$1);
function normalizeList(dom) {
  for (var child4 = dom.firstChild, prevItem = null; child4; child4 = child4.nextSibling) {
    var name = child4.nodeType == 1 ? child4.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child4);
      child4 = prevItem;
    } else if (name == "li") {
      prevItem = child4;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style) {
  var re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m2, result2 = [];
  while (m2 = re2.exec(style)) {
    result2.push(m2[1], m2[2].trim());
  }
  return result2;
}
function copy2(obj) {
  var copy6 = {};
  for (var prop in obj) {
    copy6[prop] = obj[prop];
  }
  return copy6;
}
function markMayApply(markType, nodeType2) {
  var nodes2 = nodeType2.schema.nodes;
  var loop2 = function(name2) {
    var parent = nodes2[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i2 = 0; i2 < match.edgeCount; i2++) {
        var ref = match.edge(i2);
        var type = ref.type;
        var next = ref.next;
        if (type == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes2) {
    var returned = loop2(name);
    if (returned)
      return returned.v;
  }
}
function findSameMarkInSet(mark3, set3) {
  for (var i2 = 0; i2 < set3.length; i2++) {
    if (mark3.eq(set3[i2])) {
      return set3[i2];
    }
  }
}
var DOMSerializer = function DOMSerializer2(nodes2, marks3) {
  this.nodes = nodes2 || {};
  this.marks = marks3 || {};
};
DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  if (!target) {
    target = doc$1(options).createDocumentFragment();
  }
  var top2 = target, active = null;
  fragment.forEach(function(node5) {
    if (active || node5.marks.length) {
      if (!active) {
        active = [];
      }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node5.marks.length) {
        var next = node5.marks[rendered];
        if (!this$1$1.marks[next.type.name]) {
          rendered++;
          continue;
        }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
          break;
        }
        keep += 2;
        rendered++;
      }
      while (keep < active.length) {
        top2 = active.pop();
        active.pop();
      }
      while (rendered < node5.marks.length) {
        var add3 = node5.marks[rendered++];
        var markDOM = this$1$1.serializeMark(add3, node5.isInline, options);
        if (markDOM) {
          active.push(add3, top2);
          top2.appendChild(markDOM.dom);
          top2 = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top2.appendChild(this$1$1.serializeNodeInner(node5, options));
  });
  return target;
};
DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node5, options) {
  if (options === void 0)
    options = {};
  var ref = DOMSerializer.renderSpec(doc$1(options), this.nodes[node5.type.name](node5));
  var dom = ref.dom;
  var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node5.isLeaf) {
      throw new RangeError("Content hole not allowed in a leaf node spec");
    }
    if (options.onContent) {
      options.onContent(node5, contentDOM, options);
    } else {
      this.serializeFragment(node5.content, options, contentDOM);
    }
  }
  return dom;
};
DOMSerializer.prototype.serializeNode = function serializeNode(node5, options) {
  if (options === void 0)
    options = {};
  var dom = this.serializeNodeInner(node5, options);
  for (var i2 = node5.marks.length - 1; i2 >= 0; i2--) {
    var wrap2 = this.serializeMark(node5.marks[i2], node5.isInline, options);
    if (wrap2) {
      (wrap2.contentDOM || wrap2.dom).appendChild(dom);
      dom = wrap2.dom;
    }
  }
  return dom;
};
DOMSerializer.prototype.serializeMark = function serializeMark(mark3, inline3, options) {
  if (options === void 0)
    options = {};
  var toDOM = this.marks[mark3.type.name];
  return toDOM && DOMSerializer.renderSpec(doc$1(options), toDOM(mark3, inline3));
};
DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
  if (xmlNS === void 0)
    xmlNS = null;
  if (typeof structure == "string") {
    return { dom: doc2.createTextNode(structure) };
  }
  if (structure.nodeType != null) {
    return { dom: structure };
  }
  if (structure.dom && structure.dom.nodeType != null) {
    return structure;
  }
  var tagName = structure[0], space2 = tagName.indexOf(" ");
  if (space2 > 0) {
    xmlNS = tagName.slice(0, space2);
    tagName = tagName.slice(space2 + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  var attrs = structure[1], start4 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start4 = 2;
    for (var name in attrs) {
      if (attrs[name] != null) {
        var space$1 = name.indexOf(" ");
        if (space$1 > 0) {
          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
        } else {
          dom.setAttribute(name, attrs[name]);
        }
      }
    }
  }
  for (var i2 = start4; i2 < structure.length; i2++) {
    var child4 = structure[i2];
    if (child4 === 0) {
      if (i2 < structure.length - 1 || i2 > start4) {
        throw new RangeError("Content hole must be the only child of its parent node");
      }
      return { dom, contentDOM: dom };
    } else {
      var ref = DOMSerializer.renderSpec(doc2, child4, xmlNS);
      var inner = ref.dom;
      var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) {
          throw new RangeError("Multiple content holes");
        }
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
};
DOMSerializer.fromSchema = function fromSchema2(schema2) {
  return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
};
DOMSerializer.nodesFromSchema = function nodesFromSchema(schema2) {
  var result2 = gatherToDOM(schema2.nodes);
  if (!result2.text) {
    result2.text = function(node5) {
      return node5.text;
    };
  }
  return result2;
};
DOMSerializer.marksFromSchema = function marksFromSchema(schema2) {
  return gatherToDOM(schema2.marks);
};
function gatherToDOM(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
function doc$1(options) {
  return options.document || window.document;
}
const hasText = (node5) => node5.isText;
const maybeMerge = (a2, b2) => {
  if (hasText(a2) && hasText(b2) && Mark.sameSet(a2.marks, b2.marks)) {
    return a2.withText(a2.text + b2.text);
  }
  return;
};
const getAtom = (id2, schema2, isNode) => schema2[isNode ? "nodes" : "marks"][id2];
const getStackUtil = () => {
  const size2 = (ctx) => ctx.elements.length;
  const top2 = (ctx) => ctx.elements[size2(ctx) - 1];
  const push2 = (ctx) => (node5) => {
    var _a;
    return (_a = top2(ctx)) === null || _a === void 0 ? void 0 : _a.push(node5);
  };
  const open2 = (ctx) => (node5) => ctx.elements.push(node5);
  const close3 = (ctx) => {
    const el2 = ctx.elements.pop();
    if (!el2)
      throw stackOverFlow();
    return el2;
  };
  return {
    size: size2,
    top: top2,
    push: push2,
    open: open2,
    close: close3
  };
};
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index3, offset2) {
  return index3 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var MapResult = function MapResult2(pos, deleted, recover2) {
  if (deleted === void 0)
    deleted = false;
  if (recover2 === void 0)
    recover2 = null;
  this.pos = pos;
  this.deleted = deleted;
  this.recover = recover2;
};
var StepMap = function StepMap2(ranges, inverted) {
  if (inverted === void 0)
    inverted = false;
  this.ranges = ranges;
  this.inverted = inverted;
};
StepMap.prototype.recover = function recover(value) {
  var diff = 0, index3 = recoverIndex(value);
  if (!this.inverted) {
    for (var i2 = 0; i2 < index3; i2++) {
      diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
    }
  }
  return this.ranges[index3 * 3] + diff + recoverOffset(value);
};
StepMap.prototype.mapResult = function mapResult(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
StepMap.prototype.map = function map2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, true);
};
StepMap.prototype._map = function _map(pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2] - (this.inverted ? diff : 0);
    if (start4 > pos) {
      break;
    }
    var oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end3 = start4 + oldSize;
    if (pos <= end3) {
      var side = !oldSize ? assoc : pos == start4 ? -1 : pos == end3 ? 1 : assoc;
      var result2 = start4 + diff + (side < 0 ? 0 : newSize);
      if (simple) {
        return result2;
      }
      var recover2 = pos == (assoc < 0 ? start4 : end3) ? null : makeRecover(i2 / 3, pos - start4);
      return new MapResult(result2, assoc < 0 ? pos != start4 : pos != end3, recover2);
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff);
};
StepMap.prototype.touches = function touches(pos, recover2) {
  var diff = 0, index3 = recoverIndex(recover2);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2] - (this.inverted ? diff : 0);
    if (start4 > pos) {
      break;
    }
    var oldSize = this.ranges[i2 + oldIndex], end3 = start4 + oldSize;
    if (pos <= end3 && i2 == index3 * 3) {
      return true;
    }
    diff += this.ranges[i2 + newIndex] - oldSize;
  }
  return false;
};
StepMap.prototype.forEach = function forEach3(f2) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
    var start4 = this.ranges[i2], oldStart = start4 - (this.inverted ? diff : 0), newStart = start4 + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
    f2(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};
StepMap.prototype.invert = function invert() {
  return new StepMap(this.ranges, !this.inverted);
};
StepMap.prototype.toString = function toString7() {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
};
StepMap.offset = function offset(n2) {
  return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
};
StepMap.empty = new StepMap([]);
var Mapping = function Mapping2(maps, mirror2, from5, to2) {
  this.maps = maps || [];
  this.from = from5 || 0;
  this.to = to2 == null ? this.maps.length : to2;
  this.mirror = mirror2;
};
Mapping.prototype.slice = function slice3(from5, to2) {
  if (from5 === void 0)
    from5 = 0;
  if (to2 === void 0)
    to2 = this.maps.length;
  return new Mapping(this.maps, this.mirror, from5, to2);
};
Mapping.prototype.copy = function copy3() {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
};
Mapping.prototype.appendMap = function appendMap(map21, mirrors) {
  this.to = this.maps.push(map21);
  if (mirrors != null) {
    this.setMirror(this.maps.length - 1, mirrors);
  }
};
Mapping.prototype.appendMapping = function appendMapping(mapping) {
  for (var i2 = 0, startSize = this.maps.length; i2 < mapping.maps.length; i2++) {
    var mirr = mapping.getMirror(i2);
    this.appendMap(mapping.maps[i2], mirr != null && mirr < i2 ? startSize + mirr : null);
  }
};
Mapping.prototype.getMirror = function getMirror(n2) {
  if (this.mirror) {
    for (var i2 = 0; i2 < this.mirror.length; i2++) {
      if (this.mirror[i2] == n2) {
        return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
      }
    }
  }
};
Mapping.prototype.setMirror = function setMirror(n2, m2) {
  if (!this.mirror) {
    this.mirror = [];
  }
  this.mirror.push(n2, m2);
};
Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
  for (var i2 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i2 >= 0; i2--) {
    var mirr = mapping.getMirror(i2);
    this.appendMap(mapping.maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : null);
  }
};
Mapping.prototype.invert = function invert2() {
  var inverse = new Mapping();
  inverse.appendMappingInverted(this);
  return inverse;
};
Mapping.prototype.map = function map3(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  if (this.mirror) {
    return this._map(pos, assoc, true);
  }
  for (var i2 = this.from; i2 < this.to; i2++) {
    pos = this.maps[i2].map(pos, assoc);
  }
  return pos;
};
Mapping.prototype.mapResult = function mapResult2(pos, assoc) {
  if (assoc === void 0)
    assoc = 1;
  return this._map(pos, assoc, false);
};
Mapping.prototype._map = function _map2(pos, assoc, simple) {
  var deleted = false;
  for (var i2 = this.from; i2 < this.to; i2++) {
    var map21 = this.maps[i2], result2 = map21.mapResult(pos, assoc);
    if (result2.recover != null) {
      var corr = this.getMirror(i2);
      if (corr != null && corr > i2 && corr < this.to) {
        i2 = corr;
        pos = this.maps[corr].recover(result2.recover);
        continue;
      }
    }
    if (result2.deleted) {
      deleted = true;
    }
    pos = result2.pos;
  }
  return simple ? pos : new MapResult(pos, deleted);
};
function TransformError(message2) {
  var err2 = Error.call(this, message2);
  err2.__proto__ = TransformError.prototype;
  return err2;
}
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = function Transform2(doc2) {
  this.doc = doc2;
  this.steps = [];
  this.docs = [];
  this.mapping = new Mapping();
};
var prototypeAccessors$5 = { before: { configurable: true }, docChanged: { configurable: true } };
prototypeAccessors$5.before.get = function() {
  return this.docs.length ? this.docs[0] : this.doc;
};
Transform.prototype.step = function step(object) {
  var result2 = this.maybeStep(object);
  if (result2.failed) {
    throw new TransformError(result2.failed);
  }
  return this;
};
Transform.prototype.maybeStep = function maybeStep(step3) {
  var result2 = step3.apply(this.doc);
  if (!result2.failed) {
    this.addStep(step3, result2.doc);
  }
  return result2;
};
prototypeAccessors$5.docChanged.get = function() {
  return this.steps.length > 0;
};
Transform.prototype.addStep = function addStep(step3, doc2) {
  this.docs.push(this.doc);
  this.steps.push(step3);
  this.mapping.appendMap(step3.getMap());
  this.doc = doc2;
};
Object.defineProperties(Transform.prototype, prototypeAccessors$5);
function mustOverride() {
  throw new Error("Override me");
}
var stepsByID = Object.create(null);
var Step = function Step2() {
};
Step.prototype.apply = function apply(_doc) {
  return mustOverride();
};
Step.prototype.getMap = function getMap() {
  return StepMap.empty;
};
Step.prototype.invert = function invert3(_doc) {
  return mustOverride();
};
Step.prototype.map = function map4(_mapping) {
  return mustOverride();
};
Step.prototype.merge = function merge(_other) {
  return null;
};
Step.prototype.toJSON = function toJSON5() {
  return mustOverride();
};
Step.fromJSON = function fromJSON5(schema2, json) {
  if (!json || !json.stepType) {
    throw new RangeError("Invalid input for Step.fromJSON");
  }
  var type = stepsByID[json.stepType];
  if (!type) {
    throw new RangeError("No step type " + json.stepType + " defined");
  }
  return type.fromJSON(schema2, json);
};
Step.jsonID = function jsonID(id2, stepClass) {
  if (id2 in stepsByID) {
    throw new RangeError("Duplicate use of step JSON ID " + id2);
  }
  stepsByID[id2] = stepClass;
  stepClass.prototype.jsonID = id2;
  return stepClass;
};
var StepResult = function StepResult2(doc2, failed) {
  this.doc = doc2;
  this.failed = failed;
};
StepResult.ok = function ok(doc2) {
  return new StepResult(doc2, null);
};
StepResult.fail = function fail2(message2) {
  return new StepResult(null, message2);
};
StepResult.fromReplace = function fromReplace(doc2, from5, to2, slice5) {
  try {
    return StepResult.ok(doc2.replace(from5, to2, slice5));
  } catch (e3) {
    if (e3 instanceof ReplaceError) {
      return StepResult.fail(e3.message);
    }
    throw e3;
  }
};
var ReplaceStep = /* @__PURE__ */ function(Step3) {
  function ReplaceStep2(from5, to2, slice5, structure) {
    Step3.call(this);
    this.from = from5;
    this.to = to2;
    this.slice = slice5;
    this.structure = !!structure;
  }
  if (Step3)
    ReplaceStep2.__proto__ = Step3;
  ReplaceStep2.prototype = Object.create(Step3 && Step3.prototype);
  ReplaceStep2.prototype.constructor = ReplaceStep2;
  ReplaceStep2.prototype.apply = function apply9(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to)) {
      return StepResult.fail("Structure replace would overwrite content");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  };
  ReplaceStep2.prototype.getMap = function getMap2() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  };
  ReplaceStep2.prototype.invert = function invert4(doc2) {
    return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  };
  ReplaceStep2.prototype.map = function map21(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    if (from5.deleted && to2.deleted) {
      return null;
    }
    return new ReplaceStep2(from5.pos, Math.max(from5.pos, to2.pos), this.slice);
  };
  ReplaceStep2.prototype.merge = function merge3(other) {
    if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
      return null;
    }
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice5 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice5, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$12 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep2(other.from, this.to, slice$12, this.structure);
    } else {
      return null;
    }
  };
  ReplaceStep2.prototype.toJSON = function toJSON7() {
    var json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceStep2.fromJSON = function fromJSON8(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    }
    return new ReplaceStep2(json.from, json.to, Slice.fromJSON(schema2, json.slice), !!json.structure);
  };
  return ReplaceStep2;
}(Step);
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = /* @__PURE__ */ function(Step3) {
  function ReplaceAroundStep2(from5, to2, gapFrom, gapTo, slice5, insert, structure) {
    Step3.call(this);
    this.from = from5;
    this.to = to2;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice5;
    this.insert = insert;
    this.structure = !!structure;
  }
  if (Step3)
    ReplaceAroundStep2.__proto__ = Step3;
  ReplaceAroundStep2.prototype = Object.create(Step3 && Step3.prototype);
  ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
  ReplaceAroundStep2.prototype.apply = function apply9(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) {
      return StepResult.fail("Structure gap-replace would overwrite content");
    }
    var gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd) {
      return StepResult.fail("Gap is not a flat range");
    }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) {
      return StepResult.fail("Content does not fit in gap");
    }
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  };
  ReplaceAroundStep2.prototype.getMap = function getMap2() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  };
  ReplaceAroundStep2.prototype.invert = function invert4(doc2) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  };
  ReplaceAroundStep2.prototype.map = function map21(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from5.deleted && to2.deleted || gapFrom < from5.pos || gapTo > to2.pos) {
      return null;
    }
    return new ReplaceAroundStep2(from5.pos, to2.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  };
  ReplaceAroundStep2.prototype.toJSON = function toJSON7() {
    var json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size) {
      json.slice = this.slice.toJSON();
    }
    if (this.structure) {
      json.structure = true;
    }
    return json;
  };
  ReplaceAroundStep2.fromJSON = function fromJSON8(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    }
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema2, json.slice), json.insert, !!json.structure);
  };
  return ReplaceAroundStep2;
}(Step);
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from5, to2) {
  var $from = doc2.resolve(from5), dist2 = to2 - from5, depth = $from.depth;
  while (dist2 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist2--;
  }
  if (dist2 > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist2 > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist2--;
    }
  }
  return false;
}
function canCut(node5, start4, end3) {
  return (start4 == 0 || node5.canReplace(start4, node5.childCount)) && (end3 == node5.childCount || node5.canReplace(0, end3));
}
function liftTarget(range) {
  var parent = range.parent;
  var content3 = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth; ; --depth) {
    var node5 = range.$from.node(depth);
    var index3 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node5.canReplace(index3, endIndex, content3)) {
      return depth;
    }
    if (depth == 0 || node5.type.spec.isolating || !canCut(node5, index3, endIndex)) {
      break;
    }
  }
}
Transform.prototype.lift = function(range, target) {
  var $from = range.$from;
  var $to = range.$to;
  var depth = range.depth;
  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start4 = gapStart, end3 = gapEnd;
  var before2 = Fragment.empty, openStart = 0;
  for (var d2 = depth, splitting = false; d2 > target; d2--) {
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before2 = Fragment.from($from.node(d2).copy(before2));
      openStart++;
    } else {
      start4--;
    }
  }
  var after2 = Fragment.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after2 = Fragment.from($to.node(d$1).copy(after2));
      openEnd++;
    } else {
      end3++;
    }
  }
  return this.step(new ReplaceAroundStep(start4, end3, gapStart, gapEnd, new Slice(before2.append(after2), openStart, openEnd), before2.size - openStart, true));
};
function findWrapping3(range, nodeType2, attrs, innerRange) {
  if (innerRange === void 0)
    innerRange = range;
  var around = findWrappingOutside(range, nodeType2);
  var inner = around && findWrappingInside(innerRange, nodeType2);
  if (!inner) {
    return null;
  }
  return around.map(withAttrs).concat({ type: nodeType2, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) {
    return null;
  }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) {
    return null;
  }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i2 = startIndex; innerMatch && i2 < endIndex; i2++) {
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  }
  if (!innerMatch || !innerMatch.validEnd) {
    return null;
  }
  return inside;
}
Transform.prototype.wrap = function(range, wrappers) {
  var content3 = Fragment.empty;
  for (var i2 = wrappers.length - 1; i2 >= 0; i2--) {
    content3 = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content3));
  }
  var start4 = range.start, end3 = range.end;
  return this.step(new ReplaceAroundStep(start4, end3, start4, end3, new Slice(content3, 0, 0), wrappers.length, true));
};
Transform.prototype.setBlockType = function(from5, to2, type, attrs) {
  var this$1$1 = this;
  if (to2 === void 0)
    to2 = from5;
  if (!type.isTextblock) {
    throw new RangeError("Type given to setBlockType should be a textblock");
  }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from5, to2, function(node5, pos) {
    if (node5.isTextblock && !node5.hasMarkup(type, attrs) && canChangeType(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type)) {
      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = this$1$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node5.nodeSize, 1);
      this$1$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node5.marks)), 0, 0), 1, true));
      return false;
    }
  });
  return this;
};
function canChangeType(doc2, pos, type) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return $pos.parent.canReplaceWith(index3, index3 + 1, type);
}
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks3) {
  var node5 = this.doc.nodeAt(pos);
  if (!node5) {
    throw new RangeError("No node at given position");
  }
  if (!type) {
    type = node5.type;
  }
  var newNode = type.create(attrs, null, marks3 || node5.marks);
  if (node5.isLeaf) {
    return this.replaceWith(pos, pos + node5.nodeSize, newNode);
  }
  if (!type.validContent(node5.content)) {
    throw new RangeError("Invalid content for node type " + type.name);
  }
  return this.step(new ReplaceAroundStep(pos, pos + node5.nodeSize, pos + 1, pos + node5.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
};
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
    return false;
  }
  for (var d2 = $pos.depth - 1, i2 = depth - 2; d2 > base2; d2--, i2--) {
    var node5 = $pos.node(d2), index$1 = $pos.index(d2);
    if (node5.type.spec.isolating) {
      return false;
    }
    var rest = node5.content.cutByIndex(index$1, node5.childCount);
    var after2 = typesAfter && typesAfter[i2] || node5;
    if (after2 != node5) {
      rest = rest.replaceChild(0, after2.type.create(after2.attrs));
    }
    if (!node5.canReplace(index$1 + 1, node5.childCount) || !after2.type.validContent(rest)) {
      return false;
    }
  }
  var index3 = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
Transform.prototype.split = function(pos, depth, typesAfter) {
  if (depth === void 0)
    depth = 1;
  var $pos = this.doc.resolve(pos), before2 = Fragment.empty, after2 = Fragment.empty;
  for (var d2 = $pos.depth, e3 = $pos.depth - depth, i2 = depth - 1; d2 > e3; d2--, i2--) {
    before2 = Fragment.from($pos.node(d2).copy(before2));
    var typeAfter = typesAfter && typesAfter[i2];
    after2 = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after2) : $pos.node(d2).copy(after2));
  }
  return this.step(new ReplaceStep(pos, pos, new Slice(before2.append(after2), depth, depth), true));
};
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
}
function joinable(a2, b2) {
  return a2 && b2 && !a2.isLeaf && a2.canAppend(b2);
}
Transform.prototype.join = function(pos, depth) {
  if (depth === void 0)
    depth = 1;
  var step3 = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  return this.step(step3);
};
function insertPoint(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d2 = $pos.depth - 1; d2 >= 0; d2--) {
      var index3 = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index3, index3, nodeType2)) {
        return $pos.before(d2 + 1);
      }
      if (index3 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function dropPoint(doc2, pos, slice5) {
  var $pos = doc2.resolve(pos);
  if (!slice5.content.size) {
    return pos;
  }
  var content3 = slice5.content;
  for (var i2 = 0; i2 < slice5.openStart; i2++) {
    content3 = content3.firstChild.content;
  }
  for (var pass = 1; pass <= (slice5.openStart == 0 && slice5.size ? 2 : 1); pass++) {
    for (var d2 = $pos.depth; d2 >= 0; d2--) {
      var bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content3);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content3.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
      }
    }
  }
  return null;
}
function mapFragment(fragment, f2, parent) {
  var mapped = [];
  for (var i2 = 0; i2 < fragment.childCount; i2++) {
    var child4 = fragment.child(i2);
    if (child4.content.size) {
      child4 = child4.copy(mapFragment(child4.content, f2, child4));
    }
    if (child4.isInline) {
      child4 = f2(child4, parent, i2);
    }
    mapped.push(child4);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = /* @__PURE__ */ function(Step3) {
  function AddMarkStep2(from5, to2, mark3) {
    Step3.call(this);
    this.from = from5;
    this.to = to2;
    this.mark = mark3;
  }
  if (Step3)
    AddMarkStep2.__proto__ = Step3;
  AddMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
  AddMarkStep2.prototype.constructor = AddMarkStep2;
  AddMarkStep2.prototype.apply = function apply9(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice5 = new Slice(mapFragment(oldSlice.content, function(node5, parent2) {
      if (!node5.isAtom || !parent2.type.allowsMarkType(this$1$1.mark.type)) {
        return node5;
      }
      return node5.mark(this$1$1.mark.addToSet(node5.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice5);
  };
  AddMarkStep2.prototype.invert = function invert4() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  };
  AddMarkStep2.prototype.map = function map21(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    if (from5.deleted && to2.deleted || from5.pos >= to2.pos) {
      return null;
    }
    return new AddMarkStep2(from5.pos, to2.pos, this.mark);
  };
  AddMarkStep2.prototype.merge = function merge3(other) {
    if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  AddMarkStep2.prototype.toJSON = function toJSON7() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  AddMarkStep2.fromJSON = function fromJSON8(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    }
    return new AddMarkStep2(json.from, json.to, schema2.markFromJSON(json.mark));
  };
  return AddMarkStep2;
}(Step);
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = /* @__PURE__ */ function(Step3) {
  function RemoveMarkStep2(from5, to2, mark3) {
    Step3.call(this);
    this.from = from5;
    this.to = to2;
    this.mark = mark3;
  }
  if (Step3)
    RemoveMarkStep2.__proto__ = Step3;
  RemoveMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
  RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
  RemoveMarkStep2.prototype.apply = function apply9(doc2) {
    var this$1$1 = this;
    var oldSlice = doc2.slice(this.from, this.to);
    var slice5 = new Slice(mapFragment(oldSlice.content, function(node5) {
      return node5.mark(this$1$1.mark.removeFromSet(node5.marks));
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice5);
  };
  RemoveMarkStep2.prototype.invert = function invert4() {
    return new AddMarkStep(this.from, this.to, this.mark);
  };
  RemoveMarkStep2.prototype.map = function map21(mapping) {
    var from5 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    if (from5.deleted && to2.deleted || from5.pos >= to2.pos) {
      return null;
    }
    return new RemoveMarkStep2(from5.pos, to2.pos, this.mark);
  };
  RemoveMarkStep2.prototype.merge = function merge3(other) {
    if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
      return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    }
  };
  RemoveMarkStep2.prototype.toJSON = function toJSON7() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  };
  RemoveMarkStep2.fromJSON = function fromJSON8(schema2, json) {
    if (typeof json.from != "number" || typeof json.to != "number") {
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    }
    return new RemoveMarkStep2(json.from, json.to, schema2.markFromJSON(json.mark));
  };
  return RemoveMarkStep2;
}(Step);
Step.jsonID("removeMark", RemoveMarkStep);
Transform.prototype.addMark = function(from5, to2, mark3) {
  var this$1$1 = this;
  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from5, to2, function(node5, pos, parent) {
    if (!node5.isInline) {
      return;
    }
    var marks3 = node5.marks;
    if (!mark3.isInSet(marks3) && parent.type.allowsMarkType(mark3.type)) {
      var start4 = Math.max(pos, from5), end3 = Math.min(pos + node5.nodeSize, to2);
      var newSet = mark3.addToSet(marks3);
      for (var i2 = 0; i2 < marks3.length; i2++) {
        if (!marks3[i2].isInSet(newSet)) {
          if (removing && removing.to == start4 && removing.mark.eq(marks3[i2])) {
            removing.to = end3;
          } else {
            removed.push(removing = new RemoveMarkStep(start4, end3, marks3[i2]));
          }
        }
      }
      if (adding && adding.to == start4) {
        adding.to = end3;
      } else {
        added.push(adding = new AddMarkStep(start4, end3, mark3));
      }
    }
  });
  removed.forEach(function(s2) {
    return this$1$1.step(s2);
  });
  added.forEach(function(s2) {
    return this$1$1.step(s2);
  });
  return this;
};
Transform.prototype.removeMark = function(from5, to2, mark3) {
  var this$1$1 = this;
  if (mark3 === void 0)
    mark3 = null;
  var matched = [], step3 = 0;
  this.doc.nodesBetween(from5, to2, function(node5, pos) {
    if (!node5.isInline) {
      return;
    }
    step3++;
    var toRemove = null;
    if (mark3 instanceof MarkType) {
      var set3 = node5.marks, found2;
      while (found2 = mark3.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark3) {
      if (mark3.isInSet(node5.marks)) {
        toRemove = [mark3];
      }
    } else {
      toRemove = node5.marks;
    }
    if (toRemove && toRemove.length) {
      var end3 = Math.min(pos + node5.nodeSize, to2);
      for (var i2 = 0; i2 < toRemove.length; i2++) {
        var style = toRemove[i2], found$1 = void 0;
        for (var j2 = 0; j2 < matched.length; j2++) {
          var m2 = matched[j2];
          if (m2.step == step3 - 1 && style.eq(matched[j2].style)) {
            found$1 = m2;
          }
        }
        if (found$1) {
          found$1.to = end3;
          found$1.step = step3;
        } else {
          matched.push({ style, from: Math.max(pos, from5), to: end3, step: step3 });
        }
      }
    }
  });
  matched.forEach(function(m2) {
    return this$1$1.step(new RemoveMarkStep(m2.from, m2.to, m2.style));
  });
  return this;
};
Transform.prototype.clearIncompatible = function(pos, parentType, match) {
  if (match === void 0)
    match = parentType.contentMatch;
  var node5 = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i2 = 0; i2 < node5.childCount; i2++) {
    var child4 = node5.child(i2), end3 = cur + child4.nodeSize;
    var allowed = match.matchType(child4.type, child4.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end3, Slice.empty));
    } else {
      match = allowed;
      for (var j2 = 0; j2 < child4.marks.length; j2++) {
        if (!parentType.allowsMarkType(child4.marks[j2].type)) {
          this.step(new RemoveMarkStep(cur, end3, child4.marks[j2]));
        }
      }
    }
    cur = end3;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(Fragment.empty, true);
    this.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
    this.step(delSteps[i$1]);
  }
  return this;
};
function replaceStep(doc2, from5, to2, slice5) {
  if (to2 === void 0)
    to2 = from5;
  if (slice5 === void 0)
    slice5 = Slice.empty;
  if (from5 == to2 && !slice5.size) {
    return null;
  }
  var $from = doc2.resolve(from5), $to = doc2.resolve(to2);
  if (fitsTrivially($from, $to, slice5)) {
    return new ReplaceStep(from5, to2, slice5);
  }
  return new Fitter($from, $to, slice5).fit();
}
Transform.prototype.replace = function(from5, to2, slice5) {
  if (to2 === void 0)
    to2 = from5;
  if (slice5 === void 0)
    slice5 = Slice.empty;
  var step3 = replaceStep(this.doc, from5, to2, slice5);
  if (step3) {
    this.step(step3);
  }
  return this;
};
Transform.prototype.replaceWith = function(from5, to2, content3) {
  return this.replace(from5, to2, new Slice(Fragment.from(content3), 0, 0));
};
Transform.prototype.delete = function(from5, to2) {
  return this.replace(from5, to2, Slice.empty);
};
Transform.prototype.insert = function(pos, content3) {
  return this.replaceWith(pos, pos, content3);
};
function fitsTrivially($from, $to, slice5) {
  return !slice5.openStart && !slice5.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice5.content);
}
var Fitter = function Fitter2($from, $to, slice5) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice5;
  this.frontier = [];
  for (var i2 = 0; i2 <= $from.depth; i2++) {
    var node5 = $from.node(i2);
    this.frontier.push({
      type: node5.type,
      match: node5.contentMatchAt($from.indexAfter(i2))
    });
  }
  this.placed = Fragment.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--) {
    this.placed = Fragment.from($from.node(i$1).copy(this.placed));
  }
};
var prototypeAccessors$1$3 = { depth: { configurable: true } };
prototypeAccessors$1$3.depth.get = function() {
  return this.frontier.length - 1;
};
Fitter.prototype.fit = function fit() {
  while (this.unplaced.size) {
    var fit2 = this.findFittable();
    if (fit2) {
      this.placeNodes(fit2);
    } else {
      this.openMore() || this.dropNode();
    }
  }
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) {
    return null;
  }
  var content3 = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content3.childCount == 1) {
    content3 = content3.firstChild.content;
    openStart--;
    openEnd--;
  }
  var slice5 = new Slice(content3, openStart, openEnd);
  if (moveInline > -1) {
    return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice5, placedSize);
  }
  if (slice5.size || $from.pos != this.$to.pos) {
    return new ReplaceStep($from.pos, $to.pos, slice5);
  }
};
Fitter.prototype.findFittable = function findFittable() {
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = void 0, parent = void 0;
      if (sliceDepth) {
        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref = this.frontier[frontierDepth];
        var type = ref.type;
        var match = ref.match;
        var wrap2 = void 0, inject = void 0;
        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : type.compatibleContent(parent.type))) {
          return { sliceDepth, frontierDepth, parent, inject };
        } else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type))) {
          return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
        }
        if (parent && match.matchType(parent.type)) {
          break;
        }
      }
    }
  }
};
Fitter.prototype.openMore = function openMore() {
  var ref = this.unplaced;
  var content3 = ref.content;
  var openStart = ref.openStart;
  var openEnd = ref.openEnd;
  var inner = contentAt(content3, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) {
    return false;
  }
  this.unplaced = new Slice(content3, openStart + 1, Math.max(openEnd, inner.size + openStart >= content3.size - openEnd ? openStart + 1 : 0));
  return true;
};
Fitter.prototype.dropNode = function dropNode() {
  var ref = this.unplaced;
  var content3 = ref.content;
  var openStart = ref.openStart;
  var openEnd = ref.openEnd;
  var inner = contentAt(content3, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content3.size - openStart <= openStart + inner.size;
    this.unplaced = new Slice(dropFromFragment(content3, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new Slice(dropFromFragment(content3, openStart, 1), openStart, openEnd);
  }
};
Fitter.prototype.placeNodes = function placeNodes(ref) {
  var sliceDepth = ref.sliceDepth;
  var frontierDepth = ref.frontierDepth;
  var parent = ref.parent;
  var inject = ref.inject;
  var wrap2 = ref.wrap;
  while (this.depth > frontierDepth) {
    this.closeFrontierNode();
  }
  if (wrap2) {
    for (var i2 = 0; i2 < wrap2.length; i2++) {
      this.openFrontierNode(wrap2[i2]);
    }
  }
  var slice5 = this.unplaced, fragment = parent ? parent.content : slice5.content;
  var openStart = slice5.openStart - sliceDepth;
  var taken = 0, add3 = [];
  var ref$1 = this.frontier[frontierDepth];
  var match = ref$1.match;
  var type = ref$1.type;
  if (inject) {
    for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
      add3.push(inject.child(i$1));
    }
    match = match.matchFragment(inject);
  }
  var openEndCount = fragment.size + sliceDepth - (slice5.content.size - slice5.openEnd);
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches2 = match.matchType(next.type);
    if (!matches2) {
      break;
    }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) {
      match = matches2;
      add3.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) {
    openEndCount = -1;
  }
  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add3));
  this.frontier[frontierDepth].match = match;
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
    this.closeFrontierNode();
  }
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node5 = cur.lastChild;
    this.frontier.push({ type: node5.type, match: node5.contentMatchAt(node5.childCount) });
    cur = node5.content;
  }
  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice5.content, sliceDepth, taken), slice5.openStart, slice5.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice5.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice5.openEnd : sliceDepth - 1);
};
Fitter.prototype.mustMoveInline = function mustMoveInline() {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
    return -1;
  }
  var top2 = this.frontier[this.depth], level;
  if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
    return -1;
  }
  var ref = this.$to;
  var depth = ref.depth;
  var after2 = this.$to.after(depth);
  while (depth > 1 && after2 == this.$to.end(--depth)) {
    ++after2;
  }
  return after2;
};
Fitter.prototype.findCloseLevel = function findCloseLevel($to) {
  scan:
    for (var i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
      var ref = this.frontier[i2];
      var match = ref.match;
      var type = ref.type;
      var dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
      var fit2 = contentAfterFits($to, i2, type, match, dropInner);
      if (!fit2) {
        continue;
      }
      for (var d2 = i2 - 1; d2 >= 0; d2--) {
        var ref$1 = this.frontier[d2];
        var match$1 = ref$1.match;
        var type$1 = ref$1.type;
        var matches2 = contentAfterFits($to, d2, type$1, match$1, true);
        if (!matches2 || matches2.childCount) {
          continue scan;
        }
      }
      return { depth: i2, fit: fit2, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
    }
};
Fitter.prototype.close = function close($to) {
  var close3 = this.findCloseLevel($to);
  if (!close3) {
    return null;
  }
  while (this.depth > close3.depth) {
    this.closeFrontierNode();
  }
  if (close3.fit.childCount) {
    this.placed = addToFragment(this.placed, close3.depth, close3.fit);
  }
  $to = close3.move;
  for (var d2 = close3.depth + 1; d2 <= $to.depth; d2++) {
    var node5 = $to.node(d2), add3 = node5.type.contentMatch.fillBefore(node5.content, true, $to.index(d2));
    this.openFrontierNode(node5.type, node5.attrs, add3);
  }
  return $to;
};
Fitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content3) {
  var top2 = this.frontier[this.depth];
  top2.match = top2.match.matchType(type);
  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content3)));
  this.frontier.push({ type, match: type.contentMatch });
};
Fitter.prototype.closeFrontierNode = function closeFrontierNode() {
  var open2 = this.frontier.pop();
  var add3 = open2.match.fillBefore(Fragment.empty, true);
  if (add3.childCount) {
    this.placed = addToFragment(this.placed, this.frontier.length, add3);
  }
};
Object.defineProperties(Fitter.prototype, prototypeAccessors$1$3);
function dropFromFragment(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content3) {
  if (depth == 0) {
    return fragment.append(content3);
  }
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content3)));
}
function contentAt(fragment, depth) {
  for (var i2 = 0; i2 < depth; i2++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart(node5, openStart, openEnd) {
  if (openStart <= 0) {
    return node5;
  }
  var frag = node5.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node5.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node5.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
  }
  return node5.copy(frag);
}
function contentAfterFits($to, depth, type, match, open2) {
  var node5 = $to.node(depth), index3 = open2 ? $to.indexAfter(depth) : $to.index(depth);
  if (index3 == node5.childCount && !type.compatibleContent(node5.type)) {
    return null;
  }
  var fit2 = match.fillBefore(node5.content, true, index3);
  return fit2 && !invalidMarks(type, node5.content, index3) ? fit2 : null;
}
function invalidMarks(type, fragment, start4) {
  for (var i2 = start4; i2 < fragment.childCount; i2++) {
    if (!type.allowsMarks(fragment.child(i2).marks)) {
      return true;
    }
  }
  return false;
}
Transform.prototype.replaceRange = function(from5, to2, slice5) {
  if (!slice5.size) {
    return this.deleteRange(from5, to2);
  }
  var $from = this.doc.resolve(from5), $to = this.doc.resolve(to2);
  if (fitsTrivially($from, $to, slice5)) {
    return this.step(new ReplaceStep(from5, to2, slice5));
  }
  var targetDepths = coveredDepths($from, this.doc.resolve(to2));
  if (targetDepths[targetDepths.length - 1] == 0) {
    targetDepths.pop();
  }
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (var d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    var spec = $from.node(d2).type.spec;
    if (spec.defining || spec.isolating) {
      break;
    }
    if (targetDepths.indexOf(d2) > -1) {
      preferredTarget = d2;
    } else if ($from.before(d2) == pos) {
      targetDepths.splice(1, 0, -d2);
    }
  }
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [], preferredDepth = slice5.openStart;
  for (var content3 = slice5.content, i2 = 0; ; i2++) {
    var node5 = content3.firstChild;
    leftNodes.push(node5);
    if (i2 == slice5.openStart) {
      break;
    }
    content3 = node5.content;
  }
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
    preferredDepth -= 1;
  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
    preferredDepth -= 2;
  }
  for (var j2 = slice5.openStart; j2 >= 0; j2--) {
    var openDepth = (j2 + preferredDepth + 1) % (slice5.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) {
      continue;
    }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index3, index3, insert.type, insert.marks)) {
        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to2, new Slice(closeFragment(slice5.content, 0, slice5.openStart, openDepth), openDepth, slice5.openEnd));
      }
    }
  }
  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from5, to2, slice5);
    if (this.steps.length > startSteps) {
      break;
    }
    var depth = targetDepths[i$2];
    if (depth < 0) {
      continue;
    }
    from5 = $from.before(depth);
    to2 = $to.after(depth);
  }
  return this;
};
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start4 = match.fillBefore(fragment).append(fragment);
    fragment = start4.append(match.matchFragment(start4).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
Transform.prototype.replaceRangeWith = function(from5, to2, node5) {
  if (!node5.isInline && from5 == to2 && this.doc.resolve(from5).parent.content.size) {
    var point2 = insertPoint(this.doc, from5, node5.type);
    if (point2 != null) {
      from5 = to2 = point2;
    }
  }
  return this.replaceRange(from5, to2, new Slice(Fragment.from(node5), 0, 0));
};
Transform.prototype.deleteRange = function(from5, to2) {
  var $from = this.doc.resolve(from5), $to = this.doc.resolve(to2);
  var covered = coveredDepths($from, $to);
  for (var i2 = 0; i2 < covered.length; i2++) {
    var depth = covered[i2], last = i2 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
      return this.delete($from.start(depth), $to.end(depth));
    }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
      return this.delete($from.before(depth), $to.after(depth));
    }
  }
  for (var d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from5 - $from.start(d2) == $from.depth - d2 && to2 > $from.end(d2) && $to.end(d2) - to2 != $to.depth - d2) {
      return this.delete($from.before(d2), to2);
    }
  }
  return this.delete(from5, to2);
};
function coveredDepths($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d2 = minDepth; d2 >= 0; d2--) {
    var start4 = $from.start(d2);
    if (start4 < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating) {
      break;
    }
    if (start4 == $to.start(d2)) {
      result2.push(d2);
    }
  }
  return result2;
}
var classesById = Object.create(null);
var Selection = function Selection2($anchor, $head, ranges) {
  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  this.$anchor = $anchor;
  this.$head = $head;
};
var prototypeAccessors$4 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
prototypeAccessors$4.anchor.get = function() {
  return this.$anchor.pos;
};
prototypeAccessors$4.head.get = function() {
  return this.$head.pos;
};
prototypeAccessors$4.from.get = function() {
  return this.$from.pos;
};
prototypeAccessors$4.to.get = function() {
  return this.$to.pos;
};
prototypeAccessors$4.$from.get = function() {
  return this.ranges[0].$from;
};
prototypeAccessors$4.$to.get = function() {
  return this.ranges[0].$to;
};
prototypeAccessors$4.empty.get = function() {
  var ranges = this.ranges;
  for (var i2 = 0; i2 < ranges.length; i2++) {
    if (ranges[i2].$from.pos != ranges[i2].$to.pos) {
      return false;
    }
  }
  return true;
};
Selection.prototype.content = function content2() {
  return this.$from.node(0).slice(this.from, this.to, true);
};
Selection.prototype.replace = function replace(tr, content3) {
  if (content3 === void 0)
    content3 = Slice.empty;
  var lastNode = content3.content.lastChild, lastParent = null;
  for (var i2 = 0; i2 < content3.openEnd; i2++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref = ranges[i$1];
    var $from = ref.$from;
    var $to = ref.$to;
    var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content3);
    if (i$1 == 0) {
      selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
};
Selection.prototype.replaceWith = function replaceWith(tr, node5) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i2 = 0; i2 < ranges.length; i2++) {
    var ref = ranges[i2];
    var $from = ref.$from;
    var $to = ref.$to;
    var mapping = tr.mapping.slice(mapFrom);
    var from5 = mapping.map($from.pos), to2 = mapping.map($to.pos);
    if (i2) {
      tr.deleteRange(from5, to2);
    } else {
      tr.replaceRangeWith(from5, to2, node5);
      selectionToInsertionEnd(tr, mapFrom, node5.isInline ? -1 : 1);
    }
  }
};
Selection.findFrom = function findFrom($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) {
    return inner;
  }
  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found2) {
      return found2;
    }
  }
};
Selection.near = function near($pos, bias) {
  if (bias === void 0)
    bias = 1;
  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
};
Selection.atStart = function atStart(doc2) {
  return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
};
Selection.atEnd = function atEnd(doc2) {
  return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
};
Selection.fromJSON = function fromJSON6(doc2, json) {
  if (!json || !json.type) {
    throw new RangeError("Invalid input for Selection.fromJSON");
  }
  var cls = classesById[json.type];
  if (!cls) {
    throw new RangeError("No selection type " + json.type + " defined");
  }
  return cls.fromJSON(doc2, json);
};
Selection.jsonID = function jsonID2(id2, selectionClass) {
  if (id2 in classesById) {
    throw new RangeError("Duplicate use of selection JSON ID " + id2);
  }
  classesById[id2] = selectionClass;
  selectionClass.prototype.jsonID = id2;
  return selectionClass;
};
Selection.prototype.getBookmark = function getBookmark() {
  return TextSelection.between(this.$anchor, this.$head).getBookmark();
};
Object.defineProperties(Selection.prototype, prototypeAccessors$4);
Selection.prototype.visible = true;
var SelectionRange = function SelectionRange2($from, $to) {
  this.$from = $from;
  this.$to = $to;
};
var TextSelection = /* @__PURE__ */ function(Selection3) {
  function TextSelection2($anchor, $head) {
    if ($head === void 0)
      $head = $anchor;
    Selection3.call(this, $anchor, $head);
  }
  if (Selection3)
    TextSelection2.__proto__ = Selection3;
  TextSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  TextSelection2.prototype.constructor = TextSelection2;
  var prototypeAccessors$12 = { $cursor: { configurable: true } };
  prototypeAccessors$12.$cursor.get = function() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  };
  TextSelection2.prototype.map = function map21(doc2, mapping) {
    var $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) {
      return Selection3.near($head);
    }
    var $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  };
  TextSelection2.prototype.replace = function replace4(tr, content3) {
    if (content3 === void 0)
      content3 = Slice.empty;
    Selection3.prototype.replace.call(this, tr, content3);
    if (content3 == Slice.empty) {
      var marks3 = this.$from.marksAcross(this.$to);
      if (marks3) {
        tr.ensureMarks(marks3);
      }
    }
  };
  TextSelection2.prototype.eq = function eq20(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  };
  TextSelection2.prototype.getBookmark = function getBookmark2() {
    return new TextBookmark(this.anchor, this.head);
  };
  TextSelection2.prototype.toJSON = function toJSON7() {
    return { type: "text", anchor: this.anchor, head: this.head };
  };
  TextSelection2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number") {
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    }
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  TextSelection2.create = function create7(doc2, anchor2, head) {
    if (head === void 0)
      head = anchor2;
    var $anchor = doc2.resolve(anchor2);
    return new this($anchor, head == anchor2 ? $anchor : doc2.resolve(head));
  };
  TextSelection2.between = function between($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) {
      bias = dPos >= 0 ? 1 : -1;
    }
    if (!$head.parent.inlineContent) {
      var found2 = Selection3.findFrom($head, bias, true) || Selection3.findFrom($head, -bias, true);
      if (found2) {
        $head = found2.$head;
      } else {
        return Selection3.near($head, bias);
      }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection3.findFrom($anchor, -bias, true) || Selection3.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0) {
          $anchor = $head;
        }
      }
    }
    return new TextSelection2($anchor, $head);
  };
  Object.defineProperties(TextSelection2.prototype, prototypeAccessors$12);
  return TextSelection2;
}(Selection);
Selection.jsonID("text", TextSelection);
var TextBookmark = function TextBookmark2(anchor2, head) {
  this.anchor = anchor2;
  this.head = head;
};
TextBookmark.prototype.map = function map5(mapping) {
  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
};
TextBookmark.prototype.resolve = function resolve3(doc2) {
  return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
};
var NodeSelection = /* @__PURE__ */ function(Selection3) {
  function NodeSelection2($pos) {
    var node5 = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node5.nodeSize);
    Selection3.call(this, $pos, $end);
    this.node = node5;
  }
  if (Selection3)
    NodeSelection2.__proto__ = Selection3;
  NodeSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  NodeSelection2.prototype.constructor = NodeSelection2;
  NodeSelection2.prototype.map = function map21(doc2, mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    var $pos = doc2.resolve(pos);
    if (deleted) {
      return Selection3.near($pos);
    }
    return new NodeSelection2($pos);
  };
  NodeSelection2.prototype.content = function content3() {
    return new Slice(Fragment.from(this.node), 0, 0);
  };
  NodeSelection2.prototype.eq = function eq20(other) {
    return other instanceof NodeSelection2 && other.anchor == this.anchor;
  };
  NodeSelection2.prototype.toJSON = function toJSON7() {
    return { type: "node", anchor: this.anchor };
  };
  NodeSelection2.prototype.getBookmark = function getBookmark2() {
    return new NodeBookmark(this.anchor);
  };
  NodeSelection2.fromJSON = function fromJSON8(doc2, json) {
    if (typeof json.anchor != "number") {
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    }
    return new NodeSelection2(doc2.resolve(json.anchor));
  };
  NodeSelection2.create = function create7(doc2, from5) {
    return new this(doc2.resolve(from5));
  };
  NodeSelection2.isSelectable = function isSelectable(node5) {
    return !node5.isText && node5.type.spec.selectable !== false;
  };
  return NodeSelection2;
}(Selection);
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = function NodeBookmark2(anchor2) {
  this.anchor = anchor2;
};
NodeBookmark.prototype.map = function map6(mapping) {
  var ref = mapping.mapResult(this.anchor);
  var deleted = ref.deleted;
  var pos = ref.pos;
  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
};
NodeBookmark.prototype.resolve = function resolve4(doc2) {
  var $pos = doc2.resolve(this.anchor), node5 = $pos.nodeAfter;
  if (node5 && NodeSelection.isSelectable(node5)) {
    return new NodeSelection($pos);
  }
  return Selection.near($pos);
};
var AllSelection = /* @__PURE__ */ function(Selection3) {
  function AllSelection2(doc2) {
    Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  if (Selection3)
    AllSelection2.__proto__ = Selection3;
  AllSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  AllSelection2.prototype.constructor = AllSelection2;
  AllSelection2.prototype.replace = function replace4(tr, content3) {
    if (content3 === void 0)
      content3 = Slice.empty;
    if (content3 == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection3.atStart(tr.doc);
      if (!sel.eq(tr.selection)) {
        tr.setSelection(sel);
      }
    } else {
      Selection3.prototype.replace.call(this, tr, content3);
    }
  };
  AllSelection2.prototype.toJSON = function toJSON7() {
    return { type: "all" };
  };
  AllSelection2.fromJSON = function fromJSON8(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.map = function map21(doc2) {
    return new AllSelection2(doc2);
  };
  AllSelection2.prototype.eq = function eq20(other) {
    return other instanceof AllSelection2;
  };
  AllSelection2.prototype.getBookmark = function getBookmark2() {
    return AllBookmark;
  };
  return AllSelection2;
}(Selection);
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map7() {
    return this;
  },
  resolve: function resolve5(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node5, pos, index3, dir, text3) {
  if (node5.inlineContent) {
    return TextSelection.create(doc2, pos);
  }
  for (var i2 = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node5.childCount : i2 >= 0; i2 += dir) {
    var child4 = node5.child(i2);
    if (!child4.isAtom) {
      var inner = findSelectionIn(doc2, child4, pos + dir, dir < 0 ? child4.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection.isSelectable(child4)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child4.nodeSize : 0));
    }
    pos += child4.nodeSize * dir;
  }
}
function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step3 = tr.steps[last];
  if (!(step3 instanceof ReplaceStep || step3 instanceof ReplaceAroundStep)) {
    return;
  }
  var map21 = tr.mapping.maps[last], end3;
  map21.forEach(function(_from, _to, _newFrom, newTo) {
    if (end3 == null) {
      end3 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end3), bias));
}
var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
var Transaction = /* @__PURE__ */ function(Transform3) {
  function Transaction2(state) {
    Transform3.call(this, state.doc);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.curSelectionFor = 0;
    this.storedMarks = state.storedMarks;
    this.updated = 0;
    this.meta = Object.create(null);
  }
  if (Transform3)
    Transaction2.__proto__ = Transform3;
  Transaction2.prototype = Object.create(Transform3 && Transform3.prototype);
  Transaction2.prototype.constructor = Transaction2;
  var prototypeAccessors2 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
  prototypeAccessors2.selection.get = function() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  };
  Transaction2.prototype.setSelection = function setSelection3(selection) {
    if (selection.$from.doc != this.doc) {
      throw new RangeError("Selection passed to setSelection must point at the current document");
    }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  };
  prototypeAccessors2.selectionSet.get = function() {
    return (this.updated & UPDATED_SEL) > 0;
  };
  Transaction2.prototype.setStoredMarks = function setStoredMarks(marks3) {
    this.storedMarks = marks3;
    this.updated |= UPDATED_MARKS;
    return this;
  };
  Transaction2.prototype.ensureMarks = function ensureMarks(marks3) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks3)) {
      this.setStoredMarks(marks3);
    }
    return this;
  };
  Transaction2.prototype.addStoredMark = function addStoredMark(mark3) {
    return this.ensureMarks(mark3.addToSet(this.storedMarks || this.selection.$head.marks()));
  };
  Transaction2.prototype.removeStoredMark = function removeStoredMark(mark3) {
    return this.ensureMarks(mark3.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  };
  prototypeAccessors2.storedMarksSet.get = function() {
    return (this.updated & UPDATED_MARKS) > 0;
  };
  Transaction2.prototype.addStep = function addStep2(step3, doc2) {
    Transform3.prototype.addStep.call(this, step3, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };
  Transaction2.prototype.setTime = function setTime(time) {
    this.time = time;
    return this;
  };
  Transaction2.prototype.replaceSelection = function replaceSelection(slice5) {
    this.selection.replace(this, slice5);
    return this;
  };
  Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node5, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false) {
      node5 = node5.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    }
    selection.replaceWith(this, node5);
    return this;
  };
  Transaction2.prototype.deleteSelection = function deleteSelection2() {
    this.selection.replace(this);
    return this;
  };
  Transaction2.prototype.insertText = function insertText(text3, from5, to2) {
    if (to2 === void 0)
      to2 = from5;
    var schema2 = this.doc.type.schema;
    if (from5 == null) {
      if (!text3) {
        return this.deleteSelection();
      }
      return this.replaceSelectionWith(schema2.text(text3), true);
    } else {
      if (!text3) {
        return this.deleteRange(from5, to2);
      }
      var marks3 = this.storedMarks;
      if (!marks3) {
        var $from = this.doc.resolve(from5);
        marks3 = to2 == from5 ? $from.marks() : $from.marksAcross(this.doc.resolve(to2));
      }
      this.replaceRangeWith(from5, to2, schema2.text(text3, marks3));
      if (!this.selection.empty) {
        this.setSelection(Selection.near(this.selection.$to));
      }
      return this;
    }
  };
  Transaction2.prototype.setMeta = function setMeta(key2, value) {
    this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
    return this;
  };
  Transaction2.prototype.getMeta = function getMeta(key2) {
    return this.meta[typeof key2 == "string" ? key2 : key2.key];
  };
  prototypeAccessors2.isGeneric.get = function() {
    for (var _2 in this.meta) {
      return false;
    }
    return true;
  };
  Transaction2.prototype.scrollIntoView = function scrollIntoView2() {
    this.updated |= UPDATED_SCROLL;
    return this;
  };
  prototypeAccessors2.scrolledIntoView.get = function() {
    return (this.updated & UPDATED_SCROLL) > 0;
  };
  Object.defineProperties(Transaction2.prototype, prototypeAccessors2);
  return Transaction2;
}(Transform);
function bind(f2, self2) {
  return !self2 || !f2 ? f2 : f2.bind(self2);
}
var FieldDesc = function FieldDesc2(name, desc, self2) {
  this.name = name;
  this.init = bind(desc.init, self2);
  this.apply = bind(desc.apply, self2);
};
var baseFields = [
  new FieldDesc("doc", {
    init: function init(config2) {
      return config2.doc || config2.schema.topNodeType.createAndFill();
    },
    apply: function apply2(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init: function init2(config2, instance) {
      return config2.selection || Selection.atStart(instance.doc);
    },
    apply: function apply3(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init: function init3(config2) {
      return config2.storedMarks || null;
    },
    apply: function apply4(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init: function init4() {
      return 0;
    },
    apply: function apply5(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = function Configuration2(schema2, plugins) {
  var this$1$1 = this;
  this.schema = schema2;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  if (plugins) {
    plugins.forEach(function(plugin2) {
      if (this$1$1.pluginsByKey[plugin2.key]) {
        throw new RangeError("Adding different instances of a keyed plugin (" + plugin2.key + ")");
      }
      this$1$1.plugins.push(plugin2);
      this$1$1.pluginsByKey[plugin2.key] = plugin2;
      if (plugin2.spec.state) {
        this$1$1.fields.push(new FieldDesc(plugin2.key, plugin2.spec.state, plugin2));
      }
    });
  }
};
var EditorState = function EditorState2(config2) {
  this.config = config2;
};
var prototypeAccessors$1$2 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
prototypeAccessors$1$2.schema.get = function() {
  return this.config.schema;
};
prototypeAccessors$1$2.plugins.get = function() {
  return this.config.plugins;
};
EditorState.prototype.apply = function apply6(tr) {
  return this.applyTransaction(tr).state;
};
EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
  if (ignore === void 0)
    ignore = -1;
  for (var i2 = 0; i2 < this.config.plugins.length; i2++) {
    if (i2 != ignore) {
      var plugin2 = this.config.plugins[i2];
      if (plugin2.spec.filterTransaction && !plugin2.spec.filterTransaction.call(plugin2, tr, this)) {
        return false;
      }
    }
  }
  return true;
};
EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
  if (!this.filterTransaction(rootTr)) {
    return { state: this, transactions: [] };
  }
  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  for (; ; ) {
    var haveNew = false;
    for (var i2 = 0; i2 < this.config.plugins.length; i2++) {
      var plugin2 = this.config.plugins[i2];
      if (plugin2.spec.appendTransaction) {
        var n2 = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
        var tr = n2 < trs.length && plugin2.spec.appendTransaction.call(plugin2, n2 ? trs.slice(n2) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i2)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j2 = 0; j2 < this.config.plugins.length; j2++) {
              seen.push(j2 < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) {
          seen[i2] = { state: newState, n: trs.length };
        }
      }
    }
    if (!haveNew) {
      return { state: newState, transactions: trs };
    }
  }
};
EditorState.prototype.applyInner = function applyInner(tr) {
  if (!tr.before.eq(this.doc)) {
    throw new RangeError("Applying a mismatched transaction");
  }
  var newInstance = new EditorState(this.config), fields = this.config.fields;
  for (var i2 = 0; i2 < fields.length; i2++) {
    var field = fields[i2];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
    applyListeners[i$1](this, tr, newInstance);
  }
  return newInstance;
};
prototypeAccessors$1$2.tr.get = function() {
  return new Transaction(this);
};
EditorState.create = function create3(config2) {
  var $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
  var instance = new EditorState($config);
  for (var i2 = 0; i2 < $config.fields.length; i2++) {
    instance[$config.fields[i2].name] = $config.fields[i2].init(config2, instance);
  }
  return instance;
};
EditorState.prototype.reconfigure = function reconfigure(config2) {
  var $config = new Configuration(this.schema, config2.plugins);
  var fields = $config.fields, instance = new EditorState($config);
  for (var i2 = 0; i2 < fields.length; i2++) {
    var name = fields[i2].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config2, instance);
  }
  return instance;
};
EditorState.prototype.toJSON = function toJSON6(pluginFields) {
  var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
  if (this.storedMarks) {
    result2.storedMarks = this.storedMarks.map(function(m2) {
      return m2.toJSON();
    });
  }
  if (pluginFields && typeof pluginFields == "object") {
    for (var prop in pluginFields) {
      if (prop == "doc" || prop == "selection") {
        throw new RangeError("The JSON fields `doc` and `selection` are reserved");
      }
      var plugin2 = pluginFields[prop], state = plugin2.spec.state;
      if (state && state.toJSON) {
        result2[prop] = state.toJSON.call(plugin2, this[plugin2.key]);
      }
    }
  }
  return result2;
};
EditorState.fromJSON = function fromJSON7(config2, json, pluginFields) {
  if (!json) {
    throw new RangeError("Invalid input for EditorState.fromJSON");
  }
  if (!config2.schema) {
    throw new RangeError("Required config field 'schema' missing");
  }
  var $config = new Configuration(config2.schema, config2.plugins);
  var instance = new EditorState($config);
  $config.fields.forEach(function(field) {
    if (field.name == "doc") {
      instance.doc = Node.fromJSON(config2.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) {
        instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
      }
    } else {
      if (pluginFields) {
        for (var prop in pluginFields) {
          var plugin2 = pluginFields[prop], state = plugin2.spec.state;
          if (plugin2.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
            instance[field.name] = state.fromJSON.call(plugin2, config2, json[prop], instance);
            return;
          }
        }
      }
      instance[field.name] = field.init(config2, instance);
    }
  });
  return instance;
};
EditorState.addApplyListener = function addApplyListener(f2) {
  applyListeners.push(f2);
};
EditorState.removeApplyListener = function removeApplyListener(f2) {
  var found2 = applyListeners.indexOf(f2);
  if (found2 > -1) {
    applyListeners.splice(found2, 1);
  }
};
Object.defineProperties(EditorState.prototype, prototypeAccessors$1$2);
var applyListeners = [];
function bindProps(obj, self2, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) {
      val = val.bind(self2);
    } else if (prop == "handleDOMEvents") {
      val = bindProps(val, self2, {});
    }
    target[prop] = val;
  }
  return target;
}
var Plugin = function Plugin2(spec) {
  this.props = {};
  if (spec.props) {
    bindProps(spec.props, this, this.props);
  }
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};
Plugin.prototype.getState = function getState(state) {
  return state[this.key];
};
var keys$3 = Object.create(null);
function createKey(name) {
  if (name in keys$3) {
    return name + "$" + ++keys$3[name];
  }
  keys$3[name] = 0;
  return name + "$";
}
var PluginKey = function PluginKey2(name) {
  if (name === void 0)
    name = "key";
  this.key = createKey(name);
};
PluginKey.prototype.get = function get(state) {
  return state.config.pluginsByKey[this.key];
};
PluginKey.prototype.getState = function getState2(state) {
  return state[this.key];
};
var result$1 = {};
if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge$1 = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10$1 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up$1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  result$1.mac = /Mac/.test(navigator.platform);
  var ie$3 = result$1.ie = !!(ie_upto10$1 || ie_11up$1 || ie_edge$1);
  result$1.ie_version = ie_upto10$1 ? document.documentMode || 6 : ie_11up$1 ? +ie_11up$1[1] : ie_edge$1 ? +ie_edge$1[1] : null;
  result$1.gecko = !ie$3 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result$1.gecko_version = result$1.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome$2 = !ie$3 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result$1.chrome = !!chrome$2;
  result$1.chrome_version = chrome$2 && +chrome$2[1];
  result$1.safari = !ie$3 && /Apple Computer/.test(navigator.vendor);
  result$1.ios = result$1.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result$1.android = /Android \d/.test(navigator.userAgent);
  result$1.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result$1.webkit_version = result$1.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}
var domIndex$1 = function(node5) {
  for (var index3 = 0; ; index3++) {
    node5 = node5.previousSibling;
    if (!node5) {
      return index3;
    }
  }
};
var parentNode$1 = function(node5) {
  var parent = node5.assignedSlot || node5.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange$1 = null;
var textRange$1 = function(node5, from5, to2) {
  var range = reusedRange$1 || (reusedRange$1 = document.createRange());
  range.setEnd(node5, to2 == null ? node5.nodeValue.length : to2);
  range.setStart(node5, from5 || 0);
  return range;
};
var isEquivalentPosition$1 = function(node5, off, targetNode, targetOff) {
  return targetNode && (scanFor$1(node5, off, targetNode, targetOff, -1) || scanFor$1(node5, off, targetNode, targetOff, 1));
};
var atomElements$1 = /^(img|br|input|textarea|hr)$/i;
function scanFor$1(node5, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node5 == targetNode && off == targetOff) {
      return true;
    }
    if (off == (dir < 0 ? 0 : nodeSize$1(node5))) {
      var parent = node5.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc$1(node5) || atomElements$1.test(node5.nodeName) || node5.contentEditable == "false") {
        return false;
      }
      off = domIndex$1(node5) + (dir < 0 ? 0 : 1);
      node5 = parent;
    } else if (node5.nodeType == 1) {
      node5 = node5.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node5.contentEditable == "false") {
        return false;
      }
      off = dir < 0 ? nodeSize$1(node5) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize$1(node5) {
  return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
}
function isOnEdge$1(node5, offset2, parent) {
  for (var atStart2 = offset2 == 0, atEnd2 = offset2 == nodeSize$1(node5); atStart2 || atEnd2; ) {
    if (node5 == parent) {
      return true;
    }
    var index3 = domIndex$1(node5);
    node5 = node5.parentNode;
    if (!node5) {
      return false;
    }
    atStart2 = atStart2 && index3 == 0;
    atEnd2 = atEnd2 && index3 == nodeSize$1(node5);
  }
}
function hasBlockDesc$1(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed$1 = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result$1.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function keyEvent$1(keyCode, key2) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key2;
  return event;
}
function windowRect$1(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide$1(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect$1(node5) {
  var rect = node5.getBoundingClientRect();
  var scaleX = rect.width / node5.offsetWidth || 1;
  var scaleY = rect.height / node5.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node5.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node5.clientHeight * scaleY
  };
}
function scrollRectIntoView$1(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode$1(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc2.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect$1(doc2) : clientRect$1(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide$1(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect.top + getSide$1(scrollMargin, "top"));
    } else if (rect.bottom > bounding.bottom - getSide$1(scrollThreshold, "bottom")) {
      moveY = rect.bottom - bounding.bottom + getSide$1(scrollMargin, "bottom");
    }
    if (rect.left < bounding.left + getSide$1(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect.left + getSide$1(scrollMargin, "left"));
    } else if (rect.right > bounding.right - getSide$1(scrollThreshold, "right")) {
      moveX = rect.right - bounding.right + getSide$1(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos$1(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x2 = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    var dom = view.root.elementFromPoint(x2, y2);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack$1(view.dom) };
}
function scrollStack$1(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (; dom; dom = parentNode$1(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc2) {
      break;
    }
  }
  return stack;
}
function resetScrollPos$1(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack$1(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack$1(stack, dTop) {
  for (var i2 = 0; i2 < stack.length; i2++) {
    var ref = stack[i2];
    var dom = ref.dom;
    var top2 = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top2 + dTop) {
      dom.scrollTop = top2 + dTop;
    }
    if (dom.scrollLeft != left) {
      dom.scrollLeft = left;
    }
  }
}
var preventScrollSupported$1 = null;
function focusPreventScroll$1(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported$1) {
    return dom.focus(preventScrollSupported$1);
  }
  var stored = scrollStack$1(dom);
  dom.focus(preventScrollSupported$1 == null ? {
    get preventScroll() {
      preventScrollSupported$1 = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported$1) {
    preventScrollSupported$1 = false;
    restoreScrollStack$1(stored, 0);
  }
}
function findOffsetInNode$1(node5, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child4 = node5.firstChild, childIndex = 0; child4; child4 = child4.nextSibling, childIndex++) {
    var rects = void 0;
    if (child4.nodeType == 1) {
      rects = child4.getClientRects();
    } else if (child4.nodeType == 3) {
      rects = textRange$1(child4).getClientRects();
    } else {
      continue;
    }
    for (var i2 = 0; i2 < rects.length; i2++) {
      var rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child4;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child4.nodeType == 1 && dx) {
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset2 = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText$1(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node5, offset: offset2 };
  }
  return findOffsetInNode$1(closest, coordsClosest);
}
function findOffsetInText$1(node5, coords) {
  var len = node5.nodeValue.length;
  var range = document.createRange();
  for (var i2 = 0; i2 < len; i2++) {
    range.setEnd(node5, i2 + 1);
    range.setStart(node5, i2);
    var rect = singleRect$1(range, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (inRect$1(coords, rect)) {
      return { node: node5, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node5, offset: 0 };
}
function inRect$1(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge$1(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement$1(view, elt, coords) {
  var ref = findOffsetInNode$1(elt, coords);
  var node5 = ref.node;
  var offset2 = ref.offset;
  var bias = -1;
  if (node5.nodeType == 1 && !node5.firstChild) {
    var rect = node5.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node5, offset2, bias);
}
function posFromCaret$1(view, node5, offset2, coords) {
  var outside = -1;
  for (var cur = node5; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node5, offset2);
}
function elementFromPoint$1(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      var child4 = element.childNodes[i2];
      if (child4.nodeType == 1) {
        var rects = child4.getClientRects();
        for (var j2 = 0; j2 < rects.length; j2++) {
          var rect = rects[j2];
          if (inRect$1(coords, rect)) {
            return elementFromPoint$1(child4, coords, rect);
          }
        }
      }
      if ((i2 = (i2 + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords$1(view, coords) {
  var assign2, assign$12;
  var root2 = view.root, node5, offset2;
  if (root2.caretPositionFromPoint) {
    try {
      var pos$1 = root2.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign2 = pos$1, node5 = assign2.offsetNode, offset2 = assign2.offset;
      }
    } catch (_2) {
    }
  }
  if (!node5 && root2.caretRangeFromPoint) {
    var range = root2.caretRangeFromPoint(coords.left, coords.top);
    if (range) {
      assign$12 = range, node5 = assign$12.startContainer, offset2 = assign$12.startOffset;
    }
  }
  var elt = root2.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect$1(coords, box)) {
      return null;
    }
    elt = elementFromPoint$1(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result$1.safari) {
    for (var p2 = elt; node5 && p2; p2 = parentNode$1(p2)) {
      if (p2.draggable) {
        node5 = offset2 = null;
      }
    }
  }
  elt = targetKludge$1(elt, coords);
  if (node5) {
    if (result$1.gecko && node5.nodeType == 1) {
      offset2 = Math.min(offset2, node5.childNodes.length);
      if (offset2 < node5.childNodes.length) {
        var next = node5.childNodes[offset2], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset2++;
        }
      }
    }
    if (node5 == view.dom && offset2 == node5.childNodes.length - 1 && node5.lastChild.nodeType == 1 && coords.top > node5.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset2 == 0 || node5.nodeType != 1 || node5.childNodes[offset2 - 1].nodeName != "BR") {
      pos = posFromCaret$1(view, node5, offset2, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement$1(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect$1(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
var BIDI$1 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos$1(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node5 = ref.node;
  var offset2 = ref.offset;
  var supportEmptyRange = result$1.webkit || result$1.gecko;
  if (node5.nodeType == 3) {
    if (supportEmptyRange && (BIDI$1.test(node5.nodeValue) || (side < 0 ? !offset2 : offset2 == node5.nodeValue.length))) {
      var rect = singleRect$1(textRange$1(node5, offset2, offset2), side);
      if (result$1.gecko && offset2 && /\s/.test(node5.nodeValue[offset2 - 1]) && offset2 < node5.nodeValue.length) {
        var rectBefore = singleRect$1(textRange$1(node5, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect$1(textRange$1(node5, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top) {
            return flattenV$1(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect;
    } else {
      var from5 = offset2, to2 = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to2++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node5.nodeValue.length) {
        from5--;
        takeSide = 1;
      } else if (side < 0) {
        from5--;
      } else {
        to2++;
      }
      return flattenV$1(singleRect$1(textRange$1(node5, from5, to2), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset2 && (side < 0 || offset2 == nodeSize$1(node5))) {
      var before2 = node5.childNodes[offset2 - 1];
      if (before2.nodeType == 1) {
        return flattenH$1(before2.getBoundingClientRect(), false);
      }
    }
    if (offset2 < nodeSize$1(node5)) {
      var after2 = node5.childNodes[offset2];
      if (after2.nodeType == 1) {
        return flattenH$1(after2.getBoundingClientRect(), true);
      }
    }
    return flattenH$1(node5.getBoundingClientRect(), side >= 0);
  }
  if (offset2 && (side < 0 || offset2 == nodeSize$1(node5))) {
    var before$1 = node5.childNodes[offset2 - 1];
    var target = before$1.nodeType == 3 ? textRange$1(before$1, nodeSize$1(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) {
      return flattenV$1(singleRect$1(target, 1), false);
    }
  }
  if (offset2 < nodeSize$1(node5)) {
    var after$1 = node5.childNodes[offset2];
    var target$1 = after$1.nodeType == 3 ? textRange$1(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV$1(singleRect$1(target$1, -1), true);
    }
  }
  return flattenV$1(singleRect$1(node5.nodeType == 3 ? textRange$1(node5) : node5, -side), side >= 0);
}
function flattenV$1(rect, left) {
  if (rect.width == 0) {
    return rect;
  }
  var x2 = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
}
function flattenH$1(rect, top2) {
  if (rect.height == 0) {
    return rect;
  }
  var y2 = top2 ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState$1(view, state, f2) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f2();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical$1(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState$1(view, state, function() {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos$1(view, $pos.pos, 1);
    for (var child4 = dom.firstChild; child4; child4 = child4.nextSibling) {
      var boxes = void 0;
      if (child4.nodeType == 1) {
        boxes = child4.getClientRects();
      } else if (child4.nodeType == 3) {
        boxes = textRange$1(child4, 0, child4.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i2 = 0; i2 < boxes.length; i2++) {
        var box = boxes[i2];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL$1 = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal$1(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset2 = $head.parentOffset, atStart2 = !offset2, atEnd2 = offset2 == $head.parent.content.size;
  var sel = getSelection();
  if (!maybeRTL$1.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState$1(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
var cachedState$1 = null, cachedDir$1 = null, cachedResult$1 = false;
function endOfTextblock$1(view, state, dir) {
  if (cachedState$1 == state && cachedDir$1 == dir) {
    return cachedResult$1;
  }
  cachedState$1 = state;
  cachedDir$1 = dir;
  return cachedResult$1 = dir == "up" || dir == "down" ? endOfTextblockVertical$1(view, state, dir) : endOfTextblockHorizontal$1(view, state, dir);
}
var NOT_DIRTY$1 = 0, CHILD_DIRTY$1 = 1, CONTENT_DIRTY$1 = 2, NODE_DIRTY$1 = 3;
var ViewDesc$1 = function ViewDesc(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY$1;
};
var prototypeAccessors$3 = { beforePosition: { configurable: true }, size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true } };
ViewDesc$1.prototype.matchesWidget = function matchesWidget() {
  return false;
};
ViewDesc$1.prototype.matchesMark = function matchesMark() {
  return false;
};
ViewDesc$1.prototype.matchesNode = function matchesNode() {
  return false;
};
ViewDesc$1.prototype.matchesHack = function matchesHack(_nodeName) {
  return false;
};
prototypeAccessors$3.beforePosition.get = function() {
  return false;
};
ViewDesc$1.prototype.parseRule = function parseRule() {
  return null;
};
ViewDesc$1.prototype.stopEvent = function stopEvent() {
  return false;
};
prototypeAccessors$3.size.get = function() {
  var size2 = 0;
  for (var i2 = 0; i2 < this.children.length; i2++) {
    size2 += this.children[i2].size;
  }
  return size2;
};
prototypeAccessors$3.border.get = function() {
  return 0;
};
ViewDesc$1.prototype.destroy = function destroy() {
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i2 = 0; i2 < this.children.length; i2++) {
    this.children[i2].destroy();
  }
};
ViewDesc$1.prototype.posBeforeChild = function posBeforeChild(child4) {
  for (var i2 = 0, pos = this.posAtStart; i2 < this.children.length; i2++) {
    var cur = this.children[i2];
    if (cur == child4) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors$3.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors$3.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors$3.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors$3.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc$1.prototype.localPosFromDOM = function localPosFromDOM(dom, offset2, bias) {
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset2 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset2];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd2;
  if (dom == this.dom && this.contentDOM) {
    atEnd2 = offset2 > domIndex$1(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset2 == 0) {
      for (var search3 = dom; ; search3 = search3.parentNode) {
        if (search3 == this.dom) {
          atEnd2 = false;
          break;
        }
        if (search3.parentNode.firstChild != search3) {
          break;
        }
      }
    }
    if (atEnd2 == null && offset2 == dom.childNodes.length) {
      for (var search$12 = dom; ; search$12 = search$12.parentNode) {
        if (search$12 == this.dom) {
          atEnd2 = true;
          break;
        }
        if (search$12.parentNode.lastChild != search$12) {
          break;
        }
      }
    }
  }
  return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
};
ViewDesc$1.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
        first = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc$1.prototype.getDesc = function getDesc(dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this) {
      return desc;
    }
  }
};
ViewDesc$1.prototype.posFromDOM = function posFromDOM(dom, offset2, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset2, bias);
    }
  }
  return -1;
};
ViewDesc$1.prototype.descAt = function descAt(pos) {
  for (var i2 = 0, offset2 = 0; i2 < this.children.length; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (offset2 == pos && end3 != offset2) {
      while (!child4.border && child4.children.length) {
        child4 = child4.children[0];
      }
      return child4;
    }
    if (pos < end3) {
      return child4.descAt(pos - offset2 - child4.border);
    }
    offset2 = end3;
  }
};
ViewDesc$1.prototype.domFromPos = function domFromPos(pos, side) {
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  for (var offset2 = 0, i2 = 0, first = true; ; i2++, first = false) {
    while (i2 < this.children.length && (this.children[i2].beforePosition || this.children[i2].dom.parentNode != this.contentDOM)) {
      offset2 += this.children[i2++].size;
    }
    var child4 = i2 == this.children.length ? null : this.children[i2];
    if (offset2 == pos && (side == 0 || !child4 || !child4.size || child4.border || side < 0 && first) || child4 && child4.domAtom && pos < offset2 + child4.size) {
      return {
        node: this.contentDOM,
        offset: child4 ? domIndex$1(child4.dom) : this.contentDOM.childNodes.length
      };
    }
    if (!child4) {
      throw new Error("Invalid position " + pos);
    }
    var end3 = offset2 + child4.size;
    if (!child4.domAtom && (side < 0 && !child4.border ? end3 >= pos : end3 > pos) && (end3 > pos || i2 + 1 >= this.children.length || !this.children[i2 + 1].beforePosition)) {
      return child4.domFromPos(pos - offset2 - child4.border, side);
    }
    offset2 = end3;
  }
};
ViewDesc$1.prototype.parseRange = function parseRange(from5, to2, base2) {
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from5, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset2 = base2, i2 = 0; ; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (fromOffset == -1 && from5 <= end3) {
      var childBase = offset2 + child4.border;
      if (from5 >= childBase && to2 <= end3 - child4.border && child4.node && child4.contentDOM && this.contentDOM.contains(child4.contentDOM)) {
        return child4.parseRange(from5, to2, childBase);
      }
      from5 = offset2;
      for (var j2 = i2; j2 > 0; j2--) {
        var prev = this.children[j2 - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex$1(prev.dom) + 1;
          break;
        }
        from5 -= prev.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && (end3 > to2 || i2 == this.children.length - 1)) {
      to2 = end3;
      for (var j$1 = i2 + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex$1(next.dom);
          break;
        }
        to2 += next.size;
      }
      if (toOffset == -1) {
        toOffset = this.contentDOM.childNodes.length;
      }
      break;
    }
    offset2 = end3;
  }
  return { node: this.contentDOM, from: from5, to: to2, fromOffset, toOffset };
};
ViewDesc$1.prototype.emptyChildAt = function emptyChildAt(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child4 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child4.size == 0 || child4.emptyChildAt(side);
};
ViewDesc$1.prototype.domAfterPos = function domAfterPos(pos) {
  var ref = this.domFromPos(pos, 0);
  var node5 = ref.node;
  var offset2 = ref.offset;
  if (node5.nodeType != 1 || offset2 == node5.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node5.childNodes[offset2];
};
ViewDesc$1.prototype.setSelection = function setSelection(anchor2, head, root2, force) {
  var from5 = Math.min(anchor2, head), to2 = Math.max(anchor2, head);
  for (var i2 = 0, offset2 = 0; i2 < this.children.length; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (from5 > offset2 && to2 < end3) {
      return child4.setSelection(anchor2 - offset2 - child4.border, head - offset2 - child4.border, root2, force);
    }
    offset2 = end3;
  }
  var anchorDOM = this.domFromPos(anchor2, anchor2 ? -1 : 1);
  var headDOM = head == anchor2 ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root2.getSelection();
  var brKludge = false;
  if ((result$1.gecko || result$1.safari) && anchor2 == head) {
    var node5 = anchorDOM.node;
    var offset$1 = anchorDOM.offset;
    if (node5.nodeType == 3) {
      brKludge = offset$1 && node5.nodeValue[offset$1 - 1] == "\n";
      if (brKludge && offset$1 == node5.nodeValue.length) {
        for (var scan = node5, after2 = void 0; scan; scan = scan.parentNode) {
          if (after2 = scan.nextSibling) {
            if (after2.nodeName == "BR") {
              anchorDOM = headDOM = { node: after2.parentNode, offset: domIndex$1(after2) + 1 };
            }
            break;
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) {
            break;
          }
        }
      }
    } else {
      var prev = node5.childNodes[offset$1 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  if (result$1.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") {
      force = true;
    }
  }
  if (!(force || brKludge && result$1.safari) && isEquivalentPosition$1(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition$1(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  var domSelExtended = false;
  if ((domSel.extend || anchor2 == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor2 != head) {
        domSel.extend(headDOM.node, headDOM.offset);
      }
      domSelExtended = true;
    } catch (err2) {
      if (!(err2 instanceof DOMException)) {
        throw err2;
      }
    }
  }
  if (!domSelExtended) {
    if (anchor2 > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    var range = document.createRange();
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range);
  }
};
ViewDesc$1.prototype.ignoreMutation = function ignoreMutation(mutation) {
  return !this.contentDOM && mutation.type != "selection";
};
prototypeAccessors$3.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc$1.prototype.markDirty = function markDirty(from5, to2) {
  for (var offset2 = 0, i2 = 0; i2 < this.children.length; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (offset2 == end3 ? from5 <= end3 && to2 >= offset2 : from5 < end3 && to2 > offset2) {
      var startInside = offset2 + child4.border, endInside = end3 - child4.border;
      if (from5 >= startInside && to2 <= endInside) {
        this.dirty = from5 == offset2 || to2 == end3 ? CONTENT_DIRTY$1 : CHILD_DIRTY$1;
        if (from5 == startInside && to2 == endInside && (child4.contentLost || child4.dom.parentNode != this.contentDOM)) {
          child4.dirty = NODE_DIRTY$1;
        } else {
          child4.markDirty(from5 - startInside, to2 - startInside);
        }
        return;
      } else {
        child4.dirty = child4.dom == child4.contentDOM && child4.dom.parentNode == this.contentDOM ? CONTENT_DIRTY$1 : NODE_DIRTY$1;
      }
    }
    offset2 = end3;
  }
  this.dirty = CONTENT_DIRTY$1;
};
ViewDesc$1.prototype.markParentsDirty = function markParentsDirty() {
  var level = 1;
  for (var node5 = this.parent; node5; node5 = node5.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY$1 : CHILD_DIRTY$1;
    if (node5.dirty < dirty) {
      node5.dirty = dirty;
    }
  }
};
prototypeAccessors$3.domAtom.get = function() {
  return false;
};
Object.defineProperties(ViewDesc$1.prototype, prototypeAccessors$3);
var nothing$1 = [];
var WidgetViewDesc$1 = /* @__PURE__ */ function(ViewDesc4) {
  function WidgetViewDesc2(parent, widget3, view, pos) {
    var self2, dom = widget3.type.toDOM;
    if (typeof dom == "function") {
      dom = dom(view, function() {
        if (!self2) {
          return pos;
        }
        if (self2.parent) {
          return self2.parent.posBeforeChild(self2);
        }
      });
    }
    if (!widget3.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc4.call(this, parent, nothing$1, dom, null);
    this.widget = widget3;
    self2 = this;
  }
  if (ViewDesc4)
    WidgetViewDesc2.__proto__ = ViewDesc4;
  WidgetViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { beforePosition: { configurable: true }, domAtom: { configurable: true } };
  prototypeAccessors$12.beforePosition.get = function() {
    return this.widget.type.side < 0;
  };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget3(widget3) {
    return this.dirty == NOT_DIRTY$1 && widget3.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    var stop3 = this.widget.spec.stopEvent;
    return stop3 ? stop3(event) : false;
  };
  WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  };
  prototypeAccessors$12.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc$1);
var CompositionViewDesc$1 = /* @__PURE__ */ function(ViewDesc4) {
  function CompositionViewDesc2(parent, dom, textDOM, text3) {
    ViewDesc4.call(this, parent, nothing$1, dom, null);
    this.textDOM = textDOM;
    this.text = text3;
  }
  if (ViewDesc4)
    CompositionViewDesc2.__proto__ = ViewDesc4;
  CompositionViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
  var prototypeAccessors$22 = { size: { configurable: true } };
  prototypeAccessors$22.size.get = function() {
    return this.text.length;
  };
  CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM3(dom, offset2) {
    if (dom != this.textDOM) {
      return this.posAtStart + (offset2 ? this.size : 0);
    }
    return this.posAtStart + offset2;
  };
  CompositionViewDesc2.prototype.domFromPos = function domFromPos3(pos) {
    return { node: this.textDOM, offset: pos };
  };
  CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  };
  Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
  return CompositionViewDesc2;
}(ViewDesc$1);
var MarkViewDesc$1 = /* @__PURE__ */ function(ViewDesc4) {
  function MarkViewDesc2(parent, mark3, dom, contentDOM) {
    ViewDesc4.call(this, parent, [], dom, contentDOM);
    this.mark = mark3;
  }
  if (ViewDesc4)
    MarkViewDesc2.__proto__ = ViewDesc4;
  MarkViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create7(parent, mark3, inline3, view) {
    var custom = view.nodeViews[mark3.type.name];
    var spec = custom && custom(mark3, view, inline3);
    if (!spec || !spec.dom) {
      spec = DOMSerializer.renderSpec(document, mark3.type.spec.toDOM(mark3, inline3));
    }
    return new MarkViewDesc2(parent, mark3, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule3() {
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark3(mark3) {
    return this.dirty != NODE_DIRTY$1 && this.mark.eq(mark3);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty3(from5, to2) {
    ViewDesc4.prototype.markDirty.call(this, from5, to2);
    if (this.dirty != NOT_DIRTY$1) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY$1;
    }
  };
  MarkViewDesc2.prototype.slice = function slice5(from5, to2, view) {
    var copy6 = MarkViewDesc2.create(this.parent, this.mark, true, view);
    var nodes2 = this.children, size2 = this.size;
    if (to2 < size2) {
      nodes2 = replaceNodes$1(nodes2, to2, size2, view);
    }
    if (from5 > 0) {
      nodes2 = replaceNodes$1(nodes2, 0, from5, view);
    }
    for (var i2 = 0; i2 < nodes2.length; i2++) {
      nodes2[i2].parent = copy6;
    }
    copy6.children = nodes2;
    return copy6;
  };
  return MarkViewDesc2;
}(ViewDesc$1);
var NodeViewDesc$1 = /* @__PURE__ */ function(ViewDesc4) {
  function NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, view, pos) {
    ViewDesc4.call(this, parent, node5.isLeaf ? nothing$1 : [], dom, contentDOM);
    this.nodeDOM = nodeDOM3;
    this.node = node5;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view, pos);
    }
  }
  if (ViewDesc4)
    NodeViewDesc2.__proto__ = ViewDesc4;
  NodeViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$32 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
  NodeViewDesc2.create = function create7(parent, node5, outerDeco, innerDeco, view, pos) {
    var assign2;
    var custom = view.nodeViews[node5.type.name], descObj;
    var spec = custom && custom(node5, view, function() {
      if (!descObj) {
        return pos;
      }
      if (descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco, innerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node5.isText) {
      if (!dom) {
        dom = document.createTextNode(node5.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      assign2 = DOMSerializer.renderSpec(document, node5.type.spec.toDOM(node5)), dom = assign2.dom, contentDOM = assign2.contentDOM;
    }
    if (!contentDOM && !node5.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable")) {
        dom.contentEditable = false;
      }
      if (node5.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM3 = dom;
    dom = applyOuterDeco$1(dom, outerDeco, node5);
    if (spec) {
      return descObj = new CustomNodeViewDesc$1(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, spec, view, pos + 1);
    } else if (node5.isText) {
      return new TextViewDesc$1(parent, node5, outerDeco, innerDeco, dom, nodeDOM3, view);
    } else {
      return new NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, view, pos + 1);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule3() {
    var this$1$1 = this;
    if (this.node.type.spec.reparseInView) {
      return null;
    }
    var rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.spec.code) {
      rule.preserveWhitespace = "full";
    }
    if (this.contentDOM && !this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      rule.getContent = function() {
        return this$1$1.contentDOM ? Fragment.empty : this$1$1.node.content;
      };
    }
    return rule;
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode3(node5, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY$1 && node5.eq(this.node) && sameOuterDeco$1(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$32.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$32.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
    var this$1$1 = this;
    var inline3 = this.node.inlineContent, off = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater$1(this, localComposition && localComposition.node);
    iterDeco$1(this.node, this.innerDeco, function(widget3, i2, insideNode) {
      if (widget3.spec.marks) {
        updater.syncToMarks(widget3.spec.marks, inline3, view);
      } else if (widget3.type.side >= 0 && !insideNode) {
        updater.syncToMarks(i2 == this$1$1.node.childCount ? Mark.none : this$1$1.node.child(i2).marks, inline3, view);
      }
      updater.placeWidget(widget3, view, off);
    }, function(child4, outerDeco, innerDeco, i2) {
      updater.syncToMarks(child4.marks, inline3, view);
      var compIndex;
      if (updater.findNodeMatch(child4, outerDeco, innerDeco, i2))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child4.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child4, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child4, outerDeco, innerDeco, view, i2))
        ;
      else {
        updater.addNode(child4, outerDeco, innerDeco, view, off);
      }
      off += child4.nodeSize;
    });
    updater.syncToMarks(nothing$1, inline3, view);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY$1) {
      if (localComposition) {
        this.protectLocalComposition(view, localComposition);
      }
      renderDescs$1(this.contentDOM, this.children, view);
      if (result$1.ios) {
        iosHacks$1(this.dom);
      }
    }
  };
  NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
    var ref = view.state.selection;
    var from5 = ref.from;
    var to2 = ref.to;
    if (!(view.state.selection instanceof TextSelection) || from5 < pos || to2 > pos + this.node.content.size) {
      return;
    }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode$1(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) {
      return;
    }
    if (this.node.inlineContent) {
      var text3 = textNode.nodeValue;
      var textPos = findTextInFragment$1(this.node.content, text3, from5 - pos, to2 - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
    } else {
      return { node: textNode, pos: -1 };
    }
  };
  NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
    var node5 = ref.node;
    var pos = ref.pos;
    var text3 = ref.text;
    if (this.getDesc(node5)) {
      return;
    }
    var topNode = node5;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) {
        break;
      }
      while (topNode.previousSibling) {
        topNode.parentNode.removeChild(topNode.previousSibling);
      }
      while (topNode.nextSibling) {
        topNode.parentNode.removeChild(topNode.nextSibling);
      }
      if (topNode.pmViewDesc) {
        topNode.pmViewDesc = null;
      }
    }
    var desc = new CompositionViewDesc$1(this, topNode, node5, text3);
    view.compositionNodes.push(desc);
    this.children = replaceNodes$1(this.children, pos, pos + text3.length, view, desc);
  };
  NodeViewDesc2.prototype.update = function update4(node5, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY$1 || !node5.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node5, outerDeco, innerDeco, view);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node5, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node5;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view, this.posAtStart);
    }
    this.dirty = NOT_DIRTY$1;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco$1(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco$1(this.dom, this.nodeDOM, computeOuterDeco$1(this.outerDeco, this.node, needsWrap), computeOuterDeco$1(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.draggable = true;
    }
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.removeAttribute("draggable");
    }
  };
  prototypeAccessors$32.domAtom.get = function() {
    return this.node.isAtom;
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$32);
  return NodeViewDesc2;
}(ViewDesc$1);
function docViewDesc$1(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco$1(dom, outerDeco, doc2);
  return new NodeViewDesc$1(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
var TextViewDesc$1 = /* @__PURE__ */ function(NodeViewDesc2) {
  function TextViewDesc2(parent, node5, outerDeco, innerDeco, dom, nodeDOM3, view) {
    NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, null, nodeDOM3, view);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  var prototypeAccessors$42 = { domAtom: { configurable: true } };
  TextViewDesc2.prototype.parseRule = function parseRule3() {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) {
      skip = skip.parentNode;
    }
    return { skip: skip || true };
  };
  TextViewDesc2.prototype.update = function update4(node5, outerDeco, _2, view) {
    if (this.dirty == NODE_DIRTY$1 || this.dirty != NOT_DIRTY$1 && !this.inParent() || !node5.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY$1 || node5.text != this.node.text) && node5.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node5.text;
      if (view.trackWrites == this.nodeDOM) {
        view.trackWrites = null;
      }
    }
    this.node = node5;
    this.dirty = NOT_DIRTY$1;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n2 = this.nodeDOM; n2; n2 = n2.parentNode) {
      if (n2 == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos3(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM3(dom, offset2, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset2, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  };
  TextViewDesc2.prototype.slice = function slice5(from5, to2, view) {
    var node5 = this.node.cut(from5, to2), dom = document.createTextNode(node5.text);
    return new TextViewDesc2(this.parent, node5, this.outerDeco, this.innerDeco, dom, dom, view);
  };
  TextViewDesc2.prototype.markDirty = function markDirty3(from5, to2) {
    NodeViewDesc2.prototype.markDirty.call(this, from5, to2);
    if (this.dom != this.nodeDOM && (from5 == 0 || to2 == this.nodeDOM.nodeValue.length)) {
      this.dirty = NODE_DIRTY$1;
    }
  };
  prototypeAccessors$42.domAtom.get = function() {
    return false;
  };
  Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$42);
  return TextViewDesc2;
}(NodeViewDesc$1);
var TrailingHackViewDesc$1 = /* @__PURE__ */ function(ViewDesc4) {
  function TrailingHackViewDesc2() {
    ViewDesc4.apply(this, arguments);
  }
  if (ViewDesc4)
    TrailingHackViewDesc2.__proto__ = ViewDesc4;
  TrailingHackViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
  var prototypeAccessors$52 = { domAtom: { configurable: true } };
  TrailingHackViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  TrailingHackViewDesc2.prototype.matchesHack = function matchesHack3(nodeName) {
    return this.dirty == NOT_DIRTY$1 && this.dom.nodeName == nodeName;
  };
  prototypeAccessors$52.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$52);
  return TrailingHackViewDesc2;
}(ViewDesc$1);
var CustomNodeViewDesc$1 = /* @__PURE__ */ function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, spec, view, pos) {
    NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, view, pos);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update4(node5, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY$1) {
      return false;
    }
    if (this.spec.update) {
      var result2 = this.spec.update(node5, outerDeco, innerDeco);
      if (result2) {
        this.updateInner(node5, outerDeco, innerDeco, view);
      }
      return result2;
    } else if (!this.contentDOM && !node5.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node5, outerDeco, innerDeco, view);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection3(anchor2, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor2, head, root2) : NodeViewDesc2.prototype.setSelection.call(this, anchor2, head, root2, force);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy5() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc$1);
function renderDescs$1(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i2 = 0; i2 < descs.length; i2++) {
    var desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm$1(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc$1) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs$1(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm$1(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel$1(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel$1.prototype = Object.create(null);
var noDeco$1 = [new OuterDecoLevel$1()];
function computeOuterDeco$1(outerDeco, node5, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco$1;
  }
  var top2 = needsWrap ? noDeco$1[0] : new OuterDecoLevel$1(), result2 = [top2];
  for (var i2 = 0; i2 < outerDeco.length; i2++) {
    var attrs = outerDeco[i2].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top2 = new OuterDecoLevel$1(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top2 = new OuterDecoLevel$1(node5.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top2.class = (top2.class ? top2.class + " " : "") + val;
      } else if (name == "style") {
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top2[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco$1(outerDOM, nodeDOM3, prevComputed, curComputed) {
  if (prevComputed == noDeco$1 && curComputed == noDeco$1) {
    return nodeDOM3;
  }
  var curDOM = nodeDOM3;
  for (var i2 = 0; i2 < curComputed.length; i2++) {
    var deco = curComputed[i2], prev = prevComputed[i2];
    if (i2) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco$1[0];
        curDOM = parent;
      }
    }
    patchAttributes$1(curDOM, prev || noDeco$1[0], deco);
  }
  return curDOM;
}
function patchAttributes$1(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing$1;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing$1;
    for (var i2 = 0; i2 < prevList.length; i2++) {
      if (curList.indexOf(prevList[i2]) == -1) {
        dom.classList.remove(prevList[i2]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev.style)) {
        dom.style.removeProperty(m2[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco$1(dom, deco, node5) {
  return patchOuterDeco$1(dom, dom, noDeco$1, computeOuterDeco$1(deco, node5, dom.nodeType != 1));
}
function sameOuterDeco$1(a2, b2) {
  if (a2.length != b2.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].type.eq(b2[i2].type)) {
      return false;
    }
  }
  return true;
}
function rm$1(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater$1 = function ViewTreeUpdater(top2, lockedNode) {
  this.top = top2;
  this.lock = lockedNode;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatch = preMatch$1(top2.node.content, top2.children);
};
ViewTreeUpdater$1.prototype.destroyBetween = function destroyBetween(start4, end3) {
  if (start4 == end3) {
    return;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    this.top.children[i2].destroy();
  }
  this.top.children.splice(start4, end3 - start4);
  this.changed = true;
};
ViewTreeUpdater$1.prototype.destroyRest = function destroyRest() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater$1.prototype.syncToMarks = function syncToMarks(marks3, inline3, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks3.length);
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks3[keep]) && marks3[keep].type.spec.spanning !== false) {
    keep++;
  }
  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY$1;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks3.length) {
    this.stack.push(this.top, this.index + 1);
    var found2 = -1;
    for (var i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
      if (this.top.children[i2].matchesMark(marks3[depth])) {
        found2 = i2;
        break;
      }
    }
    if (found2 > -1) {
      if (found2 > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found2);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc$1.create(this.top, marks3[depth], inline3, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};
ViewTreeUpdater$1.prototype.findNodeMatch = function findNodeMatch(node5, outerDeco, innerDeco, index3) {
  var children = this.top.children, found2 = -1;
  if (index3 >= this.preMatch.index) {
    for (var i2 = this.index; i2 < children.length; i2++) {
      if (children[i2].matchesNode(node5, outerDeco, innerDeco)) {
        found2 = i2;
        break;
      }
    }
  } else {
    for (var i$1 = this.index, e3 = Math.min(children.length, i$1 + 1); i$1 < e3; i$1++) {
      var child4 = children[i$1];
      if (child4.matchesNode(node5, outerDeco, innerDeco) && !this.preMatch.matched.has(child4)) {
        found2 = i$1;
        break;
      }
    }
  }
  if (found2 < 0) {
    return false;
  }
  this.destroyBetween(this.index, found2);
  this.index++;
  return true;
};
ViewTreeUpdater$1.prototype.updateNodeAt = function updateNodeAt(node5, outerDeco, innerDeco, index3, view) {
  var child4 = this.top.children[index3];
  if (!child4.update(node5, outerDeco, innerDeco, view)) {
    return false;
  }
  this.destroyBetween(this.index, index3);
  this.index = index3 + 1;
  return true;
};
ViewTreeUpdater$1.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
  for (; ; ) {
    var parent = domNode.parentNode;
    if (!parent) {
      return -1;
    }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) {
        for (var i2 = this.index; i2 < this.top.children.length; i2++) {
          if (this.top.children[i2] == desc) {
            return i2;
          }
        }
      }
      return -1;
    }
    domNode = parent;
  }
};
ViewTreeUpdater$1.prototype.updateNextNode = function updateNextNode(node5, outerDeco, innerDeco, view, index3) {
  for (var i2 = this.index; i2 < this.top.children.length; i2++) {
    var next = this.top.children[i2];
    if (next instanceof NodeViewDesc$1) {
      var preMatch2 = this.preMatch.matched.get(next);
      if (preMatch2 != null && preMatch2 != index3) {
        return false;
      }
      var nextDOM = next.dom;
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node5.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node5.text && next.dirty != NODE_DIRTY$1 && sameOuterDeco$1(outerDeco, next.outerDeco));
      if (!locked && next.update(node5, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i2);
        if (next.dom != nextDOM) {
          this.changed = true;
        }
        this.index++;
        return true;
      }
      break;
    }
  }
  return false;
};
ViewTreeUpdater$1.prototype.addNode = function addNode(node5, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc$1.create(this.top, node5, outerDeco, innerDeco, view, pos));
  this.changed = true;
};
ViewTreeUpdater$1.prototype.placeWidget = function placeWidget(widget3, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget3) && (widget3 == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc$1(this.top, widget3, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater$1.prototype.addTextblockHacks = function addTextblockHacks() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc$1) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc$1) || /\n$/.test(lastChild.node.text)) {
    if (result$1.safari && lastChild && lastChild.dom.contentEditable == "false") {
      this.addHackNode("IMG");
    }
    this.addHackNode("BR");
  }
};
ViewTreeUpdater$1.prototype.addHackNode = function addHackNode(nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc$1(this.top, nothing$1, dom, null));
    this.changed = true;
  }
};
function preMatch$1(frag, descs) {
  var fI = frag.childCount, dI = descs.length, matched = new Map();
  for (; fI > 0 && dI > 0; dI--) {
    var desc = descs[dI - 1], node5 = desc.node;
    if (!node5) {
      continue;
    }
    if (node5 != frag.child(fI - 1)) {
      break;
    }
    --fI;
    matched.set(desc, fI);
  }
  return { index: fI, matched };
}
function compareSide$1(a2, b2) {
  return a2.type.side - b2.type.side;
}
function iterDeco$1(parent, deco, onWidget, onNode) {
  var locals5 = deco.locals(parent), offset2 = 0;
  if (locals5.length == 0) {
    for (var i2 = 0; i2 < parent.childCount; i2++) {
      var child4 = parent.child(i2);
      onNode(child4, locals5, deco.forChild(offset2, child4), i2);
      offset2 += child4.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
      var widget3 = locals5[decoIndex++], widgets = void 0;
      while (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
        (widgets || (widgets = [widget3])).push(locals5[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide$1);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget3, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index3 = void 0;
    if (restNode) {
      index3 = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset2) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals5.length && locals5[decoIndex].from <= offset2 && locals5[decoIndex].to > offset2) {
      active.push(locals5[decoIndex++]);
    }
    var end3 = offset2 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end3;
      if (decoIndex < locals5.length && locals5[decoIndex].from < cutAt) {
        cutAt = locals5[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end3) {
        restNode = child$1.cut(cutAt - offset2);
        child$1 = child$1.cut(0, cutAt - offset2);
        end3 = cutAt;
        index3 = -1;
      }
    }
    var outerDeco = !active.length ? nothing$1 : child$1.isInline && !child$1.isLeaf ? active.filter(function(d2) {
      return !d2.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset2, child$1), index3);
    offset2 = end3;
  }
}
function iosHacks$1(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode$1(node5, offset2) {
  for (; ; ) {
    if (node5.nodeType == 3) {
      return node5;
    }
    if (node5.nodeType == 1 && offset2 > 0) {
      if (node5.childNodes.length > offset2 && node5.childNodes[offset2].nodeType == 3) {
        return node5.childNodes[offset2];
      }
      node5 = node5.childNodes[offset2 - 1];
      offset2 = nodeSize$1(node5);
    } else if (node5.nodeType == 1 && offset2 < node5.childNodes.length) {
      node5 = node5.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment$1(frag, text3, from5, to2) {
  for (var i2 = 0, pos = 0; i2 < frag.childCount && pos <= to2; ) {
    var child4 = frag.child(i2++), childStart = pos;
    pos += child4.nodeSize;
    if (!child4.isText) {
      continue;
    }
    var str = child4.text;
    while (i2 < frag.childCount) {
      var next = frag.child(i2++);
      pos += next.nodeSize;
      if (!next.isText) {
        break;
      }
      str += next.text;
    }
    if (pos >= from5) {
      var found2 = str.lastIndexOf(text3, to2 - childStart);
      if (found2 >= 0 && found2 + text3.length + childStart >= from5) {
        return childStart + found2;
      }
    }
  }
  return -1;
}
function replaceNodes$1(nodes2, from5, to2, view, replacement) {
  var result2 = [];
  for (var i2 = 0, off = 0; i2 < nodes2.length; i2++) {
    var child4 = nodes2[i2], start4 = off, end3 = off += child4.size;
    if (start4 >= to2 || end3 <= from5) {
      result2.push(child4);
    } else {
      if (start4 < from5) {
        result2.push(child4.slice(0, from5 - start4, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end3 > to2) {
        result2.push(child4.slice(to2 - start4, child4.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM$1(view, origin) {
  var domSel = view.root.getSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc3 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc3 && nearestDesc3.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed$1(domSel)) {
    $anchor = $head;
    while (nearestDesc3 && !nearestDesc3.node) {
      nearestDesc3 = nearestDesc3.parent;
    }
    if (nearestDesc3 && nearestDesc3.node.isAtom && NodeSelection.isSelectable(nearestDesc3.node) && nearestDesc3.parent && !(nearestDesc3.node.isInline && isOnEdge$1(domSel.focusNode, domSel.focusOffset, nearestDesc3.dom))) {
      var pos = nearestDesc3.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor2 = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor2 < 0) {
      return null;
    }
    $anchor = doc2.resolve(anchor2);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween$1(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection$1(view) {
  return view.editable ? view.hasFocus() : hasSelection$1(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM$1(view, force) {
  var sel = view.state.selection;
  syncNodeSelection$1(view, sel);
  if (!editorOwnsSelection$1(view)) {
    return;
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper$1(view);
  } else {
    var anchor2 = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable$1 && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear$1(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear$1(view, sel.to);
      }
    }
    view.docView.setSelection(anchor2, head, view.root, force);
    if (brokenSelectBetweenUneditable$1) {
      if (resetEditableFrom) {
        resetEditable$1(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable$1(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange$1(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable$1 = result$1.safari || result$1.chrome && result$1.chrome_version < 63;
function temporarilyEditableNear$1(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node5 = ref.node;
  var offset2 = ref.offset;
  var after2 = offset2 < node5.childNodes.length ? node5.childNodes[offset2] : null;
  var before2 = offset2 ? node5.childNodes[offset2 - 1] : null;
  if (result$1.safari && after2 && after2.contentEditable == "false") {
    return setEditable$1(after2);
  }
  if ((!after2 || after2.contentEditable == "false") && (!before2 || before2.contentEditable == "false")) {
    if (after2) {
      return setEditable$1(after2);
    } else if (before2) {
      return setEditable$1(before2);
    }
  }
}
function setEditable$1(element) {
  element.contentEditable = "true";
  if (result$1.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable$1(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange$1(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node5 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node5 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection$1(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper$1(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node5 = view.cursorWrapper.dom, img = node5.nodeName == "IMG";
  if (img) {
    range.setEnd(node5.parentNode, domIndex$1(node5) + 1);
  } else {
    range.setEnd(node5, 0);
  }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && result$1.ie && result$1.ie_version <= 11) {
    node5.disabled = true;
    node5.disabled = false;
  }
}
function syncNodeSelection$1(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection$1(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection$1(view);
  }
}
function clearNodeSelection$1(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween$1(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f2) {
    return f2(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection$1(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection$1(view);
}
function hasSelection$1(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace$1(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition$1(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock$1(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply$1(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally$1(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock$1(view.state, dir);
      if (next && next instanceof NodeSelection) {
        return apply$1(view, next);
      }
      return false;
    } else if (!(result$1.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node5 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node5 || node5.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node5.nodeSize : $head.pos;
      if (!(node5.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection.isSelectable(node5)) {
        return apply$1(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node5.nodeSize) : $head));
      } else if (result$1.webkit) {
        return apply$1(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node5.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply$1(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock$1(view.state, dir);
    if (next$1) {
      return apply$1(view, next$1);
    }
    return false;
  }
}
function nodeLen$1(node5) {
  return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
}
function isIgnorable$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft$1(view) {
  var sel = view.root.getSelection();
  var node5 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node5) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result$1.gecko && node5.nodeType == 1 && offset2 < nodeLen$1(node5) && isIgnorable$1(node5.childNodes[offset2])) {
    force = true;
  }
  for (; ; ) {
    if (offset2 > 0) {
      if (node5.nodeType != 1) {
        break;
      } else {
        var before2 = node5.childNodes[offset2 - 1];
        if (isIgnorable$1(before2)) {
          moveNode = node5;
          moveOffset = --offset2;
        } else if (before2.nodeType == 3) {
          node5 = before2;
          offset2 = node5.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode$1(node5)) {
      break;
    } else {
      var prev = node5.previousSibling;
      while (prev && isIgnorable$1(prev)) {
        moveNode = node5.parentNode;
        moveOffset = domIndex$1(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node5 = node5.parentNode;
        if (node5 == view.dom) {
          break;
        }
        offset2 = 0;
      } else {
        node5 = prev;
        offset2 = nodeLen$1(node5);
      }
    }
  }
  if (force) {
    setSelFocus$1(view, sel, node5, offset2);
  } else if (moveNode) {
    setSelFocus$1(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight$1(view) {
  var sel = view.root.getSelection();
  var node5 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node5) {
    return;
  }
  var len = nodeLen$1(node5);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node5.nodeType != 1) {
        break;
      }
      var after2 = node5.childNodes[offset2];
      if (isIgnorable$1(after2)) {
        moveNode = node5;
        moveOffset = ++offset2;
      } else {
        break;
      }
    } else if (isBlockNode$1(node5)) {
      break;
    } else {
      var next = node5.nextSibling;
      while (next && isIgnorable$1(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex$1(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node5 = node5.parentNode;
        if (node5 == view.dom) {
          break;
        }
        offset2 = len = 0;
      } else {
        node5 = next;
        offset2 = 0;
        len = nodeLen$1(node5);
      }
    }
  }
  if (moveNode) {
    setSelFocus$1(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode$1(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus$1(view, sel, node5, offset2) {
  if (selectionCollapsed$1(sel)) {
    var range = document.createRange();
    range.setEnd(node5, offset2);
    range.setStart(node5, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node5, offset2);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM$1(view);
    }
  }, 50);
}
function selectVertically$1(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result$1.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock$1(view.state, dir);
    if (next && next instanceof NodeSelection) {
      return apply$1(view, next);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply$1(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete$1(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return true;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty2 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable$1(view, node5, state) {
  view.domObserver.stop();
  node5.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug$1(view) {
  if (!result$1.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child4 = focusNode.firstChild;
    switchEditable$1(view, child4, true);
    setTimeout(function() {
      return switchEditable$1(view, child4, false);
    }, 20);
  }
}
function getMods$1(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown$1(view, event) {
  var code2 = event.keyCode, mods = getMods$1(event);
  if (code2 == 8 || result$1.mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete$1(view, -1) || skipIgnoredNodesLeft$1(view);
  } else if (code2 == 46 || result$1.mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete$1(view, 1) || skipIgnoredNodesRight$1(view);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37) {
    return selectHorizontally$1(view, -1, mods) || skipIgnoredNodesLeft$1(view);
  } else if (code2 == 39) {
    return selectHorizontally$1(view, 1, mods) || skipIgnoredNodesRight$1(view);
  } else if (code2 == 38) {
    return selectVertically$1(view, -1, mods) || skipIgnoredNodesLeft$1(view);
  } else if (code2 == 40) {
    return safariDownArrowBug$1(view) || selectVertically$1(view, 1, mods) || skipIgnoredNodesRight$1(view);
  } else if (mods == (result$1.mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function parseBetween$1(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from5 = ref.from;
  var to2 = ref.to;
  var domSel = view.root.getSelection(), find4 = null, anchor2 = domSel.anchorNode;
  if (anchor2 && view.dom.contains(anchor2.nodeType == 1 ? anchor2 : anchor2.parentNode)) {
    find4 = [{ node: anchor2, offset: domSel.anchorOffset }];
    if (!selectionCollapsed$1(domSel)) {
      find4.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result$1.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node5 = parent.childNodes[off - 1], desc = node5.pmViewDesc;
      if (node5.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser2 = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from5);
  var sel = null, doc2 = parser2.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find4,
    ruleFromNode: ruleFromNode$1,
    context: $from
  });
  if (find4 && find4[0].pos != null) {
    var anchor$1 = find4[0].pos, head = find4[1] && find4[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from5, head: head + from5 };
  }
  return { doc: doc2, sel, from: from5, to: to2 };
}
function ruleFromNode$1(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result$1.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result$1.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange$1(view, from5, to2, typeOver, addedNodes) {
  if (from5 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM$1(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from5);
  var shared = $before.sharedDepth(to2);
  from5 = $before.before(shared + 1);
  to2 = view.state.doc.resolve(to2).after(shared + 1);
  var sel = view.state.selection;
  var parse4 = parseBetween$1(view, from5, to2);
  if (result$1.chrome && view.cursorWrapper && parse4.sel && parse4.sel.anchor == view.cursorWrapper.deco.from) {
    var text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size2 = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse4.sel = { anchor: parse4.sel.anchor + size2, head: parse4.sel.anchor + size2 };
  }
  var doc2 = view.state.doc, compare = doc2.slice(parse4.from, parse4.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff$1(compare.content, parse4.doc.content, parse4.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse4.sel && parse4.sel.anchor != parse4.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else if ((result$1.ios && view.lastIOSEnter > Date.now() - 225 || result$1.android) && addedNodes.some(function(n2) {
      return n2.nodeName == "DIV" || n2.nodeName == "P";
    }) && view.someProp("handleKeyDown", function(f2) {
      return f2(view, keyEvent$1(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    } else {
      if (parse4.sel) {
        var sel$1 = resolveSelection$1(view, view.state.doc, parse4.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result$1.ie && result$1.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse4.from && parse4.doc.textBetween(change.start - parse4.from - 1, change.start - parse4.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse4.doc.resolveNoCache(change.start - parse4.from);
  var $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result$1.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n2) {
    return n2.nodeName == "DIV" || n2.nodeName == "P";
  })) || !inlineChange && $from.pos < parse4.doc.content.size && (nextSel = Selection.findFrom(parse4.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent$1(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin$1(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent$1(8, "Backspace"));
  })) {
    if (result$1.android && result$1.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result$1.chrome && result$1.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result$1.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse4.sel && parse4.sel.anchor == parse4.sel.head && parse4.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent$1(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result$1.ie && result$1.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM$1(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange$1($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$12 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f2) {
        return f2(view, chFrom, chTo, text$12);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$12, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse4.doc.slice(change.start - parse4.from, change.endB - parse4.from));
  }
  if (parse4.sel) {
    var sel$2 = resolveSelection$1(view, tr.doc, parse4.sel);
    if (sel$2 && !(result$1.chrome && result$1.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result$1.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection$1(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween$1(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange$1(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark3, update4;
  for (var i2 = 0; i2 < prevMarks.length; i2++) {
    added = prevMarks[i2].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark3 = added[0];
    type = "add";
    update4 = function(node5) {
      return node5.mark(mark3.addToSet(node5.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark3 = removed[0];
    type = "remove";
    update4 = function(node5) {
      return node5.mark(mark3.removeFromSet(node5.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
    updated.push(update4(prev.child(i$2)));
  }
  if (Fragment.from(updated).eq(cur)) {
    return { mark: mark3, type };
  }
}
function looksLikeJoin$1(old, start4, end3, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end3 - start4 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening$1($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start4);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening$1($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end3 || skipClosingAndOpening$1($next, true, false) < end3) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening$1($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end3 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end3++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end3++;
    }
  }
  return end3;
}
function findDiff$1(a2, b2, pos, preferredPos, preferredSide) {
  var start4 = a2.findDiffStart(b2, pos);
  if (start4 == null) {
    return null;
  }
  var ref = a2.findDiffEnd(b2, pos + a2.size, pos + b2.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start4 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start4;
  }
  if (endA < start4 && a2.size < b2.size) {
    var move3 = preferredPos <= start4 && preferredPos >= endA ? start4 - preferredPos : 0;
    start4 -= move3;
    endB = start4 + (endB - endA);
    endA = start4;
  } else if (endB < start4) {
    var move$1 = preferredPos <= start4 && preferredPos >= endB ? start4 - preferredPos : 0;
    start4 -= move$1;
    endA = start4 + (endA - endB);
    endB = start4;
  }
  return { start: start4, endA, endB };
}
function serializeForClipboard$1(view, slice5) {
  var context = [];
  var content3 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  while (openStart > 1 && openEnd > 1 && content3.childCount == 1 && content3.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node5 = content3.firstChild;
    context.push(node5.type.name, node5.attrs != node5.type.defaultAttrs ? node5.attrs : null);
    content3 = node5.content;
  }
  var serializer2 = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc2 = detachedDoc$1(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer2.serializeFragment(content3, { document: doc2 }));
  var firstChild = wrap2.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap$1[firstChild.nodeName.toLowerCase()])) {
    for (var i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      var wrapper = doc2.createElement(needsWrap[i2]);
      while (wrap2.firstChild) {
        wrapper.appendChild(wrap2.firstChild);
      }
      wrap2.appendChild(wrapper);
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text3 = view.someProp("clipboardTextSerializer", function(f2) {
    return f2(slice5);
  }) || slice5.content.textBetween(0, slice5.content.size, "\n\n");
  return { dom: wrap2, text: text3 };
}
function parseFromClipboard$1(view, text3, html2, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice5;
  if (!html2 && !text3) {
    return null;
  }
  var asText = text3 && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", function(f2) {
      text3 = f2(text3, inCode || plainText);
    });
    if (inCode) {
      return new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0);
    }
    var parsed = view.someProp("clipboardTextParser", function(f2) {
      return f2(text3, $context, plainText);
    });
    if (parsed) {
      slice5 = parsed;
    } else {
      var marks3 = $context.marks();
      var ref = view.state;
      var schema2 = ref.schema;
      var serializer2 = DOMSerializer.fromSchema(schema2);
      dom = document.createElement("div");
      text3.trim().split(/(?:\r\n?|\n)+/).forEach(function(block) {
        dom.appendChild(document.createElement("p")).appendChild(serializer2.serializeNode(schema2.text(block, marks3)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f2) {
      html2 = f2(html2);
    });
    dom = readHTML$1(html2);
    if (result$1.webkit) {
      restoreReplacedSpaces$1(dom);
    }
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice5) {
    var parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice5 = parser2.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context });
  }
  if (sliceData) {
    slice5 = addContext$1(closeSlice$1(slice5, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice5 = Slice.maxOpen(normalizeSiblings$1(slice5.content, $context), false);
  }
  view.someProp("transformPasted", function(f2) {
    slice5 = f2(slice5);
  });
  return slice5;
}
function normalizeSiblings$1(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop2 = function(d3) {
    var parent = $context.node(d3);
    var match = parent.contentMatchAt($context.index(d3));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node5) {
      if (!result2) {
        return;
      }
      var wrap2 = match.findWrapping(node5.type), inLast;
      if (!wrap2) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling$1(wrap2, lastWrap, node5, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight$1(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers$1(node5, wrap2);
        result2.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap2;
      }
    });
    if (result2) {
      return { v: Fragment.from(result2) };
    }
  };
  for (var d2 = $context.depth; d2 >= 0; d2--) {
    var returned = loop2(d2);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers$1(node5, wrap2, from5) {
  if (from5 === void 0)
    from5 = 0;
  for (var i2 = wrap2.length - 1; i2 >= from5; i2--) {
    node5 = wrap2[i2].create(null, Fragment.from(node5));
  }
  return node5;
}
function addToSibling$1(wrap2, lastWrap, node5, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    var inner = addToSibling$1(wrap2, lastWrap, node5, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node5.type : wrap2[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers$1(node5, wrap2, depth + 1))));
    }
  }
}
function closeRight$1(node5, depth) {
  if (depth == 0) {
    return node5;
  }
  var fragment = node5.content.replaceChild(node5.childCount - 1, closeRight$1(node5.lastChild, depth - 1));
  var fill = node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true);
  return node5.copy(fragment.append(fill));
}
function closeRange$1(fragment, side, from5, to2, depth, openEnd) {
  var node5 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node5.content;
  if (depth < to2 - 1) {
    inner = closeRange$1(inner, side, from5, to2, depth + 1, openEnd);
  }
  if (depth >= from5) {
    inner = side < 0 ? node5.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node5.copy(inner));
}
function closeSlice$1(slice5, openStart, openEnd) {
  if (openStart < slice5.openStart) {
    slice5 = new Slice(closeRange$1(slice5.content, -1, openStart, slice5.openStart, 0, slice5.openEnd), openStart, slice5.openEnd);
  }
  if (openEnd < slice5.openEnd) {
    slice5 = new Slice(closeRange$1(slice5.content, 1, openEnd, slice5.openEnd, 0, 0), slice5.openStart, openEnd);
  }
  return slice5;
}
var wrapMap$1 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc$1 = null;
function detachedDoc$1() {
  return _detachedDoc$1 || (_detachedDoc$1 = document.implementation.createHTMLDocument("title"));
}
function readHTML$1(html2) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas) {
    html2 = html2.slice(metas[0].length);
  }
  var elt = detachedDoc$1().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap$1[firstTag[1].toLowerCase()]) {
    html2 = wrap2.map(function(n2) {
      return "<" + n2 + ">";
    }).join("") + html2 + wrap2.map(function(n2) {
      return "</" + n2 + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html2;
  if (wrap2) {
    for (var i2 = 0; i2 < wrap2.length; i2++) {
      elt = elt.querySelector(wrap2[i2]) || elt;
    }
  }
  return elt;
}
function restoreReplacedSpaces$1(dom) {
  var nodes2 = dom.querySelectorAll(result$1.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i2 = 0; i2 < nodes2.length; i2++) {
    var node5 = nodes2[i2];
    if (node5.childNodes.length == 1 && node5.textContent == "\xA0" && node5.parentNode) {
      node5.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node5);
    }
  }
}
function addContext$1(slice5, context) {
  if (!slice5.size) {
    return slice5;
  }
  var schema2 = slice5.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e3) {
    return slice5;
  }
  var content3 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  for (var i2 = array.length - 2; i2 >= 0; i2 -= 2) {
    var type = schema2.nodes[array[i2]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content3 = Fragment.from(type.create(array[i2 + 1], content3));
    openStart++;
    openEnd++;
  }
  return new Slice(content3, openStart, openEnd);
}
var observeOptions$1 = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData$1 = result$1.ie && result$1.ie_version <= 11;
var SelectionState$1 = function SelectionState() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};
SelectionState$1.prototype.set = function set(sel) {
  this.anchorNode = sel.anchorNode;
  this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode;
  this.focusOffset = sel.focusOffset;
};
SelectionState$1.prototype.eq = function eq6(sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
};
var DOMObserver$1 = function DOMObserver(view, handleDOMChange) {
  var this$1$1 = this;
  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      this$1$1.queue.push(mutations[i2]);
    }
    if (result$1.ie && result$1.ie_version <= 11 && mutations.some(function(m2) {
      return m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length;
    })) {
      this$1$1.flushSoon();
    } else {
      this$1$1.flush();
    }
  });
  this.currentSelection = new SelectionState$1();
  if (useCharData$1) {
    this.onCharData = function(e3) {
      this$1$1.queue.push({ target: e3.target, type: "characterData", oldValue: e3.prevValue });
      this$1$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};
DOMObserver$1.prototype.flushSoon = function flushSoon() {
  var this$1$1 = this;
  if (this.flushingSoon < 0) {
    this.flushingSoon = window.setTimeout(function() {
      this$1$1.flushingSoon = -1;
      this$1$1.flush();
    }, 20);
  }
};
DOMObserver$1.prototype.forceFlush = function forceFlush() {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};
DOMObserver$1.prototype.start = function start2() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions$1);
  }
  if (useCharData$1) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.connectSelection();
};
DOMObserver$1.prototype.stop = function stop() {
  var this$1$1 = this;
  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i2 = 0; i2 < take.length; i2++) {
        this.queue.push(take[i2]);
      }
      window.setTimeout(function() {
        return this$1$1.flush();
      }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData$1) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.disconnectSelection();
};
DOMObserver$1.prototype.connectSelection = function connectSelection() {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver$1.prototype.disconnectSelection = function disconnectSelection() {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver$1.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
  var this$1$1 = this;
  this.suppressingSelectionUpdates = true;
  setTimeout(function() {
    return this$1$1.suppressingSelectionUpdates = false;
  }, 50);
};
DOMObserver$1.prototype.onSelectionChange = function onSelectionChange() {
  if (!hasFocusAndSelection$1(this.view)) {
    return;
  }
  if (this.suppressingSelectionUpdates) {
    return selectionToDOM$1(this.view);
  }
  if (result$1.ie && result$1.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    if (sel.focusNode && isEquivalentPosition$1(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
      return this.flushSoon();
    }
  }
  this.flush();
};
DOMObserver$1.prototype.setCurSelection = function setCurSelection() {
  this.currentSelection.set(this.view.root.getSelection());
};
DOMObserver$1.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
  if (sel.rangeCount == 0) {
    return true;
  }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
    this.setCurSelection();
    return true;
  }
};
DOMObserver$1.prototype.flush = function flush() {
  if (!this.view.docView || this.flushingSoon > -1) {
    return;
  }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }
  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection$1(this.view) && !this.ignoreSelectionChange(sel);
  var from5 = -1, to2 = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      var result$1$1 = this.registerMutation(mutations[i2], added);
      if (result$1$1) {
        from5 = from5 < 0 ? result$1$1.from : Math.min(result$1$1.from, from5);
        to2 = to2 < 0 ? result$1$1.to : Math.max(result$1$1.to, to2);
        if (result$1$1.typeOver) {
          typeOver = true;
        }
      }
    }
  }
  if (result$1.gecko && added.length > 1) {
    var brs = added.filter(function(n2) {
      return n2.nodeName == "BR";
    });
    if (brs.length == 2) {
      var a2 = brs[0];
      var b2 = brs[1];
      if (a2.parentNode && a2.parentNode.parentNode == b2.parentNode) {
        b2.remove();
      } else {
        a2.remove();
      }
    }
  }
  if (from5 > -1 || newSel) {
    if (from5 > -1) {
      this.view.docView.markDirty(from5, to2);
      checkCSS$1(this.view);
    }
    this.handleDOMChange(from5, to2, typeOver, added);
    if (this.view.docView.dirty) {
      this.view.updateState(this.view.state);
    } else if (!this.currentSelection.eq(sel)) {
      selectionToDOM$1(this.view);
    }
    this.currentSelection.set(sel);
  }
};
DOMObserver$1.prototype.registerMutation = function registerMutation(mut, added) {
  if (added.indexOf(mut.target) > -1) {
    return null;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
    return null;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return null;
  }
  if (mut.type == "childList") {
    for (var i2 = 0; i2 < mut.addedNodes.length; i2++) {
      added.push(mut.addedNodes[i2]);
    }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
      return { from: desc.posBefore, to: desc.posAfter };
    }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result$1.ie && result$1.ie_version <= 11 && mut.addedNodes.length) {
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref = mut.addedNodes[i$1];
        var previousSibling = ref.previousSibling;
        var nextSibling = ref.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
          prev = previousSibling;
        }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
          next = nextSibling;
        }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target ? domIndex$1(prev) + 1 : 0;
    var from5 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target ? domIndex$1(next) : mut.target.childNodes.length;
    var to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
    return { from: from5, to: to2 };
  } else if (mut.type == "attributes") {
    return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
  } else {
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      typeOver: mut.target.nodeValue == mut.oldValue
    };
  }
};
var cssChecked$1 = false;
function checkCSS$1(view) {
  if (cssChecked$1) {
    return;
  }
  cssChecked$1 = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
var handlers$1 = {}, editHandlers$1 = {};
function initInput$1(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver$1(view, function(from5, to2, typeOver, added) {
    return readDOMChange$1(view, from5, to2, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = Object.create(null);
  var loop2 = function(event2) {
    var handler = handlers$1[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView$1(view, event3) && !runCustomHandler$1(view, event3) && (view.editable || !(event3.type in editHandlers$1))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers$1)
    loop2(event);
  if (result$1.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners$1(view);
}
function setSelectionOrigin$1(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput$1(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers) {
    view.dom.removeEventListener(type, view.eventHandlers[type]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners$1(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.eventHandlers[type]) {
        view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
          return runCustomHandler$1(view, event);
        });
      }
    }
  });
}
function runCustomHandler$1(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView$1(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node5 = event.target; node5 != view.dom; node5 = node5.parentNode) {
    if (!node5 || node5.nodeType == 11 || node5.pmViewDesc && node5.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent$2(view, event) {
  if (!runCustomHandler$1(view, event) && handlers$1[event.type] && (view.editable || !(event.type in editHandlers$1))) {
    handlers$1[event.type](view, event);
  }
}
editHandlers$1.keydown = function(view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition$1(view, event)) {
    return;
  }
  if (event.keyCode != 229) {
    view.domObserver.forceFlush();
  }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  if (result$1.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now3 = Date.now();
    view.lastIOSEnter = now3;
    view.lastIOSEnterFallbackTimeout = setTimeout(function() {
      if (view.lastIOSEnter == now3) {
        view.someProp("handleKeyDown", function(f2) {
          return f2(view, keyEvent$1(13, "Enter"));
        });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function(f2) {
    return f2(view, event);
  }) || captureKeyDown$1(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin$1(view, "key");
  }
};
editHandlers$1.keyup = function(view, e3) {
  if (e3.keyCode == 16) {
    view.shiftKey = false;
  }
};
editHandlers$1.keypress = function(view, event) {
  if (inOrNearComposition$1(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result$1.mac && event.metaKey) {
    return;
  }
  if (view.someProp("handleKeyPress", function(f2) {
    return f2(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function(f2) {
      return f2(view, sel.$from.pos, sel.$to.pos, text3);
    })) {
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords$1(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear$1(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext$1(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop2 = function(i3) {
    if (view.someProp(propName, function(f2) {
      return i3 > $pos.depth ? f2(view, pos, $pos.nodeAfter, $pos.before(i3), event, true) : f2(view, pos, $pos.node(i3), $pos.before(i3), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var returned = loop2(i2);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection$1(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf$1(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node5 = $pos.nodeAfter;
  if (node5 && node5.isAtom && NodeSelection.isSelectable(node5)) {
    updateSelection$1(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode$1(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node5 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node5)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i2);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection$1(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick$1(view, pos, inside, event, selectNode) {
  return runHandlerOnContext$1(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f2) {
    return f2(view, pos, event);
  }) || (selectNode ? selectClickedNode$1(view, inside) : selectClickedLeaf$1(view, inside));
}
function handleDoubleClick$1(view, pos, inside, event) {
  return runHandlerOnContext$1(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f2) {
    return f2(view, pos, event);
  });
}
function handleTripleClick$2(view, pos, inside, event) {
  return runHandlerOnContext$1(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f2) {
    return f2(view, pos, event);
  }) || defaultTripleClick$1(view, inside, event);
}
function defaultTripleClick$1(view, inside, event) {
  if (event.button != 0) {
    return false;
  }
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection$1(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node5 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    var nodePos = $pos.before(i2);
    if (node5.inlineContent) {
      updateSelection$1(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node5.content.size), "pointer");
    } else if (NodeSelection.isSelectable(node5)) {
      updateSelection$1(view, NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush$1(view) {
  return endComposition$1(view);
}
var selectNodeModifier$1 = result$1.mac ? "metaKey" : "ctrlKey";
handlers$1.mousedown = function(view, event) {
  view.shiftKey = event.shiftKey;
  var flushed2 = forceDOMFlush$1(view);
  var now3 = Date.now(), type = "singleClick";
  if (now3 - view.lastClick.time < 500 && isNear$1(event, view.lastClick) && !event[selectNodeModifier$1]) {
    if (view.lastClick.type == "singleClick") {
      type = "doubleClick";
    } else if (view.lastClick.type == "doubleClick") {
      type = "tripleClick";
    }
  }
  view.lastClick = { time: now3, x: event.clientX, y: event.clientY, type };
  var pos = view.posAtCoords(eventCoords$1(event));
  if (!pos) {
    return;
  }
  if (type == "singleClick") {
    if (view.mouseDown) {
      view.mouseDown.done();
    }
    view.mouseDown = new MouseDown$1(view, pos, event, flushed2);
  } else if ((type == "doubleClick" ? handleDoubleClick$1 : handleTripleClick$2)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin$1(view, "pointer");
  }
};
var MouseDown$1 = function MouseDown(view, pos, event, flushed2) {
  var this$1$1 = this;
  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed2;
  this.selectNode = event[selectNodeModifier$1];
  this.allowDefault = event.shiftKey;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  var target = flushed2 ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;
  var ref = view.state;
  var selection = ref.selection;
  if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result$1.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        if (this$1$1.view.mouseDown == this$1$1) {
          this$1$1.target.setAttribute("contentEditable", "false");
        }
      }, 20);
    }
    this.view.domObserver.start();
  }
  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin$1(view, "pointer");
};
MouseDown$1.prototype.done = function done() {
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.removeAttribute("draggable");
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  this.view.mouseDown = null;
};
MouseDown$1.prototype.up = function up(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) {
    pos = this.view.posAtCoords(eventCoords$1(event));
  }
  if (this.allowDefault || !pos) {
    setSelectionOrigin$1(this.view, "pointer");
  } else if (handleSingleClick$1(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 && (this.flushed || result$1.safari && this.mightDrag && !this.mightDrag.node.isAtom || result$1.chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
    updateSelection$1(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin$1(this.view, "pointer");
  }
};
MouseDown$1.prototype.move = function move(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  setSelectionOrigin$1(this.view, "pointer");
  if (event.buttons == 0) {
    this.done();
  }
};
handlers$1.touchdown = function(view) {
  forceDOMFlush$1(view);
  setSelectionOrigin$1(view, "pointer");
};
handlers$1.contextmenu = function(view) {
  return forceDOMFlush$1(view);
};
function inOrNearComposition$1(view, event) {
  if (view.composing) {
    return true;
  }
  if (result$1.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition$1 = result$1.android ? 5e3 : -1;
editHandlers$1.compositionstart = editHandlers$1.compositionupdate = function(view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m2) {
      return m2.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition$1(view, true);
      view.markCursor = null;
    } else {
      endComposition$1(view);
      if (result$1.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node5 = sel.focusNode, offset2 = sel.focusOffset; node5 && node5.nodeType == 1 && offset2 != 0; ) {
          var before2 = offset2 < 0 ? node5.lastChild : node5.childNodes[offset2 - 1];
          if (!before2) {
            break;
          }
          if (before2.nodeType == 3) {
            sel.collapse(before2, before2.nodeValue.length);
            break;
          } else {
            node5 = before2;
            offset2 = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd$1(view, timeoutComposition$1);
};
editHandlers$1.compositionend = function(view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd$1(view, 20);
  }
};
function scheduleComposeEnd$1(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition$1(view);
    }, delay);
  }
}
function clearComposition$1(view) {
  view.composing = false;
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function endComposition$1(view, forceUpdate) {
  view.domObserver.forceFlush();
  clearComposition$1(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM$1(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy$1(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    if (wrap2.parentNode) {
      wrap2.parentNode.removeChild(wrap2);
    }
    view.focus();
  }, 50);
}
var brokenClipboardAPI$1 = result$1.ie && result$1.ie_version < 15 || result$1.ios && result$1.webkit_version < 604;
handlers$1.copy = editHandlers$1.cut = function(view, e3) {
  var sel = view.state.selection, cut3 = e3.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI$1 ? null : e3.clipboardData;
  var slice5 = sel.content();
  var ref = serializeForClipboard$1(view, slice5);
  var dom = ref.dom;
  var text3 = ref.text;
  if (data) {
    e3.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy$1(view, dom);
  }
  if (cut3) {
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode$1(slice5) {
  return slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1 ? slice5.content.firstChild : null;
}
function capturePaste$1(view, e3) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view.focus();
    if (target.parentNode) {
      target.parentNode.removeChild(target);
    }
    if (plainText) {
      doPaste$1(view, target.value, null, e3);
    } else {
      doPaste$1(view, target.textContent, target.innerHTML, e3);
    }
  }, 50);
}
function doPaste$1(view, text3, html2, e3) {
  var slice5 = parseFromClipboard$1(view, text3, html2, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f2) {
    return f2(view, e3, slice5 || Slice.empty);
  })) {
    return true;
  }
  if (!slice5) {
    return false;
  }
  var singleNode = sliceSingleNode$1(slice5);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice5);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers$1.paste = function(view, e3) {
  var data = brokenClipboardAPI$1 ? null : e3.clipboardData;
  if (data && doPaste$1(view, data.getData("text/plain"), data.getData("text/html"), e3)) {
    e3.preventDefault();
  } else {
    capturePaste$1(view, e3);
  }
};
var Dragging$1 = function Dragging(slice5, move3) {
  this.slice = slice5;
  this.move = move3;
};
var dragCopyModifier$1 = result$1.mac ? "altKey" : "ctrlKey";
handlers$1.dragstart = function(view, e3) {
  var mouseDown = view.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e3.dataTransfer) {
    return;
  }
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords$1(e3));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e3.target && e3.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e3.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) {
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
    }
  }
  var slice5 = view.state.selection.content();
  var ref = serializeForClipboard$1(view, slice5);
  var dom = ref.dom;
  var text3 = ref.text;
  e3.dataTransfer.clearData();
  e3.dataTransfer.setData(brokenClipboardAPI$1 ? "Text" : "text/html", dom.innerHTML);
  e3.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI$1) {
    e3.dataTransfer.setData("text/plain", text3);
  }
  view.dragging = new Dragging$1(slice5, !e3[dragCopyModifier$1]);
};
handlers$1.dragend = function(view) {
  var dragging = view.dragging;
  window.setTimeout(function() {
    if (view.dragging == dragging) {
      view.dragging = null;
    }
  }, 50);
};
editHandlers$1.dragover = editHandlers$1.dragenter = function(_2, e3) {
  return e3.preventDefault();
};
editHandlers$1.drop = function(view, e3) {
  var dragging = view.dragging;
  view.dragging = null;
  if (!e3.dataTransfer) {
    return;
  }
  var eventPos = view.posAtCoords(eventCoords$1(e3));
  if (!eventPos) {
    return;
  }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice5 = dragging && dragging.slice;
  if (slice5) {
    view.someProp("transformPasted", function(f2) {
      slice5 = f2(slice5);
    });
  } else {
    slice5 = parseFromClipboard$1(view, e3.dataTransfer.getData(brokenClipboardAPI$1 ? "Text" : "text/plain"), brokenClipboardAPI$1 ? null : e3.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move3 = dragging && !e3[dragCopyModifier$1];
  if (view.someProp("handleDrop", function(f2) {
    return f2(view, e3, slice5 || Slice.empty, move3);
  })) {
    e3.preventDefault();
    return;
  }
  if (!slice5) {
    return;
  }
  e3.preventDefault();
  var insertPos = slice5 ? dropPoint(view.state.doc, $mouse.pos, slice5) : $mouse.pos;
  if (insertPos == null) {
    insertPos = $mouse.pos;
  }
  var tr = view.state.tr;
  if (move3) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode = slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) {
    tr.replaceRangeWith(pos, pos, slice5.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice5);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice5.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice5.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    var end3 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
      return end3 = newTo;
    });
    tr.setSelection(selectionBetween$1(view, $pos, tr.doc.resolve(end3)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers$1.focus = function(view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function() {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
        selectionToDOM$1(view);
      }
    }, 20);
  }
};
handlers$1.blur = function(view) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    view.domObserver.currentSelection.set({});
    view.focused = false;
  }
};
handlers$1.beforeinput = function(view, event) {
  if (result$1.chrome && result$1.android && event.inputType == "deleteContentBackward") {
    var domChangeCount = view.domChangeCount;
    setTimeout(function() {
      if (view.domChangeCount != domChangeCount) {
        return;
      }
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent$1(8, "Backspace"));
      })) {
        return;
      }
      var ref = view.state.selection;
      var $cursor = ref.$cursor;
      if ($cursor && $cursor.pos > 0) {
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }
    }, 50);
  }
};
for (var prop$1 in editHandlers$1) {
  handlers$1[prop$1] = editHandlers$1[prop$1];
}
function compareObjs$1(a2, b2) {
  if (a2 == b2) {
    return true;
  }
  for (var p2 in a2) {
    if (a2[p2] !== b2[p2]) {
      return false;
    }
  }
  for (var p$12 in b2) {
    if (!(p$12 in a2)) {
      return false;
    }
  }
  return true;
}
var WidgetType$1 = function WidgetType(toDOM, spec) {
  this.spec = spec || noSpec$1;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};
WidgetType$1.prototype.map = function map8(mapping, span, offset2, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref.pos;
  var deleted = ref.deleted;
  return deleted ? null : new Decoration$1(pos - offset2, pos - offset2, this);
};
WidgetType$1.prototype.valid = function valid() {
  return true;
};
WidgetType$1.prototype.eq = function eq7(other) {
  return this == other || other instanceof WidgetType$1 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs$1(this.spec, other.spec));
};
var InlineType$1 = function InlineType(attrs, spec) {
  this.spec = spec || noSpec$1;
  this.attrs = attrs;
};
InlineType$1.prototype.map = function map9(mapping, span, offset2, oldOffset) {
  var from5 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
  var to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
  return from5 >= to2 ? null : new Decoration$1(from5, to2, this);
};
InlineType$1.prototype.valid = function valid2(_2, span) {
  return span.from < span.to;
};
InlineType$1.prototype.eq = function eq8(other) {
  return this == other || other instanceof InlineType$1 && compareObjs$1(this.attrs, other.attrs) && compareObjs$1(this.spec, other.spec);
};
InlineType$1.is = function is(span) {
  return span.type instanceof InlineType$1;
};
var NodeType$1 = function NodeType2(attrs, spec) {
  this.spec = spec || noSpec$1;
  this.attrs = attrs;
};
NodeType$1.prototype.map = function map10(mapping, span, offset2, oldOffset) {
  var from5 = mapping.mapResult(span.from + oldOffset, 1);
  if (from5.deleted) {
    return null;
  }
  var to2 = mapping.mapResult(span.to + oldOffset, -1);
  if (to2.deleted || to2.pos <= from5.pos) {
    return null;
  }
  return new Decoration$1(from5.pos - offset2, to2.pos - offset2, this);
};
NodeType$1.prototype.valid = function valid3(node5, span) {
  var ref = node5.content.findIndex(span.from);
  var index3 = ref.index;
  var offset2 = ref.offset;
  return offset2 == span.from && offset2 + node5.child(index3).nodeSize == span.to;
};
NodeType$1.prototype.eq = function eq9(other) {
  return this == other || other instanceof NodeType$1 && compareObjs$1(this.attrs, other.attrs) && compareObjs$1(this.spec, other.spec);
};
var Decoration$1 = function Decoration(from5, to2, type) {
  this.from = from5;
  this.to = to2;
  this.type = type;
};
var prototypeAccessors$1$1 = { spec: { configurable: true }, inline: { configurable: true } };
Decoration$1.prototype.copy = function copy4(from5, to2) {
  return new Decoration$1(from5, to2, this.type);
};
Decoration$1.prototype.eq = function eq10(other, offset2) {
  if (offset2 === void 0)
    offset2 = 0;
  return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
};
Decoration$1.prototype.map = function map11(mapping, offset2, oldOffset) {
  return this.type.map(mapping, this, offset2, oldOffset);
};
Decoration$1.widget = function widget(pos, toDOM, spec) {
  return new Decoration$1(pos, pos, new WidgetType$1(toDOM, spec));
};
Decoration$1.inline = function inline(from5, to2, attrs, spec) {
  return new Decoration$1(from5, to2, new InlineType$1(attrs, spec));
};
Decoration$1.node = function node3(from5, to2, attrs, spec) {
  return new Decoration$1(from5, to2, new NodeType$1(attrs, spec));
};
prototypeAccessors$1$1.spec.get = function() {
  return this.type.spec;
};
prototypeAccessors$1$1.inline.get = function() {
  return this.type instanceof InlineType$1;
};
Object.defineProperties(Decoration$1.prototype, prototypeAccessors$1$1);
var none$1 = [], noSpec$1 = {};
var DecorationSet$1 = function DecorationSet(local, children) {
  this.local = local && local.length ? local : none$1;
  this.children = children && children.length ? children : none$1;
};
DecorationSet$1.create = function create4(doc2, decorations) {
  return decorations.length ? buildTree$1(decorations, doc2, 0, noSpec$1) : empty$1;
};
DecorationSet$1.prototype.find = function find(start4, end3, predicate) {
  var result2 = [];
  this.findInner(start4 == null ? 0 : start4, end3 == null ? 1e9 : end3, result2, 0, predicate);
  return result2;
};
DecorationSet$1.prototype.findInner = function findInner(start4, end3, result2, offset2, predicate) {
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var span = this.local[i2];
    if (span.from <= end3 && span.to >= start4 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset2, span.to + offset2));
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end3 && this.children[i$1 + 1] > start4) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start4 - childOff, end3 - childOff, result2, offset2 + childOff, predicate);
    }
  }
};
DecorationSet$1.prototype.map = function map12(mapping, doc2, options) {
  if (this == empty$1 || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec$1);
};
DecorationSet$1.prototype.mapInner = function mapInner(mapping, node5, offset2, oldOffset, options) {
  var newLocal;
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var mapped = this.local[i2].map(mapping, offset2, oldOffset);
    if (mapped && mapped.type.valid(node5, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this.local[i2].spec);
    }
  }
  if (this.children.length) {
    return mapChildren$1(this.children, newLocal, mapping, node5, offset2, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet$1(newLocal.sort(byPos$1)) : empty$1;
  }
};
DecorationSet$1.prototype.add = function add(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty$1) {
    return DecorationSet$1.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet$1.prototype.addInner = function addInner(doc2, decorations, offset2) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset2, found2;
    if (!(found2 = takeSpansForNode$1(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree$1(found2, childNode, baseOffset + 1, noSpec$1));
    }
    childIndex += 3;
  });
  var local = moveSpans$1(childIndex ? withoutNulls$1(decorations) : decorations, -offset2);
  for (var i2 = 0; i2 < local.length; i2++) {
    if (!local[i2].type.valid(doc2, local[i2])) {
      local.splice(i2--, 1);
    }
  }
  return new DecorationSet$1(local.length ? this.local.concat(local).sort(byPos$1) : this.local, children || this.children);
};
DecorationSet$1.prototype.remove = function remove(decorations) {
  if (decorations.length == 0 || this == empty$1) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet$1.prototype.removeInner = function removeInner(decorations, offset2) {
  var children = this.children, local = this.local;
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    var found2 = void 0, from5 = children[i2] + offset2, to2 = children[i2 + 1] + offset2;
    for (var j2 = 0, span = void 0; j2 < decorations.length; j2++) {
      if (span = decorations[j2]) {
        if (span.from > from5 && span.to < to2) {
          decorations[j2] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this.children) {
      children = this.children.slice();
    }
    var removed = children[i2 + 2].removeInner(found2, from5 + 1);
    if (removed != empty$1) {
      children[i2 + 2] = removed;
    } else {
      children.splice(i2, 3);
      i2 -= 3;
    }
  }
  if (local.length) {
    for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
      if (span$1 = decorations[i$1]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].eq(span$1, offset2)) {
            if (local == this.local) {
              local = this.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet$1(local, children) : empty$1;
};
DecorationSet$1.prototype.forChild = function forChild(offset2, node5) {
  if (this == empty$1) {
    return this;
  }
  if (node5.isLeaf) {
    return DecorationSet$1.empty;
  }
  var child4, local;
  for (var i2 = 0; i2 < this.children.length; i2 += 3) {
    if (this.children[i2] >= offset2) {
      if (this.children[i2] == offset2) {
        child4 = this.children[i2 + 2];
      }
      break;
    }
  }
  var start4 = offset2 + 1, end3 = start4 + node5.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end3 && dec.to > start4 && dec.type instanceof InlineType$1) {
      var from5 = Math.max(start4, dec.from) - start4, to2 = Math.min(end3, dec.to) - start4;
      if (from5 < to2) {
        (local || (local = [])).push(dec.copy(from5, to2));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet$1(local.sort(byPos$1));
    return child4 ? new DecorationGroup$1([localSet, child4]) : localSet;
  }
  return child4 || empty$1;
};
DecorationSet$1.prototype.eq = function eq11(other) {
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet$1) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!this.local[i2].eq(other.local[i2])) {
      return false;
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
      return false;
    }
  }
  return true;
};
DecorationSet$1.prototype.locals = function locals(node5) {
  return removeOverlap$1(this.localsInner(node5));
};
DecorationSet$1.prototype.localsInner = function localsInner(node5) {
  if (this == empty$1) {
    return none$1;
  }
  if (node5.inlineContent || !this.local.some(InlineType$1.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!(this.local[i2].type instanceof InlineType$1)) {
      result2.push(this.local[i2]);
    }
  }
  return result2;
};
var empty$1 = new DecorationSet$1();
DecorationSet$1.empty = empty$1;
DecorationSet$1.removeOverlap = removeOverlap$1;
var DecorationGroup$1 = function DecorationGroup(members) {
  this.members = members;
};
DecorationGroup$1.prototype.forChild = function forChild2(offset2, child4) {
  if (child4.isLeaf) {
    return DecorationSet$1.empty;
  }
  var found2 = [];
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var result2 = this.members[i2].forChild(offset2, child4);
    if (result2 == empty$1) {
      continue;
    }
    if (result2 instanceof DecorationGroup$1) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup$1.from(found2);
};
DecorationGroup$1.prototype.eq = function eq12(other) {
  if (!(other instanceof DecorationGroup$1) || other.members.length != this.members.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.members.length; i2++) {
    if (!this.members[i2].eq(other.members[i2])) {
      return false;
    }
  }
  return true;
};
DecorationGroup$1.prototype.locals = function locals2(node5) {
  var result2, sorted = true;
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var locals5 = this.members[i2].localsInner(node5);
    if (!locals5.length) {
      continue;
    }
    if (!result2) {
      result2 = locals5;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j2 = 0; j2 < locals5.length; j2++) {
        result2.push(locals5[j2]);
      }
    }
  }
  return result2 ? removeOverlap$1(sorted ? result2 : result2.sort(byPos$1)) : none$1;
};
DecorationGroup$1.from = function from2(members) {
  switch (members.length) {
    case 0:
      return empty$1;
    case 1:
      return members[0];
    default:
      return new DecorationGroup$1(members);
  }
};
function mapChildren$1(oldChildren, newLocal, mapping, node5, offset2, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i3 = 0; i3 < children.length; i3 += 3) {
      var end3 = children[i3 + 1], dSize = void 0;
      if (end3 == -1 || oldStart > end3 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i3] + oldOffset) {
        children[i3 + 1] = -1;
      } else if (newStart >= offset2 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i3] += dSize;
        children[i3 + 1] += dSize;
      }
    }
  };
  for (var i2 = 0; i2 < mapping.maps.length; i2++) {
    mapping.maps[i2].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] == -1) {
      var from5 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from5 - offset2;
      if (fromLocal < 0 || fromLocal >= node5.content.size) {
        mustRebuild = true;
        continue;
      }
      var to2 = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to2 - offset2;
      var ref = node5.content.findIndex(fromLocal);
      var index3 = ref.index;
      var childOffset = ref.offset;
      var childNode = node5.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from5 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty$1) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations$1(children, oldChildren, newLocal || [], mapping, offset2, oldOffset, options);
    var built = buildTree$1(decorations, node5, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] < 0) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j2 = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j2 < children.length && children[j2] < from$1) {
        j2 += 3;
      }
      children.splice(j2, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet$1(newLocal && newLocal.sort(byPos$1), children);
}
function moveSpans$1(spans, offset2) {
  if (!offset2 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i2 = 0; i2 < spans.length; i2++) {
    var span = spans[i2];
    result2.push(new Decoration$1(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations$1(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather2(set3, oldOffset2) {
    for (var i3 = 0; i3 < set3.local.length; i3++) {
      var mapped = set3.local[i3].map(mapping, offset2, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set3.local[i3].spec);
      }
    }
    for (var i$1 = 0; i$1 < set3.children.length; i$1 += 3) {
      gather2(set3.children[i$1 + 2], set3.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    if (children[i2 + 1] == -1) {
      gather2(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode$1(spans, node5, offset2) {
  if (node5.isLeaf) {
    return null;
  }
  var end3 = offset2 + node5.nodeSize, found2 = null;
  for (var i2 = 0, span = void 0; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset2 && span.to < end3) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls$1(array) {
  var result2 = [];
  for (var i2 = 0; i2 < array.length; i2++) {
    if (array[i2] != null) {
      result2.push(array[i2]);
    }
  }
  return result2;
}
function buildTree$1(spans, node5, offset2, options) {
  var children = [], hasNulls = false;
  node5.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode$1(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree$1(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty$1) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals5 = moveSpans$1(hasNulls ? withoutNulls$1(spans) : spans, -offset2).sort(byPos$1);
  for (var i2 = 0; i2 < locals5.length; i2++) {
    if (!locals5[i2].type.valid(node5, locals5[i2])) {
      if (options.onRemove) {
        options.onRemove(locals5[i2].spec);
      }
      locals5.splice(i2--, 1);
    }
  }
  return locals5.length || children.length ? new DecorationSet$1(locals5, children) : empty$1;
}
function byPos$1(a2, b2) {
  return a2.from - b2.from || a2.to - b2.to;
}
function removeOverlap$1(spans) {
  var working = spans;
  for (var i2 = 0; i2 < working.length - 1; i2++) {
    var span = working[i2];
    if (span.from != span.to) {
      for (var j2 = i2 + 1; j2 < working.length; j2++) {
        var next = working[j2];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j2] = next.copy(next.from, span.to);
            insertAhead$1(working, j2 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i2] = span.copy(span.from, next.from);
            insertAhead$1(working, j2, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead$1(array, i2, deco) {
  while (i2 < array.length && byPos$1(deco, array[i2]) > 0) {
    i2++;
  }
  array.splice(i2, 0, deco);
}
function viewDecorations$1(view) {
  var found2 = [];
  view.someProp("decorations", function(f2) {
    var result2 = f2(view.state);
    if (result2 && result2 != empty$1) {
      found2.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found2.push(DecorationSet$1.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup$1.from(found2);
}
var EditorView$1 = function EditorView(place, props) {
  this._props = props;
  this.state = props.state;
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.trackWrites = null;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable$1(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper$1(this);
  this.nodeViews = buildNodeViews$1(this);
  this.docView = docViewDesc$1(this.state.doc, computeDocDeco$1(this), viewDecorations$1(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput$1(this);
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$2$1 = { props: { configurable: true }, root: { configurable: true } };
prototypeAccessors$2$1.props.get = function() {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) {
      this._props[name] = prev[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView$1.prototype.update = function update(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners$1(this);
  }
  this._props = props;
  this.updateStateInner(props.state, true);
};
EditorView$1.prototype.setProps = function setProps(props) {
  var updated = {};
  for (var name in this._props) {
    updated[name] = this._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView$1.prototype.updateState = function updateState(state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};
EditorView$1.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
  var this$1$1 = this;
  var prev = this.state, redraw = false, updateSel = false;
  if (state.storedMarks && this.composing) {
    clearComposition$1(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews$1(this);
    if (changedNodeViews$1(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners$1(this);
  }
  this.editable = getEditable$1(this);
  updateCursorWrapper$1(this);
  var innerDeco = viewDecorations$1(this), outerDeco = computeDocDeco$1(this);
  var scroll2 = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) {
    updateSel = true;
  }
  var oldScrollPos = scroll2 == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos$1(this);
  if (updateSel) {
    this.domObserver.stop();
    var forceSelUpdate = updateDoc && (result$1.ie || result$1.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged$1(prev.selection, state.selection);
    if (updateDoc) {
      var chromeKludge = result$1.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc$1(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) {
        forceSelUpdate = true;
      }
    }
    if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace$1(this))) {
      selectionToDOM$1(this, forceSelUpdate);
    } else {
      syncNodeSelection$1(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }
  this.updatePluginViews(prev);
  if (scroll2 == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll2 == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function(f2) {
      return f2(this$1$1);
    }))
      ;
    else if (state.selection instanceof NodeSelection) {
      scrollRectIntoView$1(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView$1(this, this.coordsAtPos(state.selection.head, 1), startDOM);
    }
  } else if (oldScrollPos) {
    resetScrollPos$1(oldScrollPos);
  }
};
EditorView$1.prototype.destroyPluginViews = function destroyPluginViews() {
  var view;
  while (view = this.pluginViews.pop()) {
    if (view.destroy) {
      view.destroy();
    }
  }
};
EditorView$1.prototype.updatePluginViews = function updatePluginViews(prevState) {
  if (!prevState || prevState.plugins != this.state.plugins) {
    this.destroyPluginViews();
    for (var i2 = 0; i2 < this.state.plugins.length; i2++) {
      var plugin2 = this.state.plugins[i2];
      if (plugin2.spec.view) {
        this.pluginViews.push(plugin2.spec.view(this));
      }
    }
  } else {
    for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {
      var pluginView = this.pluginViews[i$1];
      if (pluginView.update) {
        pluginView.update(this, prevState);
      }
    }
  }
};
EditorView$1.prototype.someProp = function someProp(propName, f2) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f2 ? f2(prop) : prop)) {
    return value;
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i2 = 0; i2 < plugins.length; i2++) {
      var prop$1 = plugins[i2].props[propName];
      if (prop$1 != null && (value = f2 ? f2(prop$1) : prop$1)) {
        return value;
      }
    }
  }
};
EditorView$1.prototype.hasFocus = function hasFocus() {
  return this.root.activeElement == this.dom;
};
EditorView$1.prototype.focus = function focus() {
  this.domObserver.stop();
  if (this.editable) {
    focusPreventScroll$1(this.dom);
  }
  selectionToDOM$1(this);
  this.domObserver.start();
};
prototypeAccessors$2$1.root.get = function() {
  var cached = this._root;
  if (cached == null) {
    for (var search3 = this.dom.parentNode; search3; search3 = search3.parentNode) {
      if (search3.nodeType == 9 || search3.nodeType == 11 && search3.host) {
        if (!search3.getSelection) {
          Object.getPrototypeOf(search3).getSelection = function() {
            return document.getSelection();
          };
        }
        return this._root = search3;
      }
    }
  }
  return cached || document;
};
EditorView$1.prototype.posAtCoords = function posAtCoords$1$1(coords) {
  return posAtCoords$1(this, coords);
};
EditorView$1.prototype.coordsAtPos = function coordsAtPos$1$1(pos, side) {
  if (side === void 0)
    side = 1;
  return coordsAtPos$1(this, pos, side);
};
EditorView$1.prototype.domAtPos = function domAtPos(pos, side) {
  if (side === void 0)
    side = 0;
  return this.docView.domFromPos(pos, side);
};
EditorView$1.prototype.nodeDOM = function nodeDOM(pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null;
};
EditorView$1.prototype.posAtDOM = function posAtDOM(node5, offset2, bias) {
  if (bias === void 0)
    bias = -1;
  var pos = this.docView.posFromDOM(node5, offset2, bias);
  if (pos == null) {
    throw new RangeError("DOM position not inside the editor");
  }
  return pos;
};
EditorView$1.prototype.endOfTextblock = function endOfTextblock$1$1(dir, state) {
  return endOfTextblock$1(this, state || this.state, dir);
};
EditorView$1.prototype.destroy = function destroy2() {
  if (!this.docView) {
    return;
  }
  destroyInput$1(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations$1(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
EditorView$1.prototype.dispatchEvent = function dispatchEvent$1(event) {
  return dispatchEvent$2(this, event);
};
EditorView$1.prototype.dispatch = function dispatch(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction.call(this, tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView$1.prototype, prototypeAccessors$2$1);
function computeDocDeco$1(view) {
  var attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration$1.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper$1(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = { dom, deco: Decoration$1.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable$1(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged$1(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews$1(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
        result2[prop] = obj[prop];
      }
    }
  });
  return result2;
}
function changedNodeViews$1(a2, b2) {
  var nA = 0, nB = 0;
  for (var prop in a2) {
    if (a2[prop] != b2[prop]) {
      return true;
    }
    nA++;
  }
  for (var _2 in b2) {
    nB++;
  }
  return nA != nB;
}
function deleteSelection(state, dispatch3) {
  if (state.selection.empty) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.deleteSelection().scrollIntoView());
  }
  return true;
}
function joinBackward(state, dispatch3, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  var before2 = $cut.nodeBefore;
  if (!before2.type.spec.isolating && deleteBarrier(state, $cut, dispatch3)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(before2, "end") || NodeSelection.isSelectable(before2))) {
    if (dispatch3) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(before2, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before2.nodeSize));
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  if (before2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch3) {
      dispatch3(state.tr.delete($cut.pos - before2.nodeSize, $cut.pos).scrollIntoView());
    }
    return true;
  }
  return false;
}
function textblockAt(node5, side, only) {
  for (; node5; node5 = side == "start" ? node5.firstChild : node5.lastChild) {
    if (node5.isTextblock) {
      return true;
    }
    if (only && node5.childCount != 1) {
      return false;
    }
  }
  return false;
}
function selectNodeBackward(state, dispatch3, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty2 = ref.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
      return false;
    }
    $cut = findCutBefore($head);
  }
  var node5 = $cut && $cut.nodeBefore;
  if (!node5 || !NodeSelection.isSelectable(node5)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node5.nodeSize)).scrollIntoView());
  }
  return true;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0) {
        return $pos.doc.resolve($pos.before(i2 + 1));
      }
      if ($pos.node(i2).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinForward(state, dispatch3, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor);
  if (!$cut) {
    return false;
  }
  var after2 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch3)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(after2, "start") || NodeSelection.isSelectable(after2))) {
    if (dispatch3) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(after2, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  if (after2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch3) {
      dispatch3(state.tr.delete($cut.pos, $cut.pos + after2.nodeSize).scrollIntoView());
    }
    return true;
  }
  return false;
}
function selectNodeForward(state, dispatch3, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty2 = ref.empty;
  var $cut = $head;
  if (!empty2) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
      return false;
    }
    $cut = findCutAfter($head);
  }
  var node5 = $cut && $cut.nodeAfter;
  if (!node5 || !NodeSelection.isSelectable(node5)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  }
  return true;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i2 = $pos.depth - 1; i2 >= 0; i2--) {
      var parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount) {
        return $pos.doc.resolve($pos.after(i2 + 1));
      }
      if (parent.type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function newlineInCode(state, dispatch3) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.insertText("\n").scrollIntoView());
  }
  return true;
}
function defaultBlockAt(match) {
  for (var i2 = 0; i2 < match.edgeCount; i2++) {
    var ref = match.edge(i2);
    var type = ref.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function exitCode(state, dispatch3) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  var above = $head.node(-1), after2 = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after2));
  if (!above.canReplaceWith(after2, after2, type)) {
    return false;
  }
  if (dispatch3) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function createParagraphNear(state, dispatch3) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {
    return false;
  }
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) {
    return false;
  }
  if (dispatch3) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function liftEmptyBlock(state, dispatch3) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) {
    return false;
  }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before2 = $cursor.before();
    if (canSplit(state.doc, before2)) {
      if (dispatch3) {
        dispatch3(state.tr.split(before2).scrollIntoView());
      }
      return true;
    }
  }
  var range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.lift(range, target).scrollIntoView());
  }
  return true;
}
function splitBlock(state, dispatch3) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.split($from.pos).scrollIntoView());
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch3) {
    var atEnd2 = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) {
      tr.deleteSelection();
    }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd2 && deflt ? [{ type: deflt }] : null;
    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
      types = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd2 && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    dispatch3(tr.scrollIntoView());
  }
  return true;
}
function selectAll(state, dispatch3) {
  if (dispatch3) {
    dispatch3(state.tr.setSelection(new AllSelection(state.doc)));
  }
  return true;
}
function joinMaybeClear(state, $pos, dispatch3) {
  var before2 = $pos.nodeBefore, after2 = $pos.nodeAfter, index3 = $pos.index();
  if (!before2 || !after2 || !before2.type.compatibleContent(after2.type)) {
    return false;
  }
  if (!before2.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
    if (dispatch3) {
      dispatch3(state.tr.delete($pos.pos - before2.nodeSize, $pos.pos).scrollIntoView());
    }
    return true;
  }
  if (!$pos.parent.canReplace(index3, index3 + 1) || !(after2.isTextblock || canJoin(state.doc, $pos.pos))) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.clearIncompatible($pos.pos, before2.type, before2.contentMatchAt(before2.childCount)).join($pos.pos).scrollIntoView());
  }
  return true;
}
function deleteBarrier(state, $cut, dispatch3) {
  var before2 = $cut.nodeBefore, after2 = $cut.nodeAfter, conn, match;
  if (before2.type.spec.isolating || after2.type.spec.isolating) {
    return false;
  }
  if (joinMaybeClear(state, $cut, dispatch3)) {
    return true;
  }
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before2.contentMatchAt(before2.childCount)).findWrapping(after2.type)) && match.matchType(conn[0] || after2.type).validEnd) {
    if (dispatch3) {
      var end3 = $cut.pos + after2.nodeSize, wrap2 = Fragment.empty;
      for (var i2 = conn.length - 1; i2 >= 0; i2--) {
        wrap2 = Fragment.from(conn[i2].create(null, wrap2));
      }
      wrap2 = Fragment.from(before2.copy(wrap2));
      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end3, $cut.pos, end3, new Slice(wrap2, 1, 0), conn.length, true));
      var joinAt = end3 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt)) {
        tr.join(joinAt);
      }
      dispatch3(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch3) {
      dispatch3(state.tr.lift(range, target).scrollIntoView());
    }
    return true;
  }
  if (canDelAfter && textblockAt(after2, "start", true) && textblockAt(before2, "end")) {
    var at = before2, wrap$12 = [];
    for (; ; ) {
      wrap$12.push(at);
      if (at.isTextblock) {
        break;
      }
      at = at.lastChild;
    }
    var afterText = after2, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch3) {
        var end$1 = Fragment.empty;
        for (var i$1 = wrap$12.length - 1; i$1 >= 0; i$1--) {
          end$1 = Fragment.from(wrap$12[i$1].copy(end$1));
        }
        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$12.length, $cut.pos + after2.nodeSize, $cut.pos + afterDepth, $cut.pos + after2.nodeSize - afterDepth, new Slice(end$1, wrap$12.length, 0), 0, true));
        dispatch3(tr$1.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function wrapIn(nodeType2, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), wrapping = range && findWrapping3(range, nodeType2, attrs);
    if (!wrapping) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.wrap(range, wrapping).scrollIntoView());
    }
    return true;
  };
}
function setBlockType(nodeType2, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var from5 = ref.from;
    var to2 = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from5, to2, function(node5, pos) {
      if (applicable) {
        return false;
      }
      if (!node5.isTextblock || node5.hasMarkup(nodeType2, attrs)) {
        return;
      }
      if (node5.type == nodeType2) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index3 = $pos.index();
        applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType2);
      }
    });
    if (!applicable) {
      return false;
    }
    if (dispatch3) {
      dispatch3(state.tr.setBlockType(from5, to2, nodeType2, attrs).scrollIntoView());
    }
    return true;
  };
}
function markApplies(doc2, ranges, type) {
  var loop2 = function(i3) {
    var ref = ranges[i3];
    var $from = ref.$from;
    var $to = ref.$to;
    var can = $from.depth == 0 ? doc2.type.allowsMarkType(type) : false;
    doc2.nodesBetween($from.pos, $to.pos, function(node5) {
      if (can) {
        return false;
      }
      can = node5.inlineContent && node5.type.allowsMarkType(type);
    });
    if (can) {
      return { v: true };
    }
  };
  for (var i2 = 0; i2 < ranges.length; i2++) {
    var returned = loop2(i2);
    if (returned)
      return returned.v;
  }
  return false;
}
function toggleMark(markType, attrs) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var empty2 = ref.empty;
    var $cursor = ref.$cursor;
    var ranges = ref.ranges;
    if (empty2 && !$cursor || !markApplies(state.doc, ranges, markType)) {
      return false;
    }
    if (dispatch3) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) {
          dispatch3(state.tr.removeStoredMark(markType));
        } else {
          dispatch3(state.tr.addStoredMark(markType.create(attrs)));
        }
      } else {
        var has = false, tr = state.tr;
        for (var i2 = 0; !has && i2 < ranges.length; i2++) {
          var ref$1 = ranges[i2];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref$2 = ranges[i$1];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            var from5 = $from$1.pos, to2 = $to$1.pos, start4 = $from$1.nodeAfter, end3 = $to$1.nodeBefore;
            var spaceStart = start4 && start4.isText ? /^\s*/.exec(start4.text)[0].length : 0;
            var spaceEnd = end3 && end3.isText ? /\s*$/.exec(end3.text)[0].length : 0;
            if (from5 + spaceStart < to2) {
              from5 += spaceStart;
              to2 -= spaceEnd;
            }
            tr.addMark(from5, to2, markType.create(attrs));
          }
        }
        dispatch3(tr.scrollIntoView());
      }
    }
    return true;
  };
}
function chainCommands() {
  var commands2 = [], len = arguments.length;
  while (len--)
    commands2[len] = arguments[len];
  return function(state, dispatch3, view) {
    for (var i2 = 0; i2 < commands2.length; i2++) {
      if (commands2[i2](state, dispatch3, view)) {
        return true;
      }
    }
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (var key$3 in pcBaseKeymap) {
  macBaseKeymap[key$3] = pcBaseKeymap[key$3];
}
var mac$2 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
var baseKeymap = mac$2 ? macBaseKeymap : pcBaseKeymap;
var InputRule = function InputRule2(match, handler) {
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
};
function stringHandler(string2) {
  return function(state, match, start4, end3) {
    var insert = string2;
    if (match[1]) {
      var offset2 = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset2 + match[1].length);
      start4 += offset2;
      var cutOff = start4 - end3;
      if (cutOff > 0) {
        insert = match[0].slice(offset2 - cutOff, offset2) + insert;
        start4 = end3;
      }
    }
    return state.tr.insertText(insert, start4, end3);
  };
}
var MAX_MATCH = 500;
function inputRules$1(ref) {
  var rules = ref.rules;
  var plugin2 = new Plugin({
    state: {
      init: function init6() {
        return null;
      },
      apply: function apply9(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from5, to2, text3) {
        return run(view, from5, to2, text3, rules, plugin2);
      },
      handleDOMEvents: {
        compositionend: function(view) {
          setTimeout(function() {
            var ref2 = view.state.selection;
            var $cursor = ref2.$cursor;
            if ($cursor) {
              run(view, $cursor.pos, $cursor.pos, "", rules, plugin2);
            }
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin2;
}
function run(view, from5, to2, text3, rules, plugin2) {
  if (view.composing) {
    return false;
  }
  var state = view.state, $from = state.doc.resolve(from5);
  if ($from.parent.type.spec.code) {
    return false;
  }
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\uFFFC") + text3;
  for (var i2 = 0; i2 < rules.length; i2++) {
    var match = rules[i2].match.exec(textBefore);
    var tr = match && rules[i2].handler(state, match, from5 - (match[0].length - text3.length), to2);
    if (!tr) {
      continue;
    }
    view.dispatch(tr.setMeta(plugin2, { transform: tr, from: from5, to: to2, text: text3 }));
    return true;
  }
  return false;
}
new InputRule(/--$/, "\u2014");
new InputRule(/\.\.\.$/, "\u2026");
new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "\u201C");
new InputRule(/"$/, "\u201D");
new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "\u2018");
new InputRule(/'$/, "\u2019");
function wrappingInputRule(regexp, nodeType2, getAttrs, joinPredicate) {
  return new InputRule(regexp, function(state, match, start4, end3) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr.delete(start4, end3);
    var $start = tr.doc.resolve(start4), range = $start.blockRange(), wrapping = range && findWrapping3(range, nodeType2, attrs);
    if (!wrapping) {
      return null;
    }
    tr.wrap(range, wrapping);
    var before2 = tr.doc.resolve(start4 - 1).nodeBefore;
    if (before2 && before2.type == nodeType2 && canJoin(tr.doc, start4 - 1) && (!joinPredicate || joinPredicate(match, before2))) {
      tr.join(start4 - 1);
    }
    return tr;
  });
}
function textblockTypeInputRule(regexp, nodeType2, getAttrs) {
  return new InputRule(regexp, function(state, match, start4, end3) {
    var $start = state.doc.resolve(start4);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType2)) {
      return null;
    }
    return state.tr.delete(start4, end3).setBlockType(start4, start4, nodeType2, attrs);
  });
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome$1 && (mac$1 || +chrome$1[1] < 57) || gecko && mac$1;
for (var i$1 = 0; i$1 < 10; i$1++)
  base[48 + i$1] = base[96 + i$1] = String(i$1);
for (var i$1 = 1; i$1 <= 24; i$1++)
  base[i$1 + 111] = "F" + i$1;
for (var i$1 = 65; i$1 <= 90; i$1++) {
  base[i$1] = String.fromCharCode(i$1 + 32);
  shift[i$1] = String.fromCharCode(i$1);
}
for (var code$1 in base)
  if (!shift.hasOwnProperty(code$1))
    shift[code$1] = base[code$1];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie$2) && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta;
  for (var i2 = 0; i2 < parts.length - 1; i2++) {
    var mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize(map21) {
  var copy6 = Object.create(null);
  for (var prop in map21) {
    copy6[normalizeKeyName(prop)] = map21[prop];
  }
  return copy6;
}
function modifiers(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap$1(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  var map21 = normalize(bindings);
  return function(view, event) {
    var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map21[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
      var fromCode = map21[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) {
        return true;
      }
    } else if (isChar && event.shiftKey) {
      var withShift = map21[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) {
        return true;
      }
    }
    return false;
  };
}
const inputRulesCtx = createCtx([]);
const inputRulesTimerCtx = createCtx([]);
const InputRulesReady = createTimer("InputRulesReady");
const inputRules = (pre) => {
  pre.inject(inputRulesCtx).inject(inputRulesTimerCtx, [SchemaReady]).record(InputRulesReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(inputRulesTimerCtx);
    const nodes2 = ctx.get(nodesCtx);
    const marks3 = ctx.get(marksCtx);
    const schema2 = ctx.get(schemaCtx);
    const getInputRules = (atoms, isNode) => atoms.map((x2) => [getAtom(x2.id, schema2, isNode), x2.inputRules]).flatMap(([atom, inputRules3]) => atom && (inputRules3 === null || inputRules3 === void 0 ? void 0 : inputRules3(atom, schema2))).filter((x2) => !!x2);
    const inputRules2 = [...getInputRules(nodes2, true), ...getInputRules(marks3, false)];
    ctx.set(inputRulesCtx, inputRules2);
    ctx.done(InputRulesReady);
  });
};
const keymapCtx = createCtx([]);
const keymapTimerCtx = createCtx([]);
const KeymapReady = createTimer("KeymapReady");
const keymap = (pre) => {
  pre.inject(keymapCtx).inject(keymapTimerCtx, [SchemaReady, CommandsReady]).record(KeymapReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(keymapTimerCtx);
    const nodes2 = ctx.get(nodesCtx);
    const marks3 = ctx.get(marksCtx);
    const schema2 = ctx.get(schemaCtx);
    const commandManager = ctx.get(commandsCtx);
    const getKeymap2 = (atoms, isNode) => atoms.map((x2) => [getAtom(x2.id, schema2, isNode), x2.keymap]).map(([atom, keymap2]) => atom && (keymap2 === null || keymap2 === void 0 ? void 0 : keymap2(atom, schema2, commandManager.get))).filter((x2) => !!x2).map(keymap$1);
    const nodesKeymap = getKeymap2(nodes2, true);
    const marksKeymap = getKeymap2(marks3, false);
    const keymapList = [...nodesKeymap, ...marksKeymap];
    ctx.set(keymapCtx, keymapList);
    ctx.done(KeymapReady);
  });
};
var _State_instances$1, _State_matchTarget$1, _State_runNode$1;
class State$1 {
  constructor(stack, schema2, specMap) {
    this.stack = stack;
    this.schema = schema2;
    this.specMap = specMap;
    _State_instances$1.add(this);
    this.run = (remark2, markdown) => {
      const tree = remark2.runSync(remark2.parse(markdown));
      this.next(tree);
      return this;
    };
    this.injectRoot = (node5, nodeType2, attrs) => {
      this.stack.openNode(nodeType2, attrs);
      this.next(node5.children);
      return this;
    };
    this.addText = (text3 = "") => {
      this.stack.addText((marks3) => this.schema.text(text3, marks3));
      return this;
    };
    this.addNode = (...args) => {
      this.stack.addNode(...args);
      return this;
    };
    this.openNode = (...args) => {
      this.stack.openNode(...args);
      return this;
    };
    this.closeNode = (...args) => {
      this.stack.closeNode(...args);
      return this;
    };
    this.openMark = (...args) => {
      this.stack.openMark(...args);
      return this;
    };
    this.closeMark = (...args) => {
      this.stack.closeMark(...args);
      return this;
    };
    this.toDoc = () => this.stack.build();
    this.next = (nodes2 = []) => {
      [nodes2].flat().forEach((node5) => __classPrivateFieldGet(this, _State_instances$1, "m", _State_runNode$1).call(this, node5));
      return this;
    };
  }
}
_State_instances$1 = new WeakSet(), _State_matchTarget$1 = function _State_matchTarget(node5) {
  const result2 = Object.values(this.specMap).find((x2) => x2.match(node5));
  if (!result2)
    throw parserMatchError(node5);
  return result2;
}, _State_runNode$1 = function _State_runNode(node5) {
  const { key: key2, runner: runner2, is: is3 } = __classPrivateFieldGet(this, _State_instances$1, "m", _State_matchTarget$1).call(this, node5);
  const proseType = this.schema[is3 === "node" ? "nodes" : "marks"][key2];
  runner2(this, node5, proseType);
};
const pushElement$1 = (element, node5, ...rest) => {
  element.content.push(node5, ...rest);
};
const popElement$1 = (element) => element.content.pop();
const createElement$1 = (type, content3, attrs) => {
  const element = {
    type,
    content: content3,
    attrs,
    push: (...args) => pushElement$1(element, ...args),
    pop: () => popElement$1(element)
  };
  return element;
};
const { size: size$1, push: push$1, top: top$1, open: open$1, close: close$1 } = getStackUtil();
const openNode$1 = (ctx) => (nodeType2, attrs) => open$1(ctx)(createElement$1(nodeType2, [], attrs));
const addNode$1 = (ctx) => (nodeType2, attrs, content3) => {
  const node5 = nodeType2.createAndFill(attrs, content3, ctx.marks);
  if (!node5)
    throw createNodeInParserFail(nodeType2, attrs, content3);
  push$1(ctx)(node5);
  return node5;
};
const closeNode$1 = (ctx) => () => {
  ctx.marks = Mark.none;
  const element = close$1(ctx);
  return addNode$1(ctx)(element.type, element.attrs, element.content);
};
const openMark$1 = (ctx) => (markType, attrs) => {
  const mark3 = markType.create(attrs);
  ctx.marks = mark3.addToSet(ctx.marks);
};
const closeMark$1 = (ctx) => (markType) => {
  ctx.marks = markType.removeFromSet(ctx.marks);
};
const addText = (ctx) => (createTextNode) => {
  const topElement = top$1(ctx);
  if (!topElement)
    throw stackOverFlow();
  const prevNode = topElement.pop();
  const currNode = createTextNode(ctx.marks);
  if (!prevNode) {
    topElement.push(currNode);
    return;
  }
  const merged = maybeMerge(prevNode, currNode);
  if (merged) {
    topElement.push(merged);
    return;
  }
  topElement.push(prevNode, currNode);
};
const build$1 = (ctx) => () => {
  let doc2 = null;
  do {
    doc2 = closeNode$1(ctx)();
  } while (size$1(ctx));
  return doc2;
};
const createStack$1 = () => {
  const ctx = {
    marks: [],
    elements: []
  };
  return {
    build: build$1(ctx),
    openMark: openMark$1(ctx),
    closeMark: closeMark$1(ctx),
    addText: addText(ctx),
    openNode: openNode$1(ctx),
    addNode: addNode$1(ctx),
    closeNode: closeNode$1(ctx)
  };
};
function createParser(schema2, specMap, remark2) {
  return (text3) => {
    const state = new State$1(createStack$1(), schema2, specMap);
    state.run(remark2, text3);
    return state.toDoc();
  };
}
const SchemaReady = createTimer("schemaReady");
const schemaCtx = createCtx({});
const nodesCtx = createCtx([]);
const marksCtx = createCtx([]);
const schemaTimerCtx = createCtx([]);
const schema = (pre) => {
  pre.inject(schemaCtx).inject(nodesCtx).inject(marksCtx).inject(schemaTimerCtx, [Initialize]).record(SchemaReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(schemaTimerCtx);
    const getAtom2 = (x2) => fromPairs(x2.map(({ id: id2, schema: schema2 }) => [id2, schema2]));
    const nodes2 = getAtom2(ctx.get(nodesCtx));
    const marks3 = getAtom2(ctx.get(marksCtx));
    ctx.set(schemaCtx, new Schema({
      nodes: nodes2,
      marks: marks3
    }));
    ctx.done(SchemaReady);
  });
};
const parserCtx = createCtx(() => null);
const parserTimerCtx = createCtx([]);
const ParserReady = createTimer("ParserReady");
const parser = (pre) => {
  pre.inject(parserCtx).inject(parserTimerCtx, [SchemaReady]).record(ParserReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(parserTimerCtx);
    const nodes2 = ctx.get(nodesCtx);
    const marks3 = ctx.get(marksCtx);
    const remark2 = ctx.get(remarkCtx);
    const schema2 = ctx.get(schemaCtx);
    const children = [
      ...nodes2.map((node5) => Object.assign(Object.assign({}, node5), { is: "node" })),
      ...marks3.map((mark3) => Object.assign(Object.assign({}, mark3), { is: "mark" }))
    ];
    const spec = fromPairs(children.map(({ id: id2, parser: parser2, is: is3 }) => [id2, Object.assign(Object.assign({}, parser2), { is: is3, key: id2 })]));
    ctx.set(parserCtx, createParser(schema2, spec, remark2));
    ctx.done(ParserReady);
  });
};
const pushElement = (element, node5, ...rest) => {
  if (!element.children) {
    element.children = [];
  }
  element.children.push(node5, ...rest);
};
const popElement = (element) => {
  var _a;
  return (_a = element.children) === null || _a === void 0 ? void 0 : _a.pop();
};
const createElement = (type, children, value, props = {}) => {
  const element = {
    type,
    children,
    props,
    value,
    push: (...args) => pushElement(element, ...args),
    pop: () => popElement(element)
  };
  return element;
};
const { size, push, open, close: close2 } = getStackUtil();
const createMarkdownNode = (element) => {
  const node5 = Object.assign(Object.assign({}, element.props), { type: element.type });
  if (element.children) {
    node5.children = element.children;
  }
  if (element.value) {
    node5.value = element.value;
  }
  return node5;
};
const openNode = (ctx) => (type, value, props) => open(ctx)(createElement(type, [], value, props));
const addNode2 = (ctx) => (type, children, value, props) => {
  const element = createElement(type, children, value, props);
  const node5 = createMarkdownNode(element);
  push(ctx)(node5);
  return node5;
};
const closeNode = (ctx) => () => {
  const element = close2(ctx);
  return addNode2(ctx)(element.type, element.children, element.value, element.props);
};
const openMark = (ctx) => (mark3, type, value, props) => {
  const isIn = mark3.isInSet(ctx.marks);
  if (isIn) {
    return;
  }
  ctx.marks = mark3.addToSet(ctx.marks);
  openNode(ctx)(type, value, props);
};
const closeMark = (ctx) => (mark3) => {
  if (!mark3.isInSet(ctx.marks))
    return null;
  ctx.marks = mark3.type.removeFromSet(ctx.marks);
  return closeNode(ctx)();
};
const build = (ctx) => () => {
  let doc2 = null;
  do {
    doc2 = closeNode(ctx)();
  } while (size(ctx));
  return doc2;
};
const createStack = () => {
  const ctx = {
    marks: [],
    elements: []
  };
  return {
    build: build(ctx),
    openMark: openMark(ctx),
    closeMark: closeMark(ctx),
    openNode: openNode(ctx),
    addNode: addNode2(ctx),
    closeNode: closeNode(ctx)
  };
};
var _State_instances, _State_matchTarget2, _State_runProseNode, _State_runProseMark, _State_runNode2;
const isFragment = (x2) => Object.prototype.hasOwnProperty.call(x2, "size");
class State {
  constructor(stack, schema2, specMap) {
    this.stack = stack;
    this.schema = schema2;
    this.specMap = specMap;
    _State_instances.add(this);
    this.next = (node5) => {
      if (isFragment(node5)) {
        node5.forEach((n2) => {
          __classPrivateFieldGet(this, _State_instances, "m", _State_runNode2).call(this, n2);
        });
        return this;
      }
      __classPrivateFieldGet(this, _State_instances, "m", _State_runNode2).call(this, node5);
      return this;
    };
    this.addNode = (...args) => {
      this.stack.addNode(...args);
      return this;
    };
    this.openNode = (...args) => {
      this.stack.openNode(...args);
      return this;
    };
    this.closeNode = (...args) => {
      this.stack.closeNode(...args);
      return this;
    };
    this.toString = (remark2) => remark2.stringify(this.stack.build());
    this.withMark = (...args) => {
      this.stack.openMark(...args);
      return this;
    };
  }
  run(tree) {
    this.next(tree);
    return this;
  }
}
_State_instances = new WeakSet(), _State_matchTarget2 = function _State_matchTarget3(node5) {
  const result2 = Object.entries(this.specMap).map(([key2, spec]) => Object.assign({ key: key2 }, spec)).find((x2) => x2.match(node5));
  if (!result2)
    throw serializerMatchError(node5.type);
  return result2;
}, _State_runProseNode = function _State_runProseNode2(node5) {
  const { runner: runner2 } = __classPrivateFieldGet(this, _State_instances, "m", _State_matchTarget2).call(this, node5);
  runner2(this, node5);
}, _State_runProseMark = function _State_runProseMark2(mark3, node5) {
  const { runner: runner2 } = __classPrivateFieldGet(this, _State_instances, "m", _State_matchTarget2).call(this, mark3);
  return runner2(this, mark3, node5);
}, _State_runNode2 = function _State_runNode3(node5) {
  const { marks: marks3 } = node5;
  const unPreventNext = marks3.every((mark3) => !__classPrivateFieldGet(this, _State_instances, "m", _State_runProseMark).call(this, mark3, node5));
  if (unPreventNext) {
    __classPrivateFieldGet(this, _State_instances, "m", _State_runProseNode).call(this, node5);
  }
  marks3.forEach((mark3) => this.stack.closeMark(mark3));
};
function createSerializer(schema2, specMap, remark2) {
  return (content3) => {
    const state = new State(createStack(), schema2, specMap);
    state.run(content3);
    return state.toString(remark2);
  };
}
const serializerCtx = createCtx(() => "");
const serializerTimerCtx = createCtx([]);
const SerializerReady = createTimer("SerializerReady");
const serializer = (pre) => {
  pre.inject(serializerCtx).inject(serializerTimerCtx, [SchemaReady]).record(SerializerReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(serializerTimerCtx);
    const nodes2 = ctx.get(nodesCtx);
    const marks3 = ctx.get(marksCtx);
    const remark2 = ctx.get(remarkCtx);
    const schema2 = ctx.get(schemaCtx);
    const children = [...nodes2, ...marks3];
    const spec = fromPairs(children.map((child4) => [child4.id, child4.serializer]));
    ctx.set(serializerCtx, createSerializer(schema2, spec, remark2));
    ctx.done(SerializerReady);
  });
};
const defaultValueCtx = createCtx("");
const editorStateCtx = createCtx({});
const editorStateOptionsCtx = createCtx({});
const editorStateTimerCtx = createCtx([]);
const EditorStateReady = createTimer("EditorStateReady");
const getDoc = (defaultValue, parser2, schema2) => {
  if (typeof defaultValue === "string") {
    return parser2(defaultValue);
  }
  if (defaultValue.type === "html") {
    return DOMParser.fromSchema(schema2).parse(defaultValue.dom);
  }
  if (defaultValue.type === "json") {
    return Node.fromJSON(schema2, defaultValue.value);
  }
  throw docTypeError(defaultValue);
};
const editorState = (pre) => {
  pre.inject(defaultValueCtx).inject(editorStateCtx).inject(editorStateOptionsCtx).inject(editorStateTimerCtx, [KeymapReady, InputRulesReady, ParserReady, SerializerReady]).record(EditorStateReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(editorStateTimerCtx);
    const schema2 = ctx.get(schemaCtx);
    const parser2 = ctx.get(parserCtx);
    const rules = ctx.get(inputRulesCtx);
    const keymap2 = ctx.get(keymapCtx);
    const options = ctx.get(editorStateOptionsCtx);
    const prosePlugins = ctx.get(prosePluginsCtx);
    const defaultValue = ctx.get(defaultValueCtx);
    const doc2 = getDoc(defaultValue, parser2, schema2);
    const state = EditorState.create(Object.assign({
      schema: schema2,
      doc: doc2,
      plugins: [...prosePlugins, ...keymap2, keymap$1(baseKeymap), inputRules$1({ rules })]
    }, options));
    ctx.set(editorStateCtx, state);
    ctx.done(EditorStateReady);
  });
};
const nodeViewCtx = createCtx({});
const nodeViewTimerCtx = createCtx([]);
const NodeViewReady = createTimer("NodeViewReady");
const nodeView = (pre) => {
  pre.inject(nodeViewCtx).inject(nodeViewTimerCtx, [SchemaReady]).record(NodeViewReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(nodeViewTimerCtx);
    const nodes2 = ctx.get(nodesCtx);
    const marks3 = ctx.get(marksCtx);
    const schema2 = ctx.get(schemaCtx);
    const editor = ctx.get(editorCtx);
    const getViewMap = (atoms, isNode) => atoms.map(({ id: id2, view }) => [getAtom(id2, schema2, isNode), { view, id: id2 }]).map(([atom, { id: id2, view }]) => atom && view ? [id2, (...args) => view(editor, atom, ...args)] : void 0).filter((x2) => !!x2);
    const nodeViewMap = getViewMap(nodes2, true);
    const markViewMap = getViewMap(marks3, false);
    const nodeView2 = fromPairs([...nodeViewMap, ...markViewMap]);
    ctx.set(nodeViewCtx, nodeView2);
    ctx.done(NodeViewReady);
  });
};
const editorViewCtx = createCtx({});
const editorViewOptionsCtx = createCtx({});
const rootCtx = createCtx(document.body);
const editorViewTimerCtx = createCtx([]);
const Complete = createTimer("complete");
const createViewContainer = (root2) => {
  const container = document.createElement("div");
  container.className = "milkdown";
  root2.appendChild(container);
  return container;
};
const prepareViewDom = (dom) => {
  dom.classList.add("editor");
  dom.setAttribute("role", "textbox");
};
const editorView = (pre) => {
  pre.inject(rootCtx, document.body).inject(editorViewCtx).inject(editorViewOptionsCtx).inject(editorViewTimerCtx, [EditorStateReady, NodeViewReady]).record(Complete);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(editorViewTimerCtx);
    const state = ctx.get(editorStateCtx);
    const options = ctx.get(editorViewOptionsCtx);
    const nodeView2 = ctx.get(nodeViewCtx);
    const root2 = ctx.get(rootCtx);
    const container = root2 ? createViewContainer(root2) : void 0;
    const view = new EditorView$1(container, Object.assign({ state, nodeViews: nodeView2 }, options));
    prepareViewDom(view.dom);
    ctx.set(editorViewCtx, view);
    ctx.done(Complete);
  });
};
const createCmd = (key2, value) => [key2, value];
const commandsCtx = createCtx({});
const createCmdKey = () => createCtx(() => () => false);
const commandsTimerCtx = createCtx([]);
const CommandsReady = createTimer("KeymapReady");
const commands$1 = (pre) => {
  const container = createContainer();
  const commandManager = {
    create: (meta, value) => meta(container.contextMap, value),
    get: (meta) => container.getCtx(meta).get(),
    call: () => {
      throw callCommandBeforeEditorView();
    }
  };
  pre.inject(commandsCtx, commandManager).inject(commandsTimerCtx, [SchemaReady]).record(CommandsReady);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(commandsTimerCtx);
    const nodes2 = ctx.get(nodesCtx);
    const marks3 = ctx.get(marksCtx);
    const schema2 = ctx.get(schemaCtx);
    const getCommands = (atoms, isNode) => atoms.map((x2) => [getAtom(x2.id, schema2, isNode), x2.commands]).map(([atom, commands3]) => atom && (commands3 === null || commands3 === void 0 ? void 0 : commands3(atom, schema2))).filter((x2) => !!x2).flat();
    const commands2 = [...getCommands(nodes2, true), ...getCommands(marks3, false)];
    const commandManager2 = ctx.get(commandsCtx);
    commands2.forEach(([key2, command]) => {
      commandManager2.create(key2, command);
    });
    ctx.done(CommandsReady);
    yield ctx.wait(Complete);
    ctx.update(commandsCtx, (prev) => Object.assign(Object.assign({}, prev), { call: (meta, info2) => {
      const cmd = commandManager2.get(meta);
      const command = cmd(info2);
      const view = ctx.get(editorViewCtx);
      return command(view.state, view.dispatch, view);
    } }));
  });
};
const prosePluginsCtx = createCtx([]);
const prosePluginFactory = (plugin2) => () => (ctx) => __awaiter(void 0, void 0, void 0, function* () {
  yield ctx.wait(CommandsReady);
  const plugins = typeof plugin2 === "function" ? [plugin2(ctx)] : [plugin2];
  ctx.update(prosePluginsCtx, (prev) => prev.concat(plugins.flat()));
});
const remarkPluginsCtx = createCtx([]);
const remarkPluginFactory = (plugin2) => () => (ctx) => {
  ctx.update(remarkPluginsCtx, (prev) => prev.concat([plugin2].flat()));
};
const Initialize = createTimer("Initialize");
const initTimerCtx = createCtx([]);
const editorCtx = createCtx({});
const remarkCtx = createCtx(remark());
const init5 = (editor) => (pre) => {
  pre.inject(editorCtx, editor).inject(prosePluginsCtx).inject(remarkPluginsCtx).inject(remarkCtx, remark()).inject(initTimerCtx, [Config]).record(Initialize);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.waitTimers(initTimerCtx);
    const remark2 = ctx.get(remarkCtx);
    const remarkPlugins = ctx.get(remarkPluginsCtx);
    const processor = remarkPlugins.reduce((acc, plug) => acc.use(plug), remark2);
    ctx.set(remarkCtx, processor);
    ctx.done(Initialize);
  });
};
const markFactory = (mark3) => () => (ctx) => {
  const atom = typeof mark3 === "function" ? mark3(ctx) : mark3;
  ctx.update(marksCtx, (prev) => prev.concat(atom));
};
const nodeFactory = (node5) => () => (ctx) => {
  const atom = typeof node5 === "function" ? node5(ctx) : node5;
  ctx.update(nodesCtx, (prev) => prev.concat(atom));
};
var _Editor_container, _Editor_clock, _Editor_ctx, _Editor_plugins, _Editor_pre, _Editor_loadInternal, _Editor_configureList;
class Editor {
  constructor() {
    _Editor_container.set(this, createContainer());
    _Editor_clock.set(this, createClock());
    _Editor_ctx.set(this, {
      use: __classPrivateFieldGet(this, _Editor_container, "f").getCtx,
      get: (meta) => __classPrivateFieldGet(this, _Editor_container, "f").getCtx(meta).get(),
      set: (meta, value) => __classPrivateFieldGet(this, _Editor_container, "f").getCtx(meta).set(value),
      update: (meta, updater) => __classPrivateFieldGet(this, _Editor_container, "f").getCtx(meta).update(updater),
      wait: (timer) => __classPrivateFieldGet(this, _Editor_clock, "f").get(timer)(),
      done: (timer) => __classPrivateFieldGet(this, _Editor_clock, "f").get(timer).done(),
      waitTimers: (meta) => __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(__classPrivateFieldGet(this, _Editor_ctx, "f").get(meta).map((x2) => __classPrivateFieldGet(this, _Editor_ctx, "f").wait(x2)));
        return;
      })
    });
    _Editor_plugins.set(this, new Set());
    this.inject = (meta, resetValue) => {
      meta(__classPrivateFieldGet(this, _Editor_container, "f").contextMap, resetValue);
      return __classPrivateFieldGet(this, _Editor_pre, "f");
    };
    this.record = (timingMeta) => {
      timingMeta(__classPrivateFieldGet(this, _Editor_clock, "f").store);
      return __classPrivateFieldGet(this, _Editor_pre, "f");
    };
    _Editor_pre.set(this, {
      inject: this.inject,
      record: this.record
    });
    this.use = (plugins) => {
      [plugins].flat().forEach((plugin2) => {
        __classPrivateFieldGet(this, _Editor_plugins, "f").add(plugin2(__classPrivateFieldGet(this, _Editor_pre, "f")));
      });
      return this;
    };
    _Editor_loadInternal.set(this, () => {
      const internalPlugins = [
        schema,
        parser,
        serializer,
        nodeView,
        commands$1,
        keymap,
        inputRules,
        editorState,
        editorView
      ];
      const configPlugin = config$1((x2) => __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(__classPrivateFieldGet(this, _Editor_configureList, "f").map((fn) => fn(x2)));
      }));
      this.use(internalPlugins.concat(init5(this)).concat(configPlugin));
    });
    this.create = () => __awaiter(this, void 0, void 0, function* () {
      __classPrivateFieldGet(this, _Editor_loadInternal, "f").call(this);
      yield Promise.all([...__classPrivateFieldGet(this, _Editor_plugins, "f")].map((loader) => {
        return loader(__classPrivateFieldGet(this, _Editor_ctx, "f"));
      }));
      return this;
    });
    _Editor_configureList.set(this, []);
    this.config = (configure2) => {
      __classPrivateFieldGet(this, _Editor_configureList, "f").push(configure2);
      return this;
    };
    this.action = (action) => action(__classPrivateFieldGet(this, _Editor_ctx, "f"));
  }
  static make() {
    return new Editor();
  }
}
_Editor_container = new WeakMap(), _Editor_clock = new WeakMap(), _Editor_ctx = new WeakMap(), _Editor_plugins = new WeakMap(), _Editor_pre = new WeakMap(), _Editor_loadInternal = new WeakMap(), _Editor_configureList = new WeakMap();
const listenerCtx = createCtx({});
const listener = (pre) => {
  pre.inject(listenerCtx);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.wait(SerializerReady);
    const listener2 = ctx.get(listenerCtx);
    const serializer2 = ctx.get(serializerCtx);
    const plugin2 = new Plugin({
      state: {
        init: () => {
        },
        apply: (tr) => {
          var _a, _b;
          if (!tr.docChanged)
            return;
          (_a = listener2.markdown) === null || _a === void 0 ? void 0 : _a.forEach((markdownListener) => {
            markdownListener(() => serializer2(tr.doc));
          });
          (_b = listener2.doc) === null || _b === void 0 ? void 0 : _b.forEach((docListener) => {
            docListener(tr.doc);
          });
        }
      }
    });
    ctx.update(prosePluginsCtx, (x2) => x2.concat(plugin2));
  });
};
const equalNodeType$1 = (nodeType2, node5) => {
  return Array.isArray(nodeType2) && nodeType2.indexOf(node5.type) > -1 || node5.type === nodeType2;
};
const findSelectedNodeOfType$1 = (selection, nodeType2) => {
  if (!(selection instanceof NodeSelection)) {
    return;
  }
  const { node: node5, $from } = selection;
  if (equalNodeType$1(nodeType2, node5)) {
    return { node: node5, pos: $from.pos, start: $from.start($from.depth), depth: $from.depth };
  }
  return void 0;
};
const commands2Tuples$2 = (commands2) => Object.entries(commands2).filter((x2) => !!x2);
const getShortCuts$2 = (name, defaultKey, userKeymap) => {
  var _a;
  return (_a = userKeymap === null || userKeymap === void 0 ? void 0 : userKeymap[name]) !== null && _a !== void 0 ? _a : defaultKey;
};
const getKeymap$2 = (getCommand, userKeymap) => ([name, { defaultKey, commandKey, args }]) => [getShortCuts$2(name, defaultKey, userKeymap)].flat().map((shortcut) => [shortcut, getCommand(commandKey)(args)]);
const tuple2Keymap$2 = (tuples, getCommand, userKeymap) => tuples.flatMap(getKeymap$2(getCommand, userKeymap));
const createKeymap$2 = (commands2, userKeymap) => !commands2 ? () => ({}) : (_type, _schema, getCommand) => Object.fromEntries(tuple2Keymap$2(commands2Tuples$2(commands2), getCommand, userKeymap));
const createMark$1 = (factory2) => {
  const origin = (options) => {
    const getClassName = (attrs, defaultValue) => {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.className) === null || _a === void 0 ? void 0 : _a.call(options, attrs)) !== null && _b !== void 0 ? _b : defaultValue;
    };
    const node5 = factory2(options, {
      getClassName
    });
    const keymap2 = createKeymap$2(node5.shortcuts, options === null || options === void 0 ? void 0 : options.keymap);
    const plugin2 = markFactory(Object.assign(Object.assign({}, node5), { keymap: keymap2, view: options === null || options === void 0 ? void 0 : options.view }));
    plugin2.origin = origin;
    return plugin2;
  };
  return origin;
};
const createNode$2 = (factory2) => {
  const origin = (options) => {
    const getClassName = (attrs, defaultValue) => {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.className) === null || _a === void 0 ? void 0 : _a.call(options, attrs)) !== null && _b !== void 0 ? _b : defaultValue;
    };
    const node5 = factory2(options, {
      getClassName
    });
    const keymap2 = createKeymap$2(node5.shortcuts, options === null || options === void 0 ? void 0 : options.keymap);
    const plugin2 = nodeFactory(Object.assign(Object.assign({ view: options === null || options === void 0 ? void 0 : options.view }, node5), { keymap: keymap2 }));
    plugin2.origin = origin;
    return plugin2;
  };
  return origin;
};
class AtomList$1 extends Array {
  configure(target, config2) {
    const index3 = this.findIndex((x2) => x2.origin === target);
    if (index3 < 0)
      return this;
    this.splice(index3, 1, target(config2));
    return this;
  }
  static create(from5) {
    return new AtomList$1(...from5);
  }
}
const createShortcut$1 = (commandKey, defaultKey, args) => ({
  commandKey,
  defaultKey,
  args
});
function markRule$1(regexp, markType) {
  return new InputRule(regexp, (state, match, start4, end3) => {
    const { tr } = state;
    const matchLength = match.length;
    let markStart = start4;
    let markEnd = end3;
    if (match[matchLength - 1]) {
      const first = match[0];
      const last = match[matchLength - 1];
      const last1 = match[matchLength - 2];
      const matchStart = start4 + first.indexOf(last1);
      const matchEnd = matchStart + last1.length - 1;
      const textStart = matchStart + last1.lastIndexOf(last);
      const textEnd = textStart + last.length;
      const excludedMarks = getMarksBetween$1(start4, end3, state).filter((item) => item.mark.type.excludes(markType)).filter((item) => item.end > matchStart);
      if (excludedMarks.length) {
        return null;
      }
      if (textEnd < matchEnd) {
        tr.delete(textEnd, matchEnd);
      }
      if (textStart > matchStart) {
        tr.delete(matchStart, textStart);
      }
      markStart = matchStart;
      markEnd = markStart + last.length;
    }
    tr.addMark(markStart, markEnd, markType.create());
    tr.removeStoredMark(markType);
    return tr;
  });
}
function getMarksBetween$1(start4, end3, state) {
  let marks3 = [];
  state.doc.nodesBetween(start4, end3, (node5, pos) => {
    marks3 = [
      ...marks3,
      ...node5.marks.map((mark3) => ({
        start: pos,
        end: pos + node5.nodeSize,
        mark: mark3
      }))
    ];
  });
  return marks3;
}
const SupportedKeys$2 = {
  HardBreak: "HardBreak",
  Blockquote: "Blockquote",
  BulletList: "BulletList",
  OrderedList: "OrderedList",
  CodeFence: "CodeFence",
  H1: "H1",
  H2: "H2",
  H3: "H3",
  H4: "H4",
  H5: "H5",
  H6: "H6",
  Text: "Text",
  CodeInline: "CodeInline",
  Em: "Em",
  Bold: "Bold",
  NextListItem: "NextListItem",
  SinkListItem: "SinkListItem",
  LiftListItem: "LiftListItem"
};
const id$e = "code_inline";
const ToggleInlineCode = createCmdKey();
const codeInline = createMark$1((_2, utils) => ({
  id: id$e,
  schema: {
    excludes: "_",
    parseDOM: [{ tag: "code" }],
    toDOM: (mark3) => ["code", { class: utils.getClassName(mark3.attrs, "code-inline") }]
  },
  parser: {
    match: (node5) => node5.type === "inlineCode",
    runner: (state, node5, markType) => {
      state.openMark(markType);
      state.addText(node5.value);
      state.closeMark(markType);
    }
  },
  serializer: {
    match: (mark3) => mark3.type.name === id$e,
    runner: (state, _3, node5) => {
      state.addNode("inlineCode", void 0, node5.text || "");
      return true;
    }
  },
  inputRules: (markType) => [markRule$1(/(?:^|[^`])(`([^`]+)`)$/, markType)],
  commands: (markType) => [createCmd(ToggleInlineCode, () => toggleMark(markType))],
  shortcuts: {
    [SupportedKeys$2.CodeInline]: createShortcut$1(ToggleInlineCode, "Mod-e")
  }
}));
const id$d = "em";
const ToggleItalic = createCmdKey();
const em = createMark$1((_2, utils) => ({
  id: id$d,
  schema: {
    parseDOM: [
      { tag: "i" },
      { tag: "em" },
      { style: "font-style", getAttrs: (value) => value === "italic" }
    ],
    toDOM: (mark3) => ["em", { class: utils.getClassName(mark3.attrs, id$d) }]
  },
  parser: {
    match: (node5) => node5.type === "emphasis",
    runner: (state, node5, markType) => {
      state.openMark(markType);
      state.next(node5.children);
      state.closeMark(markType);
    }
  },
  serializer: {
    match: (mark3) => mark3.type.name === id$d,
    runner: (state, mark3) => {
      state.withMark(mark3, "emphasis");
    }
  },
  inputRules: (markType) => [
    markRule$1(/(?:^|[^_])(_([^_]+)_)$/, markType),
    markRule$1(/(?:^|[^*])(\*([^*]+)\*)$/, markType)
  ],
  commands: (markType) => [createCmd(ToggleItalic, () => toggleMark(markType))],
  shortcuts: {
    [SupportedKeys$2.Em]: createShortcut$1(ToggleItalic, "Mod-i")
  }
}));
const ToggleLink = createCmdKey();
const ModifyLink = createCmdKey();
const id$c = "link";
const link$1 = createMark$1((_2, utils) => ({
  id: id$c,
  schema: {
    attrs: {
      href: {},
      title: { default: null }
    },
    inclusive: false,
    parseDOM: [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) {
            throw new Error();
          }
          return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
        }
      }
    ],
    toDOM: (mark3) => ["a", Object.assign(Object.assign({}, mark3.attrs), { class: utils.getClassName(mark3.attrs, id$c) })]
  },
  parser: {
    match: (node5) => node5.type === "link",
    runner: (state, node5, markType) => {
      const url = node5.url;
      const title = node5.title;
      state.openMark(markType, { href: url, title });
      state.next(node5.children);
      state.closeMark(markType);
    }
  },
  serializer: {
    match: (mark3) => mark3.type.name === id$c,
    runner: (state, mark3) => {
      state.withMark(mark3, "link", void 0, {
        title: mark3.attrs.title,
        url: mark3.attrs.href
      });
    }
  },
  commands: (markType) => [
    createCmd(ToggleLink, (href = "") => toggleMark(markType, { href })),
    createCmd(ModifyLink, (href = "") => (state, dispatch3) => {
      if (!dispatch3)
        return false;
      const { marks: marks3 } = state.schema;
      let node5;
      let pos = -1;
      const { selection } = state;
      state.doc.nodesBetween(selection.from, selection.to, (n2, p2) => {
        if (marks3.link.isInSet(n2.marks)) {
          node5 = n2;
          pos = p2;
          return false;
        }
        return;
      });
      if (!node5)
        return false;
      const mark3 = node5.marks.find(({ type }) => type === markType);
      if (!mark3)
        return false;
      const start4 = pos;
      const end3 = pos + node5.nodeSize;
      const { tr } = state;
      const linkMark = marks3.link.create(Object.assign(Object.assign({}, mark3.attrs), { href }));
      dispatch3(tr.removeMark(start4, end3, mark3).addMark(start4, end3, linkMark).setSelection(new TextSelection(tr.selection.$anchor)).scrollIntoView());
      return true;
    })
  ],
  inputRules: (markType, schema2) => [
    new InputRule(/\[(?<text>.+?)]\((?<href>.*?)(?=|\))"?(?<title>[^"]+)?"?\)/, (state, match, start4, end3) => {
      const [okay, text3 = "", href, title] = match;
      const { tr } = state;
      if (okay) {
        tr.replaceWith(start4, end3, schema2.text(text3)).addMark(start4, text3.length + start4, markType.create({ title, href }));
      }
      return tr;
    })
  ]
}));
const id$b = "strong";
const ToggleBold = createCmdKey();
const strong = createMark$1((_2, utils) => ({
  id: id$b,
  schema: {
    parseDOM: [
      { tag: "b" },
      { tag: "strong" },
      { style: "font-style", getAttrs: (value) => value === "bold" }
    ],
    toDOM: (mark3) => ["strong", { class: utils.getClassName(mark3.attrs, id$b) }]
  },
  parser: {
    match: (node5) => node5.type === "strong",
    runner: (state, node5, markType) => {
      state.openMark(markType);
      state.next(node5.children);
      state.closeMark(markType);
    }
  },
  serializer: {
    match: (mark3) => mark3.type.name === id$b,
    runner: (state, mark3) => {
      state.withMark(mark3, "strong");
    }
  },
  inputRules: (markType) => [
    markRule$1(/(?:__)([^_]+)(?:__)$/, markType),
    markRule$1(/(?:\*\*)([^*]+)(?:\*\*)$/, markType)
  ],
  commands: (markType) => [createCmd(ToggleBold, () => toggleMark(markType))],
  shortcuts: {
    [SupportedKeys$2.Bold]: createShortcut$1(ToggleBold, "Mod-b")
  }
}));
const marks2 = [codeInline(), em(), strong(), link$1()];
const id$a = "blockquote";
const WrapInBlockquote = createCmdKey();
const blockquote = createNode$2((_2, utils) => ({
  id: id$a,
  schema: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (node5) => ["blockquote", { class: utils.getClassName(node5.attrs, id$a) }, 0]
  },
  parser: {
    match: ({ type }) => type === id$a,
    runner: (state, node5, type) => {
      state.openNode(type).next(node5.children).closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$a,
    runner: (state, node5) => {
      state.openNode("blockquote").next(node5.content).closeNode();
    }
  },
  inputRules: (nodeType2) => [wrappingInputRule(/^\s*>\s$/, nodeType2)],
  commands: (nodeType2) => [createCmd(WrapInBlockquote, () => wrapIn(nodeType2))],
  shortcuts: {
    [SupportedKeys$2.Blockquote]: createShortcut$1(WrapInBlockquote, "Mod-Shift-b")
  }
}));
const WrapInBulletList = createCmdKey();
const id$9 = "bullet_list";
const bulletList = createNode$2((_2, utils) => ({
  id: id$9,
  schema: {
    content: "listItem+",
    group: "block",
    parseDOM: [{ tag: "ul" }],
    toDOM: (node5) => {
      return ["ul", { class: utils.getClassName(node5.attrs, "bullet-list") }, 0];
    }
  },
  parser: {
    match: ({ type, ordered }) => type === "list" && !ordered,
    runner: (state, node5, type) => {
      state.openNode(type).next(node5.children).closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$9,
    runner: (state, node5) => {
      state.openNode("list", void 0, { ordered: false }).next(node5.content).closeNode();
    }
  },
  inputRules: (nodeType2) => [wrappingInputRule(/^\s*([-+*])\s$/, nodeType2)],
  commands: (nodeType2) => [createCmd(WrapInBulletList, () => wrapIn(nodeType2))],
  shortcuts: {
    [SupportedKeys$2.BulletList]: createShortcut$1(WrapInBulletList, "Mod-Shift-8")
  }
}));
const languageOptions = [
  "",
  "javascript",
  "typescript",
  "bash",
  "sql",
  "json",
  "html",
  "css",
  "c",
  "cpp",
  "java",
  "ruby",
  "python",
  "go",
  "rust",
  "markdown"
];
const inputRegex = /^```(?<language>[a-z]*)? $/;
const TurnIntoCodeFence = createCmdKey();
const id$8 = "fence";
const codeFence = createNode$2((options, utils) => ({
  id: id$8,
  schema: {
    content: "text*",
    group: "block",
    marks: "",
    defining: true,
    code: true,
    attrs: {
      language: {
        default: ""
      },
      fold: {
        default: true
      }
    },
    parseDOM: [
      {
        tag: "pre",
        preserveWhitespace: "full",
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) {
            throw new Error("Parse DOM error.");
          }
          return { language: dom.dataset.language };
        }
      }
    ],
    toDOM: (node5) => {
      return [
        "div",
        {
          "data-language": node5.attrs.language,
          class: utils.getClassName(node5.attrs, "code-fence")
        },
        ["pre", ["code", { spellCheck: "false" }, 0]]
      ];
    }
  },
  parser: {
    match: ({ type }) => type === "code",
    runner: (state, node5, type) => {
      const language = node5.lang;
      const value = node5.value;
      state.openNode(type, { language });
      state.addText(value);
      state.closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$8,
    runner: (state, node5) => {
      var _a;
      state.addNode("code", void 0, ((_a = node5.content.firstChild) === null || _a === void 0 ? void 0 : _a.text) || "", { lang: node5.attrs.language });
    }
  },
  inputRules: (nodeType2) => [
    textblockTypeInputRule(inputRegex, nodeType2, ([ok3, language]) => {
      if (!ok3)
        return;
      return { language };
    })
  ],
  commands: (nodeType2) => [createCmd(TurnIntoCodeFence, () => setBlockType(nodeType2))],
  shortcuts: {
    [SupportedKeys$2.CodeFence]: createShortcut$1(TurnIntoCodeFence, "Mod-Alt-c")
  },
  view: (editor, nodeType2, node5, view, getPos, decorations) => {
    if (options === null || options === void 0 ? void 0 : options.view) {
      return options.view(editor, nodeType2, node5, view, getPos, decorations);
    }
    const container = document.createElement("div");
    const selectWrapper = document.createElement("div");
    const select = document.createElement("ul");
    const pre = document.createElement("pre");
    const code2 = document.createElement("code");
    const valueWrapper = document.createElement("div");
    valueWrapper.className = "code-fence_value";
    const value = document.createElement("span");
    const button = document.createElement("span");
    button.className = "icon material-icons material-icons-outlined";
    button.textContent = "expand_more";
    valueWrapper.appendChild(value);
    valueWrapper.appendChild(button);
    select.className = "code-fence_select";
    select.addEventListener("mousedown", (e3) => {
      e3.preventDefault();
      e3.stopPropagation();
      if (!view.editable)
        return;
      const el2 = e3.target;
      if (!(el2 instanceof HTMLLIElement))
        return;
      const { tr } = view.state;
      view.dispatch(tr.setNodeMarkup(getPos(), void 0, {
        fold: true,
        language: el2.dataset.value
      }));
    });
    valueWrapper.addEventListener("mousedown", (e3) => {
      e3.preventDefault();
      e3.stopPropagation();
      if (!view.editable)
        return;
      const { tr } = view.state;
      view.dispatch(tr.setNodeMarkup(getPos(), void 0, {
        fold: false,
        language: container.dataset.language
      }));
    });
    document.addEventListener("mousedown", () => {
      if (!view.editable || select.dataset.fold === "true")
        return;
      const { tr } = view.state;
      view.dispatch(tr.setNodeMarkup(getPos(), void 0, {
        fold: true,
        language: container.dataset.language
      }));
    });
    languageOptions.concat((options === null || options === void 0 ? void 0 : options.languageList) || []).forEach((lang) => {
      const option = document.createElement("li");
      option.className = "code-fence_select-option";
      option.innerText = lang || "--";
      select.appendChild(option);
      option.setAttribute("data-value", lang);
    });
    code2.spellcheck = false;
    selectWrapper.className = "code-fence_select-wrapper";
    selectWrapper.contentEditable = "false";
    selectWrapper.append(valueWrapper);
    selectWrapper.append(select);
    pre.append(code2);
    container.append(selectWrapper, pre);
    container.setAttribute("class", utils.getClassName(node5.attrs, "code-fence"));
    container.setAttribute("data-language", node5.attrs.language);
    value.innerText = node5.attrs.language || "--";
    select.setAttribute("data-fold", node5.attrs.fold ? "true" : "false");
    return {
      dom: container,
      contentDOM: code2,
      update: (updatedNode) => {
        if (updatedNode.type.name !== id$8)
          return false;
        const lang = updatedNode.attrs.language;
        container.dataset.language = lang;
        value.innerText = lang || "--";
        select.setAttribute("data-fold", updatedNode.attrs.fold ? "true" : "false");
        return true;
      }
    };
  }
}));
const doc = createNode$2(() => ({
  id: "doc",
  schema: {
    content: "block+"
  },
  parser: {
    match: ({ type }) => type === "root",
    runner: (state, node5, type) => {
      state.injectRoot(node5, type);
    }
  },
  serializer: {
    match: (node5) => node5.type.name === "doc",
    runner: (state, node5) => {
      state.openNode("root");
      state.next(node5.content);
    }
  }
}));
const id$7 = "hardbreak";
const InsertHardbreak = createCmdKey();
const hardbreak = createNode$2((_2, utils) => ({
  id: id$7,
  schema: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{ tag: "br" }],
    toDOM: (node5) => ["br", { class: utils.getClassName(node5.attrs, id$7) }]
  },
  parser: {
    match: ({ type }) => type === "break",
    runner: (state, _3, type) => {
      state.addNode(type);
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$7,
    runner: (state) => {
      state.addNode("break");
    }
  },
  commands: (nodeType2) => [
    createCmd(InsertHardbreak, () => (state, dispatch3) => {
      dispatch3 === null || dispatch3 === void 0 ? void 0 : dispatch3(state.tr.replaceSelectionWith(nodeType2.create()).scrollIntoView());
      return true;
    })
  ],
  shortcuts: {
    [SupportedKeys$2.HardBreak]: createShortcut$1(InsertHardbreak, "Shift-Enter")
  }
}));
const headingIndex = Array(5).fill(0).map((_2, i2) => i2 + 1);
const id$6 = "heading";
const TurnIntoHeading = createCmdKey();
const heading = createNode$2((_2, utils) => ({
  id: id$6,
  schema: {
    content: "inline*",
    group: "block",
    attrs: {
      level: {
        default: 1
      }
    },
    parseDOM: headingIndex.map((x2) => ({ tag: `h${x2}`, attrs: { level: x2 } })),
    toDOM: (node5) => [
      `h${node5.attrs.level}`,
      { class: utils.getClassName(node5.attrs, `heading h${node5.attrs.level}`) },
      0
    ]
  },
  parser: {
    match: ({ type }) => type === id$6,
    runner: (state, node5, type) => {
      const depth = node5.depth;
      state.openNode(type, { level: depth });
      state.next(node5.children);
      state.closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$6,
    runner: (state, node5) => {
      state.openNode("heading", void 0, { depth: node5.attrs.level });
      state.next(node5.content);
      state.closeNode();
    }
  },
  inputRules: (nodeType2) => headingIndex.map((x2) => textblockTypeInputRule(new RegExp(`^(#{1,${x2}})\\s$`), nodeType2, () => ({
    level: x2
  }))),
  commands: (nodeType2) => [createCmd(TurnIntoHeading, (level = 1) => setBlockType(nodeType2, { level }))],
  shortcuts: {
    [SupportedKeys$2.H1]: createShortcut$1(TurnIntoHeading, "Mod-Alt-1", 1),
    [SupportedKeys$2.H2]: createShortcut$1(TurnIntoHeading, "Mod-Alt-2", 2),
    [SupportedKeys$2.H3]: createShortcut$1(TurnIntoHeading, "Mod-Alt-3", 3),
    [SupportedKeys$2.H4]: createShortcut$1(TurnIntoHeading, "Mod-Alt-4", 4),
    [SupportedKeys$2.H5]: createShortcut$1(TurnIntoHeading, "Mod-Alt-5", 5),
    [SupportedKeys$2.H6]: createShortcut$1(TurnIntoHeading, "Mod-Alt-6", 6)
  }
}));
const id$5 = "hr";
const InsertHr = createCmdKey();
const hr = createNode$2((_2, utils) => ({
  id: id$5,
  schema: {
    group: "block",
    parseDOM: [{ tag: "hr" }],
    toDOM: (node5) => ["hr", { class: utils.getClassName(node5.attrs, id$5) }]
  },
  parser: {
    match: ({ type }) => type === "thematicBreak",
    runner: (state, _3, type) => {
      state.addNode(type);
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$5,
    runner: (state) => {
      state.addNode("thematicBreak");
    }
  },
  inputRules: (nodeType2) => [
    new InputRule(/^(?:---|___\s|\*\*\*\s)$/, (state, match, start4, end3) => {
      const { tr } = state;
      if (match[0]) {
        tr.replaceWith(start4, end3, nodeType2.create({}));
      }
      return tr;
    })
  ],
  commands: (nodeType2, schema2) => [
    createCmd(InsertHr, () => (state, dispatch3) => {
      if (!dispatch3)
        return true;
      const { tr, selection } = state;
      const from5 = selection.from;
      const node5 = nodeType2.create();
      if (!node5) {
        return true;
      }
      const _tr = tr.replaceSelectionWith(node5).insert(from5, schema2.node("paragraph"));
      const sel = Selection.findFrom(_tr.doc.resolve(from5), 1, true);
      if (!sel) {
        return true;
      }
      dispatch3(_tr.setSelection(sel).scrollIntoView());
      return true;
    })
  ]
}));
const ModifyImage = createCmdKey();
const InsertImage = createCmdKey();
const id$4 = "image";
const image = createNode$2((_2, utils) => ({
  id: id$4,
  schema: {
    inline: true,
    group: "inline",
    draggable: true,
    selectable: true,
    marks: "",
    attrs: {
      src: { default: "" },
      alt: { default: null },
      title: { default: null }
    },
    parseDOM: [
      {
        tag: "img[src]",
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) {
            throw new Error();
          }
          return {
            src: dom.getAttribute("src") || "",
            alt: dom.getAttribute("alt"),
            title: dom.getAttribute("title")
          };
        }
      }
    ],
    toDOM: (node5) => {
      var _a;
      if (((_a = node5.attrs.src) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        return ["img", Object.assign(Object.assign({}, node5.attrs), { class: utils.getClassName(node5.attrs, id$4) })];
      }
      return [
        "div",
        Object.assign(Object.assign({}, node5.attrs), { class: utils.getClassName(node5.attrs, "image empty") }),
        ["span", { contentEditable: "false", class: "icon" }],
        ["span", { contentEditable: "false", class: "placeholder" }]
      ];
    }
  },
  parser: {
    match: ({ type }) => type === id$4,
    runner: (state, node5, type) => {
      const url = node5.url;
      const alt = node5.alt;
      const title = node5.title;
      state.addNode(type, {
        src: url,
        alt,
        title
      });
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$4,
    runner: (state, node5) => {
      state.addNode("image", void 0, void 0, {
        title: node5.attrs.title,
        url: node5.attrs.src,
        alt: node5.attrs.alt
      });
    }
  },
  commands: (nodeType2, schema2) => [
    createCmd(InsertImage, (src = "") => (state, dispatch3) => {
      if (!dispatch3)
        return true;
      const { tr } = state;
      const node5 = nodeType2.create({ src });
      if (!node5) {
        return true;
      }
      const _tr = tr.replaceSelectionWith(node5);
      const { $from } = _tr.selection;
      const start4 = $from.start();
      const __tr = _tr.replaceSelectionWith(schema2.node("paragraph"));
      const sel = NodeSelection.create(__tr.doc, start4);
      dispatch3(__tr.setSelection(sel));
      return true;
    }),
    createCmd(ModifyImage, (src = "") => (state, dispatch3) => {
      const node5 = findSelectedNodeOfType$1(state.selection, nodeType2);
      if (!node5)
        return false;
      const { tr } = state;
      dispatch3 === null || dispatch3 === void 0 ? void 0 : dispatch3(tr.setNodeMarkup(node5.pos, void 0, Object.assign(Object.assign({}, node5.node.attrs), { src })).scrollIntoView());
      return true;
    })
  ],
  inputRules: (nodeType2) => [
    new InputRule(/!\[(?<alt>.*?)]\((?<filename>.*?)(?=|\))"?(?<title>[^"]+)?"?\)/, (state, match, start4, end3) => {
      const [okay, alt, src = "", title] = match;
      const { tr } = state;
      if (okay) {
        tr.replaceWith(start4, end3, nodeType2.create({ src, alt, title }));
      }
      return tr;
    })
  ]
}));
function splitListItem(itemType) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var node5 = ref.node;
    if (node5 && node5.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) {
      return false;
    }
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch3) {
        var wrap2 = Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (var d2 = $from.depth - depthBefore; d2 >= $from.depth - 3; d2--) {
          wrap2 = Fragment.from($from.node(d2).copy(wrap2));
        }
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        wrap2 = wrap2.append(Fragment.from(itemType.createAndFill()));
        var start4 = $from.before($from.depth - (depthBefore - 1));
        var tr$1 = state.tr.replace(start4, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
        var sel = -1;
        tr$1.doc.nodesBetween(start4, tr$1.doc.content.size, function(node6, pos) {
          if (sel > -1) {
            return false;
          }
          if (node6.isTextblock && node6.content.size == 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve(sel)));
        }
        dispatch3(tr$1.scrollIntoView());
      }
      return true;
    }
    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var tr = state.tr.delete($from.pos, $to.pos);
    var types = nextType && [null, { type: nextType }];
    if (!canSplit(tr.doc, $from.pos, 2, types)) {
      return false;
    }
    if (dispatch3) {
      dispatch3(tr.split($from.pos, 2, types).scrollIntoView());
    }
    return true;
  };
}
function liftListItem(itemType) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function(node5) {
      return node5.childCount && node5.firstChild.type == itemType;
    });
    if (!range) {
      return false;
    }
    if (!dispatch3) {
      return true;
    }
    if ($from.node(range.depth - 1).type == itemType) {
      return liftToOuterList(state, dispatch3, itemType, range);
    } else {
      return liftOutOfList(state, dispatch3, range);
    }
  };
}
function liftToOuterList(state, dispatch3, itemType, range) {
  var tr = state.tr, end3 = range.end, endOfList = range.$to.end(range.depth);
  if (end3 < endOfList) {
    tr.step(new ReplaceAroundStep(end3 - 1, endOfList, end3, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  dispatch3(tr.lift(range, liftTarget(range)).scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch3, range) {
  var tr = state.tr, list2 = range.parent;
  for (var pos = range.end, i2 = range.endIndex - 1, e3 = range.startIndex; i2 > e3; i2--) {
    pos -= list2.child(i2).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  var atStart2 = range.startIndex == 0, atEnd2 = range.endIndex == list2.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart2 ? 0 : 1), indexBefore + 1, item.content.append(atEnd2 ? Fragment.empty : Fragment.from(list2)))) {
    return false;
  }
  var start4 = $start.pos, end3 = start4 + item.nodeSize;
  tr.step(new ReplaceAroundStep(start4 - (atStart2 ? 1 : 0), end3 + (atEnd2 ? 1 : 0), start4 + 1, end3 - 1, new Slice((atStart2 ? Fragment.empty : Fragment.from(list2.copy(Fragment.empty))).append(atEnd2 ? Fragment.empty : Fragment.from(list2.copy(Fragment.empty))), atStart2 ? 0 : 1, atEnd2 ? 0 : 1), atStart2 ? 0 : 1));
  dispatch3(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch3) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function(node5) {
      return node5.childCount && node5.firstChild.type == itemType;
    });
    if (!range) {
      return false;
    }
    var startIndex = range.startIndex;
    if (startIndex == 0) {
      return false;
    }
    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) {
      return false;
    }
    if (dispatch3) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = Fragment.from(nestedBefore ? itemType.create() : null);
      var slice5 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before2 = range.start, after2 = range.end;
      dispatch3(state.tr.step(new ReplaceAroundStep(before2 - (nestedBefore ? 3 : 1), after2, before2, after2, slice5, 1, true)).scrollIntoView());
    }
    return true;
  };
}
const id$3 = "list_item";
const SplitListItem = createCmdKey();
const SinkListItem = createCmdKey();
const LiftListItem = createCmdKey();
const listItem = createNode$2((_2, utils) => ({
  id: id$3,
  schema: {
    group: "listItem",
    content: "paragraph block*",
    defining: true,
    parseDOM: [{ tag: "li" }],
    toDOM: (node5) => ["li", { class: utils.getClassName(node5.attrs, "list-item") }, 0]
  },
  parser: {
    match: ({ type, checked }) => type === "listItem" && checked === null,
    runner: (state, node5, type) => {
      state.openNode(type);
      state.next(node5.children);
      state.closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$3,
    runner: (state, node5) => {
      state.openNode("listItem");
      state.next(node5.content);
      state.closeNode();
    }
  },
  inputRules: (nodeType2) => [wrappingInputRule(/^\s*([-+*])\s$/, nodeType2)],
  commands: (nodeType2) => [
    createCmd(SplitListItem, () => splitListItem(nodeType2)),
    createCmd(SinkListItem, () => sinkListItem(nodeType2)),
    createCmd(LiftListItem, () => liftListItem(nodeType2))
  ],
  shortcuts: {
    [SupportedKeys$2.NextListItem]: createShortcut$1(SplitListItem, "Enter"),
    [SupportedKeys$2.SinkListItem]: createShortcut$1(SinkListItem, "Mod-]"),
    [SupportedKeys$2.LiftListItem]: createShortcut$1(LiftListItem, "Mod-[")
  }
}));
const WrapInOrderedList = createCmdKey();
const id$2 = "ordered_list";
const orderedList = createNode$2((_2, utils) => ({
  id: id$2,
  schema: {
    content: "listItem+",
    group: "block",
    attrs: {
      order: {
        default: 1
      }
    },
    parseDOM: [
      {
        tag: "ol",
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) {
            throw new Error();
          }
          return { order: dom.hasAttribute("start") ? Number(dom.getAttribute("start")) : 1 };
        }
      }
    ],
    toDOM: (node5) => [
      "ol",
      Object.assign(Object.assign({}, node5.attrs.order === 1 ? {} : node5.attrs.order), { class: utils.getClassName(node5.attrs, "ordered-list") }),
      0
    ]
  },
  parser: {
    match: ({ type, ordered }) => type === "list" && !!ordered,
    runner: (state, node5, type) => {
      state.openNode(type).next(node5.children).closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === id$2,
    runner: (state, node5) => {
      state.openNode("list", void 0, { ordered: true, start: 1 });
      state.next(node5.content);
      state.closeNode();
    }
  },
  inputRules: (nodeType2) => [
    wrappingInputRule(/^(\d+)\.\s$/, nodeType2, (match) => ({ order: Number(match[1]) }), (match, node5) => node5.childCount + node5.attrs.order === Number(match[1]))
  ],
  commands: (nodeType2) => [createCmd(WrapInOrderedList, () => wrapIn(nodeType2))],
  shortcuts: {
    [SupportedKeys$2.OrderedList]: createShortcut$1(WrapInOrderedList, "Mod-Shift-7")
  }
}));
const TurnIntoText = createCmdKey();
const id$1 = "paragraph";
const paragraph = createNode$2((_2, utils) => ({
  id: id$1,
  schema: {
    content: "inline*",
    group: "block",
    parseDOM: [{ tag: "p" }],
    toDOM: (node5) => ["p", { class: utils.getClassName(node5.attrs, id$1) }, 0]
  },
  parser: {
    match: (node5) => node5.type === "paragraph",
    runner: (state, node5, type) => {
      state.openNode(type);
      if (node5.children) {
        state.next(node5.children);
      } else {
        state.addText(node5.value);
      }
      state.closeNode();
    }
  },
  serializer: {
    match: (node5) => node5.type.name === "paragraph",
    runner: (state, node5) => {
      state.openNode("paragraph");
      state.next(node5.content);
      state.closeNode();
    }
  },
  commands: (nodeType2) => [createCmd(TurnIntoText, () => setBlockType(nodeType2))],
  shortcuts: {
    [SupportedKeys$2.Text]: createShortcut$1(TurnIntoText, "Mod-Alt-0")
  }
}));
const text$1 = createNode$2(() => ({
  id: "text",
  schema: {
    group: "inline"
  },
  parser: {
    match: ({ type }) => type === "text",
    runner: (state, node5) => {
      state.addText(node5.value);
    }
  },
  serializer: {
    match: (node5) => node5.type.name === "text",
    runner: (state, node5) => {
      state.addNode("text", void 0, node5.text);
    }
  }
}));
const nodes$1 = [
  doc(),
  paragraph(),
  hardbreak(),
  blockquote(),
  codeFence(),
  bulletList(),
  orderedList(),
  listItem(),
  heading(),
  hr(),
  image(),
  text$1()
];
var convert_1 = convert$2;
function convert$2(test) {
  if (test == null) {
    return ok$1;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return "length" in test ? anyFactory(test) : allFactory(test);
  }
  if (typeof test === "function") {
    return test;
  }
  throw new Error("Expected function, string, or object as test");
}
function allFactory(test) {
  return all2;
  function all2(node5) {
    var key2;
    for (key2 in test) {
      if (node5[key2] !== test[key2])
        return false;
    }
    return true;
  }
}
function anyFactory(tests) {
  var checks = [];
  var index3 = -1;
  while (++index3 < tests.length) {
    checks[index3] = convert$2(tests[index3]);
  }
  return any;
  function any() {
    var index4 = -1;
    while (++index4 < checks.length) {
      if (checks[index4].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory(test) {
  return type;
  function type(node5) {
    return Boolean(node5 && node5.type === test);
  }
}
function ok$1() {
  return true;
}
var color_browser = identity;
function identity(d2) {
  return d2;
}
var unistUtilVisitParents = visitParents$1;
var convert$1 = convert_1;
var color = color_browser;
var CONTINUE$1 = true;
var SKIP$1 = "skip";
var EXIT$1 = false;
visitParents$1.CONTINUE = CONTINUE$1;
visitParents$1.SKIP = SKIP$1;
visitParents$1.EXIT = EXIT$1;
function visitParents$1(tree, test, visitor, reverse) {
  var step3;
  var is3;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  is3 = convert$1(test);
  step3 = reverse ? -1 : 1;
  factory2(tree, null, [])();
  function factory2(node5, index3, parents) {
    var value = typeof node5 === "object" && node5 !== null ? node5 : {};
    var name;
    if (typeof value.type === "string") {
      name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      visit2.displayName = "node (" + color(value.type + (name ? "<" + name + ">" : "")) + ")";
    }
    return visit2;
    function visit2() {
      var grandparents = parents.concat(node5);
      var result2 = [];
      var subresult;
      var offset2;
      if (!test || is3(node5, index3, parents[parents.length - 1] || null)) {
        result2 = toResult(visitor(node5, parents));
        if (result2[0] === EXIT$1) {
          return result2;
        }
      }
      if (node5.children && result2[0] !== SKIP$1) {
        offset2 = (reverse ? node5.children.length : -1) + step3;
        while (offset2 > -1 && offset2 < node5.children.length) {
          subresult = factory2(node5.children[offset2], offset2, grandparents)();
          if (subresult[0] === EXIT$1) {
            return subresult;
          }
          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step3;
        }
      }
      return result2;
    }
  }
}
function toResult(value) {
  if (value !== null && typeof value === "object" && "length" in value) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return [value];
}
var unistUtilVisit = visit$4;
var visitParents = unistUtilVisitParents;
var CONTINUE = visitParents.CONTINUE;
var SKIP = visitParents.SKIP;
var EXIT = visitParents.EXIT;
visit$4.CONTINUE = CONTINUE;
visit$4.SKIP = SKIP;
visit$4.EXIT = EXIT;
function visit$4(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node5, parents) {
    var parent = parents[parents.length - 1];
    var index3 = parent ? parent.children.indexOf(node5) : null;
    return visitor(node5, index3, parent);
  }
}
var visit$3 = unistUtilVisit;
var mdastUtilDefinitions = getDefinitionFactory;
var own$1 = {}.hasOwnProperty;
function getDefinitionFactory(node5, options) {
  return getterFactory(gather(node5));
}
function gather(node5) {
  var cache = {};
  if (!node5 || !node5.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit$3(node5, "definition", ondefinition);
  return cache;
  function ondefinition(definition2) {
    var id2 = normalise(definition2.identifier);
    if (!own$1.call(cache, id2)) {
      cache[id2] = definition2;
    }
  }
}
function getterFactory(cache) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise(identifier);
    return id2 && own$1.call(cache, id2) ? cache[id2] : null;
  }
}
function normalise(identifier) {
  return identifier.toUpperCase();
}
var visit$2 = unistUtilVisit;
var getDefinitions = mdastUtilDefinitions;
var remarkInlineLinks = inlineLinks;
function inlineLinks() {
  return transformer;
  function transformer(tree) {
    var definitions = getDefinitions(tree);
    visit$2(tree, onvisit);
    function onvisit(node5, index3, parent) {
      var definition2;
      var replacement;
      var image2;
      if (node5.type === "definition") {
        parent.children.splice(index3, 1);
        return [visit$2.SKIP, index3];
      }
      if (node5.type === "imageReference" || node5.type === "linkReference") {
        definition2 = definitions(node5.identifier);
        if (definition2) {
          image2 = node5.type === "imageReference";
          replacement = {
            type: image2 ? "image" : "link",
            url: definition2.url,
            title: definition2.title
          };
          if (image2) {
            replacement.alt = node5.alt;
          } else {
            replacement.children = node5.children;
          }
          parent.children[index3] = replacement;
          return [visit$2.SKIP, index3];
        }
      }
    }
  }
}
const commonmarkPlugins = [remarkPluginFactory(remarkInlineLinks)];
const commonmarkNodes = AtomList$1.create([...nodes$1, ...marks2]);
const commonmark = [...commonmarkPlugins, ...commonmarkNodes];
const commands = {
  ToggleInlineCode,
  ToggleItalic,
  ToggleLink,
  ToggleBold,
  ModifyLink,
  ModifyImage,
  WrapInBlockquote,
  WrapInBulletList,
  WrapInOrderedList,
  TurnIntoCodeFence,
  TurnIntoHeading,
  TurnIntoText,
  InsertHardbreak,
  InsertHr,
  InsertImage,
  SplitListItem,
  SinkListItem,
  LiftListItem
};
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice4(from5, to2) {
  if (from5 === void 0)
    from5 = 0;
  if (to2 === void 0)
    to2 = this.length;
  if (from5 >= to2) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from5), Math.min(this.length, to2));
};
RopeSequence.prototype.get = function get2(i2) {
  if (i2 < 0 || i2 >= this.length) {
    return void 0;
  }
  return this.getInner(i2);
};
RopeSequence.prototype.forEach = function forEach4(f2, from5, to2) {
  if (from5 === void 0)
    from5 = 0;
  if (to2 === void 0)
    to2 = this.length;
  if (from5 <= to2) {
    this.forEachInner(f2, from5, to2, 0);
  } else {
    this.forEachInvertedInner(f2, from5, to2, 0);
  }
};
RopeSequence.prototype.map = function map13(f2, from5, to2) {
  if (from5 === void 0)
    from5 = 0;
  if (to2 === void 0)
    to2 = this.length;
  var result2 = [];
  this.forEach(function(elt, i2) {
    return result2.push(f2(elt, i2));
  }, from5, to2);
  return result2;
};
RopeSequence.from = function from3(values2) {
  if (values2 instanceof RopeSequence) {
    return values2;
  }
  return values2 && values2.length ? new Leaf(values2) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values2) {
    RopeSequence3.call(this);
    this.values = values2;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors2 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten2() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from5, to2) {
    if (from5 == 0 && to2 == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from5, to2));
  };
  Leaf2.prototype.getInner = function getInner(i2) {
    return this.values[i2];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f2, from5, to2, start4) {
    for (var i2 = from5; i2 < to2; i2++) {
      if (f2(this.values[i2], start4 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from5, to2, start4) {
    for (var i2 = from5 - 1; i2 >= to2; i2--) {
      if (f2(this.values[i2], start4 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors2);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten2() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i2) {
    return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f2, from5, to2, start4) {
    var leftLen = this.left.length;
    if (from5 < leftLen && this.left.forEachInner(f2, from5, Math.min(to2, leftLen), start4) === false) {
      return false;
    }
    if (to2 > leftLen && this.right.forEachInner(f2, Math.max(from5 - leftLen, 0), Math.min(this.length, to2) - leftLen, start4 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from5, to2, start4) {
    var leftLen = this.left.length;
    if (from5 > leftLen && this.right.forEachInvertedInner(f2, from5 - leftLen, Math.max(to2, leftLen) - leftLen, start4 + leftLen) === false) {
      return false;
    }
    if (to2 < leftLen && this.left.forEachInvertedInner(f2, Math.min(from5, leftLen), to2, start4) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from5, to2) {
    if (from5 == 0 && to2 == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to2 <= leftLen) {
      return this.left.slice(from5, to2);
    }
    if (from5 >= leftLen) {
      return this.right.slice(from5 - leftLen, to2 - leftLen);
    }
    return this.left.slice(from5, leftLen).append(this.right.slice(0, to2 - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var ropeSequence = RopeSequence;
var max_empty_items = 500;
var Branch = function Branch2(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};
Branch.prototype.popEvent = function popEvent(state, preserveItems) {
  var this$1$1 = this;
  if (this.eventCount == 0) {
    return null;
  }
  var end3 = this.items.length;
  for (; ; end3--) {
    var next = this.items.get(end3 - 1);
    if (next.selection) {
      --end3;
      break;
    }
  }
  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end3, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];
  this.items.forEach(function(item, i2) {
    if (!item.step) {
      if (!remap) {
        remap = this$1$1.remapping(end3, i2 + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return;
    }
    if (remap) {
      addBefore.push(new Item(item.map));
      var step3 = item.step.map(remap.slice(mapFrom)), map21;
      if (step3 && transform.maybeStep(step3).doc) {
        map21 = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map21, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map21) {
        remap.appendMap(map21, mapFrom);
      }
    } else {
      transform.maybeStep(item.step);
    }
    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1$1.items.slice(0, end3).append(addBefore.reverse().concat(addAfter)), this$1$1.eventCount - 1);
      return false;
    }
  }, this.items.length, 0);
  return { remaining, transform, selection };
};
Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
  for (var i2 = 0; i2 < transform.steps.length; i2++) {
    var step3 = transform.steps[i2].invert(transform.docs[i2]);
    var item = new Item(transform.mapping.maps[i2], step3, selection), merged = void 0;
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i2) {
        newItems.pop();
      } else {
        oldItems = oldItems.slice(0, oldItems.length - 1);
      }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) {
      lastItem = item;
    }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount);
};
Branch.prototype.remapping = function remapping(from5, to2) {
  var maps = new Mapping();
  this.items.forEach(function(item, i2) {
    var mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from5 ? maps.maps.length - item.mirrorOffset : null;
    maps.appendMap(item.map, mirrorPos);
  }, from5, to2);
  return maps;
};
Branch.prototype.addMaps = function addMaps(array) {
  if (this.eventCount == 0) {
    return this;
  }
  return new Branch(this.items.append(array.map(function(map21) {
    return new Item(map21);
  })), this.eventCount);
};
Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
  if (!this.eventCount) {
    return this;
  }
  var rebasedItems = [], start4 = Math.max(0, this.items.length - rebasedCount);
  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function(item) {
    if (item.selection) {
      eventCount--;
    }
  }, start4);
  var iRebased = rebasedCount;
  this.items.forEach(function(item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) {
      return;
    }
    newUntil = Math.min(newUntil, pos);
    var map21 = mapping.maps[pos];
    if (item.step) {
      var step3 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) {
        eventCount++;
      }
      rebasedItems.push(new Item(map21, step3, selection));
    } else {
      rebasedItems.push(new Item(map21));
    }
  }, start4);
  var newMaps = [];
  for (var i2 = rebasedCount; i2 < newUntil; i2++) {
    newMaps.push(new Item(mapping.maps[i2]));
  }
  var items = this.items.slice(0, start4).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);
  if (branch.emptyItemCount() > max_empty_items) {
    branch = branch.compress(this.items.length - rebasedItems.length);
  }
  return branch;
};
Branch.prototype.emptyItemCount = function emptyItemCount() {
  var count = 0;
  this.items.forEach(function(item) {
    if (!item.step) {
      count++;
    }
  });
  return count;
};
Branch.prototype.compress = function compress(upto) {
  if (upto === void 0)
    upto = this.items.length;
  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events = 0;
  this.items.forEach(function(item, i2) {
    if (i2 >= upto) {
      items.push(item);
      if (item.selection) {
        events++;
      }
    } else if (item.step) {
      var step3 = item.step.map(remap.slice(mapFrom)), map21 = step3 && step3.getMap();
      mapFrom--;
      if (map21) {
        remap.appendMap(map21, mapFrom);
      }
      if (step3) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) {
          events++;
        }
        var newItem = new Item(map21.invert(), step3, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem)) {
          items[last] = merged;
        } else {
          items.push(newItem);
        }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(ropeSequence.from(items.reverse()), events);
};
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n2) {
  var cutPoint;
  items.forEach(function(item, i2) {
    if (item.selection && n2-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = function Item2(map21, step3, selection, mirrorOffset) {
  this.map = map21;
  this.step = step3;
  this.selection = selection;
  this.mirrorOffset = mirrorOffset;
};
Item.prototype.merge = function merge2(other) {
  if (this.step && other.step && !other.selection) {
    var step3 = other.step.merge(this.step);
    if (step3) {
      return new Item(step3.getMap().invert(), step3, this.selection);
    }
  }
};
var HistoryState = function HistoryState2(done3, undone, prevRanges, prevTime) {
  this.done = done3;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction2(history2, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased2;
  if (historyTr) {
    return historyTr.historyState;
  }
  if (tr.getMeta(closeHistoryKey)) {
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  }
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) {
      return new HistoryState(history2.done.addTransform(tr, null, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
    } else {
      return new HistoryState(history2.done, history2.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history2.prevTime);
    }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased2 = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased2), history2.undone.rebased(tr, rebased2), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) {
    return false;
  }
  if (!transform.docChanged) {
    return true;
  }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function(start4, end3) {
    for (var i2 = 0; i2 < prevRanges.length; i2 += 2) {
      if (start4 <= prevRanges[i2 + 1] && end3 >= prevRanges[i2]) {
        adjacent = true;
      }
    }
  });
  return adjacent;
}
function rangesFor(map21) {
  var result2 = [];
  map21.forEach(function(_from, _to, from5, to2) {
    return result2.push(from5, to2);
  });
  return result2;
}
function mapRanges(ranges, mapping) {
  if (!ranges) {
    return null;
  }
  var result2 = [];
  for (var i2 = 0; i2 < ranges.length; i2 += 2) {
    var from5 = mapping.map(ranges[i2], 1), to2 = mapping.map(ranges[i2 + 1], -1);
    if (from5 <= to2) {
      result2.push(from5, to2);
    }
  }
  return result2;
}
function histTransaction(history2, state, dispatch3, redo2) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop) {
    return;
  }
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch3(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i2 = 0; i2 < plugins.length; i2++) {
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history$1(config2) {
  config2 = {
    depth: config2 && config2.depth || 100,
    newGroupDelay: config2 && config2.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init: function init6() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply9(tr, hist, state) {
        return applyTransaction2(hist, state, tr, config2);
      }
    },
    config: config2,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e3) {
          var handled = e3.inputType == "historyUndo" ? undo(view.state, view.dispatch) : e3.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
          if (handled) {
            e3.preventDefault();
          }
          return handled;
        }
      }
    }
  });
}
function undo(state, dispatch3) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) {
    return false;
  }
  if (dispatch3) {
    histTransaction(hist, state, dispatch3, false);
  }
  return true;
}
function redo(state, dispatch3) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) {
    return false;
  }
  if (dispatch3) {
    histTransaction(hist, state, dispatch3, true);
  }
  return true;
}
const history = prosePluginFactory([
  history$1(),
  keymap$1({
    "Mod-z": undo,
    "Mod-y": redo,
    "Shift-Mod-z": redo
  })
]);
const clipboardPlugin = (schema2, parser2, serializer2) => new Plugin({
  props: {
    handlePaste: (view, event) => {
      var _a, _b;
      const editable = (_b = (_a = view.props).editable) === null || _b === void 0 ? void 0 : _b.call(_a, view.state);
      const { clipboardData } = event;
      if (!editable || !clipboardData) {
        return false;
      }
      const text3 = clipboardData.getData("text/plain");
      const html2 = clipboardData.getData("text/html");
      if (html2.length > 0) {
        return false;
      }
      const slice5 = parser2(text3);
      if (!slice5 || typeof slice5 === "string")
        return false;
      const { $from } = view.state.selection;
      const depth = slice5.content.childCount > 1 ? 0 : $from.depth;
      view.dispatch(view.state.tr.replaceSelection(new Slice(slice5.content, depth, depth)));
      return true;
    },
    clipboardTextSerializer: (slice5) => {
      const doc2 = schema2.topNodeType.createAndFill(void 0, slice5.content);
      if (!doc2)
        return "";
      const value = serializer2(doc2);
      return value;
    }
  }
});
const clipboard$1 = () => {
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield Promise.all([ctx.wait(ParserReady), ctx.wait(SerializerReady)]);
    const schema2 = ctx.get(schemaCtx);
    const parser2 = ctx.get(parserCtx);
    const serializer2 = ctx.get(serializerCtx);
    const plugin2 = clipboardPlugin(schema2, parser2, serializer2);
    ctx.update(prosePluginsCtx, (prev) => prev.concat(plugin2));
  });
};
const elementIsTag = (element, tagName) => element.tagName === tagName.toUpperCase();
const icon$1 = (text3) => {
  const span = document.createElement("span");
  span.textContent = text3;
  span.className = "icon material-icons";
  return span;
};
const cloneTr = (tr) => {
  return Object.assign(Object.create(tr), tr).setTime(Date.now());
};
const equalNodeType = (nodeType2, node5) => {
  return Array.isArray(nodeType2) && nodeType2.indexOf(node5.type) > -1 || node5.type === nodeType2;
};
const findParentNodeClosestToPos = (predicate) => ($pos) => {
  for (let i2 = $pos.depth; i2 > 0; i2--) {
    const node5 = $pos.node(i2);
    if (predicate(node5)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node: node5
      };
    }
  }
  return;
};
const findParentNode = (predicate) => (selection) => {
  return findParentNodeClosestToPos(predicate)(selection.$from);
};
const findSelectedNodeOfType = (selection, nodeType2) => {
  if (!(selection instanceof NodeSelection)) {
    return;
  }
  const { node: node5, $from } = selection;
  if (equalNodeType(nodeType2, node5)) {
    return { node: node5, pos: $from.pos, start: $from.start($from.depth), depth: $from.depth };
  }
  return void 0;
};
const flatten = (node5, descend = true) => {
  const result2 = [];
  node5.descendants((child4, pos) => {
    result2.push({ node: child4, pos });
    if (!descend) {
      return false;
    }
    return void 0;
  });
  return result2;
};
const findChildren = (predicate) => (node5, descend) => flatten(node5, descend).filter((child4) => predicate(child4.node));
const commands2Tuples$1 = (commands2) => Object.entries(commands2).filter((x2) => !!x2);
const getShortCuts$1 = (name, defaultKey, userKeymap) => {
  var _a;
  return (_a = userKeymap === null || userKeymap === void 0 ? void 0 : userKeymap[name]) !== null && _a !== void 0 ? _a : defaultKey;
};
const getKeymap$1 = (getCommand, userKeymap) => ([name, { defaultKey, commandKey, args }]) => [getShortCuts$1(name, defaultKey, userKeymap)].flat().map((shortcut) => [shortcut, getCommand(commandKey)(args)]);
const tuple2Keymap$1 = (tuples, getCommand, userKeymap) => tuples.flatMap(getKeymap$1(getCommand, userKeymap));
const createKeymap$1 = (commands2, userKeymap) => !commands2 ? () => ({}) : (_type, _schema, getCommand) => Object.fromEntries(tuple2Keymap$1(commands2Tuples$1(commands2), getCommand, userKeymap));
const createMark = (factory2) => {
  const origin = (options) => {
    const getClassName = (attrs, defaultValue) => {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.className) === null || _a === void 0 ? void 0 : _a.call(options, attrs)) !== null && _b !== void 0 ? _b : defaultValue;
    };
    const node5 = factory2(options, {
      getClassName
    });
    const keymap2 = createKeymap$1(node5.shortcuts, options === null || options === void 0 ? void 0 : options.keymap);
    const plugin2 = markFactory(Object.assign(Object.assign({}, node5), { keymap: keymap2, view: options === null || options === void 0 ? void 0 : options.view }));
    plugin2.origin = origin;
    return plugin2;
  };
  return origin;
};
const createNode$1 = (factory2) => {
  const origin = (options) => {
    const getClassName = (attrs, defaultValue) => {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.className) === null || _a === void 0 ? void 0 : _a.call(options, attrs)) !== null && _b !== void 0 ? _b : defaultValue;
    };
    const node5 = factory2(options, {
      getClassName
    });
    const keymap2 = createKeymap$1(node5.shortcuts, options === null || options === void 0 ? void 0 : options.keymap);
    const plugin2 = nodeFactory(Object.assign(Object.assign({ view: options === null || options === void 0 ? void 0 : options.view }, node5), { keymap: keymap2 }));
    plugin2.origin = origin;
    return plugin2;
  };
  return origin;
};
class AtomList extends Array {
  configure(target, config2) {
    const index3 = this.findIndex((x2) => x2.origin === target);
    if (index3 < 0)
      return this;
    this.splice(index3, 1, target(config2));
    return this;
  }
  static create(from5) {
    return new AtomList(...from5);
  }
}
const createShortcut = (commandKey, defaultKey, args) => ({
  commandKey,
  defaultKey,
  args
});
function markRule(regexp, markType) {
  return new InputRule(regexp, (state, match, start4, end3) => {
    const { tr } = state;
    const matchLength = match.length;
    let markStart = start4;
    let markEnd = end3;
    if (match[matchLength - 1]) {
      const first = match[0];
      const last = match[matchLength - 1];
      const last1 = match[matchLength - 2];
      const matchStart = start4 + first.indexOf(last1);
      const matchEnd = matchStart + last1.length - 1;
      const textStart = matchStart + last1.lastIndexOf(last);
      const textEnd = textStart + last.length;
      const excludedMarks = getMarksBetween(start4, end3, state).filter((item) => item.mark.type.excludes(markType)).filter((item) => item.end > matchStart);
      if (excludedMarks.length) {
        return null;
      }
      if (textEnd < matchEnd) {
        tr.delete(textEnd, matchEnd);
      }
      if (textStart > matchStart) {
        tr.delete(matchStart, textStart);
      }
      markStart = matchStart;
      markEnd = markStart + last.length;
    }
    tr.addMark(markStart, markEnd, markType.create());
    tr.removeStoredMark(markType);
    return tr;
  });
}
function getMarksBetween(start4, end3, state) {
  let marks3 = [];
  state.doc.nodesBetween(start4, end3, (node5, pos) => {
    marks3 = [
      ...marks3,
      ...node5.marks.map((mark3) => ({
        start: pos,
        end: pos + node5.nodeSize,
        mark: mark3
      }))
    ];
  });
  return marks3;
}
const calculateNodePosition$1 = (view, target, handler) => {
  var _a;
  const state = view.state;
  const { from: from5 } = state.selection;
  const node5 = view.domAtPos(from5).node;
  if (!(node5 instanceof HTMLElement)) {
    throw new Error();
  }
  const selectedNodeRect = node5.getBoundingClientRect();
  const targetNodeRect = target.getBoundingClientRect();
  const parentNodeRect = (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  if (!parentNodeRect) {
    throw new Error();
  }
  const [top2, left] = handler(selectedNodeRect, targetNodeRect, parentNodeRect);
  target.style.top = top2 + "px";
  target.style.left = left + "px";
};
const calculateTextPosition = (view, target, handler) => {
  var _a;
  const state = view.state;
  const { from: from5, to: to2 } = state.selection;
  const start4 = view.coordsAtPos(from5);
  const end3 = view.coordsAtPos(to2);
  const targetNodeRect = target.getBoundingClientRect();
  const parentNodeRect = (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  if (!parentNodeRect) {
    throw new Error();
  }
  const [top2, left] = handler(start4, end3, targetNodeRect, parentNodeRect);
  target.style.top = top2 + "px";
  target.style.left = left + "px";
};
const hasMark = (editorState2, type) => {
  const { from: from5, to: to2 } = editorState2.selection;
  return editorState2.doc.rangeHasMark(from5, to2, type);
};
const isTextSelection = (editorState2) => {
  const { selection } = editorState2;
  if (selection instanceof TextSelection) {
    const text3 = editorState2.doc.textBetween(selection.from, selection.to);
    if (!text3)
      return false;
    return true;
  }
  return false;
};
const isInCodeFence = (editorState2) => Boolean(findParentNode((node5) => node5.type.name === "fence")(editorState2.selection));
const isTextAndNotHasMark = (editorState2, mark3) => !isTextSelection(editorState2) || isInCodeFence(editorState2) || hasMark(editorState2, mark3);
const modifyLink = (ctx) => (e3) => {
  const { target } = e3;
  if (!(target instanceof HTMLElement)) {
    return () => true;
  }
  if (elementIsTag(target, "input")) {
    target.focus();
    return () => false;
  }
  const parent = target.parentNode;
  if (!parent)
    return () => false;
  const inputEl = Array.from(parent.children).find((el2) => el2.tagName === "INPUT");
  if (!(inputEl instanceof HTMLInputElement))
    return () => false;
  return ctx.get(commandsCtx).call(ModifyLink, inputEl.value);
};
const modifyImage = (ctx) => (e3) => {
  const { target } = e3;
  if (!(target instanceof HTMLElement)) {
    return () => true;
  }
  if (elementIsTag(target, "input")) {
    target.focus();
    return () => false;
  }
  const parent = target.parentNode;
  if (!parent)
    return () => false;
  const inputEl = Array.from(parent.children).find((el2) => el2.tagName === "INPUT");
  if (!(inputEl instanceof HTMLInputElement))
    return () => false;
  return ctx.get(commandsCtx).call(ModifyImage, inputEl.value);
};
const updateLinkView = (view, $2) => {
  const { marks: marks3 } = view.state.schema;
  const { firstChild, lastElementChild } = $2;
  if (!(firstChild instanceof HTMLInputElement) || !(lastElementChild instanceof HTMLButtonElement))
    return;
  const { selection } = view.state;
  let node5;
  view.state.doc.nodesBetween(selection.from, selection.to, (n2) => {
    if (marks3.link.isInSet(n2.marks)) {
      node5 = n2;
      return false;
    }
    return;
  });
  if (!node5)
    return;
  const mark3 = node5.marks.find((m2) => m2.type === marks3.link);
  if (!mark3)
    return;
  const value = mark3.attrs.href;
  firstChild.value = value;
  if (!value) {
    lastElementChild.classList.add("disable");
    return;
  }
  if (lastElementChild.classList.contains("disable")) {
    lastElementChild.classList.remove("disable");
  }
};
const updateImageView = (view, $2) => {
  var _a;
  const { nodes: nodes2 } = view.state.schema;
  const { firstChild, lastElementChild } = $2;
  if (!(firstChild instanceof HTMLInputElement) || !(lastElementChild instanceof HTMLButtonElement))
    return;
  const node5 = (_a = findChildren((node6) => node6.type === nodes2.image)(view.state.selection.$from.node())[0]) === null || _a === void 0 ? void 0 : _a.node;
  if (!node5)
    return;
  const value = node5.attrs.src;
  firstChild.value = value;
  if (!value) {
    lastElementChild.classList.add("disable");
    return;
  }
  if (lastElementChild.classList.contains("disable")) {
    lastElementChild.classList.remove("disable");
  }
};
const createToggleIcon = (ctx, iconName, commandKey, mark3, disableForMark) => ({
  $: icon$1(iconName),
  command: () => ctx.get(commandsCtx).call(commandKey),
  active: (view) => hasMark(view.state, mark3),
  disable: (view) => isTextAndNotHasMark(view.state, disableForMark),
  enable: (view) => !!mark3 && !!view.state.schema.marks[mark3.name]
});
var result = {};
if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  result.mac = /Mac/.test(navigator.platform);
  var ie$1 = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie$1 && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome = !ie$1 && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome;
  result.chrome_version = chrome && +chrome[1];
  result.safari = !ie$1 && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}
var domIndex = function(node5) {
  for (var index3 = 0; ; index3++) {
    node5 = node5.previousSibling;
    if (!node5) {
      return index3;
    }
  }
};
var parentNode = function(node5) {
  var parent = node5.assignedSlot || node5.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node5, from5, to2) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node5, to2 == null ? node5.nodeValue.length : to2);
  range.setStart(node5, from5 || 0);
  return range;
};
var isEquivalentPosition = function(node5, off, targetNode, targetOff) {
  return targetNode && (scanFor(node5, off, targetNode, targetOff, -1) || scanFor(node5, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node5, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node5 == targetNode && off == targetOff) {
      return true;
    }
    if (off == (dir < 0 ? 0 : nodeSize(node5))) {
      var parent = node5.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node5) || atomElements.test(node5.nodeName) || node5.contentEditable == "false") {
        return false;
      }
      off = domIndex(node5) + (dir < 0 ? 0 : 1);
      node5 = parent;
    } else if (node5.nodeType == 1) {
      node5 = node5.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node5.contentEditable == "false") {
        return false;
      }
      off = dir < 0 ? nodeSize(node5) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node5) {
  return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
}
function isOnEdge(node5, offset2, parent) {
  for (var atStart2 = offset2 == 0, atEnd2 = offset2 == nodeSize(node5); atStart2 || atEnd2; ) {
    if (node5 == parent) {
      return true;
    }
    var index3 = domIndex(node5);
    node5 = node5.parentNode;
    if (!node5) {
      return false;
    }
    atStart2 = atStart2 && index3 == 0;
    atEnd2 = atEnd2 && index3 == nodeSize(node5);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
    collapsed = false;
  }
  return collapsed;
};
function keyEvent(keyCode, key2) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key2;
  return event;
}
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node5) {
  var rect = node5.getBoundingClientRect();
  var scaleX = rect.width / node5.offsetWidth || 1;
  var scaleY = rect.height / node5.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node5.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node5.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc2.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc2) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x2 = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    var dom = view.root.elementFromPoint(x2, y2);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc2) {
      break;
    }
  }
  return stack;
}
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i2 = 0; i2 < stack.length; i2++) {
    var ref = stack[i2];
    var dom = ref.dom;
    var top2 = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top2 + dTop) {
      dom.scrollTop = top2 + dTop;
    }
    if (dom.scrollLeft != left) {
      dom.scrollLeft = left;
    }
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported) {
    return dom.focus(preventScrollSupported);
  }
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node5, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child4 = node5.firstChild, childIndex = 0; child4; child4 = child4.nextSibling, childIndex++) {
    var rects = void 0;
    if (child4.nodeType == 1) {
      rects = child4.getClientRects();
    } else if (child4.nodeType == 3) {
      rects = textRange(child4).getClientRects();
    } else {
      continue;
    }
    for (var i2 = 0; i2 < rects.length; i2++) {
      var rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child4;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
          if (child4.nodeType == 1 && dx) {
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
        offset2 = childIndex + 1;
      }
    }
  }
  if (closest && closest.nodeType == 3) {
    return findOffsetInText(closest, coordsClosest);
  }
  if (!closest || dxClosest && closest.nodeType == 1) {
    return { node: node5, offset: offset2 };
  }
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node5, coords) {
  var len = node5.nodeValue.length;
  var range = document.createRange();
  for (var i2 = 0; i2 < len; i2++) {
    range.setEnd(node5, i2 + 1);
    range.setStart(node5, i2);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) {
      continue;
    }
    if (inRect(coords, rect)) {
      return { node: node5, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node5, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node5 = ref.node;
  var offset2 = ref.offset;
  var bias = -1;
  if (node5.nodeType == 1 && !node5.firstChild) {
    var rect = node5.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node5, offset2, bias);
}
function posFromCaret(view, node5, offset2, coords) {
  var outside = -1;
  for (var cur = node5; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect.right < coords.left || rect.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node5, offset2);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      var child4 = element.childNodes[i2];
      if (child4.nodeType == 1) {
        var rects = child4.getClientRects();
        for (var j2 = 0; j2 < rects.length; j2++) {
          var rect = rects[j2];
          if (inRect(coords, rect)) {
            return elementFromPoint(child4, coords, rect);
          }
        }
      }
      if ((i2 = (i2 + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  var assign2, assign$12;
  var root2 = view.root, node5, offset2;
  if (root2.caretPositionFromPoint) {
    try {
      var pos$1 = root2.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign2 = pos$1, node5 = assign2.offsetNode, offset2 = assign2.offset;
      }
    } catch (_2) {
    }
  }
  if (!node5 && root2.caretRangeFromPoint) {
    var range = root2.caretRangeFromPoint(coords.left, coords.top);
    if (range) {
      assign$12 = range, node5 = assign$12.startContainer, offset2 = assign$12.startOffset;
    }
  }
  var elt = root2.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) {
      return null;
    }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result.safari) {
    for (var p2 = elt; node5 && p2; p2 = parentNode(p2)) {
      if (p2.draggable) {
        node5 = offset2 = null;
      }
    }
  }
  elt = targetKludge(elt, coords);
  if (node5) {
    if (result.gecko && node5.nodeType == 1) {
      offset2 = Math.min(offset2, node5.childNodes.length);
      if (offset2 < node5.childNodes.length) {
        var next = node5.childNodes[offset2], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset2++;
        }
      }
    }
    if (node5 == view.dom && offset2 == node5.childNodes.length - 1 && node5.lastChild.nodeType == 1 && coords.top > node5.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset2 == 0 || node5.nodeType != 1 || node5.childNodes[offset2 - 1].nodeName != "BR") {
      pos = posFromCaret(view, node5, offset2, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node5 = ref.node;
  var offset2 = ref.offset;
  var supportEmptyRange = result.webkit || result.gecko;
  if (node5.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node5.nodeValue) || (side < 0 ? !offset2 : offset2 == node5.nodeValue.length))) {
      var rect = singleRect(textRange(node5, offset2, offset2), side);
      if (result.gecko && offset2 && /\s/.test(node5.nodeValue[offset2 - 1]) && offset2 < node5.nodeValue.length) {
        var rectBefore = singleRect(textRange(node5, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node5, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top) {
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect;
    } else {
      var from5 = offset2, to2 = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to2++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node5.nodeValue.length) {
        from5--;
        takeSide = 1;
      } else if (side < 0) {
        from5--;
      } else {
        to2++;
      }
      return flattenV(singleRect(textRange(node5, from5, to2), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset2 && (side < 0 || offset2 == nodeSize(node5))) {
      var before2 = node5.childNodes[offset2 - 1];
      if (before2.nodeType == 1) {
        return flattenH(before2.getBoundingClientRect(), false);
      }
    }
    if (offset2 < nodeSize(node5)) {
      var after2 = node5.childNodes[offset2];
      if (after2.nodeType == 1) {
        return flattenH(after2.getBoundingClientRect(), true);
      }
    }
    return flattenH(node5.getBoundingClientRect(), side >= 0);
  }
  if (offset2 && (side < 0 || offset2 == nodeSize(node5))) {
    var before$1 = node5.childNodes[offset2 - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) {
      return flattenV(singleRect(target, 1), false);
    }
  }
  if (offset2 < nodeSize(node5)) {
    var after$1 = node5.childNodes[offset2];
    var target$1 = after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV(singleRect(target$1, -1), true);
    }
  }
  return flattenV(singleRect(node5.nodeType == 3 ? textRange(node5) : node5, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0) {
    return rect;
  }
  var x2 = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
}
function flattenH(rect, top2) {
  if (rect.height == 0) {
    return rect;
  }
  var y2 = top2 ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f2) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f2();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child4 = dom.firstChild; child4; child4 = child4.nextSibling) {
      var boxes = void 0;
      if (child4.nodeType == 1) {
        boxes = child4.getClientRects();
      } else if (child4.nodeType == 3) {
        boxes = textRange(child4, 0, child4.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i2 = 0; i2 < boxes.length; i2++) {
        var box = boxes[i2];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
          return false;
        }
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset2 = $head.parentOffset, atStart2 = !offset2, atEnd2 = offset2 == $head.parent.content.size;
  var sel = view.root.getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
var ViewDesc2 = function ViewDesc3(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  dom.pmViewDesc = this;
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};
var prototypeAccessors = { beforePosition: { configurable: true }, size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true } };
ViewDesc2.prototype.matchesWidget = function matchesWidget2() {
  return false;
};
ViewDesc2.prototype.matchesMark = function matchesMark2() {
  return false;
};
ViewDesc2.prototype.matchesNode = function matchesNode2() {
  return false;
};
ViewDesc2.prototype.matchesHack = function matchesHack2(_nodeName) {
  return false;
};
prototypeAccessors.beforePosition.get = function() {
  return false;
};
ViewDesc2.prototype.parseRule = function parseRule2() {
  return null;
};
ViewDesc2.prototype.stopEvent = function stopEvent2() {
  return false;
};
prototypeAccessors.size.get = function() {
  var size2 = 0;
  for (var i2 = 0; i2 < this.children.length; i2++) {
    size2 += this.children[i2].size;
  }
  return size2;
};
prototypeAccessors.border.get = function() {
  return 0;
};
ViewDesc2.prototype.destroy = function destroy3() {
  this.parent = null;
  if (this.dom.pmViewDesc == this) {
    this.dom.pmViewDesc = null;
  }
  for (var i2 = 0; i2 < this.children.length; i2++) {
    this.children[i2].destroy();
  }
};
ViewDesc2.prototype.posBeforeChild = function posBeforeChild2(child4) {
  for (var i2 = 0, pos = this.posAtStart; i2 < this.children.length; i2++) {
    var cur = this.children[i2];
    if (cur == child4) {
      return pos;
    }
    pos += cur.size;
  }
};
prototypeAccessors.posBefore.get = function() {
  return this.parent.posBeforeChild(this);
};
prototypeAccessors.posAtStart.get = function() {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
};
prototypeAccessors.posAfter.get = function() {
  return this.posBefore + this.size;
};
prototypeAccessors.posAtEnd.get = function() {
  return this.posAtStart + this.size - 2 * this.border;
};
ViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset2, bias) {
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset2 - 1];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
        domBefore = domBefore.previousSibling;
      }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset2];
      } else {
        while (dom.parentNode != this.contentDOM) {
          dom = dom.parentNode;
        }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
        domAfter = domAfter.nextSibling;
      }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
    }
  }
  var atEnd2;
  if (dom == this.dom && this.contentDOM) {
    atEnd2 = offset2 > domIndex(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset2 == 0) {
      for (var search3 = dom; ; search3 = search3.parentNode) {
        if (search3 == this.dom) {
          atEnd2 = false;
          break;
        }
        if (search3.parentNode.firstChild != search3) {
          break;
        }
      }
    }
    if (atEnd2 == null && offset2 == dom.childNodes.length) {
      for (var search$12 = dom; ; search$12 = search$12.parentNode) {
        if (search$12 == this.dom) {
          atEnd2 = true;
          break;
        }
        if (search$12.parentNode.lastChild != search$12) {
          break;
        }
      }
    }
  }
  return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
};
ViewDesc2.prototype.nearestDesc = function nearestDesc2(dom, onlyNodes) {
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
        first = false;
      } else {
        return desc;
      }
    }
  }
};
ViewDesc2.prototype.getDesc = function getDesc2(dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) {
    if (cur == this) {
      return desc;
    }
  }
};
ViewDesc2.prototype.posFromDOM = function posFromDOM2(dom, offset2, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) {
      return desc.localPosFromDOM(dom, offset2, bias);
    }
  }
  return -1;
};
ViewDesc2.prototype.descAt = function descAt2(pos) {
  for (var i2 = 0, offset2 = 0; i2 < this.children.length; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (offset2 == pos && end3 != offset2) {
      while (!child4.border && child4.children.length) {
        child4 = child4.children[0];
      }
      return child4;
    }
    if (pos < end3) {
      return child4.descAt(pos - offset2 - child4.border);
    }
    offset2 = end3;
  }
};
ViewDesc2.prototype.domFromPos = function domFromPos2(pos, side) {
  if (!this.contentDOM) {
    return { node: this.dom, offset: 0 };
  }
  for (var offset2 = 0, i2 = 0, first = true; ; i2++, first = false) {
    while (i2 < this.children.length && (this.children[i2].beforePosition || this.children[i2].dom.parentNode != this.contentDOM)) {
      offset2 += this.children[i2++].size;
    }
    var child4 = i2 == this.children.length ? null : this.children[i2];
    if (offset2 == pos && (side == 0 || !child4 || !child4.size || child4.border || side < 0 && first) || child4 && child4.domAtom && pos < offset2 + child4.size) {
      return {
        node: this.contentDOM,
        offset: child4 ? domIndex(child4.dom) : this.contentDOM.childNodes.length
      };
    }
    if (!child4) {
      throw new Error("Invalid position " + pos);
    }
    var end3 = offset2 + child4.size;
    if (!child4.domAtom && (side < 0 && !child4.border ? end3 >= pos : end3 > pos) && (end3 > pos || i2 + 1 >= this.children.length || !this.children[i2 + 1].beforePosition)) {
      return child4.domFromPos(pos - offset2 - child4.border, side);
    }
    offset2 = end3;
  }
};
ViewDesc2.prototype.parseRange = function parseRange2(from5, to2, base2) {
  if (base2 === void 0)
    base2 = 0;
  if (this.children.length == 0) {
    return { node: this.contentDOM, from: from5, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
  }
  var fromOffset = -1, toOffset = -1;
  for (var offset2 = base2, i2 = 0; ; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (fromOffset == -1 && from5 <= end3) {
      var childBase = offset2 + child4.border;
      if (from5 >= childBase && to2 <= end3 - child4.border && child4.node && child4.contentDOM && this.contentDOM.contains(child4.contentDOM)) {
        return child4.parseRange(from5, to2, childBase);
      }
      from5 = offset2;
      for (var j2 = i2; j2 > 0; j2--) {
        var prev = this.children[j2 - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex(prev.dom) + 1;
          break;
        }
        from5 -= prev.size;
      }
      if (fromOffset == -1) {
        fromOffset = 0;
      }
    }
    if (fromOffset > -1 && (end3 > to2 || i2 == this.children.length - 1)) {
      to2 = end3;
      for (var j$1 = i2 + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex(next.dom);
          break;
        }
        to2 += next.size;
      }
      if (toOffset == -1) {
        toOffset = this.contentDOM.childNodes.length;
      }
      break;
    }
    offset2 = end3;
  }
  return { node: this.contentDOM, from: from5, to: to2, fromOffset, toOffset };
};
ViewDesc2.prototype.emptyChildAt = function emptyChildAt2(side) {
  if (this.border || !this.contentDOM || !this.children.length) {
    return false;
  }
  var child4 = this.children[side < 0 ? 0 : this.children.length - 1];
  return child4.size == 0 || child4.emptyChildAt(side);
};
ViewDesc2.prototype.domAfterPos = function domAfterPos2(pos) {
  var ref = this.domFromPos(pos, 0);
  var node5 = ref.node;
  var offset2 = ref.offset;
  if (node5.nodeType != 1 || offset2 == node5.childNodes.length) {
    throw new RangeError("No node after pos " + pos);
  }
  return node5.childNodes[offset2];
};
ViewDesc2.prototype.setSelection = function setSelection2(anchor2, head, root2, force) {
  var from5 = Math.min(anchor2, head), to2 = Math.max(anchor2, head);
  for (var i2 = 0, offset2 = 0; i2 < this.children.length; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (from5 > offset2 && to2 < end3) {
      return child4.setSelection(anchor2 - offset2 - child4.border, head - offset2 - child4.border, root2, force);
    }
    offset2 = end3;
  }
  var anchorDOM = this.domFromPos(anchor2, anchor2 ? -1 : 1);
  var headDOM = head == anchor2 ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root2.getSelection();
  var brKludge = false;
  if ((result.gecko || result.safari) && anchor2 == head) {
    var node5 = anchorDOM.node;
    var offset$1 = anchorDOM.offset;
    if (node5.nodeType == 3) {
      brKludge = offset$1 && node5.nodeValue[offset$1 - 1] == "\n";
      if (brKludge && offset$1 == node5.nodeValue.length) {
        for (var scan = node5, after2 = void 0; scan; scan = scan.parentNode) {
          if (after2 = scan.nextSibling) {
            if (after2.nodeName == "BR") {
              anchorDOM = headDOM = { node: after2.parentNode, offset: domIndex(after2) + 1 };
            }
            break;
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) {
            break;
          }
        }
      }
    } else {
      var prev = node5.childNodes[offset$1 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") {
      force = true;
    }
  }
  if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
    return;
  }
  var domSelExtended = false;
  if ((domSel.extend || anchor2 == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor2 != head) {
        domSel.extend(headDOM.node, headDOM.offset);
      }
      domSelExtended = true;
    } catch (err2) {
      if (!(err2 instanceof DOMException)) {
        throw err2;
      }
    }
  }
  if (!domSelExtended) {
    if (anchor2 > head) {
      var tmp = anchorDOM;
      anchorDOM = headDOM;
      headDOM = tmp;
    }
    var range = document.createRange();
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range);
  }
};
ViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
  return !this.contentDOM && mutation.type != "selection";
};
prototypeAccessors.contentLost.get = function() {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
};
ViewDesc2.prototype.markDirty = function markDirty2(from5, to2) {
  for (var offset2 = 0, i2 = 0; i2 < this.children.length; i2++) {
    var child4 = this.children[i2], end3 = offset2 + child4.size;
    if (offset2 == end3 ? from5 <= end3 && to2 >= offset2 : from5 < end3 && to2 > offset2) {
      var startInside = offset2 + child4.border, endInside = end3 - child4.border;
      if (from5 >= startInside && to2 <= endInside) {
        this.dirty = from5 == offset2 || to2 == end3 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from5 == startInside && to2 == endInside && (child4.contentLost || child4.dom.parentNode != this.contentDOM)) {
          child4.dirty = NODE_DIRTY;
        } else {
          child4.markDirty(from5 - startInside, to2 - startInside);
        }
        return;
      } else {
        child4.dirty = child4.dom == child4.contentDOM && child4.dom.parentNode == this.contentDOM ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset2 = end3;
  }
  this.dirty = CONTENT_DIRTY;
};
ViewDesc2.prototype.markParentsDirty = function markParentsDirty2() {
  var level = 1;
  for (var node5 = this.parent; node5; node5 = node5.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node5.dirty < dirty) {
      node5.dirty = dirty;
    }
  }
};
prototypeAccessors.domAtom.get = function() {
  return false;
};
Object.defineProperties(ViewDesc2.prototype, prototypeAccessors);
var nothing = [];
var WidgetViewDesc = /* @__PURE__ */ function(ViewDesc4) {
  function WidgetViewDesc2(parent, widget3, view, pos) {
    var self2, dom = widget3.type.toDOM;
    if (typeof dom == "function") {
      dom = dom(view, function() {
        if (!self2) {
          return pos;
        }
        if (self2.parent) {
          return self2.parent.posBeforeChild(self2);
        }
      });
    }
    if (!widget3.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc4.call(this, parent, nothing, dom, null);
    this.widget = widget3;
    self2 = this;
  }
  if (ViewDesc4)
    WidgetViewDesc2.__proto__ = ViewDesc4;
  WidgetViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
  var prototypeAccessors$12 = { beforePosition: { configurable: true }, domAtom: { configurable: true } };
  prototypeAccessors$12.beforePosition.get = function() {
    return this.widget.type.side < 0;
  };
  WidgetViewDesc2.prototype.matchesWidget = function matchesWidget3(widget3) {
    return this.dirty == NOT_DIRTY && widget3.type.eq(this.widget.type);
  };
  WidgetViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  WidgetViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    var stop3 = this.widget.spec.stopEvent;
    return stop3 ? stop3(event) : false;
  };
  WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  };
  prototypeAccessors$12.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$12);
  return WidgetViewDesc2;
}(ViewDesc2);
var CompositionViewDesc = /* @__PURE__ */ function(ViewDesc4) {
  function CompositionViewDesc2(parent, dom, textDOM, text3) {
    ViewDesc4.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text3;
  }
  if (ViewDesc4)
    CompositionViewDesc2.__proto__ = ViewDesc4;
  CompositionViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
  var prototypeAccessors$22 = { size: { configurable: true } };
  prototypeAccessors$22.size.get = function() {
    return this.text.length;
  };
  CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM3(dom, offset2) {
    if (dom != this.textDOM) {
      return this.posAtStart + (offset2 ? this.size : 0);
    }
    return this.posAtStart + offset2;
  };
  CompositionViewDesc2.prototype.domFromPos = function domFromPos3(pos) {
    return { node: this.textDOM, offset: pos };
  };
  CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  };
  Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$22);
  return CompositionViewDesc2;
}(ViewDesc2);
var MarkViewDesc = /* @__PURE__ */ function(ViewDesc4) {
  function MarkViewDesc2(parent, mark3, dom, contentDOM) {
    ViewDesc4.call(this, parent, [], dom, contentDOM);
    this.mark = mark3;
  }
  if (ViewDesc4)
    MarkViewDesc2.__proto__ = ViewDesc4;
  MarkViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  MarkViewDesc2.prototype.constructor = MarkViewDesc2;
  MarkViewDesc2.create = function create7(parent, mark3, inline3, view) {
    var custom = view.nodeViews[mark3.type.name];
    var spec = custom && custom(mark3, view, inline3);
    if (!spec || !spec.dom) {
      spec = DOMSerializer.renderSpec(document, mark3.type.spec.toDOM(mark3, inline3));
    }
    return new MarkViewDesc2(parent, mark3, spec.dom, spec.contentDOM || spec.dom);
  };
  MarkViewDesc2.prototype.parseRule = function parseRule3() {
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  };
  MarkViewDesc2.prototype.matchesMark = function matchesMark3(mark3) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark3);
  };
  MarkViewDesc2.prototype.markDirty = function markDirty3(from5, to2) {
    ViewDesc4.prototype.markDirty.call(this, from5, to2);
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) {
        parent = parent.parent;
      }
      if (parent.dirty < this.dirty) {
        parent.dirty = this.dirty;
      }
      this.dirty = NOT_DIRTY;
    }
  };
  MarkViewDesc2.prototype.slice = function slice5(from5, to2, view) {
    var copy6 = MarkViewDesc2.create(this.parent, this.mark, true, view);
    var nodes2 = this.children, size2 = this.size;
    if (to2 < size2) {
      nodes2 = replaceNodes(nodes2, to2, size2, view);
    }
    if (from5 > 0) {
      nodes2 = replaceNodes(nodes2, 0, from5, view);
    }
    for (var i2 = 0; i2 < nodes2.length; i2++) {
      nodes2[i2].parent = copy6;
    }
    copy6.children = nodes2;
    return copy6;
  };
  return MarkViewDesc2;
}(ViewDesc2);
var NodeViewDesc = /* @__PURE__ */ function(ViewDesc4) {
  function NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, view, pos) {
    ViewDesc4.call(this, parent, node5.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM3;
    this.node = node5;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) {
      this.updateChildren(view, pos);
    }
  }
  if (ViewDesc4)
    NodeViewDesc2.__proto__ = ViewDesc4;
  NodeViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  NodeViewDesc2.prototype.constructor = NodeViewDesc2;
  var prototypeAccessors$32 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
  NodeViewDesc2.create = function create7(parent, node5, outerDeco, innerDeco, view, pos) {
    var assign2;
    var custom = view.nodeViews[node5.type.name], descObj;
    var spec = custom && custom(node5, view, function() {
      if (!descObj) {
        return pos;
      }
      if (descObj.parent) {
        return descObj.parent.posBeforeChild(descObj);
      }
    }, outerDeco, innerDeco);
    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node5.isText) {
      if (!dom) {
        dom = document.createTextNode(node5.text);
      } else if (dom.nodeType != 3) {
        throw new RangeError("Text must be rendered as a DOM text node");
      }
    } else if (!dom) {
      assign2 = DOMSerializer.renderSpec(document, node5.type.spec.toDOM(node5)), dom = assign2.dom, contentDOM = assign2.contentDOM;
    }
    if (!contentDOM && !node5.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable")) {
        dom.contentEditable = false;
      }
      if (node5.type.spec.draggable) {
        dom.draggable = true;
      }
    }
    var nodeDOM3 = dom;
    dom = applyOuterDeco(dom, outerDeco, node5);
    if (spec) {
      return descObj = new CustomNodeViewDesc(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, spec, view, pos + 1);
    } else if (node5.isText) {
      return new TextViewDesc(parent, node5, outerDeco, innerDeco, dom, nodeDOM3, view);
    } else {
      return new NodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, view, pos + 1);
    }
  };
  NodeViewDesc2.prototype.parseRule = function parseRule3() {
    var this$1$1 = this;
    if (this.node.type.spec.reparseInView) {
      return null;
    }
    var rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.spec.code) {
      rule.preserveWhitespace = "full";
    }
    if (this.contentDOM && !this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      rule.getContent = function() {
        return this$1$1.contentDOM ? Fragment.empty : this$1$1.node.content;
      };
    }
    return rule;
  };
  NodeViewDesc2.prototype.matchesNode = function matchesNode3(node5, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node5.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  };
  prototypeAccessors$32.size.get = function() {
    return this.node.nodeSize;
  };
  prototypeAccessors$32.border.get = function() {
    return this.node.isLeaf ? 0 : 1;
  };
  NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
    var this$1$1 = this;
    var inline3 = this.node.inlineContent, off = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater2(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function(widget3, i2, insideNode) {
      if (widget3.spec.marks) {
        updater.syncToMarks(widget3.spec.marks, inline3, view);
      } else if (widget3.type.side >= 0 && !insideNode) {
        updater.syncToMarks(i2 == this$1$1.node.childCount ? Mark.none : this$1$1.node.child(i2).marks, inline3, view);
      }
      updater.placeWidget(widget3, view, off);
    }, function(child4, outerDeco, innerDeco, i2) {
      updater.syncToMarks(child4.marks, inline3, view);
      var compIndex;
      if (updater.findNodeMatch(child4, outerDeco, innerDeco, i2))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child4.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child4, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child4, outerDeco, innerDeco, view, i2))
        ;
      else {
        updater.addNode(child4, outerDeco, innerDeco, view, off);
      }
      off += child4.nodeSize;
    });
    updater.syncToMarks(nothing, inline3, view);
    if (this.node.isTextblock) {
      updater.addTextblockHacks();
    }
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition) {
        this.protectLocalComposition(view, localComposition);
      }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) {
        iosHacks(this.dom);
      }
    }
  };
  NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
    var ref = view.state.selection;
    var from5 = ref.from;
    var to2 = ref.to;
    if (!(view.state.selection instanceof TextSelection) || from5 < pos || to2 > pos + this.node.content.size) {
      return;
    }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) {
      return;
    }
    if (this.node.inlineContent) {
      var text3 = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text3, from5 - pos, to2 - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
    } else {
      return { node: textNode, pos: -1 };
    }
  };
  NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
    var node5 = ref.node;
    var pos = ref.pos;
    var text3 = ref.text;
    if (this.getDesc(node5)) {
      return;
    }
    var topNode = node5;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) {
        break;
      }
      while (topNode.previousSibling) {
        topNode.parentNode.removeChild(topNode.previousSibling);
      }
      while (topNode.nextSibling) {
        topNode.parentNode.removeChild(topNode.nextSibling);
      }
      if (topNode.pmViewDesc) {
        topNode.pmViewDesc = null;
      }
    }
    var desc = new CompositionViewDesc(this, topNode, node5, text3);
    view.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text3.length, view, desc);
  };
  NodeViewDesc2.prototype.update = function update4(node5, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node5.sameMarkup(this.node)) {
      return false;
    }
    this.updateInner(node5, outerDeco, innerDeco, view);
    return true;
  };
  NodeViewDesc2.prototype.updateInner = function updateInner(node5, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node5;
    this.innerDeco = innerDeco;
    if (this.contentDOM) {
      this.updateChildren(view, this.posAtStart);
    }
    this.dirty = NOT_DIRTY;
  };
  NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) {
      return;
    }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };
  NodeViewDesc2.prototype.selectNode = function selectNode() {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.draggable = true;
    }
  };
  NodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) {
      this.dom.removeAttribute("draggable");
    }
  };
  prototypeAccessors$32.domAtom.get = function() {
    return this.node.isAtom;
  };
  Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$32);
  return NodeViewDesc2;
}(ViewDesc2);
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
var TextViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function TextViewDesc2(parent, node5, outerDeco, innerDeco, dom, nodeDOM3, view) {
    NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, null, nodeDOM3, view);
  }
  if (NodeViewDesc2)
    TextViewDesc2.__proto__ = NodeViewDesc2;
  TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  TextViewDesc2.prototype.constructor = TextViewDesc2;
  var prototypeAccessors$42 = { domAtom: { configurable: true } };
  TextViewDesc2.prototype.parseRule = function parseRule3() {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) {
      skip = skip.parentNode;
    }
    return { skip: skip || true };
  };
  TextViewDesc2.prototype.update = function update4(node5, outerDeco, _2, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node5.sameMarkup(this.node)) {
      return false;
    }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node5.text != this.node.text) && node5.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node5.text;
      if (view.trackWrites == this.nodeDOM) {
        view.trackWrites = null;
      }
    }
    this.node = node5;
    this.dirty = NOT_DIRTY;
    return true;
  };
  TextViewDesc2.prototype.inParent = function inParent() {
    var parentDOM = this.parent.contentDOM;
    for (var n2 = this.nodeDOM; n2; n2 = n2.parentNode) {
      if (n2 == parentDOM) {
        return true;
      }
    }
    return false;
  };
  TextViewDesc2.prototype.domFromPos = function domFromPos3(pos) {
    return { node: this.nodeDOM, offset: pos };
  };
  TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM3(dom, offset2, bias) {
    if (dom == this.nodeDOM) {
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    }
    return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset2, bias);
  };
  TextViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  };
  TextViewDesc2.prototype.slice = function slice5(from5, to2, view) {
    var node5 = this.node.cut(from5, to2), dom = document.createTextNode(node5.text);
    return new TextViewDesc2(this.parent, node5, this.outerDeco, this.innerDeco, dom, dom, view);
  };
  TextViewDesc2.prototype.markDirty = function markDirty3(from5, to2) {
    NodeViewDesc2.prototype.markDirty.call(this, from5, to2);
    if (this.dom != this.nodeDOM && (from5 == 0 || to2 == this.nodeDOM.nodeValue.length)) {
      this.dirty = NODE_DIRTY;
    }
  };
  prototypeAccessors$42.domAtom.get = function() {
    return false;
  };
  Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$42);
  return TextViewDesc2;
}(NodeViewDesc);
var TrailingHackViewDesc = /* @__PURE__ */ function(ViewDesc4) {
  function TrailingHackViewDesc2() {
    ViewDesc4.apply(this, arguments);
  }
  if (ViewDesc4)
    TrailingHackViewDesc2.__proto__ = ViewDesc4;
  TrailingHackViewDesc2.prototype = Object.create(ViewDesc4 && ViewDesc4.prototype);
  TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
  var prototypeAccessors$52 = { domAtom: { configurable: true } };
  TrailingHackViewDesc2.prototype.parseRule = function parseRule3() {
    return { ignore: true };
  };
  TrailingHackViewDesc2.prototype.matchesHack = function matchesHack3(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  };
  prototypeAccessors$52.domAtom.get = function() {
    return true;
  };
  Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$52);
  return TrailingHackViewDesc2;
}(ViewDesc2);
var CustomNodeViewDesc = /* @__PURE__ */ function(NodeViewDesc2) {
  function CustomNodeViewDesc2(parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, spec, view, pos) {
    NodeViewDesc2.call(this, parent, node5, outerDeco, innerDeco, dom, contentDOM, nodeDOM3, view, pos);
    this.spec = spec;
  }
  if (NodeViewDesc2)
    CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
  CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
  CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
  CustomNodeViewDesc2.prototype.update = function update4(node5, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) {
      return false;
    }
    if (this.spec.update) {
      var result2 = this.spec.update(node5, outerDeco, innerDeco);
      if (result2) {
        this.updateInner(node5, outerDeco, innerDeco, view);
      }
      return result2;
    } else if (!this.contentDOM && !node5.isLeaf) {
      return false;
    } else {
      return NodeViewDesc2.prototype.update.call(this, node5, outerDeco, innerDeco, view);
    }
  };
  CustomNodeViewDesc2.prototype.selectNode = function selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
  };
  CustomNodeViewDesc2.prototype.setSelection = function setSelection3(anchor2, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor2, head, root2) : NodeViewDesc2.prototype.setSelection.call(this, anchor2, head, root2, force);
  };
  CustomNodeViewDesc2.prototype.destroy = function destroy5() {
    if (this.spec.destroy) {
      this.spec.destroy();
    }
    NodeViewDesc2.prototype.destroy.call(this);
  };
  CustomNodeViewDesc2.prototype.stopEvent = function stopEvent3(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  };
  CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation4(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
  };
  return CustomNodeViewDesc2;
}(NodeViewDesc);
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i2 = 0; i2 < descs.length; i2++) {
    var desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
OuterDecoLevel.prototype = Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node5, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top2];
  for (var i2 = 0; i2 < outerDeco.length; i2++) {
    var attrs = outerDeco[i2].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top2 = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top2 = new OuterDecoLevel(node5.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top2.class = (top2.class ? top2.class + " " : "") + val;
      } else if (name == "style") {
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top2[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM3, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM3;
  }
  var curDOM = nodeDOM3;
  for (var i2 = 0; i2 < curComputed.length; i2++) {
    var deco = curComputed[i2], prev = prevComputed[i2];
    if (i2) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i2 = 0; i2 < prevList.length; i2++) {
      if (curList.indexOf(prevList[i2]) == -1) {
        dom.classList.remove(prevList[i2]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev.style)) {
        dom.style.removeProperty(m2[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node5) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node5, dom.nodeType != 1));
}
function sameOuterDeco(a2, b2) {
  if (a2.length != b2.length) {
    return false;
  }
  for (var i2 = 0; i2 < a2.length; i2++) {
    if (!a2[i2].type.eq(b2[i2].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater2 = function ViewTreeUpdater3(top2, lockedNode) {
  this.top = top2;
  this.lock = lockedNode;
  this.index = 0;
  this.stack = [];
  this.changed = false;
  this.preMatch = preMatch(top2.node.content, top2.children);
};
ViewTreeUpdater2.prototype.destroyBetween = function destroyBetween2(start4, end3) {
  if (start4 == end3) {
    return;
  }
  for (var i2 = start4; i2 < end3; i2++) {
    this.top.children[i2].destroy();
  }
  this.top.children.splice(start4, end3 - start4);
  this.changed = true;
};
ViewTreeUpdater2.prototype.destroyRest = function destroyRest2() {
  this.destroyBetween(this.index, this.top.children.length);
};
ViewTreeUpdater2.prototype.syncToMarks = function syncToMarks2(marks3, inline3, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks3.length);
  while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks3[keep]) && marks3[keep].type.spec.spanning !== false) {
    keep++;
  }
  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks3.length) {
    this.stack.push(this.top, this.index + 1);
    var found2 = -1;
    for (var i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
      if (this.top.children[i2].matchesMark(marks3[depth])) {
        found2 = i2;
        break;
      }
    }
    if (found2 > -1) {
      if (found2 > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found2);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks3[depth], inline3, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};
ViewTreeUpdater2.prototype.findNodeMatch = function findNodeMatch2(node5, outerDeco, innerDeco, index3) {
  var children = this.top.children, found2 = -1;
  if (index3 >= this.preMatch.index) {
    for (var i2 = this.index; i2 < children.length; i2++) {
      if (children[i2].matchesNode(node5, outerDeco, innerDeco)) {
        found2 = i2;
        break;
      }
    }
  } else {
    for (var i$1 = this.index, e3 = Math.min(children.length, i$1 + 1); i$1 < e3; i$1++) {
      var child4 = children[i$1];
      if (child4.matchesNode(node5, outerDeco, innerDeco) && !this.preMatch.matched.has(child4)) {
        found2 = i$1;
        break;
      }
    }
  }
  if (found2 < 0) {
    return false;
  }
  this.destroyBetween(this.index, found2);
  this.index++;
  return true;
};
ViewTreeUpdater2.prototype.updateNodeAt = function updateNodeAt2(node5, outerDeco, innerDeco, index3, view) {
  var child4 = this.top.children[index3];
  if (!child4.update(node5, outerDeco, innerDeco, view)) {
    return false;
  }
  this.destroyBetween(this.index, index3);
  this.index = index3 + 1;
  return true;
};
ViewTreeUpdater2.prototype.findIndexWithChild = function findIndexWithChild2(domNode) {
  for (; ; ) {
    var parent = domNode.parentNode;
    if (!parent) {
      return -1;
    }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) {
        for (var i2 = this.index; i2 < this.top.children.length; i2++) {
          if (this.top.children[i2] == desc) {
            return i2;
          }
        }
      }
      return -1;
    }
    domNode = parent;
  }
};
ViewTreeUpdater2.prototype.updateNextNode = function updateNextNode2(node5, outerDeco, innerDeco, view, index3) {
  for (var i2 = this.index; i2 < this.top.children.length; i2++) {
    var next = this.top.children[i2];
    if (next instanceof NodeViewDesc) {
      var preMatch2 = this.preMatch.matched.get(next);
      if (preMatch2 != null && preMatch2 != index3) {
        return false;
      }
      var nextDOM = next.dom;
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node5.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node5.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node5, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i2);
        if (next.dom != nextDOM) {
          this.changed = true;
        }
        this.index++;
        return true;
      }
      break;
    }
  }
  return false;
};
ViewTreeUpdater2.prototype.addNode = function addNode3(node5, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node5, outerDeco, innerDeco, view, pos));
  this.changed = true;
};
ViewTreeUpdater2.prototype.placeWidget = function placeWidget2(widget3, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget3) && (widget3 == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget3, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};
ViewTreeUpdater2.prototype.addTextblockHacks = function addTextblockHacks2() {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) {
    lastChild = lastChild.children[lastChild.children.length - 1];
  }
  if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
    if (result.safari && lastChild && lastChild.dom.contentEditable == "false") {
      this.addHackNode("IMG");
    }
    this.addHackNode("BR");
  }
};
ViewTreeUpdater2.prototype.addHackNode = function addHackNode2(nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
    this.changed = true;
  }
};
function preMatch(frag, descs) {
  var fI = frag.childCount, dI = descs.length, matched = new Map();
  for (; fI > 0 && dI > 0; dI--) {
    var desc = descs[dI - 1], node5 = desc.node;
    if (!node5) {
      continue;
    }
    if (node5 != frag.child(fI - 1)) {
      break;
    }
    --fI;
    matched.set(desc, fI);
  }
  return { index: fI, matched };
}
function compareSide(a2, b2) {
  return a2.type.side - b2.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals5 = deco.locals(parent), offset2 = 0;
  if (locals5.length == 0) {
    for (var i2 = 0; i2 < parent.childCount; i2++) {
      var child4 = parent.child(i2);
      onNode(child4, locals5, deco.forChild(offset2, child4), i2);
      offset2 += child4.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
      var widget3 = locals5[decoIndex++], widgets = void 0;
      while (decoIndex < locals5.length && locals5[decoIndex].to == offset2) {
        (widgets || (widgets = [widget3])).push(locals5[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget3, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index3 = void 0;
    if (restNode) {
      index3 = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset2) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals5.length && locals5[decoIndex].from <= offset2 && locals5[decoIndex].to > offset2) {
      active.push(locals5[decoIndex++]);
    }
    var end3 = offset2 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end3;
      if (decoIndex < locals5.length && locals5[decoIndex].from < cutAt) {
        cutAt = locals5[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end3) {
        restNode = child$1.cut(cutAt - offset2);
        child$1 = child$1.cut(0, cutAt - offset2);
        end3 = cutAt;
        index3 = -1;
      }
    }
    var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d2) {
      return !d2.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset2, child$1), index3);
    offset2 = end3;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node5, offset2) {
  for (; ; ) {
    if (node5.nodeType == 3) {
      return node5;
    }
    if (node5.nodeType == 1 && offset2 > 0) {
      if (node5.childNodes.length > offset2 && node5.childNodes[offset2].nodeType == 3) {
        return node5.childNodes[offset2];
      }
      node5 = node5.childNodes[offset2 - 1];
      offset2 = nodeSize(node5);
    } else if (node5.nodeType == 1 && offset2 < node5.childNodes.length) {
      node5 = node5.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text3, from5, to2) {
  for (var i2 = 0, pos = 0; i2 < frag.childCount && pos <= to2; ) {
    var child4 = frag.child(i2++), childStart = pos;
    pos += child4.nodeSize;
    if (!child4.isText) {
      continue;
    }
    var str = child4.text;
    while (i2 < frag.childCount) {
      var next = frag.child(i2++);
      pos += next.nodeSize;
      if (!next.isText) {
        break;
      }
      str += next.text;
    }
    if (pos >= from5) {
      var found2 = str.lastIndexOf(text3, to2 - childStart);
      if (found2 >= 0 && found2 + text3.length + childStart >= from5) {
        return childStart + found2;
      }
    }
  }
  return -1;
}
function replaceNodes(nodes2, from5, to2, view, replacement) {
  var result2 = [];
  for (var i2 = 0, off = 0; i2 < nodes2.length; i2++) {
    var child4 = nodes2[i2], start4 = off, end3 = off += child4.size;
    if (start4 >= to2 || end3 <= from5) {
      result2.push(child4);
    } else {
      if (start4 < from5) {
        result2.push(child4.slice(0, from5 - start4, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end3 > to2) {
        result2.push(child4.slice(to2 - start4, child4.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc3 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc3 && nearestDesc3.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc3 && !nearestDesc3.node) {
      nearestDesc3 = nearestDesc3.parent;
    }
    if (nearestDesc3 && nearestDesc3.node.isAtom && NodeSelection.isSelectable(nearestDesc3.node) && nearestDesc3.parent && !(nearestDesc3.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc3.dom))) {
      var pos = nearestDesc3.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor2 = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor2 < 0) {
      return null;
    }
    $anchor = doc2.resolve(anchor2);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) {
    return;
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor2 = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
    }
    view.docView.setSelection(anchor2, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) {
        resetEditable(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node5 = ref.node;
  var offset2 = ref.offset;
  var after2 = offset2 < node5.childNodes.length ? node5.childNodes[offset2] : null;
  var before2 = offset2 ? node5.childNodes[offset2 - 1] : null;
  if (result.safari && after2 && after2.contentEditable == "false") {
    return setEditable(after2);
  }
  if ((!after2 || after2.contentEditable == "false") && (!before2 || before2.contentEditable == "false")) {
    if (after2) {
      return setEditable(after2);
    } else if (before2) {
      return setEditable(before2);
    }
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node5 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node5 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node5 = view.cursorWrapper.dom, img = node5.nodeName == "IMG";
  if (img) {
    range.setEnd(node5.parentNode, domIndex(node5) + 1);
  } else {
    range.setEnd(node5, 0);
  }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node5.disabled = true;
    node5.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f2) {
    return f2(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply7(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection) {
        return apply7(view, next);
      }
      return false;
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node5 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node5 || node5.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node5.nodeSize : $head.pos;
      if (!(node5.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection.isSelectable(node5)) {
        return apply7(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node5.nodeSize) : $head));
      } else if (result.webkit) {
        return apply7(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node5.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply7(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) {
      return apply7(view, next$1);
    }
    return false;
  }
}
function nodeLen(node5) {
  return node5.nodeType == 3 ? node5.nodeValue.length : node5.childNodes.length;
}
function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node5 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node5) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result.gecko && node5.nodeType == 1 && offset2 < nodeLen(node5) && isIgnorable(node5.childNodes[offset2])) {
    force = true;
  }
  for (; ; ) {
    if (offset2 > 0) {
      if (node5.nodeType != 1) {
        break;
      } else {
        var before2 = node5.childNodes[offset2 - 1];
        if (isIgnorable(before2)) {
          moveNode = node5;
          moveOffset = --offset2;
        } else if (before2.nodeType == 3) {
          node5 = before2;
          offset2 = node5.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode(node5)) {
      break;
    } else {
      var prev = node5.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node5.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node5 = node5.parentNode;
        if (node5 == view.dom) {
          break;
        }
        offset2 = 0;
      } else {
        node5 = prev;
        offset2 = nodeLen(node5);
      }
    }
  }
  if (force) {
    setSelFocus(view, sel, node5, offset2);
  } else if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node5 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node5) {
    return;
  }
  var len = nodeLen(node5);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node5.nodeType != 1) {
        break;
      }
      var after2 = node5.childNodes[offset2];
      if (isIgnorable(after2)) {
        moveNode = node5;
        moveOffset = ++offset2;
      } else {
        break;
      }
    } else if (isBlockNode(node5)) {
      break;
    } else {
      var next = node5.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node5 = node5.parentNode;
        if (node5 == view.dom) {
          break;
        }
        offset2 = len = 0;
      } else {
        node5 = next;
        offset2 = 0;
        len = nodeLen(node5);
      }
    }
  }
  if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node5, offset2) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node5, offset2);
    range.setStart(node5, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node5, offset2);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM(view);
    }
  }, 50);
}
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection) {
      return apply7(view, next);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply7(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return true;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty2 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty2) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node5, state) {
  view.domObserver.stop();
  node5.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child4 = focusNode.firstChild;
    switchEditable(view, child4, true);
    setTimeout(function() {
      return switchEditable(view, child4, false);
    }, 20);
  }
}
function getMods(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown(view, event) {
  var code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || result.mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code2 == 46 || result.mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37) {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 39) {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code2 == 38) {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 40) {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (result.mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from5 = ref.from;
  var to2 = ref.to;
  var domSel = view.root.getSelection(), find4 = null, anchor2 = domSel.anchorNode;
  if (anchor2 && view.dom.contains(anchor2.nodeType == 1 ? anchor2 : anchor2.parentNode)) {
    find4 = [{ node: anchor2, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel)) {
      find4.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node5 = parent.childNodes[off - 1], desc = node5.pmViewDesc;
      if (node5.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser2 = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from5);
  var sel = null, doc2 = parser2.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find4,
    ruleFromNode,
    context: $from
  });
  if (find4 && find4[0].pos != null) {
    var anchor$1 = find4[0].pos, head = find4[1] && find4[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from5, head: head + from5 };
  }
  return { doc: doc2, sel, from: from5, to: to2 };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange(view, from5, to2, typeOver, addedNodes) {
  if (from5 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from5);
  var shared = $before.sharedDepth(to2);
  from5 = $before.before(shared + 1);
  to2 = view.state.doc.resolve(to2).after(shared + 1);
  var sel = view.state.selection;
  var parse4 = parseBetween(view, from5, to2);
  if (result.chrome && view.cursorWrapper && parse4.sel && parse4.sel.anchor == view.cursorWrapper.deco.from) {
    var text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size2 = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse4.sel = { anchor: parse4.sel.anchor + size2, head: parse4.sel.anchor + size2 };
  }
  var doc2 = view.state.doc, compare = doc2.slice(parse4.from, parse4.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff(compare.content, parse4.doc.content, parse4.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse4.sel && parse4.sel.anchor != parse4.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n2) {
      return n2.nodeName == "DIV" || n2.nodeName == "P";
    }) && view.someProp("handleKeyDown", function(f2) {
      return f2(view, keyEvent(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    } else {
      if (parse4.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse4.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse4.from && parse4.doc.textBetween(change.start - parse4.from - 1, change.start - parse4.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse4.doc.resolveNoCache(change.start - parse4.from);
  var $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n2) {
    return n2.nodeName == "DIV" || n2.nodeName == "P";
  })) || !inlineChange && $from.pos < parse4.doc.content.size && (nextSel = Selection.findFrom(parse4.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f2) {
    return f2(view, keyEvent(8, "Backspace"));
  })) {
    if (result.android && result.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result.chrome && result.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse4.sel && parse4.sel.anchor == parse4.sel.head && parse4.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse4.doc.resolveNoCache(change.endB - parse4.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$12 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f2) {
        return f2(view, chFrom, chTo, text$12);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$12, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse4.doc.slice(change.start - parse4.from, change.endB - parse4.from));
  }
  if (parse4.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse4.sel);
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark3, update4;
  for (var i2 = 0; i2 < prevMarks.length; i2++) {
    added = prevMarks[i2].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark3 = added[0];
    type = "add";
    update4 = function(node5) {
      return node5.mark(mark3.addToSet(node5.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark3 = removed[0];
    type = "remove";
    update4 = function(node5) {
      return node5.mark(mark3.removeFromSet(node5.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
    updated.push(update4(prev.child(i$2)));
  }
  if (Fragment.from(updated).eq(cur)) {
    return { mark: mark3, type };
  }
}
function looksLikeJoin(old, start4, end3, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end3 - start4 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start4);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end3 || skipClosingAndOpening($next, true, false) < end3) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end3 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end3++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end3++;
    }
  }
  return end3;
}
function findDiff(a2, b2, pos, preferredPos, preferredSide) {
  var start4 = a2.findDiffStart(b2, pos);
  if (start4 == null) {
    return null;
  }
  var ref = a2.findDiffEnd(b2, pos + a2.size, pos + b2.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start4 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start4;
  }
  if (endA < start4 && a2.size < b2.size) {
    var move3 = preferredPos <= start4 && preferredPos >= endA ? start4 - preferredPos : 0;
    start4 -= move3;
    endB = start4 + (endB - endA);
    endA = start4;
  } else if (endB < start4) {
    var move$1 = preferredPos <= start4 && preferredPos >= endB ? start4 - preferredPos : 0;
    start4 -= move$1;
    endA = start4 + (endA - endB);
    endB = start4;
  }
  return { start: start4, endA, endB };
}
function serializeForClipboard(view, slice5) {
  var context = [];
  var content3 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  while (openStart > 1 && openEnd > 1 && content3.childCount == 1 && content3.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node5 = content3.firstChild;
    context.push(node5.type.name, node5.attrs != node5.type.defaultAttrs ? node5.attrs : null);
    content3 = node5.content;
  }
  var serializer2 = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer2.serializeFragment(content3, { document: doc2 }));
  var firstChild = wrap2.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      var wrapper = doc2.createElement(needsWrap[i2]);
      while (wrap2.firstChild) {
        wrapper.appendChild(wrap2.firstChild);
      }
      wrap2.appendChild(wrapper);
      if (needsWrap[i2] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text3 = view.someProp("clipboardTextSerializer", function(f2) {
    return f2(slice5);
  }) || slice5.content.textBetween(0, slice5.content.size, "\n\n");
  return { dom: wrap2, text: text3 };
}
function parseFromClipboard(view, text3, html2, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice5;
  if (!html2 && !text3) {
    return null;
  }
  var asText = text3 && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", function(f2) {
      text3 = f2(text3, inCode || plainText);
    });
    if (inCode) {
      return new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0);
    }
    var parsed = view.someProp("clipboardTextParser", function(f2) {
      return f2(text3, $context, plainText);
    });
    if (parsed) {
      slice5 = parsed;
    } else {
      var marks3 = $context.marks();
      var ref = view.state;
      var schema2 = ref.schema;
      var serializer2 = DOMSerializer.fromSchema(schema2);
      dom = document.createElement("div");
      text3.trim().split(/(?:\r\n?|\n)+/).forEach(function(block) {
        dom.appendChild(document.createElement("p")).appendChild(serializer2.serializeNode(schema2.text(block, marks3)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f2) {
      html2 = f2(html2);
    });
    dom = readHTML(html2);
    if (result.webkit) {
      restoreReplacedSpaces(dom);
    }
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice5) {
    var parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice5 = parser2.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context });
  }
  if (sliceData) {
    slice5 = addContext(closeSlice(slice5, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice5 = Slice.maxOpen(normalizeSiblings(slice5.content, $context), false);
  }
  view.someProp("transformPasted", function(f2) {
    slice5 = f2(slice5);
  });
  return slice5;
}
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop2 = function(d3) {
    var parent = $context.node(d3);
    var match = parent.contentMatchAt($context.index(d3));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node5) {
      if (!result2) {
        return;
      }
      var wrap2 = match.findWrapping(node5.type), inLast;
      if (!wrap2) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap2, lastWrap, node5, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers(node5, wrap2);
        result2.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap2;
      }
    });
    if (result2) {
      return { v: Fragment.from(result2) };
    }
  };
  for (var d2 = $context.depth; d2 >= 0; d2--) {
    var returned = loop2(d2);
    if (returned)
      return returned.v;
  }
  return fragment;
}
function withWrappers(node5, wrap2, from5) {
  if (from5 === void 0)
    from5 = 0;
  for (var i2 = wrap2.length - 1; i2 >= from5; i2--) {
    node5 = wrap2[i2].create(null, Fragment.from(node5));
  }
  return node5;
}
function addToSibling(wrap2, lastWrap, node5, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap2, lastWrap, node5, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node5.type : wrap2[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node5, wrap2, depth + 1))));
    }
  }
}
function closeRight(node5, depth) {
  if (depth == 0) {
    return node5;
  }
  var fragment = node5.content.replaceChild(node5.childCount - 1, closeRight(node5.lastChild, depth - 1));
  var fill = node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true);
  return node5.copy(fragment.append(fill));
}
function closeRange(fragment, side, from5, to2, depth, openEnd) {
  var node5 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node5.content;
  if (depth < to2 - 1) {
    inner = closeRange(inner, side, from5, to2, depth + 1, openEnd);
  }
  if (depth >= from5) {
    inner = side < 0 ? node5.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node5.contentMatchAt(node5.childCount).fillBefore(Fragment.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node5.copy(inner));
}
function closeSlice(slice5, openStart, openEnd) {
  if (openStart < slice5.openStart) {
    slice5 = new Slice(closeRange(slice5.content, -1, openStart, slice5.openStart, 0, slice5.openEnd), openStart, slice5.openEnd);
  }
  if (openEnd < slice5.openEnd) {
    slice5 = new Slice(closeRange(slice5.content, 1, openEnd, slice5.openEnd, 0, 0), slice5.openStart, openEnd);
  }
  return slice5;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html2) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas) {
    html2 = html2.slice(metas[0].length);
  }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html2 = wrap2.map(function(n2) {
      return "<" + n2 + ">";
    }).join("") + html2 + wrap2.map(function(n2) {
      return "</" + n2 + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html2;
  if (wrap2) {
    for (var i2 = 0; i2 < wrap2.length; i2++) {
      elt = elt.querySelector(wrap2[i2]) || elt;
    }
  }
  return elt;
}
function restoreReplacedSpaces(dom) {
  var nodes2 = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i2 = 0; i2 < nodes2.length; i2++) {
    var node5 = nodes2[i2];
    if (node5.childNodes.length == 1 && node5.textContent == "\xA0" && node5.parentNode) {
      node5.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node5);
    }
  }
}
function addContext(slice5, context) {
  if (!slice5.size) {
    return slice5;
  }
  var schema2 = slice5.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e3) {
    return slice5;
  }
  var content3 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  for (var i2 = array.length - 2; i2 >= 0; i2 -= 2) {
    var type = schema2.nodes[array[i2]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content3 = Fragment.from(type.create(array[i2 + 1], content3));
    openStart++;
    openEnd++;
  }
  return new Slice(content3, openStart, openEnd);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = result.ie && result.ie_version <= 11;
var SelectionState2 = function SelectionState3() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};
SelectionState2.prototype.set = function set2(sel) {
  this.anchorNode = sel.anchorNode;
  this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode;
  this.focusOffset = sel.focusOffset;
};
SelectionState2.prototype.eq = function eq13(sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
};
var DOMObserver2 = function DOMObserver3(view, handleDOMChange) {
  var this$1$1 = this;
  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      this$1$1.queue.push(mutations[i2]);
    }
    if (result.ie && result.ie_version <= 11 && mutations.some(function(m2) {
      return m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length;
    })) {
      this$1$1.flushSoon();
    } else {
      this$1$1.flush();
    }
  });
  this.currentSelection = new SelectionState2();
  if (useCharData) {
    this.onCharData = function(e3) {
      this$1$1.queue.push({ target: e3.target, type: "characterData", oldValue: e3.prevValue });
      this$1$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};
DOMObserver2.prototype.flushSoon = function flushSoon2() {
  var this$1$1 = this;
  if (this.flushingSoon < 0) {
    this.flushingSoon = window.setTimeout(function() {
      this$1$1.flushingSoon = -1;
      this$1$1.flush();
    }, 20);
  }
};
DOMObserver2.prototype.forceFlush = function forceFlush2() {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};
DOMObserver2.prototype.start = function start3() {
  if (this.observer) {
    this.observer.observe(this.view.dom, observeOptions);
  }
  if (useCharData) {
    this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.connectSelection();
};
DOMObserver2.prototype.stop = function stop2() {
  var this$1$1 = this;
  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i2 = 0; i2 < take.length; i2++) {
        this.queue.push(take[i2]);
      }
      window.setTimeout(function() {
        return this$1$1.flush();
      }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) {
    this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  this.disconnectSelection();
};
DOMObserver2.prototype.connectSelection = function connectSelection2() {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver2.prototype.disconnectSelection = function disconnectSelection2() {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};
DOMObserver2.prototype.suppressSelectionUpdates = function suppressSelectionUpdates2() {
  var this$1$1 = this;
  this.suppressingSelectionUpdates = true;
  setTimeout(function() {
    return this$1$1.suppressingSelectionUpdates = false;
  }, 50);
};
DOMObserver2.prototype.onSelectionChange = function onSelectionChange2() {
  if (!hasFocusAndSelection(this.view)) {
    return;
  }
  if (this.suppressingSelectionUpdates) {
    return selectionToDOM(this.view);
  }
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
      return this.flushSoon();
    }
  }
  this.flush();
};
DOMObserver2.prototype.setCurSelection = function setCurSelection2() {
  this.currentSelection.set(this.view.root.getSelection());
};
DOMObserver2.prototype.ignoreSelectionChange = function ignoreSelectionChange2(sel) {
  if (sel.rangeCount == 0) {
    return true;
  }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
    this.setCurSelection();
    return true;
  }
};
DOMObserver2.prototype.flush = function flush2() {
  if (!this.view.docView || this.flushingSoon > -1) {
    return;
  }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }
  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
  var from5 = -1, to2 = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i2 = 0; i2 < mutations.length; i2++) {
      var result$12 = this.registerMutation(mutations[i2], added);
      if (result$12) {
        from5 = from5 < 0 ? result$12.from : Math.min(result$12.from, from5);
        to2 = to2 < 0 ? result$12.to : Math.max(result$12.to, to2);
        if (result$12.typeOver) {
          typeOver = true;
        }
      }
    }
  }
  if (result.gecko && added.length > 1) {
    var brs = added.filter(function(n2) {
      return n2.nodeName == "BR";
    });
    if (brs.length == 2) {
      var a2 = brs[0];
      var b2 = brs[1];
      if (a2.parentNode && a2.parentNode.parentNode == b2.parentNode) {
        b2.remove();
      } else {
        a2.remove();
      }
    }
  }
  if (from5 > -1 || newSel) {
    if (from5 > -1) {
      this.view.docView.markDirty(from5, to2);
      checkCSS(this.view);
    }
    this.handleDOMChange(from5, to2, typeOver, added);
    if (this.view.docView.dirty) {
      this.view.updateState(this.view.state);
    } else if (!this.currentSelection.eq(sel)) {
      selectionToDOM(this.view);
    }
    this.currentSelection.set(sel);
  }
};
DOMObserver2.prototype.registerMutation = function registerMutation2(mut, added) {
  if (added.indexOf(mut.target) > -1) {
    return null;
  }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
    return null;
  }
  if (!desc || desc.ignoreMutation(mut)) {
    return null;
  }
  if (mut.type == "childList") {
    for (var i2 = 0; i2 < mut.addedNodes.length; i2++) {
      added.push(mut.addedNodes[i2]);
    }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
      return { from: desc.posBefore, to: desc.posAfter };
    }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref = mut.addedNodes[i$1];
        var previousSibling = ref.previousSibling;
        var nextSibling = ref.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
          prev = previousSibling;
        }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
          next = nextSibling;
        }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
    var from5 = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
    var to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
    return { from: from5, to: to2 };
  } else if (mut.type == "attributes") {
    return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
  } else {
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      typeOver: mut.target.nodeValue == mut.oldValue
    };
  }
};
var cssChecked = false;
function checkCSS(view) {
  if (cssChecked) {
    return;
  }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
var handlers = {}, editHandlers = {};
function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver2(view, function(from5, to2, typeOver, added) {
    return readDOMChange(view, from5, to2, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = Object.create(null);
  var loop2 = function(event2) {
    var handler = handlers[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers)
    loop2(event);
  if (result.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers) {
    view.dom.removeEventListener(type, view.eventHandlers[type]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.eventHandlers[type]) {
        view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
          return runCustomHandler(view, event);
        });
      }
    }
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node5 = event.target; node5 != view.dom; node5 = node5.parentNode) {
    if (!node5 || node5.nodeType == 11 || node5.pmViewDesc && node5.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent$12(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
    handlers[event.type](view, event);
  }
}
editHandlers.keydown = function(view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) {
    return;
  }
  if (event.keyCode != 229) {
    view.domObserver.forceFlush();
  }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now3 = Date.now();
    view.lastIOSEnter = now3;
    view.lastIOSEnterFallbackTimeout = setTimeout(function() {
      if (view.lastIOSEnter == now3) {
        view.someProp("handleKeyDown", function(f2) {
          return f2(view, keyEvent(13, "Enter"));
        });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function(f2) {
    return f2(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = function(view, e3) {
  if (e3.keyCode == 16) {
    view.shiftKey = false;
  }
};
editHandlers.keypress = function(view, event) {
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
    return;
  }
  if (view.someProp("handleKeyPress", function(f2) {
    return f2(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function(f2) {
      return f2(view, sel.$from.pos, sel.$to.pos, text3);
    })) {
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    }
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop2 = function(i3) {
    if (view.someProp(propName, function(f2) {
      return i3 > $pos.depth ? f2(view, pos, $pos.nodeAfter, $pos.before(i3), event, true) : f2(view, pos, $pos.node(i3), $pos.before(i3), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var returned = loop2(i2);
    if (returned)
      return returned.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node5 = $pos.nodeAfter;
  if (node5 && node5.isAtom && NodeSelection.isSelectable(node5)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node5 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node5)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i2);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f2) {
    return f2(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f2) {
    return f2(view, pos, event);
  });
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f2) {
    return f2(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0) {
    return false;
  }
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i2 = $pos.depth + 1; i2 > 0; i2--) {
    var node5 = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    var nodePos = $pos.before(i2);
    if (node5.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node5.content.size), "pointer");
    } else if (NodeSelection.isSelectable(node5)) {
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
handlers.mousedown = function(view, event) {
  view.shiftKey = event.shiftKey;
  var flushed2 = forceDOMFlush(view);
  var now3 = Date.now(), type = "singleClick";
  if (now3 - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") {
      type = "doubleClick";
    } else if (view.lastClick.type == "doubleClick") {
      type = "tripleClick";
    }
  }
  view.lastClick = { time: now3, x: event.clientX, y: event.clientY, type };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) {
    return;
  }
  if (type == "singleClick") {
    if (view.mouseDown) {
      view.mouseDown.done();
    }
    view.mouseDown = new MouseDown2(view, pos, event, flushed2);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown2 = function MouseDown3(view, pos, event, flushed2) {
  var this$1$1 = this;
  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed2;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }
  this.mightDrag = null;
  var target = flushed2 ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;
  var ref = view.state;
  var selection = ref.selection;
  if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
    this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: this.target && !this.target.draggable,
      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
    };
  }
  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.draggable = true;
    }
    if (this.mightDrag.setUneditable) {
      setTimeout(function() {
        if (this$1$1.view.mouseDown == this$1$1) {
          this$1$1.target.setAttribute("contentEditable", "false");
        }
      }, 20);
    }
    this.view.domObserver.start();
  }
  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin(view, "pointer");
};
MouseDown2.prototype.done = function done2() {
  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) {
      this.target.removeAttribute("draggable");
    }
    if (this.mightDrag.setUneditable) {
      this.target.removeAttribute("contentEditable");
    }
    this.view.domObserver.start();
  }
  this.view.mouseDown = null;
};
MouseDown2.prototype.up = function up2(event) {
  this.done();
  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
    return;
  }
  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) {
    pos = this.view.posAtCoords(eventCoords(event));
  }
  if (this.allowDefault || !pos) {
    setSelectionOrigin(this.view, "pointer");
  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 && (this.flushed || result.safari && this.mightDrag && !this.mightDrag.node.isAtom || result.chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin(this.view, "pointer");
  }
};
MouseDown2.prototype.move = function move2(event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
    this.allowDefault = true;
  }
  setSelectionOrigin(this.view, "pointer");
  if (event.buttons == 0) {
    this.done();
  }
};
handlers.touchdown = function(view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = function(view) {
  return forceDOMFlush(view);
};
function inOrNearComposition(view, event) {
  if (view.composing) {
    return true;
  }
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = result.android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m2) {
      return m2.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node5 = sel.focusNode, offset2 = sel.focusOffset; node5 && node5.nodeType == 1 && offset2 != 0; ) {
          var before2 = offset2 < 0 ? node5.lastChild : node5.childNodes[offset2 - 1];
          if (!before2) {
            break;
          }
          if (before2.nodeType == 3) {
            sel.collapse(before2, before2.nodeValue.length);
            break;
          } else {
            node5 = before2;
            offset2 = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = function(view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition(view);
    }, delay);
  }
}
function clearComposition(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate) {
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function() {
    if (wrap2.parentNode) {
      wrap2.parentNode.removeChild(wrap2);
    }
    view.focus();
  }, 50);
}
var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
handlers.copy = editHandlers.cut = function(view, e3) {
  var sel = view.state.selection, cut3 = e3.type == "cut";
  if (sel.empty) {
    return;
  }
  var data = brokenClipboardAPI ? null : e3.clipboardData;
  var slice5 = sel.content();
  var ref = serializeForClipboard(view, slice5);
  var dom = ref.dom;
  var text3 = ref.text;
  if (data) {
    e3.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy(view, dom);
  }
  if (cut3) {
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  }
};
function sliceSingleNode(slice5) {
  return slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1 ? slice5.content.firstChild : null;
}
function capturePaste(view, e3) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target.contentEditable = "true";
  }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function() {
    view.focus();
    if (target.parentNode) {
      target.parentNode.removeChild(target);
    }
    if (plainText) {
      doPaste(view, target.value, null, e3);
    } else {
      doPaste(view, target.textContent, target.innerHTML, e3);
    }
  }, 50);
}
function doPaste(view, text3, html2, e3) {
  var slice5 = parseFromClipboard(view, text3, html2, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f2) {
    return f2(view, e3, slice5 || Slice.empty);
  })) {
    return true;
  }
  if (!slice5) {
    return false;
  }
  var singleNode = sliceSingleNode(slice5);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice5);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = function(view, e3) {
  var data = brokenClipboardAPI ? null : e3.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e3)) {
    e3.preventDefault();
  } else {
    capturePaste(view, e3);
  }
};
var Dragging2 = function Dragging3(slice5, move3) {
  this.slice = slice5;
  this.move = move3;
};
var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
handlers.dragstart = function(view, e3) {
  var mouseDown = view.mouseDown;
  if (mouseDown) {
    mouseDown.done();
  }
  if (!e3.dataTransfer) {
    return;
  }
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e3));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e3.target && e3.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e3.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) {
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
    }
  }
  var slice5 = view.state.selection.content();
  var ref = serializeForClipboard(view, slice5);
  var dom = ref.dom;
  var text3 = ref.text;
  e3.dataTransfer.clearData();
  e3.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  e3.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) {
    e3.dataTransfer.setData("text/plain", text3);
  }
  view.dragging = new Dragging2(slice5, !e3[dragCopyModifier]);
};
handlers.dragend = function(view) {
  var dragging = view.dragging;
  window.setTimeout(function() {
    if (view.dragging == dragging) {
      view.dragging = null;
    }
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = function(_2, e3) {
  return e3.preventDefault();
};
editHandlers.drop = function(view, e3) {
  var dragging = view.dragging;
  view.dragging = null;
  if (!e3.dataTransfer) {
    return;
  }
  var eventPos = view.posAtCoords(eventCoords(e3));
  if (!eventPos) {
    return;
  }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) {
    return;
  }
  var slice5 = dragging && dragging.slice;
  if (slice5) {
    view.someProp("transformPasted", function(f2) {
      slice5 = f2(slice5);
    });
  } else {
    slice5 = parseFromClipboard(view, e3.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e3.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move3 = dragging && !e3[dragCopyModifier];
  if (view.someProp("handleDrop", function(f2) {
    return f2(view, e3, slice5 || Slice.empty, move3);
  })) {
    e3.preventDefault();
    return;
  }
  if (!slice5) {
    return;
  }
  e3.preventDefault();
  var insertPos = slice5 ? dropPoint(view.state.doc, $mouse.pos, slice5) : $mouse.pos;
  if (insertPos == null) {
    insertPos = $mouse.pos;
  }
  var tr = view.state.tr;
  if (move3) {
    tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode = slice5.openStart == 0 && slice5.openEnd == 0 && slice5.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) {
    tr.replaceRangeWith(pos, pos, slice5.content.firstChild);
  } else {
    tr.replaceRange(pos, pos, slice5);
  }
  if (tr.doc.eq(beforeInsert)) {
    return;
  }
  var $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice5.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice5.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    var end3 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
      return end3 = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end3)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = function(view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function() {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
        selectionToDOM(view);
      }
    }, 20);
  }
};
handlers.blur = function(view) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    view.domObserver.currentSelection.set({});
    view.focused = false;
  }
};
handlers.beforeinput = function(view, event) {
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    var domChangeCount = view.domChangeCount;
    setTimeout(function() {
      if (view.domChangeCount != domChangeCount) {
        return;
      }
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(8, "Backspace"));
      })) {
        return;
      }
      var ref = view.state.selection;
      var $cursor = ref.$cursor;
      if ($cursor && $cursor.pos > 0) {
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }
    }, 50);
  }
};
for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}
function compareObjs(a2, b2) {
  if (a2 == b2) {
    return true;
  }
  for (var p2 in a2) {
    if (a2[p2] !== b2[p2]) {
      return false;
    }
  }
  for (var p$12 in b2) {
    if (!(p$12 in a2)) {
      return false;
    }
  }
  return true;
}
var WidgetType2 = function WidgetType3(toDOM, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};
WidgetType2.prototype.map = function map14(mapping, span, offset2, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
  var pos = ref.pos;
  var deleted = ref.deleted;
  return deleted ? null : new Decoration2(pos - offset2, pos - offset2, this);
};
WidgetType2.prototype.valid = function valid4() {
  return true;
};
WidgetType2.prototype.eq = function eq14(other) {
  return this == other || other instanceof WidgetType2 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
};
var InlineType2 = function InlineType3(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
InlineType2.prototype.map = function map15(mapping, span, offset2, oldOffset) {
  var from5 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
  var to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
  return from5 >= to2 ? null : new Decoration2(from5, to2, this);
};
InlineType2.prototype.valid = function valid5(_2, span) {
  return span.from < span.to;
};
InlineType2.prototype.eq = function eq15(other) {
  return this == other || other instanceof InlineType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
InlineType2.is = function is2(span) {
  return span.type instanceof InlineType2;
};
var NodeType3 = function NodeType4(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};
NodeType3.prototype.map = function map16(mapping, span, offset2, oldOffset) {
  var from5 = mapping.mapResult(span.from + oldOffset, 1);
  if (from5.deleted) {
    return null;
  }
  var to2 = mapping.mapResult(span.to + oldOffset, -1);
  if (to2.deleted || to2.pos <= from5.pos) {
    return null;
  }
  return new Decoration2(from5.pos - offset2, to2.pos - offset2, this);
};
NodeType3.prototype.valid = function valid6(node5, span) {
  var ref = node5.content.findIndex(span.from);
  var index3 = ref.index;
  var offset2 = ref.offset;
  return offset2 == span.from && offset2 + node5.child(index3).nodeSize == span.to;
};
NodeType3.prototype.eq = function eq16(other) {
  return this == other || other instanceof NodeType3 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
};
var Decoration2 = function Decoration3(from5, to2, type) {
  this.from = from5;
  this.to = to2;
  this.type = type;
};
var prototypeAccessors$1 = { spec: { configurable: true }, inline: { configurable: true } };
Decoration2.prototype.copy = function copy5(from5, to2) {
  return new Decoration2(from5, to2, this.type);
};
Decoration2.prototype.eq = function eq17(other, offset2) {
  if (offset2 === void 0)
    offset2 = 0;
  return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
};
Decoration2.prototype.map = function map17(mapping, offset2, oldOffset) {
  return this.type.map(mapping, this, offset2, oldOffset);
};
Decoration2.widget = function widget2(pos, toDOM, spec) {
  return new Decoration2(pos, pos, new WidgetType2(toDOM, spec));
};
Decoration2.inline = function inline2(from5, to2, attrs, spec) {
  return new Decoration2(from5, to2, new InlineType2(attrs, spec));
};
Decoration2.node = function node4(from5, to2, attrs, spec) {
  return new Decoration2(from5, to2, new NodeType3(attrs, spec));
};
prototypeAccessors$1.spec.get = function() {
  return this.type.spec;
};
prototypeAccessors$1.inline.get = function() {
  return this.type instanceof InlineType2;
};
Object.defineProperties(Decoration2.prototype, prototypeAccessors$1);
var none = [], noSpec = {};
var DecorationSet2 = function DecorationSet3(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};
DecorationSet2.create = function create5(doc2, decorations) {
  return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
};
DecorationSet2.prototype.find = function find2(start4, end3, predicate) {
  var result2 = [];
  this.findInner(start4 == null ? 0 : start4, end3 == null ? 1e9 : end3, result2, 0, predicate);
  return result2;
};
DecorationSet2.prototype.findInner = function findInner2(start4, end3, result2, offset2, predicate) {
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var span = this.local[i2];
    if (span.from <= end3 && span.to >= start4 && (!predicate || predicate(span.spec))) {
      result2.push(span.copy(span.from + offset2, span.to + offset2));
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end3 && this.children[i$1 + 1] > start4) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start4 - childOff, end3 - childOff, result2, offset2 + childOff, predicate);
    }
  }
};
DecorationSet2.prototype.map = function map18(mapping, doc2, options) {
  if (this == empty || mapping.maps.length == 0) {
    return this;
  }
  return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
};
DecorationSet2.prototype.mapInner = function mapInner2(mapping, node5, offset2, oldOffset, options) {
  var newLocal;
  for (var i2 = 0; i2 < this.local.length; i2++) {
    var mapped = this.local[i2].map(mapping, offset2, oldOffset);
    if (mapped && mapped.type.valid(node5, mapped)) {
      (newLocal || (newLocal = [])).push(mapped);
    } else if (options.onRemove) {
      options.onRemove(this.local[i2].spec);
    }
  }
  if (this.children.length) {
    return mapChildren(this.children, newLocal, mapping, node5, offset2, oldOffset, options);
  } else {
    return newLocal ? new DecorationSet2(newLocal.sort(byPos)) : empty;
  }
};
DecorationSet2.prototype.add = function add2(doc2, decorations) {
  if (!decorations.length) {
    return this;
  }
  if (this == empty) {
    return DecorationSet2.create(doc2, decorations);
  }
  return this.addInner(doc2, decorations, 0);
};
DecorationSet2.prototype.addInner = function addInner2(doc2, decorations, offset2) {
  var this$1$1 = this;
  var children, childIndex = 0;
  doc2.forEach(function(childNode, childOffset) {
    var baseOffset = childOffset + offset2, found2;
    if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset))) {
      return;
    }
    if (!children) {
      children = this$1$1.children.slice();
    }
    while (childIndex < children.length && children[childIndex] < childOffset) {
      childIndex += 3;
    }
    if (children[childIndex] == childOffset) {
      children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
    } else {
      children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
    }
    childIndex += 3;
  });
  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
  for (var i2 = 0; i2 < local.length; i2++) {
    if (!local[i2].type.valid(doc2, local[i2])) {
      local.splice(i2--, 1);
    }
  }
  return new DecorationSet2(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
};
DecorationSet2.prototype.remove = function remove2(decorations) {
  if (decorations.length == 0 || this == empty) {
    return this;
  }
  return this.removeInner(decorations, 0);
};
DecorationSet2.prototype.removeInner = function removeInner2(decorations, offset2) {
  var children = this.children, local = this.local;
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    var found2 = void 0, from5 = children[i2] + offset2, to2 = children[i2 + 1] + offset2;
    for (var j2 = 0, span = void 0; j2 < decorations.length; j2++) {
      if (span = decorations[j2]) {
        if (span.from > from5 && span.to < to2) {
          decorations[j2] = null;
          (found2 || (found2 = [])).push(span);
        }
      }
    }
    if (!found2) {
      continue;
    }
    if (children == this.children) {
      children = this.children.slice();
    }
    var removed = children[i2 + 2].removeInner(found2, from5 + 1);
    if (removed != empty) {
      children[i2 + 2] = removed;
    } else {
      children.splice(i2, 3);
      i2 -= 3;
    }
  }
  if (local.length) {
    for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
      if (span$1 = decorations[i$1]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) {
          if (local[j$1].eq(span$1, offset2)) {
            if (local == this.local) {
              local = this.local.slice();
            }
            local.splice(j$1--, 1);
          }
        }
      }
    }
  }
  if (children == this.children && local == this.local) {
    return this;
  }
  return local.length || children.length ? new DecorationSet2(local, children) : empty;
};
DecorationSet2.prototype.forChild = function forChild3(offset2, node5) {
  if (this == empty) {
    return this;
  }
  if (node5.isLeaf) {
    return DecorationSet2.empty;
  }
  var child4, local;
  for (var i2 = 0; i2 < this.children.length; i2 += 3) {
    if (this.children[i2] >= offset2) {
      if (this.children[i2] == offset2) {
        child4 = this.children[i2 + 2];
      }
      break;
    }
  }
  var start4 = offset2 + 1, end3 = start4 + node5.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end3 && dec.to > start4 && dec.type instanceof InlineType2) {
      var from5 = Math.max(start4, dec.from) - start4, to2 = Math.min(end3, dec.to) - start4;
      if (from5 < to2) {
        (local || (local = [])).push(dec.copy(from5, to2));
      }
    }
  }
  if (local) {
    var localSet = new DecorationSet2(local.sort(byPos));
    return child4 ? new DecorationGroup2([localSet, child4]) : localSet;
  }
  return child4 || empty;
};
DecorationSet2.prototype.eq = function eq18(other) {
  if (this == other) {
    return true;
  }
  if (!(other instanceof DecorationSet2) || this.local.length != other.local.length || this.children.length != other.children.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!this.local[i2].eq(other.local[i2])) {
      return false;
    }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
      return false;
    }
  }
  return true;
};
DecorationSet2.prototype.locals = function locals3(node5) {
  return removeOverlap(this.localsInner(node5));
};
DecorationSet2.prototype.localsInner = function localsInner2(node5) {
  if (this == empty) {
    return none;
  }
  if (node5.inlineContent || !this.local.some(InlineType2.is)) {
    return this.local;
  }
  var result2 = [];
  for (var i2 = 0; i2 < this.local.length; i2++) {
    if (!(this.local[i2].type instanceof InlineType2)) {
      result2.push(this.local[i2]);
    }
  }
  return result2;
};
var empty = new DecorationSet2();
DecorationSet2.empty = empty;
DecorationSet2.removeOverlap = removeOverlap;
var DecorationGroup2 = function DecorationGroup3(members) {
  this.members = members;
};
DecorationGroup2.prototype.map = function map19(mapping, doc2) {
  var mappedDecos = this.members.map(function(member) {
    return member.map(mapping, doc2, noSpec);
  });
  return DecorationGroup2.from(mappedDecos);
};
DecorationGroup2.prototype.forChild = function forChild4(offset2, child4) {
  if (child4.isLeaf) {
    return DecorationSet2.empty;
  }
  var found2 = [];
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var result2 = this.members[i2].forChild(offset2, child4);
    if (result2 == empty) {
      continue;
    }
    if (result2 instanceof DecorationGroup2) {
      found2 = found2.concat(result2.members);
    } else {
      found2.push(result2);
    }
  }
  return DecorationGroup2.from(found2);
};
DecorationGroup2.prototype.eq = function eq19(other) {
  if (!(other instanceof DecorationGroup2) || other.members.length != this.members.length) {
    return false;
  }
  for (var i2 = 0; i2 < this.members.length; i2++) {
    if (!this.members[i2].eq(other.members[i2])) {
      return false;
    }
  }
  return true;
};
DecorationGroup2.prototype.locals = function locals4(node5) {
  var result2, sorted = true;
  for (var i2 = 0; i2 < this.members.length; i2++) {
    var locals5 = this.members[i2].localsInner(node5);
    if (!locals5.length) {
      continue;
    }
    if (!result2) {
      result2 = locals5;
    } else {
      if (sorted) {
        result2 = result2.slice();
        sorted = false;
      }
      for (var j2 = 0; j2 < locals5.length; j2++) {
        result2.push(locals5[j2]);
      }
    }
  }
  return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
};
DecorationGroup2.from = function from4(members) {
  switch (members.length) {
    case 0:
      return empty;
    case 1:
      return members[0];
    default:
      return new DecorationGroup2(members);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node5, offset2, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i3 = 0; i3 < children.length; i3 += 3) {
      var end3 = children[i3 + 1], dSize = void 0;
      if (end3 == -1 || oldStart > end3 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i3] + oldOffset) {
        children[i3 + 1] = -1;
      } else if (newStart >= offset2 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i3] += dSize;
        children[i3 + 1] += dSize;
      }
    }
  };
  for (var i2 = 0; i2 < mapping.maps.length; i2++) {
    mapping.maps[i2].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] == -1) {
      var from5 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from5 - offset2;
      if (fromLocal < 0 || fromLocal >= node5.content.size) {
        mustRebuild = true;
        continue;
      }
      var to2 = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to2 - offset2;
      var ref = node5.content.findIndex(fromLocal);
      var index3 = ref.index;
      var childOffset = ref.offset;
      var childNode = node5.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from5 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset2, oldOffset, options);
    var built = buildTree(decorations, node5, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] < 0) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j2 = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j2 < children.length && children[j2] < from$1) {
        j2 += 3;
      }
      children.splice(j2, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet2(newLocal && newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i2 = 0; i2 < spans.length; i2++) {
    var span = spans[i2];
    result2.push(new Decoration2(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather2(set3, oldOffset2) {
    for (var i3 = 0; i3 < set3.local.length; i3++) {
      var mapped = set3.local[i3].map(mapping, offset2, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set3.local[i3].spec);
      }
    }
    for (var i$1 = 0; i$1 < set3.children.length; i$1 += 3) {
      gather2(set3.children[i$1 + 2], set3.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i2 = 0; i2 < children.length; i2 += 3) {
    if (children[i2 + 1] == -1) {
      gather2(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode(spans, node5, offset2) {
  if (node5.isLeaf) {
    return null;
  }
  var end3 = offset2 + node5.nodeSize, found2 = null;
  for (var i2 = 0, span = void 0; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset2 && span.to < end3) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  var result2 = [];
  for (var i2 = 0; i2 < array.length; i2++) {
    if (array[i2] != null) {
      result2.push(array[i2]);
    }
  }
  return result2;
}
function buildTree(spans, node5, offset2, options) {
  var children = [], hasNulls = false;
  node5.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals5 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (var i2 = 0; i2 < locals5.length; i2++) {
    if (!locals5[i2].type.valid(node5, locals5[i2])) {
      if (options.onRemove) {
        options.onRemove(locals5[i2].spec);
      }
      locals5.splice(i2--, 1);
    }
  }
  return locals5.length || children.length ? new DecorationSet2(locals5, children) : empty;
}
function byPos(a2, b2) {
  return a2.from - b2.from || a2.to - b2.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var i2 = 0; i2 < working.length - 1; i2++) {
    var span = working[i2];
    if (span.from != span.to) {
      for (var j2 = i2 + 1; j2 < working.length; j2++) {
        var next = working[j2];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j2] = next.copy(next.from, span.to);
            insertAhead(working, j2 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i2] = span.copy(span.from, next.from);
            insertAhead(working, j2, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead(array, i2, deco) {
  while (i2 < array.length && byPos(deco, array[i2]) > 0) {
    i2++;
  }
  array.splice(i2, 0, deco);
}
function viewDecorations(view) {
  var found2 = [];
  view.someProp("decorations", function(f2) {
    var result2 = f2(view.state);
    if (result2 && result2 != empty) {
      found2.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found2.push(DecorationSet2.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup2.from(found2);
}
var EditorView2 = function EditorView3(place, props) {
  this._props = props;
  this.state = props.state;
  this.dispatch = this.dispatch.bind(this);
  this._root = null;
  this.focused = false;
  this.trackWrites = null;
  this.dom = place && place.mount || document.createElement("div");
  if (place) {
    if (place.appendChild) {
      place.appendChild(this.dom);
    } else if (place.apply) {
      place(this.dom);
    } else if (place.mount) {
      this.mounted = true;
    }
  }
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
  this.lastSelectedViewDesc = null;
  this.dragging = null;
  initInput(this);
  this.pluginViews = [];
  this.updatePluginViews();
};
var prototypeAccessors$2 = { props: { configurable: true }, root: { configurable: true } };
prototypeAccessors$2.props.get = function() {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) {
      this._props[name] = prev[name];
    }
    this._props.state = this.state;
  }
  return this._props;
};
EditorView2.prototype.update = function update2(props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) {
    ensureListeners(this);
  }
  this._props = props;
  this.updateStateInner(props.state, true);
};
EditorView2.prototype.setProps = function setProps2(props) {
  var updated = {};
  for (var name in this._props) {
    updated[name] = this._props[name];
  }
  updated.state = this.state;
  for (var name$1 in props) {
    updated[name$1] = props[name$1];
  }
  this.update(updated);
};
EditorView2.prototype.updateState = function updateState2(state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};
EditorView2.prototype.updateStateInner = function updateStateInner2(state, reconfigured) {
  var this$1$1 = this;
  var prev = this.state, redraw = false, updateSel = false;
  if (state.storedMarks && this.composing) {
    clearComposition(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }
  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
  var scroll2 = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) {
    updateSel = true;
  }
  var oldScrollPos = scroll2 == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
  if (updateSel) {
    this.domObserver.stop();
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
    if (updateDoc) {
      var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) {
        forceSelUpdate = true;
      }
    }
    if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM(this, forceSelUpdate);
    } else {
      syncNodeSelection(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }
  this.updatePluginViews(prev);
  if (scroll2 == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll2 == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function(f2) {
      return f2(this$1$1);
    }))
      ;
    else if (state.selection instanceof NodeSelection) {
      scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
    }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};
EditorView2.prototype.destroyPluginViews = function destroyPluginViews2() {
  var view;
  while (view = this.pluginViews.pop()) {
    if (view.destroy) {
      view.destroy();
    }
  }
};
EditorView2.prototype.updatePluginViews = function updatePluginViews2(prevState) {
  if (!prevState || prevState.plugins != this.state.plugins) {
    this.destroyPluginViews();
    for (var i2 = 0; i2 < this.state.plugins.length; i2++) {
      var plugin2 = this.state.plugins[i2];
      if (plugin2.spec.view) {
        this.pluginViews.push(plugin2.spec.view(this));
      }
    }
  } else {
    for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {
      var pluginView = this.pluginViews[i$1];
      if (pluginView.update) {
        pluginView.update(this, prevState);
      }
    }
  }
};
EditorView2.prototype.someProp = function someProp2(propName, f2) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f2 ? f2(prop) : prop)) {
    return value;
  }
  var plugins = this.state.plugins;
  if (plugins) {
    for (var i2 = 0; i2 < plugins.length; i2++) {
      var prop$1 = plugins[i2].props[propName];
      if (prop$1 != null && (value = f2 ? f2(prop$1) : prop$1)) {
        return value;
      }
    }
  }
};
EditorView2.prototype.hasFocus = function hasFocus2() {
  return this.root.activeElement == this.dom;
};
EditorView2.prototype.focus = function focus2() {
  this.domObserver.stop();
  if (this.editable) {
    focusPreventScroll(this.dom);
  }
  selectionToDOM(this);
  this.domObserver.start();
};
prototypeAccessors$2.root.get = function() {
  var cached = this._root;
  if (cached == null) {
    for (var search3 = this.dom.parentNode; search3; search3 = search3.parentNode) {
      if (search3.nodeType == 9 || search3.nodeType == 11 && search3.host) {
        if (!search3.getSelection) {
          Object.getPrototypeOf(search3).getSelection = function() {
            return document.getSelection();
          };
        }
        return this._root = search3;
      }
    }
  }
  return cached || document;
};
EditorView2.prototype.posAtCoords = function posAtCoords$12(coords) {
  return posAtCoords(this, coords);
};
EditorView2.prototype.coordsAtPos = function coordsAtPos$12(pos, side) {
  if (side === void 0)
    side = 1;
  return coordsAtPos(this, pos, side);
};
EditorView2.prototype.domAtPos = function domAtPos2(pos, side) {
  if (side === void 0)
    side = 0;
  return this.docView.domFromPos(pos, side);
};
EditorView2.prototype.nodeDOM = function nodeDOM2(pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null;
};
EditorView2.prototype.posAtDOM = function posAtDOM2(node5, offset2, bias) {
  if (bias === void 0)
    bias = -1;
  var pos = this.docView.posFromDOM(node5, offset2, bias);
  if (pos == null) {
    throw new RangeError("DOM position not inside the editor");
  }
  return pos;
};
EditorView2.prototype.endOfTextblock = function endOfTextblock$12(dir, state) {
  return endOfTextblock(this, state || this.state, dir);
};
EditorView2.prototype.destroy = function destroy4() {
  if (!this.docView) {
    return;
  }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};
EditorView2.prototype.dispatchEvent = function dispatchEvent$1$1(event) {
  return dispatchEvent$12(this, event);
};
EditorView2.prototype.dispatch = function dispatch2(tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) {
    dispatchTransaction.call(this, tr);
  } else {
    this.updateState(this.state.apply(tr));
  }
};
Object.defineProperties(EditorView2.prototype, prototypeAccessors$2);
function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration2.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = { dom, deco: Decoration2.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop)) {
        result2[prop] = obj[prop];
      }
    }
  });
  return result2;
}
function changedNodeViews(a2, b2) {
  var nA = 0, nB = 0;
  for (var prop in a2) {
    if (a2[prop] != b2[prop]) {
      return true;
    }
    nA++;
  }
  for (var _2 in b2) {
    nB++;
  }
  return nA != nB;
}
var readFromCache, addToCache;
if (typeof WeakMap != "undefined") {
  var cache = new WeakMap();
  readFromCache = function(key2) {
    return cache.get(key2);
  };
  addToCache = function(key2, value) {
    cache.set(key2, value);
    return value;
  };
} else {
  var cache$1 = [], cacheSize = 10, cachePos = 0;
  readFromCache = function(key2) {
    for (var i2 = 0; i2 < cache$1.length; i2 += 2) {
      if (cache$1[i2] == key2) {
        return cache$1[i2 + 1];
      }
    }
  };
  addToCache = function(key2, value) {
    if (cachePos == cacheSize) {
      cachePos = 0;
    }
    cache$1[cachePos++] = key2;
    return cache$1[cachePos++] = value;
  };
}
var Rect = function Rect2(left, top2, right, bottom) {
  this.left = left;
  this.top = top2;
  this.right = right;
  this.bottom = bottom;
};
var TableMap = function TableMap2(width, height, map21, problems) {
  this.width = width;
  this.height = height;
  this.map = map21;
  this.problems = problems;
};
TableMap.prototype.findCell = function findCell(pos) {
  for (var i2 = 0; i2 < this.map.length; i2++) {
    var curPos = this.map[i2];
    if (curPos != pos) {
      continue;
    }
    var left = i2 % this.width, top2 = i2 / this.width | 0;
    var right = left + 1, bottom = top2 + 1;
    for (var j2 = 1; right < this.width && this.map[i2 + j2] == curPos; j2++) {
      right++;
    }
    for (var j$1 = 1; bottom < this.height && this.map[i2 + this.width * j$1] == curPos; j$1++) {
      bottom++;
    }
    return new Rect(left, top2, right, bottom);
  }
  throw new RangeError("No cell with offset " + pos + " found");
};
TableMap.prototype.colCount = function colCount(pos) {
  for (var i2 = 0; i2 < this.map.length; i2++) {
    if (this.map[i2] == pos) {
      return i2 % this.width;
    }
  }
  throw new RangeError("No cell with offset " + pos + " found");
};
TableMap.prototype.nextCell = function nextCell(pos, axis, dir) {
  var ref = this.findCell(pos);
  var left = ref.left;
  var right = ref.right;
  var top2 = ref.top;
  var bottom = ref.bottom;
  if (axis == "horiz") {
    if (dir < 0 ? left == 0 : right == this.width) {
      return null;
    }
    return this.map[top2 * this.width + (dir < 0 ? left - 1 : right)];
  } else {
    if (dir < 0 ? top2 == 0 : bottom == this.height) {
      return null;
    }
    return this.map[left + this.width * (dir < 0 ? top2 - 1 : bottom)];
  }
};
TableMap.prototype.rectBetween = function rectBetween(a2, b2) {
  var ref = this.findCell(a2);
  var leftA = ref.left;
  var rightA = ref.right;
  var topA = ref.top;
  var bottomA = ref.bottom;
  var ref$1 = this.findCell(b2);
  var leftB = ref$1.left;
  var rightB = ref$1.right;
  var topB = ref$1.top;
  var bottomB = ref$1.bottom;
  return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));
};
TableMap.prototype.cellsInRect = function cellsInRect(rect) {
  var result2 = [], seen = {};
  for (var row = rect.top; row < rect.bottom; row++) {
    for (var col = rect.left; col < rect.right; col++) {
      var index3 = row * this.width + col, pos = this.map[index3];
      if (seen[pos]) {
        continue;
      }
      seen[pos] = true;
      if ((col != rect.left || !col || this.map[index3 - 1] != pos) && (row != rect.top || !row || this.map[index3 - this.width] != pos)) {
        result2.push(pos);
      }
    }
  }
  return result2;
};
TableMap.prototype.positionAt = function positionAt(row, col, table2) {
  for (var i2 = 0, rowStart = 0; ; i2++) {
    var rowEnd = rowStart + table2.child(i2).nodeSize;
    if (i2 == row) {
      var index3 = col + row * this.width, rowEndIndex = (row + 1) * this.width;
      while (index3 < rowEndIndex && this.map[index3] < rowStart) {
        index3++;
      }
      return index3 == rowEndIndex ? rowEnd - 1 : this.map[index3];
    }
    rowStart = rowEnd;
  }
};
TableMap.get = function get3(table2) {
  return readFromCache(table2) || addToCache(table2, computeMap(table2));
};
function computeMap(table2) {
  if (table2.type.spec.tableRole != "table") {
    throw new RangeError("Not a table node: " + table2.type.name);
  }
  var width = findWidth(table2), height = table2.childCount;
  var map21 = [], mapPos = 0, problems = null, colWidths = [];
  for (var i2 = 0, e3 = width * height; i2 < e3; i2++) {
    map21[i2] = 0;
  }
  for (var row = 0, pos = 0; row < height; row++) {
    var rowNode = table2.child(row);
    pos++;
    for (var i$1 = 0; ; i$1++) {
      while (mapPos < map21.length && map21[mapPos] != 0) {
        mapPos++;
      }
      if (i$1 == rowNode.childCount) {
        break;
      }
      var cellNode = rowNode.child(i$1);
      var ref = cellNode.attrs;
      var colspan = ref.colspan;
      var rowspan = ref.rowspan;
      var colwidth = ref.colwidth;
      for (var h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({ type: "overlong_rowspan", pos, n: rowspan - h2 });
          break;
        }
        var start4 = mapPos + h2 * width;
        for (var w2 = 0; w2 < colspan; w2++) {
          if (map21[start4 + w2] == 0) {
            map21[start4 + w2] = pos;
          } else {
            (problems || (problems = [])).push({ type: "collision", row, pos, n: colspan - w2 });
          }
          var colW = colwidth && colwidth[w2];
          if (colW) {
            var widthIndex = (start4 + w2) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    var expectedPos = (row + 1) * width, missing = 0;
    while (mapPos < expectedPos) {
      if (map21[mapPos++] == 0) {
        missing++;
      }
    }
    if (missing) {
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    }
    pos++;
  }
  var tableMap = new TableMap(width, height, map21, problems), badWidths = false;
  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2) {
    if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) {
      badWidths = true;
    }
  }
  if (badWidths) {
    findBadColWidths(tableMap, colWidths, table2);
  }
  return tableMap;
}
function findWidth(table2) {
  var width = -1, hasRowSpan = false;
  for (var row = 0; row < table2.childCount; row++) {
    var rowNode = table2.child(row), rowWidth = 0;
    if (hasRowSpan) {
      for (var j2 = 0; j2 < row; j2++) {
        var prevRow = table2.child(j2);
        for (var i2 = 0; i2 < prevRow.childCount; i2++) {
          var cell = prevRow.child(i2);
          if (j2 + cell.attrs.rowspan > row) {
            rowWidth += cell.attrs.colspan;
          }
        }
      }
    }
    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {
      var cell$1 = rowNode.child(i$1);
      rowWidth += cell$1.attrs.colspan;
      if (cell$1.attrs.rowspan > 1) {
        hasRowSpan = true;
      }
    }
    if (width == -1) {
      width = rowWidth;
    } else if (width != rowWidth) {
      width = Math.max(width, rowWidth);
    }
  }
  return width;
}
function findBadColWidths(map21, colWidths, table2) {
  if (!map21.problems) {
    map21.problems = [];
  }
  for (var i2 = 0, seen = {}; i2 < map21.map.length; i2++) {
    var pos = map21.map[i2];
    if (seen[pos]) {
      continue;
    }
    seen[pos] = true;
    var node5 = table2.nodeAt(pos), updated = null;
    for (var j2 = 0; j2 < node5.attrs.colspan; j2++) {
      var col = (i2 + j2) % map21.width, colWidth = colWidths[col * 2];
      if (colWidth != null && (!node5.attrs.colwidth || node5.attrs.colwidth[j2] != colWidth)) {
        (updated || (updated = freshColWidth(node5.attrs)))[j2] = colWidth;
      }
    }
    if (updated) {
      map21.problems.unshift({ type: "colwidth mismatch", pos, colwidth: updated });
    }
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) {
    return attrs.colwidth.slice();
  }
  var result2 = [];
  for (var i2 = 0; i2 < attrs.colspan; i2++) {
    result2.push(0);
  }
  return result2;
}
function getCellAttrs(dom, extraAttrs) {
  var widthAttr = dom.getAttribute("data-colwidth");
  var widths = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map(function(s2) {
    return Number(s2);
  }) : null;
  var colspan = Number(dom.getAttribute("colspan") || 1);
  var result2 = {
    colspan,
    rowspan: Number(dom.getAttribute("rowspan") || 1),
    colwidth: widths && widths.length == colspan ? widths : null
  };
  for (var prop in extraAttrs) {
    var getter = extraAttrs[prop].getFromDOM;
    var value = getter && getter(dom);
    if (value != null) {
      result2[prop] = value;
    }
  }
  return result2;
}
function setCellAttrs(node5, extraAttrs) {
  var attrs = {};
  if (node5.attrs.colspan != 1) {
    attrs.colspan = node5.attrs.colspan;
  }
  if (node5.attrs.rowspan != 1) {
    attrs.rowspan = node5.attrs.rowspan;
  }
  if (node5.attrs.colwidth) {
    attrs["data-colwidth"] = node5.attrs.colwidth.join(",");
  }
  for (var prop in extraAttrs) {
    var setter = extraAttrs[prop].setDOMAttr;
    if (setter) {
      setter(node5.attrs[prop], attrs);
    }
  }
  return attrs;
}
function tableNodes$1(options) {
  var extraAttrs = options.cellAttributes || {};
  var cellAttrs = {
    colspan: { default: 1 },
    rowspan: { default: 1 },
    colwidth: { default: null }
  };
  for (var prop in extraAttrs) {
    cellAttrs[prop] = { default: extraAttrs[prop].default };
  }
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: true,
      group: options.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM: function toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM: function toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: options.cellContent,
      attrs: cellAttrs,
      tableRole: "cell",
      isolating: true,
      parseDOM: [{ tag: "td", getAttrs: function(dom) {
        return getCellAttrs(dom, extraAttrs);
      } }],
      toDOM: function toDOM(node5) {
        return ["td", setCellAttrs(node5, extraAttrs), 0];
      }
    },
    table_header: {
      content: options.cellContent,
      attrs: cellAttrs,
      tableRole: "header_cell",
      isolating: true,
      parseDOM: [{ tag: "th", getAttrs: function(dom) {
        return getCellAttrs(dom, extraAttrs);
      } }],
      toDOM: function toDOM(node5) {
        return ["th", setCellAttrs(node5, extraAttrs), 0];
      }
    }
  };
}
function tableNodeTypes(schema2) {
  var result2 = schema2.cached.tableNodeTypes;
  if (!result2) {
    result2 = schema2.cached.tableNodeTypes = {};
    for (var name in schema2.nodes) {
      var type = schema2.nodes[name], role = type.spec.tableRole;
      if (role) {
        result2[role] = type;
      }
    }
  }
  return result2;
}
var key$2 = new PluginKey("selectingCells");
function cellAround($pos) {
  for (var d2 = $pos.depth - 1; d2 > 0; d2--) {
    if ($pos.node(d2).type.spec.tableRole == "row") {
      return $pos.node(0).resolve($pos.before(d2 + 1));
    }
  }
  return null;
}
function isInTable(state) {
  var $head = state.selection.$head;
  for (var d2 = $head.depth; d2 > 0; d2--) {
    if ($head.node(d2).type.spec.tableRole == "row") {
      return true;
    }
  }
  return false;
}
function selectionCell(state) {
  var sel = state.selection;
  if (sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if (sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  return cellAround(sel.$head) || cellNear(sel.$head);
}
function cellNear($pos) {
  for (var after2 = $pos.nodeAfter, pos = $pos.pos; after2; after2 = after2.firstChild, pos++) {
    var role = after2.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") {
      return $pos.doc.resolve(pos);
    }
  }
  for (var before2 = $pos.nodeBefore, pos$1 = $pos.pos; before2; before2 = before2.lastChild, pos$1--) {
    var role$1 = before2.type.spec.tableRole;
    if (role$1 == "cell" || role$1 == "header_cell") {
      return $pos.doc.resolve(pos$1 - before2.nodeSize);
    }
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && $pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($a, $b) {
  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);
}
function nextCell2($pos, axis, dir) {
  var start4 = $pos.start(-1), map21 = TableMap.get($pos.node(-1));
  var moved = map21.nextCell($pos.pos - start4, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(start4 + moved);
}
function setAttr(attrs, name, value) {
  var result2 = {};
  for (var prop in attrs) {
    result2[prop] = attrs[prop];
  }
  result2[name] = value;
  return result2;
}
function removeColSpan(attrs, pos, n2) {
  if (n2 === void 0)
    n2 = 1;
  var result2 = setAttr(attrs, "colspan", attrs.colspan - n2);
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    result2.colwidth.splice(pos, n2);
    if (!result2.colwidth.some(function(w2) {
      return w2 > 0;
    })) {
      result2.colwidth = null;
    }
  }
  return result2;
}
function addColSpan(attrs, pos, n2) {
  if (n2 === void 0)
    n2 = 1;
  var result2 = setAttr(attrs, "colspan", attrs.colspan + n2);
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    for (var i2 = 0; i2 < n2; i2++) {
      result2.colwidth.splice(pos, 0, 0);
    }
  }
  return result2;
}
function columnIsHeader(map21, table2, col) {
  var headerCell = tableNodeTypes(table2.type.schema).header_cell;
  for (var row = 0; row < map21.height; row++) {
    if (table2.nodeAt(map21.map[col + row * map21.width]).type != headerCell) {
      return false;
    }
  }
  return true;
}
var CellSelection = /* @__PURE__ */ function(Selection3) {
  function CellSelection2($anchorCell, $headCell) {
    if ($headCell === void 0)
      $headCell = $anchorCell;
    var table2 = $anchorCell.node(-1), map21 = TableMap.get(table2), start4 = $anchorCell.start(-1);
    var rect = map21.rectBetween($anchorCell.pos - start4, $headCell.pos - start4);
    var doc2 = $anchorCell.node(0);
    var cells = map21.cellsInRect(rect).filter(function(p2) {
      return p2 != $headCell.pos - start4;
    });
    cells.unshift($headCell.pos - start4);
    var ranges = cells.map(function(pos) {
      var cell = table2.nodeAt(pos), from5 = pos + start4 + 1;
      return new SelectionRange(doc2.resolve(from5), doc2.resolve(from5 + cell.content.size));
    });
    Selection3.call(this, ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  if (Selection3)
    CellSelection2.__proto__ = Selection3;
  CellSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
  CellSelection2.prototype.constructor = CellSelection2;
  CellSelection2.prototype.map = function map21(doc2, mapping) {
    var $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    var $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection()) {
        return CellSelection2.rowSelection($anchorCell, $headCell);
      } else if (tableChanged && this.isColSelection()) {
        return CellSelection2.colSelection($anchorCell, $headCell);
      } else {
        return new CellSelection2($anchorCell, $headCell);
      }
    }
    return TextSelection.between($anchorCell, $headCell);
  };
  CellSelection2.prototype.content = function content3() {
    var table2 = this.$anchorCell.node(-1), map21 = TableMap.get(table2), start4 = this.$anchorCell.start(-1);
    var rect = map21.rectBetween(this.$anchorCell.pos - start4, this.$headCell.pos - start4);
    var seen = {}, rows = [];
    for (var row = rect.top; row < rect.bottom; row++) {
      var rowContent = [];
      for (var index3 = row * map21.width + rect.left, col = rect.left; col < rect.right; col++, index3++) {
        var pos = map21.map[index3];
        if (!seen[pos]) {
          seen[pos] = true;
          var cellRect = map21.findCell(pos), cell = table2.nodeAt(pos);
          var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;
          if (extraLeft > 0 || extraRight > 0) {
            var attrs = cell.attrs;
            if (extraLeft > 0) {
              attrs = removeColSpan(attrs, 0, extraLeft);
            }
            if (extraRight > 0) {
              attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);
            }
            if (cellRect.left < rect.left) {
              cell = cell.type.createAndFill(attrs);
            } else {
              cell = cell.type.create(attrs, cell.content);
            }
          }
          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
            var attrs$1 = setAttr(cell.attrs, "rowspan", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));
            if (cellRect.top < rect.top) {
              cell = cell.type.createAndFill(attrs$1);
            } else {
              cell = cell.type.create(attrs$1, cell.content);
            }
          }
          rowContent.push(cell);
        }
      }
      rows.push(table2.child(row).copy(Fragment.from(rowContent)));
    }
    var fragment = this.isColSelection() && this.isRowSelection() ? table2 : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  };
  CellSelection2.prototype.replace = function replace4(tr, content3) {
    if (content3 === void 0)
      content3 = Slice.empty;
    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i2 = 0; i2 < ranges.length; i2++) {
      var ref = ranges[i2];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content3);
    }
    var sel = Selection3.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
    if (sel) {
      tr.setSelection(sel);
    }
  };
  CellSelection2.prototype.replaceWith = function replaceWith2(tr, node5) {
    this.replace(tr, new Slice(Fragment.from(node5), 0, 0));
  };
  CellSelection2.prototype.forEachCell = function forEachCell(f2) {
    var table2 = this.$anchorCell.node(-1), map21 = TableMap.get(table2), start4 = this.$anchorCell.start(-1);
    var cells = map21.cellsInRect(map21.rectBetween(this.$anchorCell.pos - start4, this.$headCell.pos - start4));
    for (var i2 = 0; i2 < cells.length; i2++) {
      f2(table2.nodeAt(cells[i2]), start4 + cells[i2]);
    }
  };
  CellSelection2.prototype.isColSelection = function isColSelection() {
    var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) {
      return false;
    }
    var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan, headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;
  };
  CellSelection2.colSelection = function colSelection($anchorCell, $headCell) {
    if ($headCell === void 0)
      $headCell = $anchorCell;
    var map21 = TableMap.get($anchorCell.node(-1)), start4 = $anchorCell.start(-1);
    var anchorRect = map21.findCell($anchorCell.pos - start4), headRect = map21.findCell($headCell.pos - start4);
    var doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0) {
        $anchorCell = doc2.resolve(start4 + map21.map[anchorRect.left]);
      }
      if (headRect.bottom < map21.height) {
        $headCell = doc2.resolve(start4 + map21.map[map21.width * (map21.height - 1) + headRect.right - 1]);
      }
    } else {
      if (headRect.top > 0) {
        $headCell = doc2.resolve(start4 + map21.map[headRect.left]);
      }
      if (anchorRect.bottom < map21.height) {
        $anchorCell = doc2.resolve(start4 + map21.map[map21.width * (map21.height - 1) + anchorRect.right - 1]);
      }
    }
    return new CellSelection2($anchorCell, $headCell);
  };
  CellSelection2.prototype.isRowSelection = function isRowSelection() {
    var map21 = TableMap.get(this.$anchorCell.node(-1)), start4 = this.$anchorCell.start(-1);
    var anchorLeft = map21.colCount(this.$anchorCell.pos - start4), headLeft = map21.colCount(this.$headCell.pos - start4);
    if (Math.min(anchorLeft, headLeft) > 0) {
      return false;
    }
    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan, headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map21.width;
  };
  CellSelection2.prototype.eq = function eq20(other) {
    return other instanceof CellSelection2 && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  };
  CellSelection2.rowSelection = function rowSelection($anchorCell, $headCell) {
    if ($headCell === void 0)
      $headCell = $anchorCell;
    var map21 = TableMap.get($anchorCell.node(-1)), start4 = $anchorCell.start(-1);
    var anchorRect = map21.findCell($anchorCell.pos - start4), headRect = map21.findCell($headCell.pos - start4);
    var doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0) {
        $anchorCell = doc2.resolve(start4 + map21.map[anchorRect.top * map21.width]);
      }
      if (headRect.right < map21.width) {
        $headCell = doc2.resolve(start4 + map21.map[map21.width * (headRect.top + 1) - 1]);
      }
    } else {
      if (headRect.left > 0) {
        $headCell = doc2.resolve(start4 + map21.map[headRect.top * map21.width]);
      }
      if (anchorRect.right < map21.width) {
        $anchorCell = doc2.resolve(start4 + map21.map[map21.width * (anchorRect.top + 1) - 1]);
      }
    }
    return new CellSelection2($anchorCell, $headCell);
  };
  CellSelection2.prototype.toJSON = function toJSON7() {
    return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos };
  };
  CellSelection2.fromJSON = function fromJSON8(doc2, json) {
    return new CellSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  };
  CellSelection2.create = function create7(doc2, anchorCell, headCell) {
    if (headCell === void 0)
      headCell = anchorCell;
    return new CellSelection2(doc2.resolve(anchorCell), doc2.resolve(headCell));
  };
  CellSelection2.prototype.getBookmark = function getBookmark2() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  };
  return CellSelection2;
}(Selection);
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = function CellBookmark2(anchor2, head) {
  this.anchor = anchor2;
  this.head = head;
};
CellBookmark.prototype.map = function map20(mapping) {
  return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
};
CellBookmark.prototype.resolve = function resolve6(doc2) {
  var $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
  if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) {
    return new CellSelection($anchorCell, $headCell);
  } else {
    return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) {
    return null;
  }
  var cells = [];
  state.selection.forEachCell(function(node5, pos) {
    cells.push(Decoration2.node(pos, pos + node5.nodeSize, { class: "selectedCell" }));
  });
  return DecorationSet2.create(state.doc, cells);
}
function isCellBoundarySelection(ref) {
  var $from = ref.$from;
  var $to = ref.$to;
  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) {
    return false;
  }
  var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++) {
    if ($from.after(depth + 1) < $from.end(depth)) {
      break;
    }
  }
  for (var d2 = $to.depth; d2 >= 0; d2--, beforeTo--) {
    if ($to.before(d2 + 1) > $to.start(d2)) {
      break;
    }
  }
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells(ref) {
  var $from = ref.$from;
  var $to = ref.$to;
  var fromCellBoundaryNode;
  var toCellBoundaryNode;
  for (var i2 = $from.depth; i2 > 0; i2--) {
    var node5 = $from.node(i2);
    if (node5.type.spec.tableRole === "cell" || node5.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node5;
      break;
    }
  }
  for (var i$1 = $to.depth; i$1 > 0; i$1--) {
    var node$1 = $to.node(i$1);
    if (node$1.type.spec.tableRole === "cell" || node$1.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node$1;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  var sel = (tr || state).selection, doc2 = (tr || state).doc, normalize2, role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      var $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      var map21 = TableMap.get(sel.node), start4 = sel.from + 1;
      var lastCell = start4 + map21.map[map21.width * map21.height - 1];
      normalize2 = CellSelection.create(doc2, start4 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection.create(doc2, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize2) {
    (tr || (tr = state.tr)).setSelection(normalize2);
  }
  return tr;
}
function pastedCells(slice5) {
  if (!slice5.size) {
    return null;
  }
  var content3 = slice5.content;
  var openStart = slice5.openStart;
  var openEnd = slice5.openEnd;
  while (content3.childCount == 1 && (openStart > 0 && openEnd > 0 || content3.firstChild.type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content3 = content3.firstChild.content;
  }
  var first = content3.firstChild, role = first.type.spec.tableRole;
  var schema2 = first.type.schema, rows = [];
  if (role == "row") {
    for (var i2 = 0; i2 < content3.childCount; i2++) {
      var cells = content3.child(i2).content;
      var left = i2 ? 0 : Math.max(0, openStart - 1);
      var right = i2 < content3.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right) {
        cells = fitSlice(tableNodeTypes(schema2).row, new Slice(cells, left, right)).content;
      }
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema2).row, new Slice(content3, openStart, openEnd)).content : content3);
  } else {
    return null;
  }
  return ensureRectangular(schema2, rows);
}
function ensureRectangular(schema2, rows) {
  var widths = [];
  for (var i2 = 0; i2 < rows.length; i2++) {
    var row = rows[i2];
    for (var j2 = row.childCount - 1; j2 >= 0; j2--) {
      var ref = row.child(j2).attrs;
      var rowspan = ref.rowspan;
      var colspan = ref.colspan;
      for (var r2 = i2; r2 < i2 + rowspan; r2++) {
        widths[r2] = (widths[r2] || 0) + colspan;
      }
    }
  }
  var width = 0;
  for (var r$12 = 0; r$12 < widths.length; r$12++) {
    width = Math.max(width, widths[r$12]);
  }
  for (var r$22 = 0; r$22 < widths.length; r$22++) {
    if (r$22 >= rows.length) {
      rows.push(Fragment.empty);
    }
    if (widths[r$22] < width) {
      var empty2 = tableNodeTypes(schema2).cell.createAndFill(), cells = [];
      for (var i$1 = widths[r$22]; i$1 < width; i$1++) {
        cells.push(empty2);
      }
      rows[r$22] = rows[r$22].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType2, slice5) {
  var node5 = nodeType2.createAndFill();
  var tr = new Transform(node5).replace(0, node5.content.size, slice5);
  return tr.doc;
}
function clipCells(ref, newWidth, newHeight) {
  var width = ref.width;
  var height = ref.height;
  var rows = ref.rows;
  if (width != newWidth) {
    var added = [], newRows = [];
    for (var row = 0; row < rows.length; row++) {
      var frag = rows[row], cells = [];
      for (var col = added[row] || 0, i2 = 0; col < newWidth; i2++) {
        var cell = frag.child(i2 % frag.childCount);
        if (col + cell.attrs.colspan > newWidth) {
          cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
        }
        cells.push(cell);
        col += cell.attrs.colspan;
        for (var j2 = 1; j2 < cell.attrs.rowspan; j2++) {
          added[row + j2] = (added[row + j2] || 0) + cell.attrs.colspan;
        }
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    var newRows$1 = [];
    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {
      var cells$1 = [], source = rows[i$1 % height];
      for (var j$1 = 0; j$1 < source.childCount; j$1++) {
        var cell$1 = source.child(j$1);
        if (row$1 + cell$1.attrs.rowspan > newHeight) {
          cell$1 = cell$1.type.create(setAttr(cell$1.attrs, "rowspan", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content);
        }
        cells$1.push(cell$1);
      }
      newRows$1.push(Fragment.from(cells$1));
    }
    rows = newRows$1;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map21, table2, start4, width, height, mapFrom) {
  var schema2 = tr.doc.type.schema, types = tableNodeTypes(schema2), empty2, emptyHead;
  if (width > map21.width) {
    for (var row = 0, rowEnd = 0; row < map21.height; row++) {
      var rowNode = table2.child(row);
      rowEnd += rowNode.nodeSize;
      var cells = [], add3 = void 0;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) {
        add3 = empty2 || (empty2 = types.cell.createAndFill());
      } else {
        add3 = emptyHead || (emptyHead = types.header_cell.createAndFill());
      }
      for (var i2 = map21.width; i2 < width; i2++) {
        cells.push(add3);
      }
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start4), cells);
    }
  }
  if (height > map21.height) {
    var cells$1 = [];
    for (var i$1 = 0, start$1 = (map21.height - 1) * map21.width; i$1 < Math.max(map21.width, width); i$1++) {
      var header = i$1 >= map21.width ? false : table2.nodeAt(map21.map[start$1 + i$1]).type == types.header_cell;
      cells$1.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill()));
    }
    var emptyRow = types.row.create(null, Fragment.from(cells$1)), rows = [];
    for (var i$2 = map21.height; i$2 < height; i$2++) {
      rows.push(emptyRow);
    }
    tr.insert(tr.mapping.slice(mapFrom).map(start4 + table2.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map21, table2, start4, left, right, top2, mapFrom) {
  if (top2 == 0 || top2 == map21.height) {
    return false;
  }
  var found2 = false;
  for (var col = left; col < right; col++) {
    var index3 = top2 * map21.width + col, pos = map21.map[index3];
    if (map21.map[index3 - map21.width] == pos) {
      found2 = true;
      var cell = table2.nodeAt(pos);
      var ref = map21.findCell(pos);
      var cellTop = ref.top;
      var cellLeft = ref.left;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start4), null, setAttr(cell.attrs, "rowspan", top2 - cellTop));
      tr.insert(tr.mapping.slice(mapFrom).map(map21.positionAt(top2, cellLeft, table2)), cell.type.createAndFill(setAttr(cell.attrs, "rowspan", cellTop + cell.attrs.rowspan - top2)));
      col += cell.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr, map21, table2, start4, top2, bottom, left, mapFrom) {
  if (left == 0 || left == map21.width) {
    return false;
  }
  var found2 = false;
  for (var row = top2; row < bottom; row++) {
    var index3 = row * map21.width + left, pos = map21.map[index3];
    if (map21.map[index3 - 1] == pos) {
      found2 = true;
      var cell = table2.nodeAt(pos), cellLeft = map21.colCount(pos);
      var updatePos = tr.mapping.slice(mapFrom).map(pos + start4);
      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));
      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));
      row += cell.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state, dispatch3, tableStart, rect, cells) {
  var table2 = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map21 = TableMap.get(table2);
  var top2 = rect.top;
  var left = rect.left;
  var right = left + cells.width, bottom = top2 + cells.height;
  var tr = state.tr, mapFrom = 0;
  function recomp() {
    table2 = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    map21 = TableMap.get(table2);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map21, table2, tableStart, right, bottom, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map21, table2, tableStart, left, right, top2, mapFrom)) {
    recomp();
  }
  if (isolateHorizontal(tr, map21, table2, tableStart, left, right, bottom, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map21, table2, tableStart, top2, bottom, left, mapFrom)) {
    recomp();
  }
  if (isolateVertical(tr, map21, table2, tableStart, top2, bottom, right, mapFrom)) {
    recomp();
  }
  for (var row = top2; row < bottom; row++) {
    var from5 = map21.positionAt(row, left, table2), to2 = map21.positionAt(row, right, table2);
    tr.replace(tr.mapping.slice(mapFrom).map(from5 + tableStart), tr.mapping.slice(mapFrom).map(to2 + tableStart), new Slice(cells.rows[row - top2], 0, 0));
  }
  recomp();
  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map21.positionAt(top2, left, table2)), tr.doc.resolve(tableStart + map21.positionAt(bottom - 1, right - 1, table2))));
  dispatch3(tr);
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  "Backspace": deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  "Delete": deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch3, selection) {
  if (selection.eq(state.selection)) {
    return false;
  }
  if (dispatch3) {
    dispatch3(state.tr.setSelection(selection).scrollIntoView());
  }
  return true;
}
function arrow(axis, dir) {
  return function(state, dispatch3, view) {
    var sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(state, dispatch3, Selection.near(sel.$headCell, dir));
    }
    if (axis != "horiz" && !sel.empty) {
      return false;
    }
    var end3 = atEndOfCell(view, axis, dir);
    if (end3 == null) {
      return false;
    }
    if (axis == "horiz") {
      return maybeSetSelection(state, dispatch3, Selection.near(state.doc.resolve(sel.head + dir), dir));
    } else {
      var $cell = state.doc.resolve(end3), $next = nextCell2($cell, axis, dir), newSel;
      if ($next) {
        newSel = Selection.near($next, 1);
      } else if (dir < 0) {
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      } else {
        newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      }
      return maybeSetSelection(state, dispatch3, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return function(state, dispatch3, view) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection)) {
      var end3 = atEndOfCell(view, axis, dir);
      if (end3 == null) {
        return false;
      }
      sel = new CellSelection(state.doc.resolve(end3));
    }
    var $head = nextCell2(sel.$headCell, axis, dir);
    if (!$head) {
      return false;
    }
    return maybeSetSelection(state, dispatch3, new CellSelection(sel.$anchorCell, $head));
  };
}
function deleteCellSelection(state, dispatch3) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection)) {
    return false;
  }
  if (dispatch3) {
    var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell(function(cell, pos) {
      if (!cell.content.eq(baseContent)) {
        tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));
      }
    });
    if (tr.docChanged) {
      dispatch3(tr);
    }
  }
  return true;
}
function handleTripleClick(view, pos) {
  var doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
  if (!$cell) {
    return false;
  }
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _2, slice5) {
  if (!isInTable(view.state)) {
    return false;
  }
  var cells = pastedCells(slice5), sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells) {
      cells = { width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice5))] };
    }
    var table2 = sel.$anchorCell.node(-1), start4 = sel.$anchorCell.start(-1);
    var rect = TableMap.get(table2).rectBetween(sel.$anchorCell.pos - start4, sel.$headCell.pos - start4);
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start4, rect, cells);
    return true;
  } else if (cells) {
    var $cell = selectionCell(view.state), start$1 = $cell.start(-1);
    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  if (startEvent.ctrlKey || startEvent.metaKey) {
    return;
  }
  var startDOMCell = domInCell(view, startEvent.target), $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    var $head = cellUnderMouse(view, event);
    var starting = key$2.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) {
        $head = $anchor2;
      } else {
        return;
      }
    }
    var selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      var tr = view.state.tr.setSelection(selection);
      if (starting) {
        tr.setMeta(key$2, $anchor2.pos);
      }
      view.dispatch(tr);
    }
  }
  function stop3() {
    view.root.removeEventListener("mouseup", stop3);
    view.root.removeEventListener("dragstart", stop3);
    view.root.removeEventListener("mousemove", move3);
    if (key$2.getState(view.state) != null) {
      view.dispatch(view.state.tr.setMeta(key$2, -1));
    }
  }
  function move3(event) {
    var anchor2 = key$2.getState(view.state), $anchor2;
    if (anchor2 != null) {
      $anchor2 = view.state.doc.resolve(anchor2);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) {
        return stop3();
      }
    }
    if ($anchor2) {
      setCellSelection($anchor2, event);
    }
  }
  view.root.addEventListener("mouseup", stop3);
  view.root.addEventListener("dragstart", stop3);
  view.root.addEventListener("mousemove", move3);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return null;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  for (var d2 = $head.depth - 1; d2 >= 0; d2--) {
    var parent = $head.node(d2), index3 = dir < 0 ? $head.index(d2) : $head.indexAfter(d2);
    if (index3 != (dir < 0 ? 0 : parent.childCount)) {
      return null;
    }
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      var cellPos = $head.before(d2);
      var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
}
function cellUnderMouse(view, event) {
  var mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!mousePos) {
    return null;
  }
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset2, f2) {
  var oldSize = old.childCount, curSize = cur.childCount;
  outer:
    for (var i2 = 0, j2 = 0; i2 < curSize; i2++) {
      var child4 = cur.child(i2);
      for (var scan = j2, e3 = Math.min(oldSize, i2 + 3); scan < e3; scan++) {
        if (old.child(scan) == child4) {
          j2 = scan + 1;
          offset2 += child4.nodeSize;
          continue outer;
        }
      }
      f2(child4, offset2);
      if (j2 < oldSize && old.child(j2).sameMarkup(child4)) {
        changedDescendants(old.child(j2), child4, offset2 + 1, f2);
      } else {
        child4.nodesBetween(0, child4.content.size, f2, offset2 + 1);
      }
      offset2 += child4.nodeSize;
    }
}
function fixTables(state, oldState) {
  var tr, check2 = function(node5, pos) {
    if (node5.type.spec.tableRole == "table") {
      tr = fixTable(state, node5, pos, tr);
    }
  };
  if (!oldState) {
    state.doc.descendants(check2);
  } else if (oldState.doc != state.doc) {
    changedDescendants(oldState.doc, state.doc, 0, check2);
  }
  return tr;
}
function fixTable(state, table2, tablePos, tr) {
  var map21 = TableMap.get(table2);
  if (!map21.problems) {
    return tr;
  }
  if (!tr) {
    tr = state.tr;
  }
  var mustAdd = [];
  for (var i2 = 0; i2 < map21.height; i2++) {
    mustAdd.push(0);
  }
  for (var i$1 = 0; i$1 < map21.problems.length; i$1++) {
    var prob = map21.problems[i$1];
    if (prob.type == "collision") {
      var cell = table2.nodeAt(prob.pos);
      for (var j2 = 0; j2 < cell.attrs.rowspan; j2++) {
        mustAdd[prob.row + j2] += prob.n;
      }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      var cell$1 = table2.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, "rowspan", cell$1.attrs.rowspan - prob.n));
    } else if (prob.type == "colwidth mismatch") {
      var cell$2 = table2.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, "colwidth", prob.colwidth));
    }
  }
  var first, last;
  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) {
    if (mustAdd[i$2]) {
      if (first == null) {
        first = i$2;
      }
      last = i$2;
    }
  }
  for (var i$3 = 0, pos = tablePos + 1; i$3 < map21.height; i$3++) {
    var row = table2.child(i$3);
    var end3 = pos + row.nodeSize;
    var add3 = mustAdd[i$3];
    if (add3 > 0) {
      var tableNodeType = "cell";
      if (row.firstChild) {
        tableNodeType = row.firstChild.type.spec.tableRole;
      }
      var nodes2 = [];
      for (var j$1 = 0; j$1 < add3; j$1++) {
        nodes2.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());
      }
      var side = (i$3 == 0 || first == i$3 - 1) && last == i$3 ? pos + 1 : end3 - 1;
      tr.insert(tr.mapping.map(side), nodes2);
    }
    pos = end3;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  var sel = state.selection, $pos = selectionCell(state);
  var table2 = $pos.node(-1), tableStart = $pos.start(-1), map21 = TableMap.get(table2);
  var rect;
  if (sel instanceof CellSelection) {
    rect = map21.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);
  } else {
    rect = map21.findCell($pos.pos - tableStart);
  }
  rect.tableStart = tableStart;
  rect.map = map21;
  rect.table = table2;
  return rect;
}
function addColumn(tr, ref, col) {
  var map21 = ref.map;
  var tableStart = ref.tableStart;
  var table2 = ref.table;
  var refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map21, table2, col + refColumn)) {
    refColumn = col == 0 || col == map21.width ? null : 0;
  }
  for (var row = 0; row < map21.height; row++) {
    var index3 = row * map21.width + col;
    if (col > 0 && col < map21.width && map21.map[index3 - 1] == map21.map[index3]) {
      var pos = map21.map[index3], cell = table2.nodeAt(pos);
      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map21.colCount(pos)));
      row += cell.attrs.rowspan - 1;
    } else {
      var type = refColumn == null ? tableNodeTypes(table2.type.schema).cell : table2.nodeAt(map21.map[index3 + refColumn]).type;
      var pos$1 = map21.positionAt(row, col, table2);
      tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch3) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch3) {
    var rect = selectedRect(state);
    dispatch3(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch3) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch3) {
    var rect = selectedRect(state);
    dispatch3(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, ref, col) {
  var map21 = ref.map;
  var table2 = ref.table;
  var tableStart = ref.tableStart;
  var mapStart = tr.mapping.maps.length;
  for (var row = 0; row < map21.height; ) {
    var index3 = row * map21.width + col, pos = map21.map[index3], cell = table2.nodeAt(pos);
    if (col > 0 && map21.map[index3 - 1] == pos || col < map21.width - 1 && map21.map[index3 + 1] == pos) {
      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map21.colCount(pos)));
    } else {
      var start4 = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start4, start4 + cell.nodeSize);
    }
    row += cell.attrs.rowspan;
  }
}
function deleteColumn(state, dispatch3) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch3) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) {
      return false;
    }
    for (var i2 = rect.right - 1; ; i2--) {
      removeColumn(tr, rect, i2);
      if (i2 == rect.left) {
        break;
      }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch3(tr);
  }
  return true;
}
function removeRow(tr, ref, row) {
  var map21 = ref.map;
  var table2 = ref.table;
  var tableStart = ref.tableStart;
  var rowPos = 0;
  for (var i2 = 0; i2 < row; i2++) {
    rowPos += table2.child(i2).nodeSize;
  }
  var nextRow = rowPos + table2.child(row).nodeSize;
  var mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  for (var col = 0, index3 = row * map21.width; col < map21.width; col++, index3++) {
    var pos = map21.map[index3];
    if (row > 0 && pos == map21.map[index3 - map21.width]) {
      var attrs = table2.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, "rowspan", attrs.rowspan - 1));
      col += attrs.colspan - 1;
    } else if (row < map21.width && pos == map21.map[index3 + map21.width]) {
      var cell = table2.nodeAt(pos);
      var copy6 = cell.type.create(setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - 1), cell.content);
      var newPos = map21.positionAt(row + 1, col, table2);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy6);
      col += cell.attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch3) {
  if (!isInTable(state)) {
    return false;
  }
  if (dispatch3) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) {
      return false;
    }
    for (var i2 = rect.bottom - 1; ; i2--) {
      removeRow(tr, rect, i2);
      if (i2 == rect.top) {
        break;
      }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch3(tr);
  }
  return true;
}
function setCellAttr(name, value) {
  return function(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    var $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) {
      return false;
    }
    if (dispatch3) {
      var tr = state.tr;
      if (state.selection instanceof CellSelection) {
        state.selection.forEachCell(function(node5, pos) {
          if (node5.attrs[name] !== value) {
            tr.setNodeMarkup(pos, null, setAttr(node5.attrs, name, value));
          }
        });
      } else {
        tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));
      }
      dispatch3(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var cells = rect.map.cellsInRect(type == "column" ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == "row" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);
      var nodes2 = cells.map(function(pos) {
        return rect.table.nodeAt(pos);
      });
      for (var i2 = 0; i2 < cells.length; i2++) {
        if (nodes2[i2].type == types.header_cell) {
          tr.setNodeMarkup(rect.tableStart + cells[i2], types.cell, nodes2[i2].attrs);
        }
      }
      if (tr.steps.length == 0) {
        for (var i$1 = 0; i$1 < cells.length; i$1++) {
          tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes2[i$1].attrs);
        }
      }
      dispatch3(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  var cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (var i2 = 0; i2 < cellPositions.length; i2++) {
    var cell = rect.table.nodeAt(cellPositions[i2]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) {
    return deprecated_toggleHeader(type);
  }
  return function(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    if (dispatch3) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      var isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);
      var isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      var selectionStartsAt = isHeaderEnabled ? 1 : 0;
      var cellsRect = type == "column" ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == "row" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
      var newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach(function(relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch3(tr);
    }
    return true;
  };
}
toggleHeader("row", { useDeprecatedLogic: true });
toggleHeader("column", { useDeprecatedLogic: true });
toggleHeader("cell", { useDeprecatedLogic: true });
function findNextCell($cell, dir) {
  if (dir < 0) {
    var before2 = $cell.nodeBefore;
    if (before2) {
      return $cell.pos - before2.nodeSize;
    }
    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      var rowNode = $cell.node(-1).child(row);
      if (rowNode.childCount) {
        return rowEnd - 1 - rowNode.lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    var table2 = $cell.node(-1);
    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table2.childCount; row$1++) {
      var rowNode$1 = table2.child(row$1);
      if (rowNode$1.childCount) {
        return rowStart + 1;
      }
      rowStart += rowNode$1.nodeSize;
    }
  }
}
function goToNextCell(direction) {
  return function(state, dispatch3) {
    if (!isInTable(state)) {
      return false;
    }
    var cell = findNextCell(selectionCell(state), direction);
    if (cell == null) {
      return;
    }
    if (dispatch3) {
      var $cell = state.doc.resolve(cell);
      dispatch3(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());
    }
    return true;
  };
}
function deleteTable(state, dispatch3) {
  var $pos = state.selection.$anchor;
  for (var d2 = $pos.depth; d2 > 0; d2--) {
    var node5 = $pos.node(d2);
    if (node5.type.spec.tableRole == "table") {
      if (dispatch3) {
        dispatch3(state.tr.delete($pos.before(d2), $pos.after(d2)).scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
var TableView = function TableView2(node5, cellMinWidth) {
  this.node = node5;
  this.cellMinWidth = cellMinWidth;
  this.dom = document.createElement("div");
  this.dom.className = "tableWrapper";
  this.table = this.dom.appendChild(document.createElement("table"));
  this.colgroup = this.table.appendChild(document.createElement("colgroup"));
  updateColumns(node5, this.colgroup, this.table, cellMinWidth);
  this.contentDOM = this.table.appendChild(document.createElement("tbody"));
};
TableView.prototype.update = function update3(node5) {
  if (node5.type != this.node.type) {
    return false;
  }
  this.node = node5;
  updateColumns(node5, this.colgroup, this.table, this.cellMinWidth);
  return true;
};
TableView.prototype.ignoreMutation = function ignoreMutation3(record) {
  return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
};
function updateColumns(node5, colgroup, table2, cellMinWidth, overrideCol, overrideValue) {
  var totalWidth = 0, fixedWidth = true;
  var nextDOM = colgroup.firstChild, row = node5.firstChild;
  for (var i2 = 0, col = 0; i2 < row.childCount; i2++) {
    var ref = row.child(i2).attrs;
    var colspan = ref.colspan;
    var colwidth = ref.colwidth;
    for (var j2 = 0; j2 < colspan; j2++, col++) {
      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j2];
      var cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    var after2 = nextDOM.nextSibling;
    nextDOM.parentNode.removeChild(nextDOM);
    nextDOM = after2;
  }
  if (fixedWidth) {
    table2.style.width = totalWidth + "px";
    table2.style.minWidth = "";
  } else {
    table2.style.width = "";
    table2.style.minWidth = totalWidth + "px";
  }
}
var key$1$1 = new PluginKey("tableColumnResizing");
function columnResizing(ref) {
  if (ref === void 0)
    ref = {};
  var handleWidth = ref.handleWidth;
  if (handleWidth === void 0)
    handleWidth = 5;
  var cellMinWidth = ref.cellMinWidth;
  if (cellMinWidth === void 0)
    cellMinWidth = 25;
  var View2 = ref.View;
  if (View2 === void 0)
    View2 = TableView;
  var lastColumnResizable = ref.lastColumnResizable;
  if (lastColumnResizable === void 0)
    lastColumnResizable = true;
  var plugin2 = new Plugin({
    key: key$1$1,
    state: {
      init: function init6(_2, state) {
        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function(node5, view) {
          return new View2(node5, cellMinWidth, view);
        };
        return new ResizeState(-1, false);
      },
      apply: function apply9(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: function attributes(state) {
        var pluginState = key$1$1.getState(state);
        return pluginState.activeHandle > -1 ? { class: "resize-cursor" } : null;
      },
      handleDOMEvents: {
        mousemove: function mousemove(view, event) {
          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);
        },
        mouseleave: function mouseleave(view) {
          handleMouseLeave(view);
        },
        mousedown: function mousedown(view, event) {
          handleMouseDown$1(view, event, cellMinWidth);
        }
      },
      decorations: function decorations(state) {
        var pluginState = key$1$1.getState(state);
        if (pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin2;
}
var ResizeState = function ResizeState2(activeHandle, dragging) {
  this.activeHandle = activeHandle;
  this.dragging = dragging;
};
ResizeState.prototype.apply = function apply8(tr) {
  var state = this, action = tr.getMeta(key$1$1);
  if (action && action.setHandle != null) {
    return new ResizeState(action.setHandle, null);
  }
  if (action && action.setDragging !== void 0) {
    return new ResizeState(state.activeHandle, action.setDragging);
  }
  if (state.activeHandle > -1 && tr.docChanged) {
    var handle2 = tr.mapping.map(state.activeHandle, -1);
    if (!pointsAtCell(tr.doc.resolve(handle2))) {
      handle2 = null;
    }
    state = new ResizeState(handle2, state.dragging);
  }
  return state;
};
function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
  var pluginState = key$1$1.getState(view.state);
  if (!pluginState.dragging) {
    var target = domCellAround(event.target), cell = -1;
    if (target) {
      var ref = target.getBoundingClientRect();
      var left = ref.left;
      var right = ref.right;
      if (event.clientX - left <= handleWidth) {
        cell = edgeCell(view, event, "left");
      } else if (right - event.clientX <= handleWidth) {
        cell = edgeCell(view, event, "right");
      }
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        var $cell = view.state.doc.resolve(cell);
        var table2 = $cell.node(-1), map21 = TableMap.get(table2), start4 = $cell.start(-1);
        var col = map21.colCount($cell.pos - start4) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map21.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  var pluginState = key$1$1.getState(view.state);
  if (pluginState.activeHandle > -1 && !pluginState.dragging) {
    updateHandle(view, -1);
  }
}
function handleMouseDown$1(view, event, cellMinWidth) {
  var pluginState = key$1$1.getState(view.state);
  if (pluginState.activeHandle == -1 || pluginState.dragging) {
    return false;
  }
  var cell = view.state.doc.nodeAt(pluginState.activeHandle);
  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(view.state.tr.setMeta(key$1$1, { setDragging: { startX: event.clientX, startWidth: width } }));
  function finish3(event2) {
    window.removeEventListener("mouseup", finish3);
    window.removeEventListener("mousemove", move3);
    var pluginState2 = key$1$1.getState(view.state);
    if (pluginState2.dragging) {
      updateColumnWidth(view, pluginState2.activeHandle, draggedWidth(pluginState2.dragging, event2, cellMinWidth));
      view.dispatch(view.state.tr.setMeta(key$1$1, { setDragging: null }));
    }
  }
  function move3(event2) {
    if (!event2.which) {
      return finish3(event2);
    }
    var pluginState2 = key$1$1.getState(view.state);
    var dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
    displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
  }
  window.addEventListener("mouseup", finish3);
  window.addEventListener("mousemove", move3);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, ref) {
  var colspan = ref.colspan;
  var colwidth = ref.colwidth;
  var width = colwidth && colwidth[colwidth.length - 1];
  if (width) {
    return width;
  }
  var dom = view.domAtPos(cellPos);
  var node5 = dom.node.childNodes[dom.offset];
  var domWidth = node5.offsetWidth, parts = colspan;
  if (colwidth) {
    for (var i2 = 0; i2 < colspan; i2++) {
      if (colwidth[i2]) {
        domWidth -= colwidth[i2];
        parts--;
      }
    }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH") {
    target = target.classList.contains("ProseMirror") ? null : target.parentNode;
  }
  return target;
}
function edgeCell(view, event, side) {
  var found2 = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (!found2) {
    return -1;
  }
  var pos = found2.pos;
  var $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) {
    return -1;
  }
  if (side == "right") {
    return $cell.pos;
  }
  var map21 = TableMap.get($cell.node(-1)), start4 = $cell.start(-1);
  var index3 = map21.map.indexOf($cell.pos - start4);
  return index3 % map21.width == 0 ? -1 : start4 + map21.map[index3 - 1];
}
function draggedWidth(dragging, event, cellMinWidth) {
  var offset2 = event.clientX - dragging.startX;
  return Math.max(cellMinWidth, dragging.startWidth + offset2);
}
function updateHandle(view, value) {
  view.dispatch(view.state.tr.setMeta(key$1$1, { setHandle: value }));
}
function updateColumnWidth(view, cell, width) {
  var $cell = view.state.doc.resolve(cell);
  var table2 = $cell.node(-1), map21 = TableMap.get(table2), start4 = $cell.start(-1);
  var col = map21.colCount($cell.pos - start4) + $cell.nodeAfter.attrs.colspan - 1;
  var tr = view.state.tr;
  for (var row = 0; row < map21.height; row++) {
    var mapIndex = row * map21.width + col;
    if (row && map21.map[mapIndex] == map21.map[mapIndex - map21.width]) {
      continue;
    }
    var pos = map21.map[mapIndex];
    var ref = table2.nodeAt(pos);
    var attrs = ref.attrs;
    var index3 = attrs.colspan == 1 ? 0 : col - map21.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index3] == width) {
      continue;
    }
    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index3] = width;
    tr.setNodeMarkup(start4 + pos, null, setAttr(attrs, "colwidth", colwidth));
  }
  if (tr.docChanged) {
    view.dispatch(tr);
  }
}
function displayColumnWidth(view, cell, width, cellMinWidth) {
  var $cell = view.state.doc.resolve(cell);
  var table2 = $cell.node(-1), start4 = $cell.start(-1);
  var col = TableMap.get(table2).colCount($cell.pos - start4) + $cell.nodeAfter.attrs.colspan - 1;
  var dom = view.domAtPos($cell.start(-1)).node;
  while (dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  updateColumns(table2, dom.firstChild, dom, cellMinWidth, col, width);
}
function zeroes(n2) {
  var result2 = [];
  for (var i2 = 0; i2 < n2; i2++) {
    result2.push(0);
  }
  return result2;
}
function handleDecorations(state, cell) {
  var decorations = [];
  var $cell = state.doc.resolve(cell);
  var table2 = $cell.node(-1), map21 = TableMap.get(table2), start4 = $cell.start(-1);
  var col = map21.colCount($cell.pos - start4) + $cell.nodeAfter.attrs.colspan;
  for (var row = 0; row < map21.height; row++) {
    var index3 = col + row * map21.width - 1;
    if ((col == map21.width || map21.map[index3] != map21.map[index3 + 1]) && (row == 0 || map21.map[index3 - 1] != map21.map[index3 - 1 - map21.width])) {
      var cellPos = map21.map[index3];
      var pos = start4 + cellPos + table2.nodeAt(cellPos).nodeSize - 1;
      var dom = document.createElement("div");
      dom.className = "column-resize-handle";
      decorations.push(Decoration2.widget(pos, dom));
    }
  }
  return DecorationSet2.create(state.doc, decorations);
}
function tableEditing(ref) {
  if (ref === void 0)
    ref = {};
  var allowTableNodeSelection = ref.allowTableNodeSelection;
  if (allowTableNodeSelection === void 0)
    allowTableNodeSelection = false;
  return new Plugin({
    key: key$2,
    state: {
      init: function init6() {
        return null;
      },
      apply: function apply9(tr, cur) {
        var set3 = tr.getMeta(key$2);
        if (set3 != null) {
          return set3 == -1 ? null : set3;
        }
        if (cur == null || !tr.docChanged) {
          return cur;
        }
        var ref2 = tr.mapping.mapResult(cur);
        var deleted = ref2.deleted;
        var pos = ref2.pos;
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween: function createSelectionBetween(view) {
        if (key$2.getState(view.state) != null) {
          return view.state.selection;
        }
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction: function appendTransaction(_2, oldState, state) {
      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);
    }
  });
}
var syntax$6 = {};
var asciiAlpha = asciiAlpha_1;
var asciiAlphanumeric = asciiAlphanumeric_1;
var asciiControl = asciiControl_1;
var markdownLineEnding = markdownLineEnding_1;
var unicodePunctuation$1 = unicodePunctuation_1;
var unicodeWhitespace$1 = unicodeWhitespace_1;
var www = { tokenize: tokenizeWww, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path = { tokenize: tokenizePath, partial: true };
var punctuation = { tokenize: tokenizePunctuation, partial: true };
var namedCharacterReference = {
  tokenize: tokenizeNamedCharacterReference,
  partial: true
};
var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
var httpAutolink = { tokenize: tokenizeHttpAutolink, previous: previousHttp };
var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
var text2 = {};
syntax$6.text = text2;
var code = 48;
while (code < 123) {
  text2[code] = emailAutolink;
  code++;
  if (code === 58)
    code = 65;
  else if (code === 91)
    code = 97;
}
text2[43] = emailAutolink;
text2[45] = emailAutolink;
text2[46] = emailAutolink;
text2[95] = emailAutolink;
text2[72] = [emailAutolink, httpAutolink];
text2[104] = [emailAutolink, httpAutolink];
text2[87] = [emailAutolink, wwwAutolink];
text2[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  var self2 = this;
  var hasDot;
  return start4;
  function start4(code2) {
    if (!gfmAtext(code2) || !previousEmail(self2.previous) || previous$2(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return label2;
    }
    return nok(code2);
  }
  function label2(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, done3, dotContinuation)(code2);
    }
    if (code2 === 45 || code2 === 95) {
      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
    }
    if (asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return label2;
    }
    return done3(code2);
  }
  function dotContinuation(code2) {
    effects.consume(code2);
    hasDot = true;
    return label2;
  }
  function dashOrUnderscoreContinuation(code2) {
    effects.consume(code2);
    return afterDashOrUnderscore;
  }
  function afterDashOrUnderscore(code2) {
    if (code2 === 46) {
      return effects.check(punctuation, nok, dotContinuation)(code2);
    }
    return label2(code2);
  }
  function done3(code2) {
    if (hasDot) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  var self2 = this;
  return start4;
  function start4(code2) {
    if (code2 !== 87 && code2 - 32 !== 87 || !previousWww(self2.previous) || previous$2(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(www, effects.attempt(domain, effects.attempt(path, done3), nok), nok)(code2);
  }
  function done3(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code2);
  }
}
function tokenizeHttpAutolink(effects, ok3, nok) {
  var self2 = this;
  return start4;
  function start4(code2) {
    if (code2 !== 72 && code2 - 32 !== 72 || !previousHttp(self2.previous) || previous$2(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkHttp");
    effects.consume(code2);
    return t1;
  }
  function t1(code2) {
    if (code2 === 84 || code2 - 32 === 84) {
      effects.consume(code2);
      return t2;
    }
    return nok(code2);
  }
  function t2(code2) {
    if (code2 === 84 || code2 - 32 === 84) {
      effects.consume(code2);
      return p2;
    }
    return nok(code2);
  }
  function p2(code2) {
    if (code2 === 80 || code2 - 32 === 80) {
      effects.consume(code2);
      return s2;
    }
    return nok(code2);
  }
  function s2(code2) {
    if (code2 === 83 || code2 - 32 === 83) {
      effects.consume(code2);
      return colon2;
    }
    return colon2(code2);
  }
  function colon2(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return slash1;
    }
    return nok(code2);
  }
  function slash1(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return slash2;
    }
    return nok(code2);
  }
  function slash2(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return after2;
    }
    return nok(code2);
  }
  function after2(code2) {
    return asciiControl(code2) || unicodeWhitespace$1(code2) || unicodePunctuation$1(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, done3), nok)(code2);
  }
  function done3(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code2);
  }
}
function tokenizeWww(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.consume(code2);
    return w2;
  }
  function w2(code2) {
    if (code2 === 87 || code2 - 32 === 87) {
      effects.consume(code2);
      return w3;
    }
    return nok(code2);
  }
  function w3(code2) {
    if (code2 === 87 || code2 - 32 === 87) {
      effects.consume(code2);
      return dot;
    }
    return nok(code2);
  }
  function dot(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      return after2;
    }
    return nok(code2);
  }
  function after2(code2) {
    return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok3(code2);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  var hasUnderscoreInLastSegment;
  var hasUnderscoreInLastLastSegment;
  return domain2;
  function domain2(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, done3, punctuationContinuation)(code2);
    }
    if (code2 === 46 || code2 === 95) {
      return effects.check(punctuation, done3, punctuationContinuation)(code2);
    }
    if (asciiControl(code2) || unicodeWhitespace$1(code2) || code2 !== 45 && unicodePunctuation$1(code2)) {
      return done3(code2);
    }
    effects.consume(code2);
    return domain2;
  }
  function punctuationContinuation(code2) {
    if (code2 === 46) {
      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
      hasUnderscoreInLastSegment = void 0;
      effects.consume(code2);
      return domain2;
    }
    if (code2 === 95)
      hasUnderscoreInLastSegment = true;
    effects.consume(code2);
    return domain2;
  }
  function done3(code2) {
    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizePath(effects, ok3) {
  var balance = 0;
  return inPath;
  function inPath(code2) {
    if (code2 === 38) {
      return effects.check(namedCharacterReference, ok3, continuedPunctuation)(code2);
    }
    if (code2 === 40) {
      balance++;
    }
    if (code2 === 41) {
      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code2);
    }
    if (pathEnd(code2)) {
      return ok3(code2);
    }
    if (trailingPunctuation(code2)) {
      return effects.check(punctuation, ok3, continuedPunctuation)(code2);
    }
    effects.consume(code2);
    return inPath;
  }
  function continuedPunctuation(code2) {
    effects.consume(code2);
    return inPath;
  }
  function parenAtPathEnd(code2) {
    balance--;
    return balance < 0 ? ok3(code2) : continuedPunctuation(code2);
  }
}
function tokenizeNamedCharacterReference(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.consume(code2);
    return inside;
  }
  function inside(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return inside;
    }
    if (code2 === 59) {
      effects.consume(code2);
      return after2;
    }
    return nok(code2);
  }
  function after2(code2) {
    return pathEnd(code2) ? ok3(code2) : nok(code2);
  }
}
function tokenizePunctuation(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    effects.consume(code2);
    return after2;
  }
  function after2(code2) {
    if (trailingPunctuation(code2)) {
      effects.consume(code2);
      return after2;
    }
    return pathEnd(code2) ? ok3(code2) : nok(code2);
  }
}
function trailingPunctuation(code2) {
  return code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 95 || code2 === 126;
}
function pathEnd(code2) {
  return code2 === null || code2 < 0 || code2 === 32 || code2 === 60;
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousWww(code2) {
  return code2 === null || code2 < 0 || code2 === 32 || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126;
}
function previousHttp(code2) {
  return code2 === null || !asciiAlpha(code2);
}
function previousEmail(code2) {
  return code2 !== 47 && previousHttp(code2);
}
function previous$2(events) {
  var index3 = events.length;
  while (index3--) {
    if ((events[index3][1].type === "labelLink" || events[index3][1].type === "labelImage") && !events[index3][1]._balanced) {
      return true;
    }
  }
}
var micromarkExtensionGfmAutolinkLiteral = syntax$6;
var micromarkExtensionGfmStrikethrough = create$1;
var classifyCharacter = classifyCharacter_1;
var chunkedSplice = chunkedSplice_1;
var resolveAll = resolveAll_1;
var shallow = shallow_1;
function create$1(options) {
  var settings = options || {};
  var single = settings.singleTilde;
  var tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return { text: { 126: tokenizer }, insideSpan: { null: tokenizer } };
  function resolveAllStrikethrough(events, context) {
    var index3 = -1;
    var strikethrough2;
    var text3;
    var open2;
    var nextEvents;
    while (++index3 < events.length) {
      if (events[index3][0] === "enter" && events[index3][1].type === "strikethroughSequenceTemporary" && events[index3][1]._close) {
        open2 = index3;
        while (open2--) {
          if (events[open2][0] === "exit" && events[open2][1].type === "strikethroughSequenceTemporary" && events[open2][1]._open && events[index3][1].end.offset - events[index3][1].start.offset === events[open2][1].end.offset - events[open2][1].start.offset) {
            events[index3][1].type = "strikethroughSequence";
            events[open2][1].type = "strikethroughSequence";
            strikethrough2 = {
              type: "strikethrough",
              start: shallow(events[open2][1].start),
              end: shallow(events[index3][1].end)
            };
            text3 = {
              type: "strikethroughText",
              start: shallow(events[open2][1].end),
              end: shallow(events[index3][1].start)
            };
            nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open2][1], context],
              ["exit", events[open2][1], context],
              ["enter", text3, context]
            ];
            chunkedSplice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open2 + 1, index3), context));
            chunkedSplice(nextEvents, nextEvents.length, 0, [
              ["exit", text3, context],
              ["enter", events[index3][1], context],
              ["exit", events[index3][1], context],
              ["exit", strikethrough2, context]
            ]);
            chunkedSplice(events, open2 - 1, index3 - open2 + 3, nextEvents);
            index3 = open2 + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    return removeRemainingSequences(events);
  }
  function removeRemainingSequences(events) {
    var index3 = -1;
    var length = events.length;
    while (++index3 < length) {
      if (events[index3][1].type === "strikethroughSequenceTemporary") {
        events[index3][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    var previous2 = this.previous;
    var events = this.events;
    var size2 = 0;
    return start4;
    function start4(code2) {
      if (code2 !== 126 || previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      var before2 = classifyCharacter(previous2);
      var token;
      var after2;
      if (code2 === 126) {
        if (size2 > 1)
          return nok(code2);
        effects.consume(code2);
        size2++;
        return more;
      }
      if (size2 < 2 && !single)
        return nok(code2);
      token = effects.exit("strikethroughSequenceTemporary");
      after2 = classifyCharacter(code2);
      token._open = !after2 || after2 === 2 && before2;
      token._close = !before2 || before2 === 2 && after2;
      return ok3(code2);
    }
  }
}
var syntax$5 = {};
syntax$5.flow = {
  null: { tokenize: tokenizeTable, resolve: resolveTable, interruptible: true }
};
var createSpace$1 = factorySpace$h;
var setextUnderlineMini = { tokenize: tokenizeSetextUnderlineMini, partial: true };
var nextPrefixedOrBlank = { tokenize: tokenizeNextPrefixedOrBlank, partial: true };
function resolveTable(events, context) {
  var length = events.length;
  var index3 = -1;
  var token;
  var inHead;
  var inDelimiterRow;
  var inRow;
  var cell;
  var content3;
  var text3;
  var contentStart;
  var contentEnd;
  var cellStart;
  while (++index3 < length) {
    token = events[index3][1];
    if (inRow) {
      if (token.type === "temporaryTableCellContent") {
        contentStart = contentStart || index3;
        contentEnd = index3;
      }
      if ((token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd) {
        content3 = {
          type: "tableContent",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text3 = {
          type: "chunkText",
          start: content3.start,
          end: content3.end,
          contentType: "text"
        };
        events.splice(contentStart, contentEnd - contentStart + 1, ["enter", content3, context], ["enter", text3, context], ["exit", text3, context], ["exit", content3, context]);
        index3 -= contentEnd - contentStart - 3;
        length = events.length;
        contentStart = void 0;
        contentEnd = void 0;
      }
    }
    if (events[index3][0] === "exit" && cellStart && cellStart + 1 < index3 && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index3 || events[cellStart][1].type !== "whitespace"))) {
      cell = {
        type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
        start: events[cellStart][1].start,
        end: events[index3][1].end
      };
      events.splice(index3 + (token.type === "tableCellDivider" ? 1 : 0), 0, [
        "exit",
        cell,
        context
      ]);
      events.splice(cellStart, 0, ["enter", cell, context]);
      index3 += 2;
      length = events.length;
      cellStart = index3 + 1;
    }
    if (token.type === "tableRow") {
      inRow = events[index3][0] === "enter";
      if (inRow) {
        cellStart = index3 + 1;
      }
    }
    if (token.type === "tableDelimiterRow") {
      inDelimiterRow = events[index3][0] === "enter";
      if (inDelimiterRow) {
        cellStart = index3 + 1;
      }
    }
    if (token.type === "tableHead") {
      inHead = events[index3][0] === "enter";
    }
  }
  return events;
}
function tokenizeTable(effects, ok3, nok) {
  var align = [];
  var tableHeaderCount = 0;
  var seenDelimiter;
  var hasDash;
  return start4;
  function start4(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return nok(code2);
    }
    effects.enter("table")._align = align;
    effects.enter("tableHead");
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    tableHeaderCount++;
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function cellDividerHead(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    seenDelimiter = true;
    return cellBreakHead;
  }
  function cellBreakHead(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return atRowEndHead(code2);
    }
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceHead;
    }
    if (seenDelimiter) {
      seenDelimiter = void 0;
      tableHeaderCount++;
    }
    if (code2 === 124) {
      return cellDividerHead(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentHead(code2);
  }
  function inWhitespaceHead(code2) {
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.consume(code2);
      return inWhitespaceHead;
    }
    effects.exit("whitespace");
    return cellBreakHead(code2);
  }
  function inCellContentHead(code2) {
    if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
      effects.exit("temporaryTableCellContent");
      return cellBreakHead(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
  }
  function inCellContentEscapeHead(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentHead;
    }
    return inCellContentHead(code2);
  }
  function atRowEndHead(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.exit("tableRow");
    effects.exit("tableHead");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.check(setextUnderlineMini, nok, createSpace$1(effects, rowStartDelimiter, "linePrefix", 4));
  }
  function rowStartDelimiter(code2) {
    if (code2 === null || code2 < 0 || code2 === 32) {
      return nok(code2);
    }
    effects.enter("tableDelimiterRow");
    return atDelimiterRowBreak(code2);
  }
  function atDelimiterRowBreak(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return rowEndDelimiter(code2);
    }
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      align.push(null);
      return inFillerDelimiter;
    }
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align.push("left");
      return afterLeftAlignment;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function inWhitespaceDelimiter(code2) {
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    effects.exit("whitespace");
    return atDelimiterRowBreak(code2);
  }
  function inFillerDelimiter(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return inFillerDelimiter;
    }
    effects.exit("tableDelimiterFiller");
    if (code2 === 58) {
      effects.enter("tableDelimiterAlignment");
      effects.consume(code2);
      effects.exit("tableDelimiterAlignment");
      align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
      return afterRightAlignment;
    }
    return atDelimiterRowBreak(code2);
  }
  function afterLeftAlignment(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      effects.consume(code2);
      hasDash = true;
      return inFillerDelimiter;
    }
    return nok(code2);
  }
  function afterRightAlignment(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return rowEndDelimiter(code2);
    }
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceDelimiter;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return atDelimiterRowBreak;
    }
    return nok(code2);
  }
  function rowEndDelimiter(code2) {
    effects.exit("tableDelimiterRow");
    if (!hasDash || tableHeaderCount !== align.length) {
      return nok(code2);
    }
    if (code2 === null) {
      return tableClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code2);
  }
  function tableClose(code2) {
    effects.exit("table");
    return ok3(code2);
  }
  function tableContinue(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return createSpace$1(effects, bodyStart, "linePrefix", 4);
  }
  function bodyStart(code2) {
    effects.enter("tableBody");
    return rowStartBody(code2);
  }
  function rowStartBody(code2) {
    effects.enter("tableRow");
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function cellDividerBody(code2) {
    effects.enter("tableCellDivider");
    effects.consume(code2);
    effects.exit("tableCellDivider");
    return cellBreakBody;
  }
  function cellBreakBody(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return atRowEndBody(code2);
    }
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.enter("whitespace");
      effects.consume(code2);
      return inWhitespaceBody;
    }
    if (code2 === 124) {
      return cellDividerBody(code2);
    }
    effects.enter("temporaryTableCellContent");
    return inCellContentBody(code2);
  }
  function inWhitespaceBody(code2) {
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.consume(code2);
      return inWhitespaceBody;
    }
    effects.exit("whitespace");
    return cellBreakBody(code2);
  }
  function inCellContentBody(code2) {
    if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
      effects.exit("temporaryTableCellContent");
      return cellBreakBody(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
  }
  function inCellContentEscapeBody(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return inCellContentBody;
    }
    return inCellContentBody(code2);
  }
  function atRowEndBody(code2) {
    effects.exit("tableRow");
    if (code2 === null) {
      return tableBodyClose(code2);
    }
    return effects.check(nextPrefixedOrBlank, tableBodyClose, tableBodyContinue)(code2);
  }
  function tableBodyClose(code2) {
    effects.exit("tableBody");
    return tableClose(code2);
  }
  function tableBodyContinue(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return createSpace$1(effects, rowStartBody, "linePrefix", 4);
  }
}
function tokenizeSetextUnderlineMini(effects, ok3, nok) {
  return start4;
  function start4(code2) {
    if (code2 !== 45) {
      return nok(code2);
    }
    effects.enter("setextUnderline");
    return sequence(code2);
  }
  function sequence(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return sequence;
    }
    return whitespace(code2);
  }
  function whitespace(code2) {
    if (code2 === -2 || code2 === -1 || code2 === 32) {
      effects.consume(code2);
      return whitespace;
    }
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeNextPrefixedOrBlank(effects, ok3, nok) {
  var size2 = 0;
  return start4;
  function start4(code2) {
    effects.enter("check");
    effects.consume(code2);
    return whitespace;
  }
  function whitespace(code2) {
    if (code2 === -1 || code2 === 32) {
      effects.consume(code2);
      size2++;
      return size2 === 4 ? ok3 : whitespace;
    }
    if (code2 === null || code2 < 0) {
      return ok3(code2);
    }
    return nok(code2);
  }
}
var micromarkExtensionGfmTable = syntax$5;
var syntax$4 = {};
var markdownLineEndingOrSpace = markdownLineEndingOrSpace_1;
var spaceFactory = factorySpace$h;
var prefixSize$1 = prefixSize_1;
var tasklistCheck = { tokenize: tokenizeTasklistCheck };
syntax$4.text = { 91: tasklistCheck };
function tokenizeTasklistCheck(effects, ok3, nok) {
  var self2 = this;
  return open2;
  function open2(code2) {
    if (code2 !== 91 || self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (code2 === -2 || code2 === 32) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close3;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close3;
    }
    return nok(code2);
  }
  function close3(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  var self2 = this;
  return spaceFactory(effects, after2, "whitespace");
  function after2(code2) {
    return prefixSize$1(self2.events, "whitespace") && code2 !== null && !markdownLineEndingOrSpace(code2) ? ok3(code2) : nok(code2);
  }
}
var micromarkExtensionGfmTaskListItem = syntax$4;
var combine = combineExtensions_1;
var autolink = micromarkExtensionGfmAutolinkLiteral;
var strikethrough$2 = micromarkExtensionGfmStrikethrough;
var table$4 = micromarkExtensionGfmTable;
var tasklist = micromarkExtensionGfmTaskListItem;
var syntax$3 = create6;
function create6(options) {
  return combine([autolink, strikethrough$2(options), table$4, tasklist]);
}
var micromarkExtensionGfm = syntax$3;
var fromMarkdown$7 = {};
var ccount_1 = ccount$1;
function ccount$1(source, character) {
  var value = String(source);
  var count = 0;
  var index3;
  if (typeof character !== "string") {
    throw new Error("Expected character");
  }
  index3 = value.indexOf(character);
  while (index3 !== -1) {
    count++;
    index3 = value.indexOf(character, index3 + character.length);
  }
  return count;
}
var escapeStringRegexp = (string2) => {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var mdastUtilFindAndReplace = findAndReplace$1;
var visit$1 = unistUtilVisitParents;
var convert = convert_1;
var escape = escapeStringRegexp;
var splice = [].splice;
function findAndReplace$1(tree, find4, replace4, options) {
  var settings;
  var schema2;
  if (typeof find4 === "string" || find4 && typeof find4.exec === "function") {
    schema2 = [[find4, replace4]];
  } else {
    schema2 = find4;
    options = replace4;
  }
  settings = options || {};
  search(tree, settings, handlerFactory(toPairs(schema2)));
  return tree;
  function handlerFactory(pairs) {
    var pair = pairs[0];
    return handler;
    function handler(node5, parent) {
      var find5 = pair[0];
      var replace5 = pair[1];
      var nodes2 = [];
      var start4 = 0;
      var index3 = parent.children.indexOf(node5);
      var position2;
      var match;
      var subhandler;
      var value;
      find5.lastIndex = 0;
      match = find5.exec(node5.value);
      while (match) {
        position2 = match.index;
        value = replace5.apply(null, [].concat(match, { index: match.index, input: match.input }));
        if (value !== false) {
          if (start4 !== position2) {
            nodes2.push({ type: "text", value: node5.value.slice(start4, position2) });
          }
          if (typeof value === "string" && value.length > 0) {
            value = { type: "text", value };
          }
          if (value) {
            nodes2 = [].concat(nodes2, value);
          }
          start4 = position2 + match[0].length;
        }
        if (!find5.global) {
          break;
        }
        match = find5.exec(node5.value);
      }
      if (position2 === void 0) {
        nodes2 = [node5];
        index3--;
      } else {
        if (start4 < node5.value.length) {
          nodes2.push({ type: "text", value: node5.value.slice(start4) });
        }
        nodes2.unshift(index3, 1);
        splice.apply(parent.children, nodes2);
      }
      if (pairs.length > 1) {
        subhandler = handlerFactory(pairs.slice(1));
        position2 = -1;
        while (++position2 < nodes2.length) {
          node5 = nodes2[position2];
          if (node5.type === "text") {
            subhandler(node5, parent);
          } else {
            search(node5, settings, subhandler);
          }
        }
      }
      return index3 + nodes2.length + 1;
    }
  }
}
function search(tree, settings, handler) {
  var ignored = convert(settings.ignore || []);
  var result2 = [];
  visit$1(tree, "text", visitor);
  return result2;
  function visitor(node5, parents) {
    var index3 = -1;
    var parent;
    var grandparent;
    while (++index3 < parents.length) {
      parent = parents[index3];
      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : void 0, grandparent)) {
        return;
      }
      grandparent = parent;
    }
    return handler(node5, grandparent);
  }
}
function toPairs(schema2) {
  var result2 = [];
  var key2;
  var index3;
  if (typeof schema2 !== "object") {
    throw new Error("Expected array or object as schema");
  }
  if ("length" in schema2) {
    index3 = -1;
    while (++index3 < schema2.length) {
      result2.push([
        toExpression(schema2[index3][0]),
        toFunction(schema2[index3][1])
      ]);
    }
  } else {
    for (key2 in schema2) {
      result2.push([toExpression(key2), toFunction(schema2[key2])]);
    }
  }
  return result2;
}
function toExpression(find4) {
  return typeof find4 === "string" ? new RegExp(escape(find4), "g") : find4;
}
function toFunction(replace4) {
  return typeof replace4 === "function" ? replace4 : returner;
  function returner() {
    return replace4;
  }
}
var ccount = ccount_1;
var findAndReplace = mdastUtilFindAndReplace;
var unicodePunctuation = unicodePunctuation_1;
var unicodeWhitespace = unicodeWhitespace_1;
fromMarkdown$7.transforms = [transformGfmAutolinkLiterals];
fromMarkdown$7.enter = {
  literalAutolink: enterLiteralAutolink,
  literalAutolinkEmail: enterLiteralAutolinkValue,
  literalAutolinkHttp: enterLiteralAutolinkValue,
  literalAutolinkWww: enterLiteralAutolinkValue
};
fromMarkdown$7.exit = {
  literalAutolink: exitLiteralAutolink,
  literalAutolinkEmail: exitLiteralAutolinkEmail,
  literalAutolinkHttp: exitLiteralAutolinkHttp,
  literalAutolinkWww: exitLiteralAutolinkWww
};
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  this.stack[this.stack.length - 1].url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [
    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/i, findUrl],
    [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/, findEmail]
  ], { ignore: ["link", "linkReference"] });
}
function findUrl($0, protocol, domain2, path2, match) {
  var prefix = "";
  var parts;
  var result2;
  if (!previous$1(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  result2 = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    result2 = [result2, { type: "text", value: parts[1] }];
  }
  return result2;
}
function findEmail($0, atext, label2, match) {
  if (!previous$1(match, true) || /[_-]$/.test(label2)) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label2,
    children: [{ type: "text", value: atext + "@" + label2 }]
  };
}
function isCorrectDomain(domain2) {
  var parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  var trail = /[!"&'),.:;<>?\]}]+$/.exec(url);
  var closingParenIndex;
  var openingParens;
  var closingParens;
  if (trail) {
    url = url.slice(0, trail.index);
    trail = trail[0];
    closingParenIndex = trail.indexOf(")");
    openingParens = ccount(url, "(");
    closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail.slice(0, closingParenIndex + 1);
      trail = trail.slice(closingParenIndex + 1);
      closingParenIndex = trail.indexOf(")");
      closingParens++;
    }
  }
  return [url, trail];
}
function previous$1(match, email2) {
  var code2 = match.input.charCodeAt(match.index - 1);
  return (code2 !== code2 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email2 || code2 !== 47);
}
var fromMarkdown$6 = {};
fromMarkdown$6.canContainEols = ["delete"];
fromMarkdown$6.enter = { strikethrough: enterStrikethrough };
fromMarkdown$6.exit = { strikethrough: exitStrikethrough };
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
var fromMarkdown$5 = {};
fromMarkdown$5.enter = {
  table: enterTable,
  tableData: enterCell,
  tableHeader: enterCell,
  tableRow: enterRow
};
fromMarkdown$5.exit = {
  codeText: exitCodeText,
  table: exitTable$1,
  tableData: exit,
  tableHeader: exit,
  tableRow: exit
};
function enterTable(token) {
  this.enter({ type: "table", align: token._align, children: [] }, token);
  this.setData("inTable", true);
}
function exitTable$1(token) {
  this.exit(token);
  this.setData("inTable");
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  var value = this.resume();
  if (this.getData("inTable")) {
    value = value.replace(/\\([\\|])/g, replace2);
  }
  this.stack[this.stack.length - 1].value = value;
  this.exit(token);
}
function replace2($0, $1) {
  return $1 === "|" ? $1 : $0;
}
var fromMarkdown$4 = {};
fromMarkdown$4.exit = {
  taskListCheckValueChecked: exitCheck,
  taskListCheckValueUnchecked: exitCheck,
  paragraph: exitParagraphWithTaskListItem
};
function exitCheck(token) {
  this.stack[this.stack.length - 2].checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  var parent = this.stack[this.stack.length - 2];
  var node5 = this.stack[this.stack.length - 1];
  var siblings = parent.children;
  var head = node5.children[0];
  var index3 = -1;
  var firstParaghraph;
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
    while (++index3 < siblings.length) {
      if (siblings[index3].type === "paragraph") {
        firstParaghraph = siblings[index3];
        break;
      }
    }
    if (firstParaghraph === node5) {
      head.value = head.value.slice(1);
      if (head.value.length === 0) {
        node5.children.shift();
      } else {
        head.position.start.column++;
        head.position.start.offset++;
        node5.position.start = Object.assign({}, head.position.start);
      }
    }
  }
  this.exit(token);
}
var autolinkLiteral$1 = fromMarkdown$7;
var strikethrough$1 = fromMarkdown$6;
var table$3 = fromMarkdown$5;
var taskListItem$2 = fromMarkdown$4;
var own = {}.hasOwnProperty;
var fromMarkdown$3 = configure$1([
  autolinkLiteral$1,
  strikethrough$1,
  table$3,
  taskListItem$2
]);
function configure$1(extensions) {
  var config2 = { transforms: [], canContainEols: [] };
  var length = extensions.length;
  var index3 = -1;
  while (++index3 < length) {
    extension(config2, extensions[index3]);
  }
  return config2;
}
function extension(config2, extension2) {
  var key2;
  var left;
  var right;
  for (key2 in extension2) {
    left = own.call(config2, key2) ? config2[key2] : config2[key2] = {};
    right = extension2[key2];
    if (key2 === "canContainEols" || key2 === "transforms") {
      config2[key2] = [].concat(left, right);
    } else {
      Object.assign(left, right);
    }
  }
}
var toMarkdown$7 = {};
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
toMarkdown$7.unsafe = [
  {
    character: "@",
    before: "[+\\-.\\w]",
    after: "[\\-.\\w]",
    inConstruct,
    notInConstruct
  },
  {
    character: ".",
    before: "[Ww]",
    after: "[\\-.\\w]",
    inConstruct,
    notInConstruct
  },
  {
    character: ":",
    before: "[ps]",
    after: "\\/",
    inConstruct,
    notInConstruct
  }
];
var toMarkdown$6 = {};
var phrasing$1 = containerPhrasing;
toMarkdown$6.unsafe = [{ character: "~", inConstruct: "phrasing" }];
toMarkdown$6.handlers = { delete: handleDelete };
handleDelete.peek = peekDelete;
function handleDelete(node5, _2, context) {
  var exit2 = context.enter("emphasis");
  var value = phrasing$1(node5, context, { before: "~", after: "~" });
  exit2();
  return "~~" + value + "~~";
}
function peekDelete() {
  return "~";
}
var repeat$2 = repeatString;
var markdownTable_1 = markdownTable$1;
var trailingWhitespace = / +$/;
var space = " ";
var lineFeed = "\n";
var dash$1 = "-";
var colon = ":";
var verticalBar = "|";
var x$2 = 0;
var C$1 = 67;
var L$1 = 76;
var R$1 = 82;
var c$1 = 99;
var l$1 = 108;
var r$2 = 114;
function markdownTable$1(table2, options) {
  var settings = options || {};
  var padding = settings.padding !== false;
  var start4 = settings.delimiterStart !== false;
  var end3 = settings.delimiterEnd !== false;
  var align = (settings.align || []).concat();
  var alignDelimiters = settings.alignDelimiters !== false;
  var alignments = [];
  var stringLength = settings.stringLength || defaultStringLength;
  var rowIndex = -1;
  var rowLength = table2.length;
  var cellMatrix = [];
  var sizeMatrix = [];
  var row = [];
  var sizes = [];
  var longestCellByColumn = [];
  var mostCellsPerRow = 0;
  var cells;
  var columnIndex;
  var columnLength;
  var largest;
  var size2;
  var cell;
  var lines;
  var line;
  var before2;
  var after2;
  var code2;
  while (++rowIndex < rowLength) {
    cells = table2[rowIndex];
    columnIndex = -1;
    columnLength = cells.length;
    row = [];
    sizes = [];
    if (columnLength > mostCellsPerRow) {
      mostCellsPerRow = columnLength;
    }
    while (++columnIndex < columnLength) {
      cell = serialize(cells[columnIndex]);
      if (alignDelimiters === true) {
        size2 = stringLength(cell);
        sizes[columnIndex] = size2;
        largest = longestCellByColumn[columnIndex];
        if (largest === void 0 || size2 > largest) {
          longestCellByColumn[columnIndex] = size2;
        }
      }
      row.push(cell);
    }
    cellMatrix[rowIndex] = row;
    sizeMatrix[rowIndex] = sizes;
  }
  columnIndex = -1;
  columnLength = mostCellsPerRow;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < columnLength) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    code2 = toAlignment(align);
    while (++columnIndex < columnLength) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  columnLength = mostCellsPerRow;
  row = [];
  sizes = [];
  while (++columnIndex < columnLength) {
    code2 = alignments[columnIndex];
    before2 = "";
    after2 = "";
    if (code2 === l$1) {
      before2 = colon;
    } else if (code2 === r$2) {
      after2 = colon;
    } else if (code2 === c$1) {
      before2 = colon;
      after2 = colon;
    }
    size2 = alignDelimiters ? Math.max(1, longestCellByColumn[columnIndex] - before2.length - after2.length) : 1;
    cell = before2 + repeat$2(dash$1, size2) + after2;
    if (alignDelimiters === true) {
      size2 = before2.length + size2 + after2.length;
      if (size2 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size2;
      }
      sizes[columnIndex] = size2;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  rowLength = cellMatrix.length;
  lines = [];
  while (++rowIndex < rowLength) {
    row = cellMatrix[rowIndex];
    sizes = sizeMatrix[rowIndex];
    columnIndex = -1;
    columnLength = mostCellsPerRow;
    line = [];
    while (++columnIndex < columnLength) {
      cell = row[columnIndex] || "";
      before2 = "";
      after2 = "";
      if (alignDelimiters === true) {
        size2 = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
        code2 = alignments[columnIndex];
        if (code2 === r$2) {
          before2 = repeat$2(space, size2);
        } else if (code2 === c$1) {
          if (size2 % 2 === 0) {
            before2 = repeat$2(space, size2 / 2);
            after2 = before2;
          } else {
            before2 = repeat$2(space, size2 / 2 + 0.5);
            after2 = repeat$2(space, size2 / 2 - 0.5);
          }
        } else {
          after2 = repeat$2(space, size2);
        }
      }
      if (start4 === true && columnIndex === 0) {
        line.push(verticalBar);
      }
      if (padding === true && !(alignDelimiters === false && cell === "") && (start4 === true || columnIndex !== 0)) {
        line.push(space);
      }
      if (alignDelimiters === true) {
        line.push(before2);
      }
      line.push(cell);
      if (alignDelimiters === true) {
        line.push(after2);
      }
      if (padding === true) {
        line.push(space);
      }
      if (end3 === true || columnIndex !== columnLength - 1) {
        line.push(verticalBar);
      }
    }
    line = line.join("");
    if (end3 === false) {
      line = line.replace(trailingWhitespace, "");
    }
    lines.push(line);
  }
  return lines.join(lineFeed);
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  var code2 = typeof value === "string" ? value.charCodeAt(0) : x$2;
  return code2 === L$1 || code2 === l$1 ? l$1 : code2 === R$1 || code2 === r$2 ? r$2 : code2 === C$1 || code2 === c$1 ? c$1 : x$2;
}
var phrasing = containerPhrasing;
var defaultInlineCode = inlineCode_1;
var markdownTable = markdownTable_1;
var toMarkdown_1$1 = toMarkdown$5;
function toMarkdown$5(options) {
  var settings = options || {};
  var padding = settings.tableCellPadding;
  var alignDelimiters = settings.tablePipeAlign;
  var stringLength = settings.stringLength;
  var around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      { atBreak: true, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: true, character: ":", after: "-" },
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  };
  function handleTable(node5, _2, context) {
    return serializeData(handleTableAsData(node5, context), node5.align);
  }
  function handleTableRow(node5, _2, context) {
    var row = handleTableRowAsData(node5, context);
    var value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node5, _2, context) {
    var exit2 = context.enter("tableCell");
    var value = phrasing(node5, context, { before: around, after: around });
    exit2();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      alignDelimiters,
      padding,
      stringLength
    });
  }
  function handleTableAsData(node5, context) {
    var children = node5.children;
    var index3 = -1;
    var length = children.length;
    var result2 = [];
    var subexit = context.enter("table");
    while (++index3 < length) {
      result2[index3] = handleTableRowAsData(children[index3], context);
    }
    subexit();
    return result2;
  }
  function handleTableRowAsData(node5, context) {
    var children = node5.children;
    var index3 = -1;
    var length = children.length;
    var result2 = [];
    var subexit = context.enter("tableRow");
    while (++index3 < length) {
      result2[index3] = handleTableCell(children[index3], node5, context);
    }
    subexit();
    return result2;
  }
  function inlineCodeWithTable(node5, parent, context) {
    var value = defaultInlineCode(node5, parent, context);
    if (context.stack.indexOf("tableCell") !== -1) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
var toMarkdown$4 = {};
var defaultListItem = listItem_1;
toMarkdown$4.unsafe = [{ atBreak: true, character: "-", after: "[:|-]" }];
toMarkdown$4.handlers = {
  listItem: listItemWithTaskListItem
};
function listItemWithTaskListItem(node5, parent, context) {
  var value = defaultListItem(node5, parent, context);
  var head = node5.children[0];
  if (typeof node5.checked === "boolean" && head && head.type === "paragraph") {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check2);
  }
  return value;
  function check2($0) {
    return $0 + "[" + (node5.checked ? "x" : " ") + "] ";
  }
}
var autolinkLiteral = toMarkdown$7;
var strikethrough = toMarkdown$6;
var table$2 = toMarkdown_1$1;
var taskListItem$1 = toMarkdown$4;
var configure = configure_1;
var toMarkdown_1 = toMarkdown$3;
function toMarkdown$3(options) {
  var config2 = configure({ handlers: {}, join: [], unsafe: [], options: {} }, {
    extensions: [autolinkLiteral, strikethrough, table$2(options), taskListItem$1]
  });
  return Object.assign(config2.options, {
    handlers: config2.handlers,
    join: config2.join,
    unsafe: config2.unsafe
  });
}
var syntax$2 = micromarkExtensionGfm;
var fromMarkdown$2 = fromMarkdown$3;
var toMarkdown$2 = toMarkdown_1;
var warningIssued$1;
var remarkGfm = gfm;
function gfm(options) {
  var data = this.data();
  if (!warningIssued$1 && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
    warningIssued$1 = true;
    console.warn("[remark-gfm] Warning: please upgrade to remark 13 to use this plugin");
  }
  add3("micromarkExtensions", syntax$2(options));
  add3("fromMarkdownExtensions", fromMarkdown$2);
  add3("toMarkdownExtensions", toMarkdown$2(options));
  function add3(field, value) {
    if (data[field])
      data[field].push(value);
    else
      data[field] = [value];
  }
}
const exitTable = (node5) => (state, dispatch3) => {
  if (!isInTable(state)) {
    return false;
  }
  const { $head } = state.selection;
  const pos = $head.after();
  const tr = state.tr.replaceWith(pos, pos, node5.createAndFill());
  tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
  dispatch3 === null || dispatch3 === void 0 ? void 0 : dispatch3(tr.scrollIntoView());
  return true;
};
const findTable = (selection) => findParentNode((node5) => node5.type.spec.tableRole === "table")(selection);
const getCellsInColumn = (columnIndex) => (selection) => {
  const table2 = findTable(selection);
  if (!table2)
    return void 0;
  const map21 = TableMap.get(table2.node);
  if (columnIndex < 0 || columnIndex >= map21.width) {
    return void 0;
  }
  return map21.cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map21.height }).map((pos) => {
    const node5 = table2.node.nodeAt(pos);
    if (!node5)
      throw new Error();
    const start4 = pos + table2.start;
    return {
      pos: start4,
      start: start4 + 1,
      node: node5
    };
  });
};
const getCellsInRow = (rowIndex) => (selection) => {
  const table2 = findTable(selection);
  if (!table2)
    return void 0;
  const map21 = TableMap.get(table2.node);
  if (rowIndex < 0 || rowIndex >= map21.height) {
    return void 0;
  }
  return map21.cellsInRect({ left: 0, right: map21.width, top: rowIndex, bottom: rowIndex + 1 }).map((pos) => {
    const node5 = table2.node.nodeAt(pos);
    if (!node5)
      throw new Error();
    const start4 = pos + table2.start;
    return {
      pos: start4,
      start: start4 + 1,
      node: node5
    };
  });
};
const createTable = (schema2, rowsCount = 3, colsCount = 3) => {
  const { cell: tableCell2, header_cell: tableHeader2, row: tableRow2, table: table2 } = tableNodeTypes(schema2);
  const cells = Array(colsCount).fill(0).map(() => tableCell2.createAndFill(null));
  const headerCells = Array(colsCount).fill(0).map(() => tableHeader2.createAndFill(null));
  const rows = Array(rowsCount).fill(0).map((_2, i2) => tableRow2.create(null, i2 === 0 ? headerCells : cells));
  return table2.create(null, rows);
};
const selectLine = (type) => (index3) => (tr) => {
  const table2 = findTable(tr.selection);
  const isRowSelection = type === "row";
  if (table2) {
    const map21 = TableMap.get(table2.node);
    if (index3 >= 0 && index3 < (isRowSelection ? map21.height : map21.width)) {
      const lastCell = map21.positionAt(isRowSelection ? index3 : map21.height - 1, isRowSelection ? map21.width - 1 : index3, table2.node);
      const $lastCell = tr.doc.resolve(table2.start + lastCell);
      const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection;
      const firstCell = map21.positionAt(isRowSelection ? index3 : 0, isRowSelection ? 0 : index3, table2.node);
      const $firstCell = tr.doc.resolve(table2.start + firstCell);
      return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell)));
    }
  }
  return tr;
};
const getCellsInTable = (selection) => {
  const table2 = findTable(selection);
  if (!table2) {
    return;
  }
  const map21 = TableMap.get(table2.node);
  const cells = map21.cellsInRect({
    left: 0,
    right: map21.width,
    top: 0,
    bottom: map21.height
  });
  return cells.map((nodePos) => {
    const node5 = table2.node.nodeAt(nodePos);
    const pos = nodePos + table2.start;
    return { pos, start: pos + 1, node: node5 };
  });
};
const selectTable = (tr) => {
  const cells = getCellsInTable(tr.selection);
  if (cells) {
    const $firstCell = tr.doc.resolve(cells[0].pos);
    const $lastCell = tr.doc.resolve(cells[cells.length - 1].pos);
    return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)));
  }
  return tr;
};
function addRowWithAlignment(tr, { map: map21, tableStart, table: table2 }, row) {
  const rowPos = Array(row).fill(0).reduce((acc, _2, i2) => {
    return acc + table2.child(i2).nodeSize;
  }, tableStart);
  const { cell: cellType, row: rowType } = tableNodeTypes(table2.type.schema);
  const cells = Array(map21.width).fill(0).map((_2, col) => {
    const headerCol = table2.nodeAt(map21.map[col]);
    return cellType.createAndFill({ alignment: headerCol === null || headerCol === void 0 ? void 0 : headerCol.attrs.alignment });
  });
  tr.insert(rowPos, rowType.create(null, cells));
  return tr;
}
const tableNodesSpec = tableNodes$1({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (dom) => dom.style.textAlign || "left",
      setDOMAttr: (value, attrs) => {
        attrs.style = `text-align: ${value || "left"}`;
      }
    }
  }
});
const SupportedKeys$1 = {
  NextCell: "NextCell",
  PrevCell: "PrevCell",
  ExitTable: "ExitTable"
};
const PrevCell = createCmdKey();
const NextCell = createCmdKey();
const BreakTable = createCmdKey();
const InsertTable = createCmdKey();
const table$1 = createNode$1(() => {
  const id2 = "table";
  return {
    id: id2,
    schema: tableNodesSpec.table,
    parser: {
      match: (node5) => node5.type === "table",
      runner: (state, node5, type) => {
        const align = node5.align;
        const children = node5.children.map((x2, i2) => Object.assign(Object.assign({}, x2), { align, isHeader: i2 === 0 }));
        state.openNode(type);
        state.next(children);
        state.closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        var _a;
        const firstLine = (_a = node5.content.firstChild) === null || _a === void 0 ? void 0 : _a.content;
        if (!firstLine)
          return;
        const align = [];
        firstLine.forEach((cell) => {
          align.push(cell.attrs.alignment);
        });
        state.openNode("table", void 0, { align });
        state.next(node5.content);
        state.closeNode();
      }
    },
    inputRules: (nodeType2, schema2) => [
      new InputRule(/^\|\|\s$/, (state, _match, start4, end3) => {
        const $start = state.doc.resolve(start4);
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType2))
          return null;
        const tableNode = createTable(schema2);
        const tr = state.tr.replaceRangeWith(start4, end3, tableNode).scrollIntoView();
        return tr.setSelection(TextSelection.create(tr.doc, start4 + 3));
      })
    ],
    commands: (_2, schema2) => [
      createCmd(PrevCell, () => goToNextCell(-1)),
      createCmd(NextCell, () => goToNextCell(1)),
      createCmd(BreakTable, () => exitTable(schema2.nodes.paragraph)),
      createCmd(InsertTable, () => (state, dispatch3) => {
        const { selection, tr } = state;
        const { from: from5 } = selection;
        const table2 = createTable(schema2);
        const _tr = tr.replaceSelectionWith(table2);
        const sel = Selection.findFrom(_tr.doc.resolve(from5), 1, true);
        if (sel) {
          dispatch3 === null || dispatch3 === void 0 ? void 0 : dispatch3(_tr.setSelection(sel));
        }
        return true;
      })
    ],
    shortcuts: {
      [SupportedKeys$1.NextCell]: createShortcut(NextCell, "Mod-]"),
      [SupportedKeys$1.PrevCell]: createShortcut(PrevCell, "Mod-["),
      [SupportedKeys$1.ExitTable]: createShortcut(BreakTable, "Mod-Enter")
    }
  };
});
const tableRow = createNode$1(() => {
  const id2 = "table_row";
  return {
    id: id2,
    schema: tableNodesSpec.table_row,
    parser: {
      match: (node5) => node5.type === "tableRow",
      runner: (state, node5, type) => {
        const align = node5.align;
        const children = node5.children.map((x2, i2) => Object.assign(Object.assign({}, x2), { align: align[i2], isHeader: node5.isHeader }));
        state.openNode(type);
        state.next(children);
        state.closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        state.openNode("tableRow");
        state.next(node5.content);
        state.closeNode();
      }
    }
  };
});
const tableCell = createNode$1(() => {
  const id2 = "table_cell";
  return {
    id: id2,
    schema: tableNodesSpec.table_cell,
    parser: {
      match: (node5) => node5.type === "tableCell" && !node5.isHeader,
      runner: (state, node5, type) => {
        const align = node5.align;
        state.openNode(type, { alignment: align }).openNode(state.schema.nodes.paragraph).next(node5.children).closeNode().closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        state.openNode("tableCell").next(node5.content).closeNode();
      }
    }
  };
});
const tableHeader = createNode$1(() => {
  const id2 = "table_header";
  return {
    id: id2,
    schema: tableNodesSpec.table_header,
    parser: {
      match: (node5) => node5.type === "tableCell" && !!node5.isHeader,
      runner: (state, node5, type) => {
        const align = node5.align;
        state.openNode(type, { alignment: align });
        state.openNode(state.schema.nodes.paragraph);
        state.next(node5.children);
        state.closeNode();
        state.closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        state.openNode("tableCell");
        state.next(node5.content);
        state.closeNode();
      }
    }
  };
});
const tableNodes = AtomList.create([table$1(), tableRow(), tableCell(), tableHeader()]);
var _PluginProps_decorations, _PluginProps_tooltip, _PluginProps_view, _PluginProps_items;
var ToolTipPos;
(function(ToolTipPos2) {
  ToolTipPos2["Left"] = "Left";
  ToolTipPos2["Top"] = "Top";
  ToolTipPos2["Point"] = "Point";
})(ToolTipPos || (ToolTipPos = {}));
var Action;
(function(Action2) {
  Action2[Action2["AddColLeft"] = 0] = "AddColLeft";
  Action2[Action2["AddColRight"] = 1] = "AddColRight";
  Action2[Action2["AddRowTop"] = 2] = "AddRowTop";
  Action2[Action2["AddRowBottom"] = 3] = "AddRowBottom";
  Action2[Action2["AlignLeft"] = 4] = "AlignLeft";
  Action2[Action2["AlignCenter"] = 5] = "AlignCenter";
  Action2[Action2["AlignRight"] = 6] = "AlignRight";
  Action2[Action2["Delete"] = 7] = "Delete";
})(Action || (Action = {}));
function icon(text3) {
  const span = document.createElement("span");
  span.textContent = text3;
  span.className = "icon material-icons material-icons-outlined";
  return span;
}
const getCellSelection = (view) => view.state.selection;
const isFirstRowSelected = (selection) => {
  const map21 = TableMap.get(selection.$anchorCell.node(-1));
  const start4 = selection.$anchorCell.start(-1);
  const cells = map21.cellsInRect({
    left: 0,
    right: map21.width,
    top: 0,
    bottom: 1
  });
  const selectedCells = map21.cellsInRect(map21.rectBetween(selection.$anchorCell.pos - start4, selection.$headCell.pos - start4));
  for (let i2 = 0, count = cells.length; i2 < count; i2++) {
    if (selectedCells.indexOf(cells[i2]) === -1) {
      return false;
    }
  }
  return true;
};
class PluginProps {
  constructor() {
    _PluginProps_decorations.set(this, []);
    _PluginProps_tooltip.set(this, void 0);
    _PluginProps_view.set(this, void 0);
    _PluginProps_items.set(this, {
      [Action.AddColLeft]: {
        $: icon("chevron_left"),
        command: () => addColumnBefore,
        disable: (view) => !getCellSelection(view).isColSelection()
      },
      [Action.AddColRight]: {
        $: icon("chevron_right"),
        command: () => addColumnAfter,
        disable: (view) => !getCellSelection(view).isColSelection()
      },
      [Action.AddRowTop]: {
        $: icon("expand_less"),
        command: () => (state, dispatch3) => {
          if (!isInTable(state))
            return false;
          if (dispatch3) {
            const rect = selectedRect(state);
            dispatch3(addRowWithAlignment(state.tr, rect, rect.top));
          }
          return true;
        },
        disable: (view) => !getCellSelection(view).isRowSelection() || getCellSelection(view).$head.parent.type.name === "table_header"
      },
      [Action.AddRowBottom]: {
        $: icon("expand_more"),
        command: () => (state, dispatch3) => {
          if (!isInTable(state))
            return false;
          if (dispatch3) {
            const rect = selectedRect(state);
            dispatch3(addRowWithAlignment(state.tr, rect, rect.bottom));
          }
          return true;
        },
        disable: (view) => !getCellSelection(view).isRowSelection()
      },
      [Action.AlignLeft]: {
        $: icon("format_align_left"),
        command: () => setCellAttr("alignment", "left"),
        disable: (view) => !getCellSelection(view).isColSelection()
      },
      [Action.AlignCenter]: {
        $: icon("format_align_center"),
        command: () => setCellAttr("alignment", "center"),
        disable: (view) => !getCellSelection(view).isColSelection()
      },
      [Action.AlignRight]: {
        $: icon("format_align_right"),
        command: () => setCellAttr("alignment", "right"),
        disable: (view) => !getCellSelection(view).isColSelection()
      },
      [Action.Delete]: {
        $: icon("delete"),
        command: (_2, view) => {
          const selection = getCellSelection(view);
          const isCol = selection.isColSelection();
          const isRow = selection.isRowSelection();
          if (isCol && isRow) {
            return deleteTable;
          }
          if (isCol) {
            return deleteColumn;
          }
          return deleteRow;
        },
        disable: (view) => {
          const selection = getCellSelection(view);
          if (selection.isRowSelection()) {
            if (selection.isColSelection()) {
              return false;
            }
            return isFirstRowSelected(selection);
          }
          return false;
        }
      }
    });
    this.key = new PluginKey("TABLE_OP");
    this.decorations = (state) => {
      const leftCells = getCellsInColumn(0)(state.selection);
      if (!leftCells)
        return null;
      const topCells = getCellsInRow(0)(state.selection);
      if (!topCells)
        return null;
      const [topLeft] = leftCells;
      this.createWidget(topLeft, ToolTipPos.Point);
      leftCells.forEach((cell, i2) => {
        this.createWidget(cell, ToolTipPos.Left, i2);
      });
      topCells.forEach((cell, i2) => {
        this.createWidget(cell, ToolTipPos.Top, i2);
      });
      return DecorationSet$1.create(state.doc, __classPrivateFieldGet(this, _PluginProps_decorations, "f"));
    };
    this.update = (view, prevState) => {
      const state = view.state;
      if ((prevState === null || prevState === void 0 ? void 0 : prevState.doc.eq(state.doc)) && prevState.selection.eq(state.selection))
        return;
      const isCellSelection = state.selection instanceof CellSelection;
      if (!isCellSelection || !view.editable) {
        this.hide();
        return;
      }
      this.calculateItem(view);
      if (Object.values(__classPrivateFieldGet(this, _PluginProps_items, "f")).every(({ $: $2 }) => $2.classList.contains("hide"))) {
        this.hide();
        return;
      }
      __classPrivateFieldGet(this, _PluginProps_tooltip, "f").classList.remove("hide");
      this.calculatePosition(view);
    };
    this.props = {
      decorations: this.decorations
    };
    this.view = (editorView2) => {
      var _a;
      __classPrivateFieldSet(this, _PluginProps_view, editorView2, "f");
      Object.values(__classPrivateFieldGet(this, _PluginProps_items, "f")).forEach(({ $: $2 }) => __classPrivateFieldGet(this, _PluginProps_tooltip, "f").appendChild($2));
      (_a = editorView2.dom.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(__classPrivateFieldGet(this, _PluginProps_tooltip, "f"));
      this.update(editorView2);
      __classPrivateFieldGet(this, _PluginProps_tooltip, "f").addEventListener("mousedown", this.listener);
      return {
        update: this.update,
        destroy: () => {
          __classPrivateFieldGet(this, _PluginProps_tooltip, "f").removeEventListener("mousedown", this.listener);
          __classPrivateFieldGet(this, _PluginProps_tooltip, "f").remove();
        }
      };
    };
    this.listener = (e3) => {
      const view = __classPrivateFieldGet(this, _PluginProps_view, "f");
      if (!view)
        return;
      e3.stopPropagation();
      e3.preventDefault();
      Object.values(__classPrivateFieldGet(this, _PluginProps_items, "f")).forEach(({ $: $2, command }) => {
        if ($2.contains(e3.target)) {
          command(e3, view)(view.state, view.dispatch);
        }
      });
    };
    __classPrivateFieldSet(this, _PluginProps_tooltip, document.createElement("div"), "f");
    __classPrivateFieldGet(this, _PluginProps_tooltip, "f").classList.add("table-tooltip");
  }
  createWidget(cell, pos, index3 = 0) {
    const widget3 = Decoration$1.widget(cell.pos + 1, () => {
      const div = document.createElement("div");
      div.classList.add(this.calculateClassName(pos));
      div.addEventListener("mousedown", (e3) => {
        if (!__classPrivateFieldGet(this, _PluginProps_view, "f"))
          return;
        e3.preventDefault();
        switch (pos) {
          case ToolTipPos.Point: {
            __classPrivateFieldGet(this, _PluginProps_view, "f").dispatch(selectTable(__classPrivateFieldGet(this, _PluginProps_view, "f").state.tr));
            return;
          }
          case ToolTipPos.Left: {
            __classPrivateFieldGet(this, _PluginProps_view, "f").dispatch(selectLine("row")(index3)(__classPrivateFieldGet(this, _PluginProps_view, "f").state.tr));
            return;
          }
          case ToolTipPos.Top: {
            __classPrivateFieldGet(this, _PluginProps_view, "f").dispatch(selectLine("col")(index3)(__classPrivateFieldGet(this, _PluginProps_view, "f").state.tr));
            return;
          }
        }
      });
      return div;
    });
    __classPrivateFieldGet(this, _PluginProps_decorations, "f").push(widget3);
  }
  calculateClassName(pos) {
    switch (pos) {
      case ToolTipPos.Left: {
        return "milkdown-cell-left";
      }
      case ToolTipPos.Top: {
        return "milkdown-cell-top";
      }
      case ToolTipPos.Point:
      default: {
        return "milkdown-cell-point";
      }
    }
  }
  calculatePosition(view) {
    const { selection } = view.state;
    const isCol = selection.isColSelection();
    const isRow = selection.isRowSelection();
    calculateNodePosition$1(view, __classPrivateFieldGet(this, _PluginProps_tooltip, "f"), (selected, target, parent) => {
      let left = !isRow ? selected.left - parent.left + (selected.width - target.width) / 2 : selected.left - parent.left - target.width / 2 - 8;
      let top2 = selected.top - parent.top - target.height - (isCol ? 14 : 0) - 14;
      if (left < 0) {
        left = 0;
      }
      if (top2 < target.height) {
        top2 = selected.top - parent.top;
      }
      return [top2, left];
    });
  }
  calculateItem(view) {
    Object.values(__classPrivateFieldGet(this, _PluginProps_items, "f")).forEach((item) => {
      var _a;
      const disable2 = (_a = item.disable) === null || _a === void 0 ? void 0 : _a.call(item, view);
      if (disable2) {
        item.$.classList.add("hide");
        return;
      }
      item.$.classList.remove("hide");
    });
  }
  hide() {
    __classPrivateFieldGet(this, _PluginProps_tooltip, "f").classList.add("hide");
  }
}
_PluginProps_decorations = new WeakMap(), _PluginProps_tooltip = new WeakMap(), _PluginProps_view = new WeakMap(), _PluginProps_items = new WeakMap();
const tableOperatorPlugin = () => new Plugin(new PluginProps());
const remarkGFMPlugin = remarkPluginFactory(remarkGfm);
const tableEditPlugin = prosePluginFactory([columnResizing({}), tableOperatorPlugin(), tableEditing()]);
const tablePlugins = [remarkGFMPlugin, tableEditPlugin];
const table = [...tablePlugins, ...tableNodes];
const urlRegex = /(https?:\/\/)?www\.[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)$/;
const proseUrlPlugin = () => inputRules$1({
  rules: [
    new InputRule(urlRegex, (state, match, start4, end3) => {
      const { schema: schema2 } = state;
      const [text3] = match;
      if (!text3)
        return null;
      return state.tr.replaceWith(start4, end3, schema2.text(text3)).addMark(start4, text3.length + start4, schema2.marks.link.create({ href: text3.startsWith("www") ? `https://${text3}` : text3 }));
    })
  ]
});
const urlPlugin = prosePluginFactory(proseUrlPlugin());
const SupportedKeys = Object.assign(Object.assign(Object.assign({}, SupportedKeys$2), SupportedKeys$1), { StrikeThrough: "StrikeThrough", TaskList: "TaskList" });
const ToggleStrikeThrough = createCmdKey();
const strikeThrough = createMark((_2, utils) => {
  const id2 = "strike_through";
  return {
    id: id2,
    schema: {
      parseDOM: [
        { tag: "del" },
        { style: "text-decoration", getAttrs: (value) => value === "line-through" }
      ],
      toDOM: (mark3) => ["del", { class: utils.getClassName(mark3.attrs, "strike-through") }]
    },
    parser: {
      match: (node5) => node5.type === "delete",
      runner: (state, node5, markType) => {
        state.openMark(markType);
        state.next(node5.children);
        state.closeMark(markType);
      }
    },
    serializer: {
      match: (mark3) => mark3.type.name === id2,
      runner: (state, mark3) => {
        state.withMark(mark3, "delete");
      }
    },
    inputRules: (markType) => [
      markRule(/(?:~~)([^~]+)(?:~~)$/, markType),
      markRule(/(?:^|[^~])(~([^~]+)~)$/, markType)
    ],
    commands: (markType) => [createCmd(ToggleStrikeThrough, () => toggleMark(markType))],
    shortcuts: {
      [SupportedKeys.StrikeThrough]: createShortcut(ToggleStrikeThrough, "Mod-Alt-x")
    }
  };
});
const SplitTaskListItem = createCmdKey();
const SinkTaskListItem = createCmdKey();
const LiftTaskListItem = createCmdKey();
const TurnIntoTaskList = createCmdKey();
const taskListItem = createNode$1((options, utils) => {
  const id2 = "task_list_item";
  return {
    id: id2,
    schema: {
      group: "listItem",
      content: "paragraph block*",
      defining: true,
      attrs: {
        checked: {
          default: false
        }
      },
      parseDOM: [
        {
          tag: 'li[data-type="task-list-item"]',
          getAttrs: (dom) => {
            if (!(dom instanceof HTMLElement)) {
              throw new Error();
            }
            return { checked: dom.dataset.checked === "true" };
          }
        }
      ],
      toDOM: (node5) => [
        "li",
        {
          "data-type": "task-item",
          "data-checked": node5.attrs.checked ? "true" : "false",
          class: utils.getClassName(node5.attrs, "task-list-item")
        },
        0
      ]
    },
    parser: {
      match: ({ type, checked }) => {
        return type === "listItem" && checked !== null;
      },
      runner: (state, node5, type) => {
        state.openNode(type, { checked: node5.checked });
        state.next(node5.children);
        state.closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        state.openNode("listItem", void 0, { checked: node5.attrs.checked });
        state.next(node5.content);
        state.closeNode();
      }
    },
    inputRules: (nodeType2) => [
      wrappingInputRule(/^\s*(\[([ |x])\])\s$/, nodeType2, (match) => ({
        checked: match[match.length - 1] === "x"
      }))
    ],
    commands: (nodeType2) => [
      createCmd(SplitTaskListItem, () => splitListItem(nodeType2)),
      createCmd(SinkTaskListItem, () => sinkListItem(nodeType2)),
      createCmd(LiftTaskListItem, () => liftListItem(nodeType2)),
      createCmd(TurnIntoTaskList, () => wrapIn(nodeType2))
    ],
    shortcuts: {
      [SupportedKeys.NextListItem]: createShortcut(SplitTaskListItem, "Enter"),
      [SupportedKeys.SinkListItem]: createShortcut(SinkTaskListItem, "Mod-]"),
      [SupportedKeys.LiftListItem]: createShortcut(LiftTaskListItem, "Mod-["),
      [SupportedKeys.TaskList]: createShortcut(TurnIntoTaskList, "Mod-Alt-9")
    },
    view: (editor, nodeType2, node5, view, getPos, decorations) => {
      if (options === null || options === void 0 ? void 0 : options.view) {
        return options.view(editor, nodeType2, node5, view, getPos, decorations);
      }
      const listItem2 = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content3 = document.createElement("div");
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      const onChange = (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement))
          return;
        if (!view.editable) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { tr } = view.state;
        view.dispatch(tr.setNodeMarkup(getPos(), void 0, {
          checked: target.checked
        }));
      };
      checkbox.addEventListener("change", onChange);
      listItem2.dataset.checked = node5.attrs.checked;
      if (node5.attrs.checked) {
        checkbox.setAttribute("checked", "checked");
      }
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem2.append(checkboxWrapper, content3);
      const attributes = {
        "data-type": "task-item",
        "data-checked": node5.attrs.checked ? "true" : "false",
        class: utils.getClassName(node5.attrs, "task-list-item")
      };
      Object.entries(attributes).forEach(([key2, value]) => {
        listItem2.setAttribute(key2, value);
      });
      return {
        dom: listItem2,
        contentDOM: content3,
        update: (updatedNode) => {
          if (updatedNode.type.name !== id2)
            return false;
          listItem2.dataset.checked = updatedNode.attrs.checked;
          if (updatedNode.attrs.checked) {
            checkbox.setAttribute("checked", "checked");
          } else {
            checkbox.removeAttribute("checked");
          }
          return true;
        },
        destroy: () => {
          checkbox.removeEventListener("change", onChange);
        }
      };
    }
  };
});
const gfmNodes = AtomList.create([...commonmarkNodes, ...tableNodes, strikeThrough(), taskListItem()]);
const gfmPlugins = [...tablePlugins, ...commonmarkPlugins, urlPlugin];
[...gfmNodes, ...gfmPlugins];
Object.assign(Object.assign({}, commands), {
  ToggleStrikeThrough,
  TurnIntoTaskList,
  SinkTaskListItem,
  LiftTaskListItem,
  SplitTaskListItem
});
var ButtonAction;
(function(ButtonAction2) {
  ButtonAction2[ButtonAction2["ToggleBold"] = 0] = "ToggleBold";
  ButtonAction2[ButtonAction2["ToggleItalic"] = 1] = "ToggleItalic";
  ButtonAction2[ButtonAction2["ToggleStrike"] = 2] = "ToggleStrike";
  ButtonAction2[ButtonAction2["ToggleCode"] = 3] = "ToggleCode";
  ButtonAction2[ButtonAction2["ToggleLink"] = 4] = "ToggleLink";
})(ButtonAction || (ButtonAction = {}));
var InputAction;
(function(InputAction2) {
  InputAction2[InputAction2["ModifyLink"] = 0] = "ModifyLink";
  InputAction2[InputAction2["ModifyImage"] = 1] = "ModifyImage";
})(InputAction || (InputAction = {}));
const inputMap = (schema2, ctx) => {
  const { marks: marks3, nodes: nodes2 } = schema2;
  return {
    [InputAction.ModifyLink]: {
      display: (view) => isTextSelection(view.state) && hasMark(view.state, marks3.link),
      command: modifyLink(ctx),
      placeholder: "Input Web Link",
      update: updateLinkView
    },
    [InputAction.ModifyImage]: {
      display: (view) => Boolean(findSelectedNodeOfType(view.state.selection, nodes2.image)),
      command: modifyImage(ctx),
      placeholder: "Input Image Link",
      update: updateImageView
    }
  };
};
const buttonMap = (schema2, ctx) => {
  const { marks: marks3 } = schema2;
  return {
    [ButtonAction.ToggleBold]: createToggleIcon(ctx, "format_bold", ToggleBold, marks3.strong, marks3.code_inline),
    [ButtonAction.ToggleItalic]: createToggleIcon(ctx, "format_italic", ToggleItalic, marks3.em, marks3.code_inline),
    [ButtonAction.ToggleStrike]: createToggleIcon(ctx, "strikethrough_s", ToggleStrikeThrough, marks3.strike_through, marks3.code_inline),
    [ButtonAction.ToggleCode]: createToggleIcon(ctx, "code", ToggleInlineCode, marks3.code_inline, marks3.link),
    [ButtonAction.ToggleLink]: createToggleIcon(ctx, "link", ToggleLink, marks3.link, marks3.code_inline)
  };
};
var _ButtonManager_buttons, _ButtonManager_buttonMap, _ButtonManager_listener;
class ButtonManager {
  constructor(buttonMap2, view) {
    this.view = view;
    _ButtonManager_buttons.set(this, void 0);
    _ButtonManager_buttonMap.set(this, void 0);
    _ButtonManager_listener.set(this, (e3) => {
      const target = Object.values(__classPrivateFieldGet(this, _ButtonManager_buttonMap, "f")).find(({ $: $2 }) => e3.target instanceof Element && $2.contains(e3.target));
      if (!target)
        return;
      e3.stopPropagation();
      e3.preventDefault();
      target.command();
    });
    __classPrivateFieldSet(this, _ButtonManager_buttonMap, buttonMap2, "f");
    __classPrivateFieldSet(this, _ButtonManager_buttons, this.createTooltip(), "f");
    __classPrivateFieldGet(this, _ButtonManager_buttons, "f").addEventListener("mousedown", __classPrivateFieldGet(this, _ButtonManager_listener, "f"));
  }
  destroy() {
    __classPrivateFieldGet(this, _ButtonManager_buttons, "f").removeEventListener("mousedown", __classPrivateFieldGet(this, _ButtonManager_listener, "f"));
    __classPrivateFieldGet(this, _ButtonManager_buttons, "f").remove();
  }
  hide() {
    __classPrivateFieldGet(this, _ButtonManager_buttons, "f").classList.add("hide");
  }
  update(view) {
    const noActive = this.filterButton(view);
    if (noActive) {
      this.hide();
      return;
    }
    this.calcPos(view);
  }
  get noActive() {
    return Object.values(__classPrivateFieldGet(this, _ButtonManager_buttonMap, "f")).filter((item) => item.enable(this.view)).every(({ $: $2 }) => $2.classList.contains("hide"));
  }
  filterButton(view) {
    Object.values(__classPrivateFieldGet(this, _ButtonManager_buttonMap, "f")).filter((item) => item.enable(this.view)).forEach((item) => {
      var _a;
      const disable2 = (_a = item.disable) === null || _a === void 0 ? void 0 : _a.call(item, view);
      if (disable2) {
        item.$.classList.add("hide");
        return;
      }
      item.$.classList.remove("hide");
      const active = item.active(view);
      if (active) {
        item.$.classList.add("active");
        return;
      }
      item.$.classList.remove("active");
    });
    return this.noActive;
  }
  calcPos(view) {
    __classPrivateFieldGet(this, _ButtonManager_buttons, "f").classList.remove("hide");
    calculateTextPosition(view, __classPrivateFieldGet(this, _ButtonManager_buttons, "f"), (start4, end3, target, parent) => {
      const selectionWidth = end3.left - start4.left;
      let left = start4.left - parent.left - (target.width - selectionWidth) / 2;
      const top2 = start4.top - parent.top - target.height - 14;
      if (left < 0)
        left = 0;
      return [top2, left];
    });
  }
  createTooltip() {
    var _a;
    const div = document.createElement("div");
    div.className = "tooltip";
    Object.values(__classPrivateFieldGet(this, _ButtonManager_buttonMap, "f")).filter((item) => item.enable(this.view)).forEach(({ $: $2 }) => div.appendChild($2));
    (_a = this.view.dom.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(div);
    return div;
  }
}
_ButtonManager_buttons = new WeakMap(), _ButtonManager_buttonMap = new WeakMap(), _ButtonManager_listener = new WeakMap();
var _InputManager_input, _InputManager_button, _InputManager_inputMap, _InputManager_inputCommand;
class InputManager {
  constructor(inputMap2, view) {
    this.view = view;
    _InputManager_input.set(this, void 0);
    _InputManager_button.set(this, void 0);
    _InputManager_inputMap.set(this, void 0);
    _InputManager_inputCommand.set(this, void 0);
    this.listener = (e3) => {
      const command = __classPrivateFieldGet(this, _InputManager_inputCommand, "f");
      if (!command || __classPrivateFieldGet(this, _InputManager_button, "f").classList.contains("disable"))
        return;
      e3.stopPropagation();
      command(e3);
    };
    __classPrivateFieldSet(this, _InputManager_inputMap, inputMap2, "f");
    const [input2, button] = this.createInput();
    __classPrivateFieldSet(this, _InputManager_input, input2, "f");
    __classPrivateFieldSet(this, _InputManager_button, button, "f");
    __classPrivateFieldGet(this, _InputManager_button, "f").addEventListener("mousedown", this.listener);
  }
  destroy() {
    __classPrivateFieldGet(this, _InputManager_input, "f").removeEventListener("mousedown", this.listener);
    __classPrivateFieldGet(this, _InputManager_button, "f").remove();
  }
  hide() {
    __classPrivateFieldGet(this, _InputManager_input, "f").classList.add("hide");
    __classPrivateFieldSet(this, _InputManager_inputCommand, void 0, "f");
  }
  update(view) {
    const result2 = this.filterInput(view);
    if (!result2)
      return;
    this.calcPos(view);
  }
  calcPos(view) {
    calculateTextPosition(view, __classPrivateFieldGet(this, _InputManager_input, "f"), (start4, end3, target, parent) => {
      const selectionWidth = end3.left - start4.left;
      let left = start4.left - parent.left - (target.width - selectionWidth) / 2;
      const top2 = start4.bottom - parent.top + 14;
      if (left < 0)
        left = 0;
      return [top2, left];
    });
    return;
  }
  createInput() {
    var _a;
    const div = document.createElement("div");
    div.className = "tooltip-input";
    const input2 = document.createElement("input");
    div.appendChild(input2);
    const button = document.createElement("button");
    button.textContent = "APPLY";
    div.appendChild(button);
    (_a = this.view.dom.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(div);
    input2.addEventListener("input", (e3) => {
      if (!(e3 instanceof InputEvent)) {
        return;
      }
      const { target } = e3;
      if (!(target instanceof HTMLInputElement)) {
        return;
      }
      if (!target.value) {
        button.classList.add("disable");
        return;
      }
      if (button.classList.contains("disable")) {
        button.classList.remove("disable");
      }
    });
    return [div, button];
  }
  filterInput(view) {
    var _a;
    const target = Object.values(__classPrivateFieldGet(this, _InputManager_inputMap, "f")).find((input2) => {
      return input2.display(view);
    });
    if (!target) {
      __classPrivateFieldGet(this, _InputManager_input, "f").classList.add("hide");
      return false;
    }
    __classPrivateFieldGet(this, _InputManager_input, "f").classList.remove("hide");
    __classPrivateFieldSet(this, _InputManager_inputCommand, target.command, "f");
    (_a = __classPrivateFieldGet(this, _InputManager_input, "f").firstElementChild) === null || _a === void 0 ? void 0 : _a.setAttribute("placeholder", target.placeholder);
    target.update(view, __classPrivateFieldGet(this, _InputManager_input, "f"));
    return true;
  }
}
_InputManager_input = new WeakMap(), _InputManager_button = new WeakMap(), _InputManager_inputMap = new WeakMap(), _InputManager_inputCommand = new WeakMap();
var _SelectionMarksTooltip_buttonManager, _SelectionMarksTooltip_inputManager;
class SelectionMarksTooltip {
  constructor(buttonMap2, inputMap2, view) {
    _SelectionMarksTooltip_buttonManager.set(this, void 0);
    _SelectionMarksTooltip_inputManager.set(this, void 0);
    __classPrivateFieldSet(this, _SelectionMarksTooltip_buttonManager, new ButtonManager(buttonMap2, view), "f");
    __classPrivateFieldSet(this, _SelectionMarksTooltip_inputManager, new InputManager(inputMap2, view), "f");
    this.update(view);
  }
  update(view, prevState) {
    if (!view.editable) {
      this.hide();
      return;
    }
    const state = view.state;
    if (state.selection.empty) {
      this.hide();
      return;
    }
    const isEqualSelection = (prevState === null || prevState === void 0 ? void 0 : prevState.doc.eq(state.doc)) && prevState.selection.eq(state.selection);
    if (isEqualSelection)
      return;
    __classPrivateFieldGet(this, _SelectionMarksTooltip_buttonManager, "f").update(view);
    __classPrivateFieldGet(this, _SelectionMarksTooltip_inputManager, "f").update(view);
  }
  destroy() {
    __classPrivateFieldGet(this, _SelectionMarksTooltip_buttonManager, "f").destroy();
    __classPrivateFieldGet(this, _SelectionMarksTooltip_inputManager, "f").destroy();
  }
  hide() {
    __classPrivateFieldGet(this, _SelectionMarksTooltip_buttonManager, "f").hide();
    __classPrivateFieldGet(this, _SelectionMarksTooltip_inputManager, "f").hide();
  }
}
_SelectionMarksTooltip_buttonManager = new WeakMap(), _SelectionMarksTooltip_inputManager = new WeakMap();
const key$1 = "MILKDOWN_PLUGIN_TOOLTIP";
const selectionMarksTooltipPlugin = (ctx) => new Plugin({
  key: new PluginKey(key$1),
  view: (editorView2) => new SelectionMarksTooltip(buttonMap(editorView2.state.schema, ctx), inputMap(editorView2.state.schema, ctx), editorView2)
});
const tooltip = prosePluginFactory(selectionMarksTooltipPlugin);
const createDropdown = () => {
  const div = document.createElement("div");
  div.setAttribute("role", "listbox");
  div.setAttribute("tabindex", "-1");
  div.classList.add("slash-dropdown");
  div.classList.add("hide");
  return div;
};
const createDropdownItem = (text3, icon2, options) => {
  var _a, _b;
  const iconClassName = (_a = options === null || options === void 0 ? void 0 : options.iconClassName) !== null && _a !== void 0 ? _a : "icon material-icons material-icons-outlined";
  const textClassName = (_b = options === null || options === void 0 ? void 0 : options.textClassName) !== null && _b !== void 0 ? _b : "text";
  const div = document.createElement("div");
  div.setAttribute("role", "option");
  div.classList.add("slash-dropdown-item");
  const iconSpan = document.createElement("span");
  iconSpan.textContent = icon2;
  iconSpan.className = iconClassName;
  const textSpan = document.createElement("span");
  textSpan.textContent = text3;
  textSpan.className = textClassName;
  div.appendChild(iconSpan);
  div.appendChild(textSpan);
  return div;
};
const cleanUp = (state, dispatch3) => {
  const { selection } = state;
  const { $from } = selection;
  const tr = state.tr.deleteRange($from.start(), $from.pos);
  dispatch3 === null || dispatch3 === void 0 ? void 0 : dispatch3(tr);
  return false;
};
const cleanUpAndCreateNode = (createCommand) => (state, dispatch3, view) => {
  if (view) {
    cleanUp(state, dispatch3);
    createCommand();
  }
  return true;
};
const nodeExists = (name) => (schema2) => Boolean(schema2.nodes[name]);
const config = (ctx) => [
  {
    dom: createDropdownItem("Large Heading", "looks_one"),
    command: () => ctx.get(commandsCtx).call(TurnIntoHeading, 1),
    keyword: ["h1", "large heading"],
    enable: nodeExists("heading")
  },
  {
    dom: createDropdownItem("Medium Heading", "looks_two"),
    command: () => ctx.get(commandsCtx).call(TurnIntoHeading, 2),
    keyword: ["h2", "medium heading"],
    enable: nodeExists("heading")
  },
  {
    dom: createDropdownItem("Small Heading", "looks_3"),
    command: () => ctx.get(commandsCtx).call(TurnIntoHeading, 3),
    keyword: ["h3", "small heading"],
    enable: nodeExists("heading")
  },
  {
    dom: createDropdownItem("Bullet List", "format_list_bulleted"),
    command: () => ctx.get(commandsCtx).call(WrapInBulletList),
    keyword: ["bullet list", "ul"],
    enable: nodeExists("bullet_list")
  },
  {
    dom: createDropdownItem("Ordered List", "format_list_numbered"),
    command: () => ctx.get(commandsCtx).call(WrapInOrderedList),
    keyword: ["ordered list", "ol"],
    enable: nodeExists("ordered_list")
  },
  {
    dom: createDropdownItem("Task List", "checklist"),
    command: () => ctx.get(commandsCtx).call(TurnIntoTaskList),
    keyword: ["task list", "task"],
    enable: nodeExists("task_list_item")
  },
  {
    dom: createDropdownItem("Image", "image"),
    command: () => ctx.get(commandsCtx).call(InsertImage),
    keyword: ["image"],
    enable: nodeExists("image")
  },
  {
    dom: createDropdownItem("Quote", "format_quote"),
    command: () => ctx.get(commandsCtx).call(WrapInBlockquote),
    keyword: ["quote", "blockquote"],
    enable: nodeExists("blockquote")
  },
  {
    dom: createDropdownItem("Table", "table_chart"),
    command: () => ctx.get(commandsCtx).call(InsertTable),
    keyword: ["table"],
    enable: nodeExists("table")
  },
  {
    dom: createDropdownItem("Code Fence", "code"),
    command: () => ctx.get(commandsCtx).call(TurnIntoCodeFence),
    keyword: ["code"],
    enable: nodeExists("fence")
  },
  {
    dom: createDropdownItem("Divide Line", "horizontal_rule"),
    command: () => ctx.get(commandsCtx).call(InsertHr),
    keyword: ["divider", "hr"],
    enable: nodeExists("hr")
  }
];
function t$1(t2) {
  return typeof t2 == "object" && t2 != null && t2.nodeType === 1;
}
function e$1(t2, e3) {
  return (!e3 || t2 !== "hidden") && t2 !== "visible" && t2 !== "clip";
}
function n$1(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e$1(r2.overflowY, n2) || e$1(r2.overflowX, n2) || function(t3) {
      var e3 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e3 && (e3.clientHeight < t3.scrollHeight || e3.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r$1(t2, e3, n2, r2, i2, o3, l2, d2) {
  return o3 < t2 && l2 > e3 || o3 > t2 && l2 < e3 ? 0 : o3 <= t2 && d2 <= n2 || l2 >= e3 && d2 >= n2 ? o3 - t2 - r2 : l2 > e3 && d2 < n2 || o3 < t2 && d2 > n2 ? l2 - e3 + i2 : 0;
}
function compute(e3, i2) {
  var o3 = window, l2 = i2.scrollMode, d2 = i2.block, u2 = i2.inline, h2 = i2.boundary, a2 = i2.skipOverflowHiddenElements, c2 = typeof h2 == "function" ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t$1(e3))
    throw new TypeError("Invalid target");
  for (var f2 = document.scrollingElement || document.documentElement, s2 = [], p2 = e3; t$1(p2) && c2(p2); ) {
    if ((p2 = p2.parentElement) === f2) {
      s2.push(p2);
      break;
    }
    p2 != null && p2 === document.body && n$1(p2) && !n$1(document.documentElement) || p2 != null && n$1(p2, a2) && s2.push(p2);
  }
  for (var m2 = o3.visualViewport ? o3.visualViewport.width : innerWidth, g2 = o3.visualViewport ? o3.visualViewport.height : innerHeight, w2 = window.scrollX || pageXOffset, v2 = window.scrollY || pageYOffset, W2 = e3.getBoundingClientRect(), b2 = W2.height, H2 = W2.width, y2 = W2.top, E2 = W2.right, M2 = W2.bottom, V2 = W2.left, x2 = d2 === "start" || d2 === "nearest" ? y2 : d2 === "end" ? M2 : y2 + b2 / 2, I2 = u2 === "center" ? V2 + H2 / 2 : u2 === "end" ? E2 : V2, C2 = [], T2 = 0; T2 < s2.length; T2++) {
    var k2 = s2[T2], B2 = k2.getBoundingClientRect(), D2 = B2.height, O2 = B2.width, R2 = B2.top, X2 = B2.right, Y2 = B2.bottom, L2 = B2.left;
    if (l2 === "if-needed" && y2 >= 0 && V2 >= 0 && M2 <= g2 && E2 <= m2 && y2 >= R2 && M2 <= Y2 && V2 >= L2 && E2 <= X2)
      return C2;
    var S2 = getComputedStyle(k2), j2 = parseInt(S2.borderLeftWidth, 10), q2 = parseInt(S2.borderTopWidth, 10), z2 = parseInt(S2.borderRightWidth, 10), A2 = parseInt(S2.borderBottomWidth, 10), F2 = 0, G2 = 0, J2 = "offsetWidth" in k2 ? k2.offsetWidth - k2.clientWidth - j2 - z2 : 0, K2 = "offsetHeight" in k2 ? k2.offsetHeight - k2.clientHeight - q2 - A2 : 0;
    if (f2 === k2)
      F2 = d2 === "start" ? x2 : d2 === "end" ? x2 - g2 : d2 === "nearest" ? r$1(v2, v2 + g2, g2, q2, A2, v2 + x2, v2 + x2 + b2, b2) : x2 - g2 / 2, G2 = u2 === "start" ? I2 : u2 === "center" ? I2 - m2 / 2 : u2 === "end" ? I2 - m2 : r$1(w2, w2 + m2, m2, j2, z2, w2 + I2, w2 + I2 + H2, H2), F2 = Math.max(0, F2 + v2), G2 = Math.max(0, G2 + w2);
    else {
      F2 = d2 === "start" ? x2 - R2 - q2 : d2 === "end" ? x2 - Y2 + A2 + K2 : d2 === "nearest" ? r$1(R2, Y2, D2, q2, A2 + K2, x2, x2 + b2, b2) : x2 - (R2 + D2 / 2) + K2 / 2, G2 = u2 === "start" ? I2 - L2 - j2 : u2 === "center" ? I2 - (L2 + O2 / 2) + J2 / 2 : u2 === "end" ? I2 - X2 + z2 + J2 : r$1(L2, X2, O2, j2, z2 + J2, I2, I2 + H2, H2);
      var N2 = k2.scrollLeft, P2 = k2.scrollTop;
      x2 += P2 - (F2 = Math.max(0, Math.min(P2 + F2, k2.scrollHeight - D2 + K2))), I2 += N2 - (G2 = Math.max(0, Math.min(N2 + G2, k2.scrollWidth - O2 + J2)));
    }
    C2.push({ el: k2, top: F2, left: G2 });
  }
  return C2;
}
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el2 = _ref.el, top2 = _ref.top, left = _ref.left;
    if (el2.scroll && canSmoothScroll) {
      el2.scroll({
        top: top2,
        left,
        behavior
      });
    } else {
      el2.scrollTop = top2;
      el2.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView$1(target, options) {
  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(targetIsDetached ? [] : compute(target, options));
  }
  if (targetIsDetached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);
}
var memoizedNow;
var now = function now2() {
  if (!memoizedNow) {
    memoizedNow = "performance" in window ? performance.now.bind(performance) : Date.now;
  }
  return memoizedNow();
};
function step2(context) {
  var time = now();
  var elapsed = Math.min((time - context.startTime) / context.duration, 1);
  var value = context.ease(elapsed);
  var currentX = context.startX + (context.x - context.startX) * value;
  var currentY = context.startY + (context.y - context.startY) * value;
  context.method(currentX, currentY);
  if (currentX !== context.x || currentY !== context.y) {
    requestAnimationFrame(function() {
      return step2(context);
    });
  } else {
    context.cb();
  }
}
function smoothScroll(el2, x2, y2, duration, ease, cb) {
  if (duration === void 0) {
    duration = 600;
  }
  if (ease === void 0) {
    ease = function ease2(t2) {
      return 1 + --t2 * t2 * t2 * t2 * t2;
    };
  }
  var scrollable;
  var startX;
  var startY;
  var method;
  scrollable = el2;
  startX = el2.scrollLeft;
  startY = el2.scrollTop;
  method = function method2(x3, y3) {
    el2.scrollLeft = Math.ceil(x3);
    el2.scrollTop = Math.ceil(y3);
  };
  step2({
    scrollable,
    method,
    startTime: now(),
    startX,
    startY,
    x: x2,
    y: y2,
    duration,
    ease,
    cb
  });
}
var shouldSmoothScroll = function shouldSmoothScroll2(options) {
  return options && !options.behavior || options.behavior === "smooth";
};
function scroll$1(target, options) {
  var overrides = options || {};
  if (shouldSmoothScroll(overrides)) {
    return scrollIntoView$1(target, {
      block: overrides.block,
      inline: overrides.inline,
      scrollMode: overrides.scrollMode,
      boundary: overrides.boundary,
      behavior: function behavior(actions) {
        return Promise.all(actions.reduce(function(results, _ref) {
          var el2 = _ref.el, left = _ref.left, top2 = _ref.top;
          var startLeft = el2.scrollLeft;
          var startTop = el2.scrollTop;
          if (startLeft === left && startTop === top2) {
            return results;
          }
          return [].concat(results, [new Promise(function(resolve7) {
            return smoothScroll(el2, left, top2, overrides.duration, overrides.ease, function() {
              return resolve7({
                el: el2,
                left: [startLeft, left],
                top: [startTop, top2]
              });
            });
          })]);
        }, []));
      }
    });
  }
  return Promise.resolve(scrollIntoView$1(target, options));
}
var smoothScrollIntoView = scroll$1;
var scrollIntoView = smoothScrollIntoView;
const transformAction = (action) => ({
  keyword: action.keyword,
  $: action.dom,
  command: cleanUpAndCreateNode(action.command),
  enable: action.enable
});
var _Status_cursorStatus, _Status_filter, _View_dropdownElement, _View_wrapper, _View_status, _View_view, _View_items, _View_mouseLock, _View_handleClick, _View_handleKeydown, _View_handleMouseEnter, _View_handleMouseLeave, _View_handleMouseMove;
var CursorStatus;
(function(CursorStatus2) {
  CursorStatus2[CursorStatus2["Empty"] = 0] = "Empty";
  CursorStatus2[CursorStatus2["Slash"] = 1] = "Slash";
})(CursorStatus || (CursorStatus = {}));
class SlashPlugin {
  constructor(items) {
    this.key = new PluginKey("milkdown-prosemirror-slash-plugin");
    this.view = (editorView2) => new View(this.status, this.items, editorView2);
    this.items = items.map(transformAction);
    this.status = new Status(this.items);
    this.props = new Props(this.status);
  }
}
class Status {
  constructor(items) {
    _Status_cursorStatus.set(this, CursorStatus.Empty);
    _Status_filter.set(this, "");
    this.activeActions = items;
  }
  clearStatus() {
    __classPrivateFieldSet(this, _Status_cursorStatus, CursorStatus.Empty, "f");
    __classPrivateFieldSet(this, _Status_filter, "", "f");
  }
  setSlash(filter2 = "") {
    __classPrivateFieldSet(this, _Status_cursorStatus, CursorStatus.Slash, "f");
    __classPrivateFieldSet(this, _Status_filter, filter2, "f");
  }
  get cursorStatus() {
    return __classPrivateFieldGet(this, _Status_cursorStatus, "f");
  }
  get filter() {
    return __classPrivateFieldGet(this, _Status_filter, "f");
  }
}
_Status_cursorStatus = new WeakMap(), _Status_filter = new WeakMap();
class Props {
  constructor(status) {
    this.status = status;
    this.handleKeyDown = (_2, event) => {
      const { cursorStatus, activeActions } = this.status;
      if (cursorStatus !== CursorStatus.Slash || activeActions.length === 0) {
        return false;
      }
      if (!(event instanceof KeyboardEvent)) {
        return false;
      }
      if (!["ArrowUp", "ArrowDown", "Enter"].includes(event.key)) {
        return false;
      }
      return true;
    };
    this.decorations = (state) => {
      const { status: status2 } = this;
      const parent = findParentNode(({ type }) => type.name === "paragraph")(state.selection);
      const isTopLevel = state.selection.$from.depth === 1;
      if (!parent || parent.node.childCount > 1 || !isTopLevel) {
        status2.clearStatus();
        return;
      }
      const pos = parent.pos;
      const isEmpty = parent.node.content.size === 0;
      const isSlash = parent.node.textContent === "/" && state.selection.$from.parentOffset > 0;
      const isSearch = parent.node.textContent.startsWith("/") && state.selection.$from.parentOffset > 1;
      if (isEmpty) {
        status2.clearStatus();
        const text3 = "Type / to use the slash commands...";
        return DecorationSet$1.create(state.doc, [
          Decoration$1.node(pos, pos + parent.node.nodeSize, {
            class: "empty-node",
            "data-text": text3
          })
        ]);
      }
      if (isSlash) {
        status2.setSlash();
        const text3 = "Type to filter...";
        return DecorationSet$1.create(state.doc, [
          Decoration$1.node(pos, pos + parent.node.nodeSize, {
            class: "empty-node is-slash",
            "data-text": text3
          })
        ]);
      }
      if (isSearch) {
        status2.setSlash(parent.node.textContent.slice(1));
        return null;
      }
      status2.clearStatus();
      return null;
    };
  }
}
class View {
  constructor(status, items, editorView2) {
    _View_dropdownElement.set(this, void 0);
    _View_wrapper.set(this, void 0);
    _View_status.set(this, void 0);
    _View_view.set(this, void 0);
    _View_items.set(this, void 0);
    _View_mouseLock.set(this, void 0);
    _View_handleClick.set(this, (e3) => {
      const { target } = e3;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      const view = __classPrivateFieldGet(this, _View_view, "f");
      if (!view)
        return;
      const el2 = Object.values(__classPrivateFieldGet(this, _View_items, "f")).find(({ $: $2 }) => $2.contains(target));
      if (!el2) {
        if (__classPrivateFieldGet(this, _View_status, "f").cursorStatus === CursorStatus.Empty) {
          return;
        }
        __classPrivateFieldGet(this, _View_status, "f").clearStatus();
        __classPrivateFieldGet(this, _View_dropdownElement, "f").classList.add("hide");
        e3.stopPropagation();
        e3.preventDefault();
        return;
      }
      e3.stopPropagation();
      e3.preventDefault();
      el2.command(view.state, view.dispatch, view);
    });
    _View_handleKeydown.set(this, (e3) => {
      if (!__classPrivateFieldGet(this, _View_mouseLock, "f")) {
        __classPrivateFieldSet(this, _View_mouseLock, true, "f");
      }
      const { key: key2 } = e3;
      if (__classPrivateFieldGet(this, _View_status, "f").cursorStatus !== CursorStatus.Slash) {
        return;
      }
      if (!["ArrowDown", "ArrowUp", "Enter"].includes(key2)) {
        return;
      }
      let active = __classPrivateFieldGet(this, _View_status, "f").activeActions.findIndex((x2) => x2.$.classList.contains("active"));
      if (active < 0)
        active = 0;
      if (key2 === "ArrowDown") {
        const next = active === __classPrivateFieldGet(this, _View_status, "f").activeActions.length - 1 ? 0 : active + 1;
        __classPrivateFieldGet(this, _View_status, "f").activeActions[active].$.classList.remove("active");
        __classPrivateFieldGet(this, _View_status, "f").activeActions[next].$.classList.add("active");
        scrollIntoView(__classPrivateFieldGet(this, _View_status, "f").activeActions[next].$, {
          scrollMode: "if-needed",
          block: "nearest",
          inline: "nearest"
        });
        return;
      }
      if (key2 === "ArrowUp") {
        const next = active === 0 ? __classPrivateFieldGet(this, _View_status, "f").activeActions.length - 1 : active - 1;
        __classPrivateFieldGet(this, _View_status, "f").activeActions[active].$.classList.remove("active");
        __classPrivateFieldGet(this, _View_status, "f").activeActions[next].$.classList.add("active");
        scrollIntoView(__classPrivateFieldGet(this, _View_status, "f").activeActions[next].$, {
          scrollMode: "if-needed",
          block: "nearest",
          inline: "nearest"
        });
        return;
      }
      __classPrivateFieldGet(this, _View_status, "f").activeActions[active].command(__classPrivateFieldGet(this, _View_view, "f").state, __classPrivateFieldGet(this, _View_view, "f").dispatch, __classPrivateFieldGet(this, _View_view, "f"));
      __classPrivateFieldGet(this, _View_status, "f").activeActions[active].$.classList.remove("active");
    });
    _View_handleMouseEnter.set(this, (e3) => {
      if (__classPrivateFieldGet(this, _View_mouseLock, "f"))
        return;
      const active = __classPrivateFieldGet(this, _View_status, "f").activeActions.findIndex((x2) => x2.$.classList.contains("active"));
      if (active >= 0) {
        __classPrivateFieldGet(this, _View_status, "f").activeActions[active].$.classList.remove("active");
      }
      const { target } = e3;
      if (!(target instanceof HTMLElement))
        return;
      target.classList.add("active");
    });
    _View_handleMouseLeave.set(this, (e3) => {
      const { target } = e3;
      if (!(target instanceof HTMLElement))
        return;
      target.classList.remove("active");
    });
    _View_handleMouseMove.set(this, () => {
      if (__classPrivateFieldGet(this, _View_mouseLock, "f")) {
        __classPrivateFieldSet(this, _View_mouseLock, false, "f");
      }
    });
    __classPrivateFieldSet(this, _View_status, status, "f");
    __classPrivateFieldSet(this, _View_dropdownElement, createDropdown(), "f");
    __classPrivateFieldSet(this, _View_view, editorView2, "f");
    __classPrivateFieldSet(this, _View_mouseLock, false, "f");
    __classPrivateFieldSet(this, _View_items, items, "f");
    const { parentNode: parentNode2 } = editorView2.dom;
    if (!parentNode2) {
      throw new Error();
    }
    __classPrivateFieldSet(this, _View_wrapper, parentNode2, "f");
    parentNode2.appendChild(__classPrivateFieldGet(this, _View_dropdownElement, "f"));
    __classPrivateFieldGet(this, _View_wrapper, "f").addEventListener("mousemove", __classPrivateFieldGet(this, _View_handleMouseMove, "f"));
    items.filter((item) => item.enable(__classPrivateFieldGet(this, _View_view, "f").state.schema)).forEach(({ $: $2 }) => {
      $2.addEventListener("mouseenter", __classPrivateFieldGet(this, _View_handleMouseEnter, "f"));
      $2.addEventListener("mouseleave", __classPrivateFieldGet(this, _View_handleMouseLeave, "f"));
      __classPrivateFieldGet(this, _View_dropdownElement, "f").appendChild($2);
    });
    __classPrivateFieldGet(this, _View_wrapper, "f").addEventListener("mousedown", __classPrivateFieldGet(this, _View_handleClick, "f"));
    __classPrivateFieldGet(this, _View_wrapper, "f").addEventListener("keydown", __classPrivateFieldGet(this, _View_handleKeydown, "f"));
  }
  update(view) {
    const show = this.renderDropdown();
    if (!show) {
      return;
    }
    this.calculatePosition(view);
  }
  destroy() {
    __classPrivateFieldGet(this, _View_wrapper, "f").removeEventListener("mousedown", __classPrivateFieldGet(this, _View_handleClick, "f"));
    __classPrivateFieldGet(this, _View_wrapper, "f").removeEventListener("keydown", __classPrivateFieldGet(this, _View_handleKeydown, "f"));
    __classPrivateFieldGet(this, _View_dropdownElement, "f").remove();
  }
  renderDropdown() {
    const { cursorStatus, filter: filter2 } = __classPrivateFieldGet(this, _View_status, "f");
    if (cursorStatus !== CursorStatus.Slash) {
      __classPrivateFieldGet(this, _View_dropdownElement, "f").classList.add("hide");
      return false;
    }
    const activeList = __classPrivateFieldGet(this, _View_items, "f").filter((item) => {
      item.$.classList.remove("active");
      const result2 = item.keyword.some((key2) => key2.includes(filter2.toLocaleLowerCase()));
      if (result2) {
        return true;
      }
      item.$.classList.add("hide");
      return false;
    }).map((item) => {
      item.$.classList.remove("hide");
      return item;
    });
    __classPrivateFieldGet(this, _View_status, "f").activeActions = activeList;
    if (activeList.length === 0) {
      __classPrivateFieldGet(this, _View_dropdownElement, "f").classList.add("hide");
      return false;
    }
    activeList[0].$.classList.add("active");
    __classPrivateFieldGet(this, _View_dropdownElement, "f").classList.remove("hide");
    return true;
  }
  calculatePosition(view) {
    calculateNodePosition$1(view, __classPrivateFieldGet(this, _View_dropdownElement, "f"), (selected, target, parent) => {
      let left = selected.left - parent.left;
      let top2 = selected.bottom - parent.top + 14;
      if (left < 0) {
        left = 0;
      }
      if (window.innerHeight - selected.bottom < target.height) {
        top2 = selected.top - parent.top - target.height - 14;
      }
      return [top2, left];
    });
  }
}
_View_dropdownElement = new WeakMap(), _View_wrapper = new WeakMap(), _View_status = new WeakMap(), _View_view = new WeakMap(), _View_items = new WeakMap(), _View_mouseLock = new WeakMap(), _View_handleClick = new WeakMap(), _View_handleKeydown = new WeakMap(), _View_handleMouseEnter = new WeakMap(), _View_handleMouseLeave = new WeakMap(), _View_handleMouseMove = new WeakMap();
const slashPlugin = (items) => new Plugin(new SlashPlugin(items));
const slashCtx = createCtx(() => []);
const slash = (pre) => {
  pre.inject(slashCtx, config);
  return (ctx) => __awaiter(void 0, void 0, void 0, function* () {
    yield ctx.wait(CommandsReady);
    const config2 = ctx.get(slashCtx);
    ctx.update(prosePluginsCtx, (prev) => prev.concat([slashPlugin(config2(ctx))].flat()));
  });
};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$7 = freeGlobal || freeSelf || Function("return this")();
var _root = root$7;
var root$6 = _root;
var Symbol$4 = root$6.Symbol;
var _Symbol = Symbol$4;
function copyArray$1(source, array) {
  var index3 = -1, length = source.length;
  array || (array = Array(length));
  while (++index3 < length) {
    array[index3] = source[index3];
  }
  return array;
}
var _copyArray = copyArray$1;
var Symbol$3 = _Symbol;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
var nativeObjectToString$1 = objectProto$6.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$4.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result2 = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result2;
}
var _getRawTag = getRawTag$1;
var objectProto$5 = Object.prototype;
var nativeObjectToString = objectProto$5.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$2;
var baseGetTag$4 = _baseGetTag, isObject$1 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$5 = _root;
var coreJsData$1 = root$5["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$4 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key2) {
  return object == null ? void 0 : object[key2];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$5(object, key2) {
  var value = getValue(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$5;
var getNative$4 = _getNative, root$4 = _root;
var DataView$1 = getNative$4(root$4, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$3 = _root;
var Map$2 = getNative$3(root$3, "Map");
var _Map = Map$2;
var getNative$2 = _getNative, root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative, root = _root;
var WeakMap$2 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag$3 = _baseGetTag, toSource = _toSource;
var mapTag$2 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$2 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag$3;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag$1(new Map$1()) != mapTag$2 || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag$2 || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag$1) {
  getTag$1 = function(value) {
    var result2 = baseGetTag$3(value), Ctor = result2 == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$2;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result2;
  };
}
var _getTag = getTag$1;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;
var isFunction = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$2(value) {
  return value != null && isLength$1(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$2;
var isArray$2 = Array.isArray;
var isArray_1 = isArray$2;
function isObjectLike$4(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$4;
var baseGetTag$2 = _baseGetTag, isArray$1 = isArray_1, isObjectLike$3 = isObjectLike_1;
var stringTag$1 = "[object String]";
function isString$1(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$3(value) && baseGetTag$2(value) == stringTag$1;
}
var isString_1 = isString$1;
function iteratorToArray$1(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var _iteratorToArray = iteratorToArray$1;
function mapToArray$1(map21) {
  var index3 = -1, result2 = Array(map21.size);
  map21.forEach(function(value, key2) {
    result2[++index3] = [key2, value];
  });
  return result2;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set3) {
  var index3 = -1, result2 = Array(set3.size);
  set3.forEach(function(value) {
    result2[++index3] = value;
  });
  return result2;
}
var _setToArray = setToArray$1;
function asciiToArray$1(string2) {
  return string2.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$1(string2) {
  return reHasUnicode.test(string2);
}
var _hasUnicode = hasUnicode$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string2) {
  return string2.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string2) {
  return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
}
var _stringToArray = stringToArray$1;
function arrayMap$1(array, iteratee) {
  var index3 = -1, length = array == null ? 0 : array.length, result2 = Array(length);
  while (++index3 < length) {
    result2[index3] = iteratee(array[index3], index3, array);
  }
  return result2;
}
var _arrayMap = arrayMap$1;
var arrayMap = _arrayMap;
function baseValues$1(object, props) {
  return arrayMap(props, function(key2) {
    return object[key2];
  });
}
var _baseValues = baseValues$1;
function baseTimes$1(n2, iteratee) {
  var index3 = -1, result2 = Array(n2);
  while (++index3 < n2) {
    result2[index3] = iteratee(index3);
  }
  return result2;
}
var _baseTimes = baseTimes$1;
var baseGetTag$1 = _baseGetTag, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$2(value) && baseGetTag$1(value) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$1 = isObjectLike_1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$1(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$1 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer3;
})(isBuffer$1, isBuffer$1.exports);
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$1;
var baseGetTag = _baseGetTag, isLength = isLength_1, isObjectLike = isObjectLike_1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e3) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$1;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray2 = isArray_1, isBuffer2 = isBuffer$1.exports, isIndex = _isIndex, isTypedArray = isTypedArray_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$1.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result2.push(key2);
    }
  }
  return result2;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$1 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$1;
  return value === proto2;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result2 = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
      result2.push(key2);
    }
  }
  return result2;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$2(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$2;
var baseValues = _baseValues, keys$1 = keys_1;
function values$1(object) {
  return object == null ? [] : baseValues(object, keys$1(object));
}
var values_1 = values$1;
var Symbol$1 = _Symbol, copyArray = _copyArray, getTag = _getTag, isArrayLike = isArrayLike_1, isString = isString_1, iteratorToArray = _iteratorToArray, mapToArray = _mapToArray, setToArray = _setToArray, stringToArray = _stringToArray, values = values_1;
var mapTag = "[object Map]", setTag = "[object Set]";
var symIterator = Symbol$1 ? Symbol$1.iterator : void 0;
function toArray$1(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]());
  }
  var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
  return func(value);
}
var toArray_1 = toArray$1;
const umbrella_with_rain_drops = "\u2614";
const coffee = "\u2615";
const aries = "\u2648";
const taurus = "\u2649";
const sagittarius = "\u2650";
const capricorn = "\u2651";
const aquarius = "\u2652";
const pisces = "\u2653";
const anchor = "\u2693";
const white_check_mark = "\u2705";
const sparkles = "\u2728";
const question = "\u2753";
const grey_question = "\u2754";
const grey_exclamation = "\u2755";
const exclamation = "\u2757";
const heavy_exclamation_mark = "\u2757";
const heavy_plus_sign = "\u2795";
const heavy_minus_sign = "\u2796";
const heavy_division_sign = "\u2797";
const hash = "#\uFE0F\u20E3";
const keycap_star = "*\uFE0F\u20E3";
const zero = "0\uFE0F\u20E3";
const one = "1\uFE0F\u20E3";
const two = "2\uFE0F\u20E3";
const three = "3\uFE0F\u20E3";
const four = "4\uFE0F\u20E3";
const five = "5\uFE0F\u20E3";
const six = "6\uFE0F\u20E3";
const seven = "7\uFE0F\u20E3";
const eight = "8\uFE0F\u20E3";
const nine = "9\uFE0F\u20E3";
const copyright = "\xA9\uFE0F";
const registered = "\xAE\uFE0F";
const mahjong = "\u{1F004}";
const black_joker = "\u{1F0CF}";
const a$1 = "\u{1F170}\uFE0F";
const b$1 = "\u{1F171}\uFE0F";
const o2 = "\u{1F17E}\uFE0F";
const parking = "\u{1F17F}\uFE0F";
const ab = "\u{1F18E}";
const cl = "\u{1F191}";
const cool = "\u{1F192}";
const free = "\u{1F193}";
const id = "\u{1F194}";
const ng = "\u{1F196}";
const ok2 = "\u{1F197}";
const sos = "\u{1F198}";
const up3 = "\u{1F199}";
const vs = "\u{1F19A}";
const cn = "\u{1F1E8}\u{1F1F3}";
const de$1 = "\u{1F1E9}\u{1F1EA}";
const es = "\u{1F1EA}\u{1F1F8}";
const fr = "\u{1F1EB}\u{1F1F7}";
const gb = "\u{1F1EC}\u{1F1E7}";
const uk = "\u{1F1EC}\u{1F1E7}";
const it = "\u{1F1EE}\u{1F1F9}";
const jp = "\u{1F1EF}\u{1F1F5}";
const kr = "\u{1F1F0}\u{1F1F7}";
const ru = "\u{1F1F7}\u{1F1FA}";
const us = "\u{1F1FA}\u{1F1F8}";
const koko = "\u{1F201}";
const sa = "\u{1F202}\uFE0F";
const u7121 = "\u{1F21A}";
const u6307 = "\u{1F22F}";
const u7981 = "\u{1F232}";
const u7a7a = "\u{1F233}";
const u5408 = "\u{1F234}";
const u6e80 = "\u{1F235}";
const u6709 = "\u{1F236}";
const u6708 = "\u{1F237}\uFE0F";
const u7533 = "\u{1F238}";
const u5272 = "\u{1F239}";
const u55b6 = "\u{1F23A}";
const ideograph_advantage = "\u{1F250}";
const accept = "\u{1F251}";
const cyclone = "\u{1F300}";
const foggy = "\u{1F301}";
const closed_umbrella = "\u{1F302}";
const night_with_stars = "\u{1F303}";
const sunrise_over_mountains = "\u{1F304}";
const sunrise = "\u{1F305}";
const city_sunset = "\u{1F306}";
const city_sunrise = "\u{1F307}";
const rainbow = "\u{1F308}";
const bridge_at_night = "\u{1F309}";
const ocean = "\u{1F30A}";
const volcano = "\u{1F30B}";
const milky_way = "\u{1F30C}";
const earth_africa = "\u{1F30D}";
const earth_americas = "\u{1F30E}";
const earth_asia = "\u{1F30F}";
const globe_with_meridians = "\u{1F310}";
const new_moon = "\u{1F311}";
const waxing_crescent_moon = "\u{1F312}";
const first_quarter_moon = "\u{1F313}";
const moon = "\u{1F314}";
const waxing_gibbous_moon = "\u{1F314}";
const full_moon = "\u{1F315}";
const waning_gibbous_moon = "\u{1F316}";
const last_quarter_moon = "\u{1F317}";
const waning_crescent_moon = "\u{1F318}";
const crescent_moon = "\u{1F319}";
const new_moon_with_face = "\u{1F31A}";
const first_quarter_moon_with_face = "\u{1F31B}";
const last_quarter_moon_with_face = "\u{1F31C}";
const full_moon_with_face = "\u{1F31D}";
const sun_with_face = "\u{1F31E}";
const star2 = "\u{1F31F}";
const stars = "\u{1F320}";
const thermometer = "\u{1F321}\uFE0F";
const mostly_sunny = "\u{1F324}\uFE0F";
const sun_small_cloud = "\u{1F324}\uFE0F";
const barely_sunny = "\u{1F325}\uFE0F";
const sun_behind_cloud = "\u{1F325}\uFE0F";
const partly_sunny_rain = "\u{1F326}\uFE0F";
const sun_behind_rain_cloud = "\u{1F326}\uFE0F";
const rain_cloud = "\u{1F327}\uFE0F";
const snow_cloud = "\u{1F328}\uFE0F";
const lightning = "\u{1F329}\uFE0F";
const lightning_cloud = "\u{1F329}\uFE0F";
const tornado = "\u{1F32A}\uFE0F";
const tornado_cloud = "\u{1F32A}\uFE0F";
const fog = "\u{1F32B}\uFE0F";
const wind_blowing_face = "\u{1F32C}\uFE0F";
const hotdog = "\u{1F32D}";
const taco = "\u{1F32E}";
const burrito = "\u{1F32F}";
const chestnut = "\u{1F330}";
const seedling = "\u{1F331}";
const evergreen_tree = "\u{1F332}";
const deciduous_tree = "\u{1F333}";
const palm_tree = "\u{1F334}";
const cactus = "\u{1F335}";
const hot_pepper = "\u{1F336}\uFE0F";
const tulip = "\u{1F337}";
const cherry_blossom = "\u{1F338}";
const rose = "\u{1F339}";
const hibiscus = "\u{1F33A}";
const sunflower = "\u{1F33B}";
const blossom = "\u{1F33C}";
const corn = "\u{1F33D}";
const ear_of_rice = "\u{1F33E}";
const herb = "\u{1F33F}";
const four_leaf_clover = "\u{1F340}";
const maple_leaf = "\u{1F341}";
const fallen_leaf = "\u{1F342}";
const leaves = "\u{1F343}";
const mushroom = "\u{1F344}";
const tomato = "\u{1F345}";
const eggplant = "\u{1F346}";
const grapes = "\u{1F347}";
const melon = "\u{1F348}";
const watermelon = "\u{1F349}";
const tangerine = "\u{1F34A}";
const lemon = "\u{1F34B}";
const banana = "\u{1F34C}";
const pineapple = "\u{1F34D}";
const apple = "\u{1F34E}";
const green_apple = "\u{1F34F}";
const pear = "\u{1F350}";
const peach = "\u{1F351}";
const cherries = "\u{1F352}";
const strawberry = "\u{1F353}";
const hamburger = "\u{1F354}";
const pizza = "\u{1F355}";
const meat_on_bone = "\u{1F356}";
const poultry_leg = "\u{1F357}";
const rice_cracker = "\u{1F358}";
const rice_ball = "\u{1F359}";
const rice = "\u{1F35A}";
const curry = "\u{1F35B}";
const ramen = "\u{1F35C}";
const spaghetti = "\u{1F35D}";
const bread = "\u{1F35E}";
const fries = "\u{1F35F}";
const sweet_potato = "\u{1F360}";
const dango = "\u{1F361}";
const oden = "\u{1F362}";
const sushi = "\u{1F363}";
const fried_shrimp = "\u{1F364}";
const fish_cake = "\u{1F365}";
const icecream = "\u{1F366}";
const shaved_ice = "\u{1F367}";
const ice_cream = "\u{1F368}";
const doughnut = "\u{1F369}";
const cookie = "\u{1F36A}";
const chocolate_bar = "\u{1F36B}";
const candy = "\u{1F36C}";
const lollipop = "\u{1F36D}";
const custard = "\u{1F36E}";
const honey_pot = "\u{1F36F}";
const cake = "\u{1F370}";
const bento = "\u{1F371}";
const stew = "\u{1F372}";
const fried_egg = "\u{1F373}";
const cooking = "\u{1F373}";
const fork_and_knife = "\u{1F374}";
const tea = "\u{1F375}";
const sake = "\u{1F376}";
const wine_glass = "\u{1F377}";
const cocktail = "\u{1F378}";
const tropical_drink = "\u{1F379}";
const beer = "\u{1F37A}";
const beers = "\u{1F37B}";
const baby_bottle = "\u{1F37C}";
const knife_fork_plate = "\u{1F37D}\uFE0F";
const champagne = "\u{1F37E}";
const popcorn = "\u{1F37F}";
const ribbon = "\u{1F380}";
const gift = "\u{1F381}";
const birthday = "\u{1F382}";
const jack_o_lantern = "\u{1F383}";
const christmas_tree = "\u{1F384}";
const santa = "\u{1F385}";
const fireworks = "\u{1F386}";
const sparkler = "\u{1F387}";
const balloon = "\u{1F388}";
const tada = "\u{1F389}";
const confetti_ball = "\u{1F38A}";
const tanabata_tree = "\u{1F38B}";
const crossed_flags = "\u{1F38C}";
const bamboo = "\u{1F38D}";
const dolls = "\u{1F38E}";
const flags = "\u{1F38F}";
const wind_chime = "\u{1F390}";
const rice_scene = "\u{1F391}";
const school_satchel = "\u{1F392}";
const mortar_board = "\u{1F393}";
const medal = "\u{1F396}\uFE0F";
const reminder_ribbon = "\u{1F397}\uFE0F";
const studio_microphone = "\u{1F399}\uFE0F";
const level_slider = "\u{1F39A}\uFE0F";
const control_knobs = "\u{1F39B}\uFE0F";
const film_frames = "\u{1F39E}\uFE0F";
const admission_tickets = "\u{1F39F}\uFE0F";
const carousel_horse = "\u{1F3A0}";
const ferris_wheel = "\u{1F3A1}";
const roller_coaster = "\u{1F3A2}";
const fishing_pole_and_fish = "\u{1F3A3}";
const microphone = "\u{1F3A4}";
const movie_camera = "\u{1F3A5}";
const cinema = "\u{1F3A6}";
const headphones = "\u{1F3A7}";
const art = "\u{1F3A8}";
const tophat = "\u{1F3A9}";
const circus_tent = "\u{1F3AA}";
const ticket = "\u{1F3AB}";
const clapper = "\u{1F3AC}";
const performing_arts = "\u{1F3AD}";
const video_game = "\u{1F3AE}";
const dart = "\u{1F3AF}";
const slot_machine = "\u{1F3B0}";
const game_die = "\u{1F3B2}";
const bowling = "\u{1F3B3}";
const flower_playing_cards = "\u{1F3B4}";
const musical_note = "\u{1F3B5}";
const notes = "\u{1F3B6}";
const saxophone = "\u{1F3B7}";
const guitar = "\u{1F3B8}";
const musical_keyboard = "\u{1F3B9}";
const trumpet = "\u{1F3BA}";
const violin = "\u{1F3BB}";
const musical_score = "\u{1F3BC}";
const running_shirt_with_sash = "\u{1F3BD}";
const tennis = "\u{1F3BE}";
const ski = "\u{1F3BF}";
const basketball = "\u{1F3C0}";
const checkered_flag = "\u{1F3C1}";
const snowboarder = "\u{1F3C2}";
const runner = "\u{1F3C3}\u200D\u2642\uFE0F";
const running = "\u{1F3C3}\u200D\u2642\uFE0F";
const surfer = "\u{1F3C4}\u200D\u2642\uFE0F";
const sports_medal = "\u{1F3C5}";
const trophy = "\u{1F3C6}";
const horse_racing = "\u{1F3C7}";
const football = "\u{1F3C8}";
const rugby_football = "\u{1F3C9}";
const swimmer = "\u{1F3CA}\u200D\u2642\uFE0F";
const weight_lifter = "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F";
const golfer = "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F";
const racing_motorcycle = "\u{1F3CD}\uFE0F";
const racing_car = "\u{1F3CE}\uFE0F";
const cricket_bat_and_ball = "\u{1F3CF}";
const volleyball = "\u{1F3D0}";
const field_hockey_stick_and_ball = "\u{1F3D1}";
const ice_hockey_stick_and_puck = "\u{1F3D2}";
const table_tennis_paddle_and_ball = "\u{1F3D3}";
const snow_capped_mountain = "\u{1F3D4}\uFE0F";
const camping = "\u{1F3D5}\uFE0F";
const beach_with_umbrella = "\u{1F3D6}\uFE0F";
const building_construction = "\u{1F3D7}\uFE0F";
const house_buildings = "\u{1F3D8}\uFE0F";
const cityscape = "\u{1F3D9}\uFE0F";
const derelict_house_building = "\u{1F3DA}\uFE0F";
const classical_building = "\u{1F3DB}\uFE0F";
const desert = "\u{1F3DC}\uFE0F";
const desert_island = "\u{1F3DD}\uFE0F";
const national_park = "\u{1F3DE}\uFE0F";
const stadium = "\u{1F3DF}\uFE0F";
const house = "\u{1F3E0}";
const house_with_garden = "\u{1F3E1}";
const office = "\u{1F3E2}";
const post_office = "\u{1F3E3}";
const european_post_office = "\u{1F3E4}";
const hospital = "\u{1F3E5}";
const bank = "\u{1F3E6}";
const atm = "\u{1F3E7}";
const hotel = "\u{1F3E8}";
const love_hotel = "\u{1F3E9}";
const convenience_store = "\u{1F3EA}";
const school = "\u{1F3EB}";
const department_store = "\u{1F3EC}";
const factory = "\u{1F3ED}";
const izakaya_lantern = "\u{1F3EE}";
const lantern = "\u{1F3EE}";
const japanese_castle = "\u{1F3EF}";
const european_castle = "\u{1F3F0}";
const transgender_flag = "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F";
const waving_white_flag = "\u{1F3F3}\uFE0F";
const pirate_flag = "\u{1F3F4}\u200D\u2620\uFE0F";
const waving_black_flag = "\u{1F3F4}";
const rosette = "\u{1F3F5}\uFE0F";
const label = "\u{1F3F7}\uFE0F";
const badminton_racquet_and_shuttlecock = "\u{1F3F8}";
const bow_and_arrow = "\u{1F3F9}";
const amphora = "\u{1F3FA}";
const rat = "\u{1F400}";
const mouse2 = "\u{1F401}";
const ox = "\u{1F402}";
const water_buffalo = "\u{1F403}";
const cow2 = "\u{1F404}";
const tiger2 = "\u{1F405}";
const leopard = "\u{1F406}";
const rabbit2 = "\u{1F407}";
const black_cat = "\u{1F408}\u200D\u2B1B";
const cat2 = "\u{1F408}";
const dragon = "\u{1F409}";
const crocodile = "\u{1F40A}";
const whale2 = "\u{1F40B}";
const snail = "\u{1F40C}";
const snake = "\u{1F40D}";
const racehorse = "\u{1F40E}";
const ram = "\u{1F40F}";
const goat = "\u{1F410}";
const sheep = "\u{1F411}";
const monkey = "\u{1F412}";
const rooster = "\u{1F413}";
const chicken = "\u{1F414}";
const service_dog = "\u{1F415}\u200D\u{1F9BA}";
const dog2 = "\u{1F415}";
const pig2 = "\u{1F416}";
const boar = "\u{1F417}";
const elephant = "\u{1F418}";
const octopus = "\u{1F419}";
const shell = "\u{1F41A}";
const bug = "\u{1F41B}";
const ant = "\u{1F41C}";
const bee = "\u{1F41D}";
const honeybee = "\u{1F41D}";
const ladybug = "\u{1F41E}";
const lady_beetle = "\u{1F41E}";
const fish = "\u{1F41F}";
const tropical_fish = "\u{1F420}";
const blowfish = "\u{1F421}";
const turtle = "\u{1F422}";
const hatching_chick = "\u{1F423}";
const baby_chick = "\u{1F424}";
const hatched_chick = "\u{1F425}";
const bird = "\u{1F426}";
const penguin = "\u{1F427}";
const koala = "\u{1F428}";
const poodle = "\u{1F429}";
const dromedary_camel = "\u{1F42A}";
const camel = "\u{1F42B}";
const dolphin = "\u{1F42C}";
const flipper = "\u{1F42C}";
const mouse = "\u{1F42D}";
const cow = "\u{1F42E}";
const tiger = "\u{1F42F}";
const rabbit = "\u{1F430}";
const cat = "\u{1F431}";
const dragon_face = "\u{1F432}";
const whale = "\u{1F433}";
const horse = "\u{1F434}";
const monkey_face = "\u{1F435}";
const dog = "\u{1F436}";
const pig = "\u{1F437}";
const frog = "\u{1F438}";
const hamster = "\u{1F439}";
const wolf = "\u{1F43A}";
const polar_bear = "\u{1F43B}\u200D\u2744\uFE0F";
const bear = "\u{1F43B}";
const panda_face = "\u{1F43C}";
const pig_nose = "\u{1F43D}";
const feet = "\u{1F43E}";
const paw_prints = "\u{1F43E}";
const chipmunk = "\u{1F43F}\uFE0F";
const eyes = "\u{1F440}";
const eye = "\u{1F441}\uFE0F";
const ear = "\u{1F442}";
const nose = "\u{1F443}";
const lips = "\u{1F444}";
const tongue = "\u{1F445}";
const point_up_2 = "\u{1F446}";
const point_down = "\u{1F447}";
const point_left = "\u{1F448}";
const point_right = "\u{1F449}";
const facepunch = "\u{1F44A}";
const punch = "\u{1F44A}";
const wave = "\u{1F44B}";
const ok_hand = "\u{1F44C}";
const thumbsup = "\u{1F44D}";
const thumbsdown = "\u{1F44E}";
const clap = "\u{1F44F}";
const open_hands = "\u{1F450}";
const crown = "\u{1F451}";
const womans_hat = "\u{1F452}";
const eyeglasses = "\u{1F453}";
const necktie = "\u{1F454}";
const shirt = "\u{1F455}";
const tshirt = "\u{1F455}";
const jeans = "\u{1F456}";
const dress = "\u{1F457}";
const kimono = "\u{1F458}";
const bikini = "\u{1F459}";
const womans_clothes = "\u{1F45A}";
const purse = "\u{1F45B}";
const handbag = "\u{1F45C}";
const pouch = "\u{1F45D}";
const mans_shoe = "\u{1F45E}";
const shoe = "\u{1F45E}";
const athletic_shoe = "\u{1F45F}";
const high_heel = "\u{1F460}";
const sandal = "\u{1F461}";
const boot = "\u{1F462}";
const footprints = "\u{1F463}";
const bust_in_silhouette = "\u{1F464}";
const busts_in_silhouette = "\u{1F465}";
const boy = "\u{1F466}";
const girl = "\u{1F467}";
const man_feeding_baby = "\u{1F468}\u200D\u{1F37C}";
const family = "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}";
const man_with_probing_cane = "\u{1F468}\u200D\u{1F9AF}";
const red_haired_man = "\u{1F468}\u200D\u{1F9B0}";
const curly_haired_man = "\u{1F468}\u200D\u{1F9B1}";
const bald_man = "\u{1F468}\u200D\u{1F9B2}";
const white_haired_man = "\u{1F468}\u200D\u{1F9B3}";
const man_in_motorized_wheelchair = "\u{1F468}\u200D\u{1F9BC}";
const man_in_manual_wheelchair = "\u{1F468}\u200D\u{1F9BD}";
const man = "\u{1F468}";
const woman_feeding_baby = "\u{1F469}\u200D\u{1F37C}";
const woman_with_probing_cane = "\u{1F469}\u200D\u{1F9AF}";
const red_haired_woman = "\u{1F469}\u200D\u{1F9B0}";
const curly_haired_woman = "\u{1F469}\u200D\u{1F9B1}";
const bald_woman = "\u{1F469}\u200D\u{1F9B2}";
const white_haired_woman = "\u{1F469}\u200D\u{1F9B3}";
const woman_in_motorized_wheelchair = "\u{1F469}\u200D\u{1F9BC}";
const woman_in_manual_wheelchair = "\u{1F469}\u200D\u{1F9BD}";
const woman = "\u{1F469}";
const man_and_woman_holding_hands = "\u{1F46B}";
const woman_and_man_holding_hands = "\u{1F46B}";
const couple = "\u{1F46B}";
const two_men_holding_hands = "\u{1F46C}";
const men_holding_hands = "\u{1F46C}";
const two_women_holding_hands = "\u{1F46D}";
const women_holding_hands = "\u{1F46D}";
const cop = "\u{1F46E}\u200D\u2642\uFE0F";
const dancers = "\u{1F46F}\u200D\u2640\uFE0F";
const woman_with_veil = "\u{1F470}\u200D\u2640\uFE0F";
const man_with_veil = "\u{1F470}\u200D\u2642\uFE0F";
const bride_with_veil = "\u{1F470}";
const person_with_blond_hair = "\u{1F471}\u200D\u2642\uFE0F";
const man_with_gua_pi_mao = "\u{1F472}";
const man_with_turban = "\u{1F473}\u200D\u2642\uFE0F";
const older_man = "\u{1F474}";
const older_woman = "\u{1F475}";
const baby = "\u{1F476}";
const construction_worker = "\u{1F477}\u200D\u2642\uFE0F";
const princess = "\u{1F478}";
const japanese_ogre = "\u{1F479}";
const japanese_goblin = "\u{1F47A}";
const ghost = "\u{1F47B}";
const angel = "\u{1F47C}";
const alien = "\u{1F47D}";
const space_invader = "\u{1F47E}";
const imp = "\u{1F47F}";
const skull = "\u{1F480}";
const information_desk_person = "\u{1F481}\u200D\u2640\uFE0F";
const guardsman = "\u{1F482}\u200D\u2642\uFE0F";
const dancer = "\u{1F483}";
const lipstick = "\u{1F484}";
const nail_care = "\u{1F485}";
const massage = "\u{1F486}\u200D\u2640\uFE0F";
const haircut = "\u{1F487}\u200D\u2640\uFE0F";
const barber = "\u{1F488}";
const syringe = "\u{1F489}";
const pill = "\u{1F48A}";
const kiss = "\u{1F48B}";
const love_letter = "\u{1F48C}";
const ring = "\u{1F48D}";
const gem = "\u{1F48E}";
const couplekiss = "\u{1F48F}";
const bouquet = "\u{1F490}";
const couple_with_heart = "\u{1F491}";
const wedding = "\u{1F492}";
const heartbeat = "\u{1F493}";
const broken_heart = "\u{1F494}";
const two_hearts = "\u{1F495}";
const sparkling_heart = "\u{1F496}";
const heartpulse = "\u{1F497}";
const cupid = "\u{1F498}";
const blue_heart = "\u{1F499}";
const green_heart = "\u{1F49A}";
const yellow_heart = "\u{1F49B}";
const purple_heart = "\u{1F49C}";
const gift_heart = "\u{1F49D}";
const revolving_hearts = "\u{1F49E}";
const heart_decoration = "\u{1F49F}";
const diamond_shape_with_a_dot_inside = "\u{1F4A0}";
const bulb = "\u{1F4A1}";
const anger = "\u{1F4A2}";
const bomb = "\u{1F4A3}";
const zzz = "\u{1F4A4}";
const boom = "\u{1F4A5}";
const collision = "\u{1F4A5}";
const sweat_drops = "\u{1F4A6}";
const droplet = "\u{1F4A7}";
const dash = "\u{1F4A8}";
const hankey = "\u{1F4A9}";
const poop = "\u{1F4A9}";
const shit = "\u{1F4A9}";
const muscle = "\u{1F4AA}";
const dizzy = "\u{1F4AB}";
const speech_balloon = "\u{1F4AC}";
const thought_balloon = "\u{1F4AD}";
const white_flower = "\u{1F4AE}";
const moneybag = "\u{1F4B0}";
const currency_exchange = "\u{1F4B1}";
const heavy_dollar_sign = "\u{1F4B2}";
const credit_card = "\u{1F4B3}";
const yen = "\u{1F4B4}";
const dollar = "\u{1F4B5}";
const euro = "\u{1F4B6}";
const pound = "\u{1F4B7}";
const money_with_wings = "\u{1F4B8}";
const chart = "\u{1F4B9}";
const seat = "\u{1F4BA}";
const computer = "\u{1F4BB}";
const briefcase = "\u{1F4BC}";
const minidisc = "\u{1F4BD}";
const floppy_disk = "\u{1F4BE}";
const cd = "\u{1F4BF}";
const dvd = "\u{1F4C0}";
const file_folder = "\u{1F4C1}";
const open_file_folder = "\u{1F4C2}";
const page_with_curl = "\u{1F4C3}";
const page_facing_up = "\u{1F4C4}";
const date = "\u{1F4C5}";
const calendar = "\u{1F4C6}";
const card_index = "\u{1F4C7}";
const chart_with_upwards_trend = "\u{1F4C8}";
const chart_with_downwards_trend = "\u{1F4C9}";
const bar_chart = "\u{1F4CA}";
const clipboard = "\u{1F4CB}";
const pushpin = "\u{1F4CC}";
const round_pushpin = "\u{1F4CD}";
const paperclip = "\u{1F4CE}";
const straight_ruler = "\u{1F4CF}";
const triangular_ruler = "\u{1F4D0}";
const bookmark_tabs = "\u{1F4D1}";
const ledger = "\u{1F4D2}";
const notebook = "\u{1F4D3}";
const notebook_with_decorative_cover = "\u{1F4D4}";
const closed_book = "\u{1F4D5}";
const book = "\u{1F4D6}";
const open_book = "\u{1F4D6}";
const green_book = "\u{1F4D7}";
const blue_book = "\u{1F4D8}";
const orange_book = "\u{1F4D9}";
const books = "\u{1F4DA}";
const name_badge = "\u{1F4DB}";
const scroll = "\u{1F4DC}";
const memo = "\u{1F4DD}";
const pencil = "\u{1F4DD}";
const telephone_receiver = "\u{1F4DE}";
const pager = "\u{1F4DF}";
const fax = "\u{1F4E0}";
const satellite_antenna = "\u{1F4E1}";
const loudspeaker = "\u{1F4E2}";
const mega = "\u{1F4E3}";
const outbox_tray = "\u{1F4E4}";
const inbox_tray = "\u{1F4E5}";
const incoming_envelope = "\u{1F4E8}";
const envelope_with_arrow = "\u{1F4E9}";
const mailbox_closed = "\u{1F4EA}";
const mailbox = "\u{1F4EB}";
const mailbox_with_mail = "\u{1F4EC}";
const mailbox_with_no_mail = "\u{1F4ED}";
const postbox = "\u{1F4EE}";
const postal_horn = "\u{1F4EF}";
const newspaper = "\u{1F4F0}";
const iphone = "\u{1F4F1}";
const calling = "\u{1F4F2}";
const vibration_mode = "\u{1F4F3}";
const mobile_phone_off = "\u{1F4F4}";
const no_mobile_phones = "\u{1F4F5}";
const signal_strength = "\u{1F4F6}";
const camera = "\u{1F4F7}";
const camera_with_flash = "\u{1F4F8}";
const video_camera = "\u{1F4F9}";
const tv = "\u{1F4FA}";
const radio = "\u{1F4FB}";
const vhs = "\u{1F4FC}";
const film_projector = "\u{1F4FD}\uFE0F";
const prayer_beads = "\u{1F4FF}";
const twisted_rightwards_arrows = "\u{1F500}";
const repeat$1 = "\u{1F501}";
const repeat_one = "\u{1F502}";
const arrows_clockwise = "\u{1F503}";
const arrows_counterclockwise = "\u{1F504}";
const low_brightness = "\u{1F505}";
const high_brightness = "\u{1F506}";
const mute = "\u{1F507}";
const speaker = "\u{1F508}";
const sound = "\u{1F509}";
const loud_sound = "\u{1F50A}";
const battery = "\u{1F50B}";
const electric_plug = "\u{1F50C}";
const mag = "\u{1F50D}";
const mag_right = "\u{1F50E}";
const lock_with_ink_pen = "\u{1F50F}";
const closed_lock_with_key = "\u{1F510}";
const key = "\u{1F511}";
const lock = "\u{1F512}";
const unlock = "\u{1F513}";
const bell = "\u{1F514}";
const no_bell = "\u{1F515}";
const bookmark = "\u{1F516}";
const link = "\u{1F517}";
const radio_button = "\u{1F518}";
const back = "\u{1F519}";
const end2 = "\u{1F51A}";
const on$1 = "\u{1F51B}";
const soon = "\u{1F51C}";
const top = "\u{1F51D}";
const underage = "\u{1F51E}";
const keycap_ten = "\u{1F51F}";
const capital_abcd = "\u{1F520}";
const abcd = "\u{1F521}";
const symbols = "\u{1F523}";
const abc = "\u{1F524}";
const fire = "\u{1F525}";
const flashlight = "\u{1F526}";
const wrench = "\u{1F527}";
const hammer = "\u{1F528}";
const nut_and_bolt = "\u{1F529}";
const hocho = "\u{1F52A}";
const knife = "\u{1F52A}";
const gun = "\u{1F52B}";
const microscope = "\u{1F52C}";
const telescope = "\u{1F52D}";
const crystal_ball = "\u{1F52E}";
const six_pointed_star = "\u{1F52F}";
const beginner = "\u{1F530}";
const trident = "\u{1F531}";
const black_square_button = "\u{1F532}";
const white_square_button = "\u{1F533}";
const red_circle = "\u{1F534}";
const large_blue_circle = "\u{1F535}";
const large_orange_diamond = "\u{1F536}";
const large_blue_diamond = "\u{1F537}";
const small_orange_diamond = "\u{1F538}";
const small_blue_diamond = "\u{1F539}";
const small_red_triangle = "\u{1F53A}";
const small_red_triangle_down = "\u{1F53B}";
const arrow_up_small = "\u{1F53C}";
const arrow_down_small = "\u{1F53D}";
const om_symbol = "\u{1F549}\uFE0F";
const dove_of_peace = "\u{1F54A}\uFE0F";
const kaaba = "\u{1F54B}";
const mosque = "\u{1F54C}";
const synagogue = "\u{1F54D}";
const menorah_with_nine_branches = "\u{1F54E}";
const clock1 = "\u{1F550}";
const clock2 = "\u{1F551}";
const clock3 = "\u{1F552}";
const clock4 = "\u{1F553}";
const clock5 = "\u{1F554}";
const clock6 = "\u{1F555}";
const clock7 = "\u{1F556}";
const clock8 = "\u{1F557}";
const clock9 = "\u{1F558}";
const clock10 = "\u{1F559}";
const clock11 = "\u{1F55A}";
const clock12 = "\u{1F55B}";
const clock130 = "\u{1F55C}";
const clock230 = "\u{1F55D}";
const clock330 = "\u{1F55E}";
const clock430 = "\u{1F55F}";
const clock530 = "\u{1F560}";
const clock630 = "\u{1F561}";
const clock730 = "\u{1F562}";
const clock830 = "\u{1F563}";
const clock930 = "\u{1F564}";
const clock1030 = "\u{1F565}";
const clock1130 = "\u{1F566}";
const clock1230 = "\u{1F567}";
const candle = "\u{1F56F}\uFE0F";
const mantelpiece_clock = "\u{1F570}\uFE0F";
const hole = "\u{1F573}\uFE0F";
const man_in_business_suit_levitating = "\u{1F574}\uFE0F";
const sleuth_or_spy = "\u{1F575}\uFE0F\u200D\u2642\uFE0F";
const dark_sunglasses = "\u{1F576}\uFE0F";
const spider = "\u{1F577}\uFE0F";
const spider_web = "\u{1F578}\uFE0F";
const joystick = "\u{1F579}\uFE0F";
const man_dancing = "\u{1F57A}";
const linked_paperclips = "\u{1F587}\uFE0F";
const lower_left_ballpoint_pen = "\u{1F58A}\uFE0F";
const lower_left_fountain_pen = "\u{1F58B}\uFE0F";
const lower_left_paintbrush = "\u{1F58C}\uFE0F";
const lower_left_crayon = "\u{1F58D}\uFE0F";
const raised_hand_with_fingers_splayed = "\u{1F590}\uFE0F";
const middle_finger = "\u{1F595}";
const reversed_hand_with_middle_finger_extended = "\u{1F595}";
const black_heart = "\u{1F5A4}";
const desktop_computer = "\u{1F5A5}\uFE0F";
const printer = "\u{1F5A8}\uFE0F";
const three_button_mouse = "\u{1F5B1}\uFE0F";
const trackball = "\u{1F5B2}\uFE0F";
const frame_with_picture = "\u{1F5BC}\uFE0F";
const card_index_dividers = "\u{1F5C2}\uFE0F";
const card_file_box = "\u{1F5C3}\uFE0F";
const file_cabinet = "\u{1F5C4}\uFE0F";
const wastebasket = "\u{1F5D1}\uFE0F";
const spiral_note_pad = "\u{1F5D2}\uFE0F";
const spiral_calendar_pad = "\u{1F5D3}\uFE0F";
const compression = "\u{1F5DC}\uFE0F";
const old_key = "\u{1F5DD}\uFE0F";
const rolled_up_newspaper = "\u{1F5DE}\uFE0F";
const dagger_knife = "\u{1F5E1}\uFE0F";
const speaking_head_in_silhouette = "\u{1F5E3}\uFE0F";
const left_speech_bubble = "\u{1F5E8}\uFE0F";
const right_anger_bubble = "\u{1F5EF}\uFE0F";
const ballot_box_with_ballot = "\u{1F5F3}\uFE0F";
const world_map = "\u{1F5FA}\uFE0F";
const mount_fuji = "\u{1F5FB}";
const tokyo_tower = "\u{1F5FC}";
const statue_of_liberty = "\u{1F5FD}";
const japan = "\u{1F5FE}";
const moyai = "\u{1F5FF}";
const grinning = "\u{1F600}";
const grin = "\u{1F601}";
const joy = "\u{1F602}";
const smiley = "\u{1F603}";
const smile = "\u{1F604}";
const sweat_smile = "\u{1F605}";
const laughing = "\u{1F606}";
const satisfied = "\u{1F606}";
const innocent = "\u{1F607}";
const smiling_imp = "\u{1F608}";
const wink = "\u{1F609}";
const blush = "\u{1F60A}";
const yum = "\u{1F60B}";
const relieved = "\u{1F60C}";
const heart_eyes = "\u{1F60D}";
const sunglasses = "\u{1F60E}";
const smirk = "\u{1F60F}";
const neutral_face = "\u{1F610}";
const expressionless = "\u{1F611}";
const unamused = "\u{1F612}";
const sweat = "\u{1F613}";
const pensive = "\u{1F614}";
const confused = "\u{1F615}";
const confounded = "\u{1F616}";
const kissing = "\u{1F617}";
const kissing_heart = "\u{1F618}";
const kissing_smiling_eyes = "\u{1F619}";
const kissing_closed_eyes = "\u{1F61A}";
const stuck_out_tongue = "\u{1F61B}";
const stuck_out_tongue_winking_eye = "\u{1F61C}";
const stuck_out_tongue_closed_eyes = "\u{1F61D}";
const disappointed = "\u{1F61E}";
const worried = "\u{1F61F}";
const angry = "\u{1F620}";
const rage = "\u{1F621}";
const cry = "\u{1F622}";
const persevere = "\u{1F623}";
const triumph = "\u{1F624}";
const disappointed_relieved = "\u{1F625}";
const frowning = "\u{1F626}";
const anguished = "\u{1F627}";
const fearful = "\u{1F628}";
const weary = "\u{1F629}";
const sleepy = "\u{1F62A}";
const tired_face = "\u{1F62B}";
const grimacing = "\u{1F62C}";
const sob = "\u{1F62D}";
const face_exhaling = "\u{1F62E}\u200D\u{1F4A8}";
const open_mouth = "\u{1F62E}";
const hushed = "\u{1F62F}";
const cold_sweat = "\u{1F630}";
const scream = "\u{1F631}";
const astonished = "\u{1F632}";
const flushed = "\u{1F633}";
const sleeping = "\u{1F634}";
const face_with_spiral_eyes = "\u{1F635}\u200D\u{1F4AB}";
const dizzy_face = "\u{1F635}";
const face_in_clouds = "\u{1F636}\u200D\u{1F32B}\uFE0F";
const no_mouth = "\u{1F636}";
const mask = "\u{1F637}";
const smile_cat = "\u{1F638}";
const joy_cat = "\u{1F639}";
const smiley_cat = "\u{1F63A}";
const heart_eyes_cat = "\u{1F63B}";
const smirk_cat = "\u{1F63C}";
const kissing_cat = "\u{1F63D}";
const pouting_cat = "\u{1F63E}";
const crying_cat_face = "\u{1F63F}";
const scream_cat = "\u{1F640}";
const slightly_frowning_face = "\u{1F641}";
const slightly_smiling_face = "\u{1F642}";
const upside_down_face = "\u{1F643}";
const face_with_rolling_eyes = "\u{1F644}";
const no_good = "\u{1F645}\u200D\u2640\uFE0F";
const ok_woman = "\u{1F646}\u200D\u2640\uFE0F";
const bow = "\u{1F647}\u200D\u2642\uFE0F";
const see_no_evil = "\u{1F648}";
const hear_no_evil = "\u{1F649}";
const speak_no_evil = "\u{1F64A}";
const raising_hand = "\u{1F64B}\u200D\u2640\uFE0F";
const raised_hands = "\u{1F64C}";
const person_frowning = "\u{1F64D}\u200D\u2640\uFE0F";
const person_with_pouting_face = "\u{1F64E}\u200D\u2640\uFE0F";
const pray = "\u{1F64F}";
const rocket = "\u{1F680}";
const helicopter = "\u{1F681}";
const steam_locomotive = "\u{1F682}";
const railway_car = "\u{1F683}";
const bullettrain_side = "\u{1F684}";
const bullettrain_front = "\u{1F685}";
const train2 = "\u{1F686}";
const metro = "\u{1F687}";
const light_rail = "\u{1F688}";
const station = "\u{1F689}";
const tram = "\u{1F68A}";
const train = "\u{1F68B}";
const bus = "\u{1F68C}";
const oncoming_bus = "\u{1F68D}";
const trolleybus = "\u{1F68E}";
const busstop = "\u{1F68F}";
const minibus = "\u{1F690}";
const ambulance = "\u{1F691}";
const fire_engine = "\u{1F692}";
const police_car = "\u{1F693}";
const oncoming_police_car = "\u{1F694}";
const taxi = "\u{1F695}";
const oncoming_taxi = "\u{1F696}";
const car = "\u{1F697}";
const red_car = "\u{1F697}";
const oncoming_automobile = "\u{1F698}";
const blue_car = "\u{1F699}";
const truck = "\u{1F69A}";
const articulated_lorry = "\u{1F69B}";
const tractor = "\u{1F69C}";
const monorail = "\u{1F69D}";
const mountain_railway = "\u{1F69E}";
const suspension_railway = "\u{1F69F}";
const mountain_cableway = "\u{1F6A0}";
const aerial_tramway = "\u{1F6A1}";
const ship = "\u{1F6A2}";
const rowboat = "\u{1F6A3}\u200D\u2642\uFE0F";
const speedboat = "\u{1F6A4}";
const traffic_light = "\u{1F6A5}";
const vertical_traffic_light = "\u{1F6A6}";
const construction = "\u{1F6A7}";
const rotating_light = "\u{1F6A8}";
const triangular_flag_on_post = "\u{1F6A9}";
const door = "\u{1F6AA}";
const no_entry_sign = "\u{1F6AB}";
const smoking = "\u{1F6AC}";
const no_smoking = "\u{1F6AD}";
const put_litter_in_its_place = "\u{1F6AE}";
const do_not_litter = "\u{1F6AF}";
const potable_water = "\u{1F6B0}";
const bike = "\u{1F6B2}";
const no_bicycles = "\u{1F6B3}";
const bicyclist = "\u{1F6B4}\u200D\u2642\uFE0F";
const mountain_bicyclist = "\u{1F6B5}\u200D\u2642\uFE0F";
const walking = "\u{1F6B6}\u200D\u2642\uFE0F";
const no_pedestrians = "\u{1F6B7}";
const children_crossing = "\u{1F6B8}";
const mens = "\u{1F6B9}";
const womens = "\u{1F6BA}";
const restroom = "\u{1F6BB}";
const baby_symbol = "\u{1F6BC}";
const toilet = "\u{1F6BD}";
const wc = "\u{1F6BE}";
const shower = "\u{1F6BF}";
const bath = "\u{1F6C0}";
const bathtub = "\u{1F6C1}";
const passport_control = "\u{1F6C2}";
const customs = "\u{1F6C3}";
const baggage_claim = "\u{1F6C4}";
const left_luggage = "\u{1F6C5}";
const couch_and_lamp = "\u{1F6CB}\uFE0F";
const sleeping_accommodation = "\u{1F6CC}";
const shopping_bags = "\u{1F6CD}\uFE0F";
const bellhop_bell = "\u{1F6CE}\uFE0F";
const bed = "\u{1F6CF}\uFE0F";
const place_of_worship = "\u{1F6D0}";
const octagonal_sign = "\u{1F6D1}";
const shopping_trolley = "\u{1F6D2}";
const hindu_temple = "\u{1F6D5}";
const hut = "\u{1F6D6}";
const elevator = "\u{1F6D7}";
const hammer_and_wrench = "\u{1F6E0}\uFE0F";
const shield = "\u{1F6E1}\uFE0F";
const oil_drum = "\u{1F6E2}\uFE0F";
const motorway = "\u{1F6E3}\uFE0F";
const railway_track = "\u{1F6E4}\uFE0F";
const motor_boat = "\u{1F6E5}\uFE0F";
const small_airplane = "\u{1F6E9}\uFE0F";
const airplane_departure = "\u{1F6EB}";
const airplane_arriving = "\u{1F6EC}";
const satellite = "\u{1F6F0}\uFE0F";
const passenger_ship = "\u{1F6F3}\uFE0F";
const scooter = "\u{1F6F4}";
const motor_scooter = "\u{1F6F5}";
const canoe = "\u{1F6F6}";
const sled = "\u{1F6F7}";
const flying_saucer = "\u{1F6F8}";
const skateboard = "\u{1F6F9}";
const auto_rickshaw = "\u{1F6FA}";
const pickup_truck = "\u{1F6FB}";
const roller_skate = "\u{1F6FC}";
const large_orange_circle = "\u{1F7E0}";
const large_yellow_circle = "\u{1F7E1}";
const large_green_circle = "\u{1F7E2}";
const large_purple_circle = "\u{1F7E3}";
const large_brown_circle = "\u{1F7E4}";
const large_red_square = "\u{1F7E5}";
const large_blue_square = "\u{1F7E6}";
const large_orange_square = "\u{1F7E7}";
const large_yellow_square = "\u{1F7E8}";
const large_green_square = "\u{1F7E9}";
const large_purple_square = "\u{1F7EA}";
const large_brown_square = "\u{1F7EB}";
const pinched_fingers = "\u{1F90C}";
const white_heart = "\u{1F90D}";
const brown_heart = "\u{1F90E}";
const pinching_hand = "\u{1F90F}";
const zipper_mouth_face = "\u{1F910}";
const money_mouth_face = "\u{1F911}";
const face_with_thermometer = "\u{1F912}";
const nerd_face = "\u{1F913}";
const thinking_face = "\u{1F914}";
const face_with_head_bandage = "\u{1F915}";
const robot_face = "\u{1F916}";
const hugging_face = "\u{1F917}";
const the_horns = "\u{1F918}";
const sign_of_the_horns = "\u{1F918}";
const call_me_hand = "\u{1F919}";
const raised_back_of_hand = "\u{1F91A}";
const handshake = "\u{1F91D}";
const crossed_fingers = "\u{1F91E}";
const hand_with_index_and_middle_fingers_crossed = "\u{1F91E}";
const i_love_you_hand_sign = "\u{1F91F}";
const face_with_cowboy_hat = "\u{1F920}";
const clown_face = "\u{1F921}";
const nauseated_face = "\u{1F922}";
const rolling_on_the_floor_laughing = "\u{1F923}";
const drooling_face = "\u{1F924}";
const lying_face = "\u{1F925}";
const face_palm = "\u{1F926}";
const sneezing_face = "\u{1F927}";
const face_with_raised_eyebrow = "\u{1F928}";
const face_with_one_eyebrow_raised = "\u{1F928}";
const grinning_face_with_star_eyes = "\u{1F929}";
const zany_face = "\u{1F92A}";
const grinning_face_with_one_large_and_one_small_eye = "\u{1F92A}";
const shushing_face = "\u{1F92B}";
const face_with_finger_covering_closed_lips = "\u{1F92B}";
const face_with_symbols_on_mouth = "\u{1F92C}";
const serious_face_with_symbols_covering_mouth = "\u{1F92C}";
const face_with_hand_over_mouth = "\u{1F92D}";
const smiling_face_with_smiling_eyes_and_hand_covering_mouth = "\u{1F92D}";
const face_vomiting = "\u{1F92E}";
const face_with_open_mouth_vomiting = "\u{1F92E}";
const exploding_head = "\u{1F92F}";
const shocked_face_with_exploding_head = "\u{1F92F}";
const pregnant_woman = "\u{1F930}";
const palms_up_together = "\u{1F932}";
const selfie = "\u{1F933}";
const prince = "\u{1F934}";
const woman_in_tuxedo = "\u{1F935}\u200D\u2640\uFE0F";
const man_in_tuxedo = "\u{1F935}\u200D\u2642\uFE0F";
const person_in_tuxedo = "\u{1F935}";
const mrs_claus = "\u{1F936}";
const mother_christmas = "\u{1F936}";
const shrug = "\u{1F937}";
const person_doing_cartwheel = "\u{1F938}";
const juggling = "\u{1F939}";
const fencer = "\u{1F93A}";
const wrestlers = "\u{1F93C}";
const water_polo = "\u{1F93D}";
const handball = "\u{1F93E}";
const diving_mask = "\u{1F93F}";
const wilted_flower = "\u{1F940}";
const drum_with_drumsticks = "\u{1F941}";
const clinking_glasses = "\u{1F942}";
const tumbler_glass = "\u{1F943}";
const spoon = "\u{1F944}";
const goal_net = "\u{1F945}";
const first_place_medal = "\u{1F947}";
const second_place_medal = "\u{1F948}";
const third_place_medal = "\u{1F949}";
const boxing_glove = "\u{1F94A}";
const martial_arts_uniform = "\u{1F94B}";
const curling_stone = "\u{1F94C}";
const lacrosse = "\u{1F94D}";
const softball = "\u{1F94E}";
const flying_disc = "\u{1F94F}";
const croissant = "\u{1F950}";
const avocado = "\u{1F951}";
const cucumber = "\u{1F952}";
const bacon = "\u{1F953}";
const potato = "\u{1F954}";
const carrot = "\u{1F955}";
const baguette_bread = "\u{1F956}";
const green_salad = "\u{1F957}";
const shallow_pan_of_food = "\u{1F958}";
const stuffed_flatbread = "\u{1F959}";
const egg = "\u{1F95A}";
const glass_of_milk = "\u{1F95B}";
const peanuts = "\u{1F95C}";
const kiwifruit = "\u{1F95D}";
const pancakes = "\u{1F95E}";
const dumpling = "\u{1F95F}";
const fortune_cookie = "\u{1F960}";
const takeout_box = "\u{1F961}";
const chopsticks = "\u{1F962}";
const bowl_with_spoon = "\u{1F963}";
const cup_with_straw = "\u{1F964}";
const coconut = "\u{1F965}";
const broccoli = "\u{1F966}";
const pie = "\u{1F967}";
const pretzel = "\u{1F968}";
const cut_of_meat = "\u{1F969}";
const sandwich = "\u{1F96A}";
const canned_food = "\u{1F96B}";
const leafy_green = "\u{1F96C}";
const mango = "\u{1F96D}";
const moon_cake = "\u{1F96E}";
const bagel = "\u{1F96F}";
const smiling_face_with_3_hearts = "\u{1F970}";
const yawning_face = "\u{1F971}";
const smiling_face_with_tear = "\u{1F972}";
const partying_face = "\u{1F973}";
const woozy_face = "\u{1F974}";
const hot_face = "\u{1F975}";
const cold_face = "\u{1F976}";
const ninja = "\u{1F977}";
const disguised_face = "\u{1F978}";
const pleading_face = "\u{1F97A}";
const sari = "\u{1F97B}";
const lab_coat = "\u{1F97C}";
const goggles = "\u{1F97D}";
const hiking_boot = "\u{1F97E}";
const womans_flat_shoe = "\u{1F97F}";
const crab = "\u{1F980}";
const lion_face = "\u{1F981}";
const scorpion = "\u{1F982}";
const turkey = "\u{1F983}";
const unicorn_face = "\u{1F984}";
const eagle = "\u{1F985}";
const duck = "\u{1F986}";
const bat = "\u{1F987}";
const shark = "\u{1F988}";
const owl = "\u{1F989}";
const fox_face = "\u{1F98A}";
const butterfly = "\u{1F98B}";
const deer = "\u{1F98C}";
const gorilla = "\u{1F98D}";
const lizard = "\u{1F98E}";
const rhinoceros = "\u{1F98F}";
const shrimp = "\u{1F990}";
const squid = "\u{1F991}";
const giraffe_face = "\u{1F992}";
const zebra_face = "\u{1F993}";
const hedgehog = "\u{1F994}";
const sauropod = "\u{1F995}";
const cricket = "\u{1F997}";
const kangaroo = "\u{1F998}";
const llama = "\u{1F999}";
const peacock = "\u{1F99A}";
const hippopotamus = "\u{1F99B}";
const parrot = "\u{1F99C}";
const raccoon = "\u{1F99D}";
const lobster = "\u{1F99E}";
const mosquito = "\u{1F99F}";
const microbe = "\u{1F9A0}";
const badger = "\u{1F9A1}";
const swan = "\u{1F9A2}";
const mammoth = "\u{1F9A3}";
const dodo = "\u{1F9A4}";
const sloth = "\u{1F9A5}";
const otter = "\u{1F9A6}";
const orangutan = "\u{1F9A7}";
const skunk = "\u{1F9A8}";
const flamingo = "\u{1F9A9}";
const oyster = "\u{1F9AA}";
const beaver = "\u{1F9AB}";
const bison = "\u{1F9AC}";
const seal = "\u{1F9AD}";
const guide_dog = "\u{1F9AE}";
const probing_cane = "\u{1F9AF}";
const bone = "\u{1F9B4}";
const leg = "\u{1F9B5}";
const foot = "\u{1F9B6}";
const tooth = "\u{1F9B7}";
const female_superhero = "\u{1F9B8}\u200D\u2640\uFE0F";
const male_superhero = "\u{1F9B8}\u200D\u2642\uFE0F";
const superhero = "\u{1F9B8}";
const female_supervillain = "\u{1F9B9}\u200D\u2640\uFE0F";
const male_supervillain = "\u{1F9B9}\u200D\u2642\uFE0F";
const supervillain = "\u{1F9B9}";
const safety_vest = "\u{1F9BA}";
const ear_with_hearing_aid = "\u{1F9BB}";
const motorized_wheelchair = "\u{1F9BC}";
const manual_wheelchair = "\u{1F9BD}";
const mechanical_arm = "\u{1F9BE}";
const mechanical_leg = "\u{1F9BF}";
const cheese_wedge = "\u{1F9C0}";
const cupcake = "\u{1F9C1}";
const salt = "\u{1F9C2}";
const beverage_box = "\u{1F9C3}";
const garlic = "\u{1F9C4}";
const onion = "\u{1F9C5}";
const falafel = "\u{1F9C6}";
const waffle = "\u{1F9C7}";
const butter = "\u{1F9C8}";
const mate_drink = "\u{1F9C9}";
const ice_cube = "\u{1F9CA}";
const bubble_tea = "\u{1F9CB}";
const woman_standing = "\u{1F9CD}\u200D\u2640\uFE0F";
const man_standing = "\u{1F9CD}\u200D\u2642\uFE0F";
const standing_person = "\u{1F9CD}";
const woman_kneeling = "\u{1F9CE}\u200D\u2640\uFE0F";
const man_kneeling = "\u{1F9CE}\u200D\u2642\uFE0F";
const kneeling_person = "\u{1F9CE}";
const deaf_woman = "\u{1F9CF}\u200D\u2640\uFE0F";
const deaf_man = "\u{1F9CF}\u200D\u2642\uFE0F";
const deaf_person = "\u{1F9CF}";
const face_with_monocle = "\u{1F9D0}";
const farmer = "\u{1F9D1}\u200D\u{1F33E}";
const cook = "\u{1F9D1}\u200D\u{1F373}";
const person_feeding_baby = "\u{1F9D1}\u200D\u{1F37C}";
const mx_claus = "\u{1F9D1}\u200D\u{1F384}";
const student = "\u{1F9D1}\u200D\u{1F393}";
const singer = "\u{1F9D1}\u200D\u{1F3A4}";
const artist = "\u{1F9D1}\u200D\u{1F3A8}";
const teacher = "\u{1F9D1}\u200D\u{1F3EB}";
const factory_worker = "\u{1F9D1}\u200D\u{1F3ED}";
const technologist = "\u{1F9D1}\u200D\u{1F4BB}";
const office_worker = "\u{1F9D1}\u200D\u{1F4BC}";
const mechanic = "\u{1F9D1}\u200D\u{1F527}";
const scientist = "\u{1F9D1}\u200D\u{1F52C}";
const astronaut = "\u{1F9D1}\u200D\u{1F680}";
const firefighter = "\u{1F9D1}\u200D\u{1F692}";
const people_holding_hands = "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}";
const person_with_probing_cane = "\u{1F9D1}\u200D\u{1F9AF}";
const red_haired_person = "\u{1F9D1}\u200D\u{1F9B0}";
const curly_haired_person = "\u{1F9D1}\u200D\u{1F9B1}";
const bald_person = "\u{1F9D1}\u200D\u{1F9B2}";
const white_haired_person = "\u{1F9D1}\u200D\u{1F9B3}";
const person_in_motorized_wheelchair = "\u{1F9D1}\u200D\u{1F9BC}";
const person_in_manual_wheelchair = "\u{1F9D1}\u200D\u{1F9BD}";
const health_worker = "\u{1F9D1}\u200D\u2695\uFE0F";
const judge = "\u{1F9D1}\u200D\u2696\uFE0F";
const pilot = "\u{1F9D1}\u200D\u2708\uFE0F";
const adult = "\u{1F9D1}";
const child3 = "\u{1F9D2}";
const older_adult = "\u{1F9D3}";
const woman_with_beard = "\u{1F9D4}\u200D\u2640\uFE0F";
const man_with_beard = "\u{1F9D4}\u200D\u2642\uFE0F";
const bearded_person = "\u{1F9D4}";
const person_with_headscarf = "\u{1F9D5}";
const woman_in_steamy_room = "\u{1F9D6}\u200D\u2640\uFE0F";
const man_in_steamy_room = "\u{1F9D6}\u200D\u2642\uFE0F";
const person_in_steamy_room = "\u{1F9D6}\u200D\u2642\uFE0F";
const woman_climbing = "\u{1F9D7}\u200D\u2640\uFE0F";
const person_climbing = "\u{1F9D7}\u200D\u2640\uFE0F";
const man_climbing = "\u{1F9D7}\u200D\u2642\uFE0F";
const woman_in_lotus_position = "\u{1F9D8}\u200D\u2640\uFE0F";
const person_in_lotus_position = "\u{1F9D8}\u200D\u2640\uFE0F";
const man_in_lotus_position = "\u{1F9D8}\u200D\u2642\uFE0F";
const female_mage = "\u{1F9D9}\u200D\u2640\uFE0F";
const mage = "\u{1F9D9}\u200D\u2640\uFE0F";
const male_mage = "\u{1F9D9}\u200D\u2642\uFE0F";
const female_fairy = "\u{1F9DA}\u200D\u2640\uFE0F";
const fairy = "\u{1F9DA}\u200D\u2640\uFE0F";
const male_fairy = "\u{1F9DA}\u200D\u2642\uFE0F";
const female_vampire = "\u{1F9DB}\u200D\u2640\uFE0F";
const vampire = "\u{1F9DB}\u200D\u2640\uFE0F";
const male_vampire = "\u{1F9DB}\u200D\u2642\uFE0F";
const mermaid = "\u{1F9DC}\u200D\u2640\uFE0F";
const merman = "\u{1F9DC}\u200D\u2642\uFE0F";
const merperson = "\u{1F9DC}\u200D\u2642\uFE0F";
const female_elf = "\u{1F9DD}\u200D\u2640\uFE0F";
const male_elf = "\u{1F9DD}\u200D\u2642\uFE0F";
const elf = "\u{1F9DD}\u200D\u2642\uFE0F";
const female_genie = "\u{1F9DE}\u200D\u2640\uFE0F";
const male_genie = "\u{1F9DE}\u200D\u2642\uFE0F";
const genie = "\u{1F9DE}\u200D\u2642\uFE0F";
const female_zombie = "\u{1F9DF}\u200D\u2640\uFE0F";
const male_zombie = "\u{1F9DF}\u200D\u2642\uFE0F";
const zombie = "\u{1F9DF}\u200D\u2642\uFE0F";
const brain = "\u{1F9E0}";
const orange_heart = "\u{1F9E1}";
const billed_cap = "\u{1F9E2}";
const scarf = "\u{1F9E3}";
const gloves = "\u{1F9E4}";
const coat = "\u{1F9E5}";
const socks = "\u{1F9E6}";
const red_envelope = "\u{1F9E7}";
const firecracker = "\u{1F9E8}";
const jigsaw = "\u{1F9E9}";
const test_tube = "\u{1F9EA}";
const petri_dish = "\u{1F9EB}";
const dna = "\u{1F9EC}";
const compass = "\u{1F9ED}";
const abacus = "\u{1F9EE}";
const fire_extinguisher = "\u{1F9EF}";
const toolbox = "\u{1F9F0}";
const bricks = "\u{1F9F1}";
const magnet = "\u{1F9F2}";
const luggage = "\u{1F9F3}";
const lotion_bottle = "\u{1F9F4}";
const thread = "\u{1F9F5}";
const yarn = "\u{1F9F6}";
const safety_pin = "\u{1F9F7}";
const teddy_bear = "\u{1F9F8}";
const broom = "\u{1F9F9}";
const basket = "\u{1F9FA}";
const roll_of_paper = "\u{1F9FB}";
const soap = "\u{1F9FC}";
const sponge = "\u{1F9FD}";
const receipt = "\u{1F9FE}";
const nazar_amulet = "\u{1F9FF}";
const ballet_shoes = "\u{1FA70}";
const briefs = "\u{1FA72}";
const shorts = "\u{1FA73}";
const thong_sandal = "\u{1FA74}";
const drop_of_blood = "\u{1FA78}";
const adhesive_bandage = "\u{1FA79}";
const stethoscope = "\u{1FA7A}";
const kite = "\u{1FA81}";
const parachute = "\u{1FA82}";
const boomerang = "\u{1FA83}";
const magic_wand = "\u{1FA84}";
const pinata = "\u{1FA85}";
const nesting_dolls = "\u{1FA86}";
const ringed_planet = "\u{1FA90}";
const chair = "\u{1FA91}";
const razor = "\u{1FA92}";
const axe = "\u{1FA93}";
const diya_lamp = "\u{1FA94}";
const banjo = "\u{1FA95}";
const military_helmet = "\u{1FA96}";
const accordion = "\u{1FA97}";
const long_drum = "\u{1FA98}";
const coin = "\u{1FA99}";
const carpentry_saw = "\u{1FA9A}";
const screwdriver = "\u{1FA9B}";
const ladder = "\u{1FA9C}";
const hook = "\u{1FA9D}";
const mirror = "\u{1FA9E}";
const window$1 = "\u{1FA9F}";
const plunger = "\u{1FAA0}";
const sewing_needle = "\u{1FAA1}";
const knot = "\u{1FAA2}";
const bucket = "\u{1FAA3}";
const mouse_trap = "\u{1FAA4}";
const toothbrush = "\u{1FAA5}";
const headstone = "\u{1FAA6}";
const placard = "\u{1FAA7}";
const rock = "\u{1FAA8}";
const fly = "\u{1FAB0}";
const worm = "\u{1FAB1}";
const beetle = "\u{1FAB2}";
const cockroach = "\u{1FAB3}";
const potted_plant = "\u{1FAB4}";
const wood = "\u{1FAB5}";
const feather = "\u{1FAB6}";
const anatomical_heart = "\u{1FAC0}";
const lungs = "\u{1FAC1}";
const people_hugging = "\u{1FAC2}";
const blueberries = "\u{1FAD0}";
const bell_pepper = "\u{1FAD1}";
const olive = "\u{1FAD2}";
const flatbread = "\u{1FAD3}";
const tamale = "\u{1FAD4}";
const fondue = "\u{1FAD5}";
const teapot = "\u{1FAD6}";
const bangbang = "\u203C\uFE0F";
const interrobang = "\u2049\uFE0F";
const tm = "\u2122\uFE0F";
const information_source = "\u2139\uFE0F";
const left_right_arrow = "\u2194\uFE0F";
const arrow_up_down = "\u2195\uFE0F";
const arrow_upper_left = "\u2196\uFE0F";
const arrow_upper_right = "\u2197\uFE0F";
const arrow_lower_right = "\u2198\uFE0F";
const arrow_lower_left = "\u2199\uFE0F";
const leftwards_arrow_with_hook = "\u21A9\uFE0F";
const arrow_right_hook = "\u21AA\uFE0F";
const watch = "\u231A";
const hourglass = "\u231B";
const keyboard = "\u2328\uFE0F";
const eject = "\u23CF\uFE0F";
const fast_forward = "\u23E9";
const rewind = "\u23EA";
const arrow_double_up = "\u23EB";
const arrow_double_down = "\u23EC";
const black_right_pointing_double_triangle_with_vertical_bar = "\u23ED\uFE0F";
const black_left_pointing_double_triangle_with_vertical_bar = "\u23EE\uFE0F";
const black_right_pointing_triangle_with_double_vertical_bar = "\u23EF\uFE0F";
const alarm_clock = "\u23F0";
const stopwatch = "\u23F1\uFE0F";
const timer_clock = "\u23F2\uFE0F";
const hourglass_flowing_sand = "\u23F3";
const double_vertical_bar = "\u23F8\uFE0F";
const black_square_for_stop = "\u23F9\uFE0F";
const black_circle_for_record = "\u23FA\uFE0F";
const m$1 = "\u24C2\uFE0F";
const black_small_square = "\u25AA\uFE0F";
const white_small_square = "\u25AB\uFE0F";
const arrow_forward = "\u25B6\uFE0F";
const arrow_backward = "\u25C0\uFE0F";
const white_medium_square = "\u25FB\uFE0F";
const black_medium_square = "\u25FC\uFE0F";
const white_medium_small_square = "\u25FD";
const black_medium_small_square = "\u25FE";
const sunny = "\u2600\uFE0F";
const cloud = "\u2601\uFE0F";
const umbrella = "\u2602\uFE0F";
const snowman = "\u2603\uFE0F";
const comet = "\u2604\uFE0F";
const phone = "\u260E\uFE0F";
const telephone = "\u260E\uFE0F";
const ballot_box_with_check = "\u2611\uFE0F";
const shamrock = "\u2618\uFE0F";
const point_up = "\u261D\uFE0F";
const skull_and_crossbones = "\u2620\uFE0F";
const radioactive_sign = "\u2622\uFE0F";
const biohazard_sign = "\u2623\uFE0F";
const orthodox_cross = "\u2626\uFE0F";
const star_and_crescent = "\u262A\uFE0F";
const peace_symbol = "\u262E\uFE0F";
const yin_yang = "\u262F\uFE0F";
const wheel_of_dharma = "\u2638\uFE0F";
const white_frowning_face = "\u2639\uFE0F";
const relaxed = "\u263A\uFE0F";
const female_sign = "\u2640\uFE0F";
const male_sign = "\u2642\uFE0F";
const gemini = "\u264A";
const cancer = "\u264B";
const leo = "\u264C";
const virgo = "\u264D";
const libra = "\u264E";
const scorpius = "\u264F";
const chess_pawn = "\u265F\uFE0F";
const spades = "\u2660\uFE0F";
const clubs = "\u2663\uFE0F";
const hearts = "\u2665\uFE0F";
const diamonds = "\u2666\uFE0F";
const hotsprings = "\u2668\uFE0F";
const recycle = "\u267B\uFE0F";
const infinity = "\u267E\uFE0F";
const wheelchair = "\u267F";
const hammer_and_pick = "\u2692\uFE0F";
const crossed_swords = "\u2694\uFE0F";
const medical_symbol = "\u2695\uFE0F";
const staff_of_aesculapius = "\u2695\uFE0F";
const scales = "\u2696\uFE0F";
const alembic = "\u2697\uFE0F";
const gear = "\u2699\uFE0F";
const atom_symbol = "\u269B\uFE0F";
const fleur_de_lis = "\u269C\uFE0F";
const warning = "\u26A0\uFE0F";
const zap = "\u26A1";
const transgender_symbol = "\u26A7\uFE0F";
const white_circle = "\u26AA";
const black_circle = "\u26AB";
const coffin = "\u26B0\uFE0F";
const funeral_urn = "\u26B1\uFE0F";
const soccer = "\u26BD";
const baseball = "\u26BE";
const snowman_without_snow = "\u26C4";
const partly_sunny = "\u26C5";
const thunder_cloud_and_rain = "\u26C8\uFE0F";
const ophiuchus = "\u26CE";
const pick = "\u26CF\uFE0F";
const helmet_with_white_cross = "\u26D1\uFE0F";
const chains = "\u26D3\uFE0F";
const no_entry = "\u26D4";
const shinto_shrine = "\u26E9\uFE0F";
const church = "\u26EA";
const mountain = "\u26F0\uFE0F";
const umbrella_on_ground = "\u26F1\uFE0F";
const fountain = "\u26F2";
const golf = "\u26F3";
const ferry = "\u26F4\uFE0F";
const boat = "\u26F5";
const sailboat = "\u26F5";
const skier = "\u26F7\uFE0F";
const ice_skate = "\u26F8\uFE0F";
const person_with_ball = "\u26F9\uFE0F\u200D\u2642\uFE0F";
const tent = "\u26FA";
const fuelpump = "\u26FD";
const scissors = "\u2702\uFE0F";
const airplane = "\u2708\uFE0F";
const email = "\u2709\uFE0F";
const envelope = "\u2709\uFE0F";
const fist = "\u270A";
const hand = "\u270B";
const raised_hand = "\u270B";
const v$1 = "\u270C\uFE0F";
const writing_hand = "\u270D\uFE0F";
const pencil2 = "\u270F\uFE0F";
const black_nib = "\u2712\uFE0F";
const heavy_check_mark = "\u2714\uFE0F";
const heavy_multiplication_x = "\u2716\uFE0F";
const latin_cross = "\u271D\uFE0F";
const star_of_david = "\u2721\uFE0F";
const eight_spoked_asterisk = "\u2733\uFE0F";
const eight_pointed_black_star = "\u2734\uFE0F";
const snowflake = "\u2744\uFE0F";
const sparkle = "\u2747\uFE0F";
const x$1 = "\u274C";
const negative_squared_cross_mark = "\u274E";
const heavy_heart_exclamation_mark_ornament = "\u2763\uFE0F";
const heart_on_fire = "\u2764\uFE0F\u200D\u{1F525}";
const mending_heart = "\u2764\uFE0F\u200D\u{1FA79}";
const heart = "\u2764\uFE0F";
const arrow_right = "\u27A1\uFE0F";
const curly_loop = "\u27B0";
const loop = "\u27BF";
const arrow_heading_up = "\u2934\uFE0F";
const arrow_heading_down = "\u2935\uFE0F";
const arrow_left = "\u2B05\uFE0F";
const arrow_up = "\u2B06\uFE0F";
const arrow_down = "\u2B07\uFE0F";
const black_large_square = "\u2B1B";
const white_large_square = "\u2B1C";
const star = "\u2B50";
const o$1 = "\u2B55";
const wavy_dash = "\u3030\uFE0F";
const part_alternation_mark = "\u303D\uFE0F";
const congratulations = "\u3297\uFE0F";
const secret = "\u3299\uFE0F";
var require$$1 = {
  "100": "\u{1F4AF}",
  "1234": "\u{1F522}",
  umbrella_with_rain_drops,
  coffee,
  aries,
  taurus,
  sagittarius,
  capricorn,
  aquarius,
  pisces,
  anchor,
  white_check_mark,
  sparkles,
  question,
  grey_question,
  grey_exclamation,
  exclamation,
  heavy_exclamation_mark,
  heavy_plus_sign,
  heavy_minus_sign,
  heavy_division_sign,
  hash,
  keycap_star,
  zero,
  one,
  two,
  three,
  four,
  five,
  six,
  seven,
  eight,
  nine,
  copyright,
  registered,
  mahjong,
  black_joker,
  a: a$1,
  b: b$1,
  o2,
  parking,
  ab,
  cl,
  cool,
  free,
  id,
  "new": "\u{1F195}",
  ng,
  ok: ok2,
  sos,
  up: up3,
  vs,
  "flag-ac": "\u{1F1E6}\u{1F1E8}",
  "flag-ad": "\u{1F1E6}\u{1F1E9}",
  "flag-ae": "\u{1F1E6}\u{1F1EA}",
  "flag-af": "\u{1F1E6}\u{1F1EB}",
  "flag-ag": "\u{1F1E6}\u{1F1EC}",
  "flag-ai": "\u{1F1E6}\u{1F1EE}",
  "flag-al": "\u{1F1E6}\u{1F1F1}",
  "flag-am": "\u{1F1E6}\u{1F1F2}",
  "flag-ao": "\u{1F1E6}\u{1F1F4}",
  "flag-aq": "\u{1F1E6}\u{1F1F6}",
  "flag-ar": "\u{1F1E6}\u{1F1F7}",
  "flag-as": "\u{1F1E6}\u{1F1F8}",
  "flag-at": "\u{1F1E6}\u{1F1F9}",
  "flag-au": "\u{1F1E6}\u{1F1FA}",
  "flag-aw": "\u{1F1E6}\u{1F1FC}",
  "flag-ax": "\u{1F1E6}\u{1F1FD}",
  "flag-az": "\u{1F1E6}\u{1F1FF}",
  "flag-ba": "\u{1F1E7}\u{1F1E6}",
  "flag-bb": "\u{1F1E7}\u{1F1E7}",
  "flag-bd": "\u{1F1E7}\u{1F1E9}",
  "flag-be": "\u{1F1E7}\u{1F1EA}",
  "flag-bf": "\u{1F1E7}\u{1F1EB}",
  "flag-bg": "\u{1F1E7}\u{1F1EC}",
  "flag-bh": "\u{1F1E7}\u{1F1ED}",
  "flag-bi": "\u{1F1E7}\u{1F1EE}",
  "flag-bj": "\u{1F1E7}\u{1F1EF}",
  "flag-bl": "\u{1F1E7}\u{1F1F1}",
  "flag-bm": "\u{1F1E7}\u{1F1F2}",
  "flag-bn": "\u{1F1E7}\u{1F1F3}",
  "flag-bo": "\u{1F1E7}\u{1F1F4}",
  "flag-bq": "\u{1F1E7}\u{1F1F6}",
  "flag-br": "\u{1F1E7}\u{1F1F7}",
  "flag-bs": "\u{1F1E7}\u{1F1F8}",
  "flag-bt": "\u{1F1E7}\u{1F1F9}",
  "flag-bv": "\u{1F1E7}\u{1F1FB}",
  "flag-bw": "\u{1F1E7}\u{1F1FC}",
  "flag-by": "\u{1F1E7}\u{1F1FE}",
  "flag-bz": "\u{1F1E7}\u{1F1FF}",
  "flag-ca": "\u{1F1E8}\u{1F1E6}",
  "flag-cc": "\u{1F1E8}\u{1F1E8}",
  "flag-cd": "\u{1F1E8}\u{1F1E9}",
  "flag-cf": "\u{1F1E8}\u{1F1EB}",
  "flag-cg": "\u{1F1E8}\u{1F1EC}",
  "flag-ch": "\u{1F1E8}\u{1F1ED}",
  "flag-ci": "\u{1F1E8}\u{1F1EE}",
  "flag-ck": "\u{1F1E8}\u{1F1F0}",
  "flag-cl": "\u{1F1E8}\u{1F1F1}",
  "flag-cm": "\u{1F1E8}\u{1F1F2}",
  cn,
  "flag-cn": "\u{1F1E8}\u{1F1F3}",
  "flag-co": "\u{1F1E8}\u{1F1F4}",
  "flag-cp": "\u{1F1E8}\u{1F1F5}",
  "flag-cr": "\u{1F1E8}\u{1F1F7}",
  "flag-cu": "\u{1F1E8}\u{1F1FA}",
  "flag-cv": "\u{1F1E8}\u{1F1FB}",
  "flag-cw": "\u{1F1E8}\u{1F1FC}",
  "flag-cx": "\u{1F1E8}\u{1F1FD}",
  "flag-cy": "\u{1F1E8}\u{1F1FE}",
  "flag-cz": "\u{1F1E8}\u{1F1FF}",
  de: de$1,
  "flag-de": "\u{1F1E9}\u{1F1EA}",
  "flag-dg": "\u{1F1E9}\u{1F1EC}",
  "flag-dj": "\u{1F1E9}\u{1F1EF}",
  "flag-dk": "\u{1F1E9}\u{1F1F0}",
  "flag-dm": "\u{1F1E9}\u{1F1F2}",
  "flag-do": "\u{1F1E9}\u{1F1F4}",
  "flag-dz": "\u{1F1E9}\u{1F1FF}",
  "flag-ea": "\u{1F1EA}\u{1F1E6}",
  "flag-ec": "\u{1F1EA}\u{1F1E8}",
  "flag-ee": "\u{1F1EA}\u{1F1EA}",
  "flag-eg": "\u{1F1EA}\u{1F1EC}",
  "flag-eh": "\u{1F1EA}\u{1F1ED}",
  "flag-er": "\u{1F1EA}\u{1F1F7}",
  es,
  "flag-es": "\u{1F1EA}\u{1F1F8}",
  "flag-et": "\u{1F1EA}\u{1F1F9}",
  "flag-eu": "\u{1F1EA}\u{1F1FA}",
  "flag-fi": "\u{1F1EB}\u{1F1EE}",
  "flag-fj": "\u{1F1EB}\u{1F1EF}",
  "flag-fk": "\u{1F1EB}\u{1F1F0}",
  "flag-fm": "\u{1F1EB}\u{1F1F2}",
  "flag-fo": "\u{1F1EB}\u{1F1F4}",
  fr,
  "flag-fr": "\u{1F1EB}\u{1F1F7}",
  "flag-ga": "\u{1F1EC}\u{1F1E6}",
  gb,
  uk,
  "flag-gb": "\u{1F1EC}\u{1F1E7}",
  "flag-gd": "\u{1F1EC}\u{1F1E9}",
  "flag-ge": "\u{1F1EC}\u{1F1EA}",
  "flag-gf": "\u{1F1EC}\u{1F1EB}",
  "flag-gg": "\u{1F1EC}\u{1F1EC}",
  "flag-gh": "\u{1F1EC}\u{1F1ED}",
  "flag-gi": "\u{1F1EC}\u{1F1EE}",
  "flag-gl": "\u{1F1EC}\u{1F1F1}",
  "flag-gm": "\u{1F1EC}\u{1F1F2}",
  "flag-gn": "\u{1F1EC}\u{1F1F3}",
  "flag-gp": "\u{1F1EC}\u{1F1F5}",
  "flag-gq": "\u{1F1EC}\u{1F1F6}",
  "flag-gr": "\u{1F1EC}\u{1F1F7}",
  "flag-gs": "\u{1F1EC}\u{1F1F8}",
  "flag-gt": "\u{1F1EC}\u{1F1F9}",
  "flag-gu": "\u{1F1EC}\u{1F1FA}",
  "flag-gw": "\u{1F1EC}\u{1F1FC}",
  "flag-gy": "\u{1F1EC}\u{1F1FE}",
  "flag-hk": "\u{1F1ED}\u{1F1F0}",
  "flag-hm": "\u{1F1ED}\u{1F1F2}",
  "flag-hn": "\u{1F1ED}\u{1F1F3}",
  "flag-hr": "\u{1F1ED}\u{1F1F7}",
  "flag-ht": "\u{1F1ED}\u{1F1F9}",
  "flag-hu": "\u{1F1ED}\u{1F1FA}",
  "flag-ic": "\u{1F1EE}\u{1F1E8}",
  "flag-id": "\u{1F1EE}\u{1F1E9}",
  "flag-ie": "\u{1F1EE}\u{1F1EA}",
  "flag-il": "\u{1F1EE}\u{1F1F1}",
  "flag-im": "\u{1F1EE}\u{1F1F2}",
  "flag-in": "\u{1F1EE}\u{1F1F3}",
  "flag-io": "\u{1F1EE}\u{1F1F4}",
  "flag-iq": "\u{1F1EE}\u{1F1F6}",
  "flag-ir": "\u{1F1EE}\u{1F1F7}",
  "flag-is": "\u{1F1EE}\u{1F1F8}",
  it,
  "flag-it": "\u{1F1EE}\u{1F1F9}",
  "flag-je": "\u{1F1EF}\u{1F1EA}",
  "flag-jm": "\u{1F1EF}\u{1F1F2}",
  "flag-jo": "\u{1F1EF}\u{1F1F4}",
  jp,
  "flag-jp": "\u{1F1EF}\u{1F1F5}",
  "flag-ke": "\u{1F1F0}\u{1F1EA}",
  "flag-kg": "\u{1F1F0}\u{1F1EC}",
  "flag-kh": "\u{1F1F0}\u{1F1ED}",
  "flag-ki": "\u{1F1F0}\u{1F1EE}",
  "flag-km": "\u{1F1F0}\u{1F1F2}",
  "flag-kn": "\u{1F1F0}\u{1F1F3}",
  "flag-kp": "\u{1F1F0}\u{1F1F5}",
  kr,
  "flag-kr": "\u{1F1F0}\u{1F1F7}",
  "flag-kw": "\u{1F1F0}\u{1F1FC}",
  "flag-ky": "\u{1F1F0}\u{1F1FE}",
  "flag-kz": "\u{1F1F0}\u{1F1FF}",
  "flag-la": "\u{1F1F1}\u{1F1E6}",
  "flag-lb": "\u{1F1F1}\u{1F1E7}",
  "flag-lc": "\u{1F1F1}\u{1F1E8}",
  "flag-li": "\u{1F1F1}\u{1F1EE}",
  "flag-lk": "\u{1F1F1}\u{1F1F0}",
  "flag-lr": "\u{1F1F1}\u{1F1F7}",
  "flag-ls": "\u{1F1F1}\u{1F1F8}",
  "flag-lt": "\u{1F1F1}\u{1F1F9}",
  "flag-lu": "\u{1F1F1}\u{1F1FA}",
  "flag-lv": "\u{1F1F1}\u{1F1FB}",
  "flag-ly": "\u{1F1F1}\u{1F1FE}",
  "flag-ma": "\u{1F1F2}\u{1F1E6}",
  "flag-mc": "\u{1F1F2}\u{1F1E8}",
  "flag-md": "\u{1F1F2}\u{1F1E9}",
  "flag-me": "\u{1F1F2}\u{1F1EA}",
  "flag-mf": "\u{1F1F2}\u{1F1EB}",
  "flag-mg": "\u{1F1F2}\u{1F1EC}",
  "flag-mh": "\u{1F1F2}\u{1F1ED}",
  "flag-mk": "\u{1F1F2}\u{1F1F0}",
  "flag-ml": "\u{1F1F2}\u{1F1F1}",
  "flag-mm": "\u{1F1F2}\u{1F1F2}",
  "flag-mn": "\u{1F1F2}\u{1F1F3}",
  "flag-mo": "\u{1F1F2}\u{1F1F4}",
  "flag-mp": "\u{1F1F2}\u{1F1F5}",
  "flag-mq": "\u{1F1F2}\u{1F1F6}",
  "flag-mr": "\u{1F1F2}\u{1F1F7}",
  "flag-ms": "\u{1F1F2}\u{1F1F8}",
  "flag-mt": "\u{1F1F2}\u{1F1F9}",
  "flag-mu": "\u{1F1F2}\u{1F1FA}",
  "flag-mv": "\u{1F1F2}\u{1F1FB}",
  "flag-mw": "\u{1F1F2}\u{1F1FC}",
  "flag-mx": "\u{1F1F2}\u{1F1FD}",
  "flag-my": "\u{1F1F2}\u{1F1FE}",
  "flag-mz": "\u{1F1F2}\u{1F1FF}",
  "flag-na": "\u{1F1F3}\u{1F1E6}",
  "flag-nc": "\u{1F1F3}\u{1F1E8}",
  "flag-ne": "\u{1F1F3}\u{1F1EA}",
  "flag-nf": "\u{1F1F3}\u{1F1EB}",
  "flag-ng": "\u{1F1F3}\u{1F1EC}",
  "flag-ni": "\u{1F1F3}\u{1F1EE}",
  "flag-nl": "\u{1F1F3}\u{1F1F1}",
  "flag-no": "\u{1F1F3}\u{1F1F4}",
  "flag-np": "\u{1F1F3}\u{1F1F5}",
  "flag-nr": "\u{1F1F3}\u{1F1F7}",
  "flag-nu": "\u{1F1F3}\u{1F1FA}",
  "flag-nz": "\u{1F1F3}\u{1F1FF}",
  "flag-om": "\u{1F1F4}\u{1F1F2}",
  "flag-pa": "\u{1F1F5}\u{1F1E6}",
  "flag-pe": "\u{1F1F5}\u{1F1EA}",
  "flag-pf": "\u{1F1F5}\u{1F1EB}",
  "flag-pg": "\u{1F1F5}\u{1F1EC}",
  "flag-ph": "\u{1F1F5}\u{1F1ED}",
  "flag-pk": "\u{1F1F5}\u{1F1F0}",
  "flag-pl": "\u{1F1F5}\u{1F1F1}",
  "flag-pm": "\u{1F1F5}\u{1F1F2}",
  "flag-pn": "\u{1F1F5}\u{1F1F3}",
  "flag-pr": "\u{1F1F5}\u{1F1F7}",
  "flag-ps": "\u{1F1F5}\u{1F1F8}",
  "flag-pt": "\u{1F1F5}\u{1F1F9}",
  "flag-pw": "\u{1F1F5}\u{1F1FC}",
  "flag-py": "\u{1F1F5}\u{1F1FE}",
  "flag-qa": "\u{1F1F6}\u{1F1E6}",
  "flag-re": "\u{1F1F7}\u{1F1EA}",
  "flag-ro": "\u{1F1F7}\u{1F1F4}",
  "flag-rs": "\u{1F1F7}\u{1F1F8}",
  ru,
  "flag-ru": "\u{1F1F7}\u{1F1FA}",
  "flag-rw": "\u{1F1F7}\u{1F1FC}",
  "flag-sa": "\u{1F1F8}\u{1F1E6}",
  "flag-sb": "\u{1F1F8}\u{1F1E7}",
  "flag-sc": "\u{1F1F8}\u{1F1E8}",
  "flag-sd": "\u{1F1F8}\u{1F1E9}",
  "flag-se": "\u{1F1F8}\u{1F1EA}",
  "flag-sg": "\u{1F1F8}\u{1F1EC}",
  "flag-sh": "\u{1F1F8}\u{1F1ED}",
  "flag-si": "\u{1F1F8}\u{1F1EE}",
  "flag-sj": "\u{1F1F8}\u{1F1EF}",
  "flag-sk": "\u{1F1F8}\u{1F1F0}",
  "flag-sl": "\u{1F1F8}\u{1F1F1}",
  "flag-sm": "\u{1F1F8}\u{1F1F2}",
  "flag-sn": "\u{1F1F8}\u{1F1F3}",
  "flag-so": "\u{1F1F8}\u{1F1F4}",
  "flag-sr": "\u{1F1F8}\u{1F1F7}",
  "flag-ss": "\u{1F1F8}\u{1F1F8}",
  "flag-st": "\u{1F1F8}\u{1F1F9}",
  "flag-sv": "\u{1F1F8}\u{1F1FB}",
  "flag-sx": "\u{1F1F8}\u{1F1FD}",
  "flag-sy": "\u{1F1F8}\u{1F1FE}",
  "flag-sz": "\u{1F1F8}\u{1F1FF}",
  "flag-ta": "\u{1F1F9}\u{1F1E6}",
  "flag-tc": "\u{1F1F9}\u{1F1E8}",
  "flag-td": "\u{1F1F9}\u{1F1E9}",
  "flag-tf": "\u{1F1F9}\u{1F1EB}",
  "flag-tg": "\u{1F1F9}\u{1F1EC}",
  "flag-th": "\u{1F1F9}\u{1F1ED}",
  "flag-tj": "\u{1F1F9}\u{1F1EF}",
  "flag-tk": "\u{1F1F9}\u{1F1F0}",
  "flag-tl": "\u{1F1F9}\u{1F1F1}",
  "flag-tm": "\u{1F1F9}\u{1F1F2}",
  "flag-tn": "\u{1F1F9}\u{1F1F3}",
  "flag-to": "\u{1F1F9}\u{1F1F4}",
  "flag-tr": "\u{1F1F9}\u{1F1F7}",
  "flag-tt": "\u{1F1F9}\u{1F1F9}",
  "flag-tv": "\u{1F1F9}\u{1F1FB}",
  "flag-tw": "\u{1F1F9}\u{1F1FC}",
  "flag-tz": "\u{1F1F9}\u{1F1FF}",
  "flag-ua": "\u{1F1FA}\u{1F1E6}",
  "flag-ug": "\u{1F1FA}\u{1F1EC}",
  "flag-um": "\u{1F1FA}\u{1F1F2}",
  "flag-un": "\u{1F1FA}\u{1F1F3}",
  us,
  "flag-us": "\u{1F1FA}\u{1F1F8}",
  "flag-uy": "\u{1F1FA}\u{1F1FE}",
  "flag-uz": "\u{1F1FA}\u{1F1FF}",
  "flag-va": "\u{1F1FB}\u{1F1E6}",
  "flag-vc": "\u{1F1FB}\u{1F1E8}",
  "flag-ve": "\u{1F1FB}\u{1F1EA}",
  "flag-vg": "\u{1F1FB}\u{1F1EC}",
  "flag-vi": "\u{1F1FB}\u{1F1EE}",
  "flag-vn": "\u{1F1FB}\u{1F1F3}",
  "flag-vu": "\u{1F1FB}\u{1F1FA}",
  "flag-wf": "\u{1F1FC}\u{1F1EB}",
  "flag-ws": "\u{1F1FC}\u{1F1F8}",
  "flag-xk": "\u{1F1FD}\u{1F1F0}",
  "flag-ye": "\u{1F1FE}\u{1F1EA}",
  "flag-yt": "\u{1F1FE}\u{1F1F9}",
  "flag-za": "\u{1F1FF}\u{1F1E6}",
  "flag-zm": "\u{1F1FF}\u{1F1F2}",
  "flag-zw": "\u{1F1FF}\u{1F1FC}",
  koko,
  sa,
  u7121,
  u6307,
  u7981,
  u7a7a,
  u5408,
  u6e80,
  u6709,
  u6708,
  u7533,
  u5272,
  u55b6,
  ideograph_advantage,
  accept,
  cyclone,
  foggy,
  closed_umbrella,
  night_with_stars,
  sunrise_over_mountains,
  sunrise,
  city_sunset,
  city_sunrise,
  rainbow,
  bridge_at_night,
  ocean,
  volcano,
  milky_way,
  earth_africa,
  earth_americas,
  earth_asia,
  globe_with_meridians,
  new_moon,
  waxing_crescent_moon,
  first_quarter_moon,
  moon,
  waxing_gibbous_moon,
  full_moon,
  waning_gibbous_moon,
  last_quarter_moon,
  waning_crescent_moon,
  crescent_moon,
  new_moon_with_face,
  first_quarter_moon_with_face,
  last_quarter_moon_with_face,
  full_moon_with_face,
  sun_with_face,
  star2,
  stars,
  thermometer,
  mostly_sunny,
  sun_small_cloud,
  barely_sunny,
  sun_behind_cloud,
  partly_sunny_rain,
  sun_behind_rain_cloud,
  rain_cloud,
  snow_cloud,
  lightning,
  lightning_cloud,
  tornado,
  tornado_cloud,
  fog,
  wind_blowing_face,
  hotdog,
  taco,
  burrito,
  chestnut,
  seedling,
  evergreen_tree,
  deciduous_tree,
  palm_tree,
  cactus,
  hot_pepper,
  tulip,
  cherry_blossom,
  rose,
  hibiscus,
  sunflower,
  blossom,
  corn,
  ear_of_rice,
  herb,
  four_leaf_clover,
  maple_leaf,
  fallen_leaf,
  leaves,
  mushroom,
  tomato,
  eggplant,
  grapes,
  melon,
  watermelon,
  tangerine,
  lemon,
  banana,
  pineapple,
  apple,
  green_apple,
  pear,
  peach,
  cherries,
  strawberry,
  hamburger,
  pizza,
  meat_on_bone,
  poultry_leg,
  rice_cracker,
  rice_ball,
  rice,
  curry,
  ramen,
  spaghetti,
  bread,
  fries,
  sweet_potato,
  dango,
  oden,
  sushi,
  fried_shrimp,
  fish_cake,
  icecream,
  shaved_ice,
  ice_cream,
  doughnut,
  cookie,
  chocolate_bar,
  candy,
  lollipop,
  custard,
  honey_pot,
  cake,
  bento,
  stew,
  fried_egg,
  cooking,
  fork_and_knife,
  tea,
  sake,
  wine_glass,
  cocktail,
  tropical_drink,
  beer,
  beers,
  baby_bottle,
  knife_fork_plate,
  champagne,
  popcorn,
  ribbon,
  gift,
  birthday,
  jack_o_lantern,
  christmas_tree,
  santa,
  fireworks,
  sparkler,
  balloon,
  tada,
  confetti_ball,
  tanabata_tree,
  crossed_flags,
  bamboo,
  dolls,
  flags,
  wind_chime,
  rice_scene,
  school_satchel,
  mortar_board,
  medal,
  reminder_ribbon,
  studio_microphone,
  level_slider,
  control_knobs,
  film_frames,
  admission_tickets,
  carousel_horse,
  ferris_wheel,
  roller_coaster,
  fishing_pole_and_fish,
  microphone,
  movie_camera,
  cinema,
  headphones,
  art,
  tophat,
  circus_tent,
  ticket,
  clapper,
  performing_arts,
  video_game,
  dart,
  slot_machine,
  "8ball": "\u{1F3B1}",
  game_die,
  bowling,
  flower_playing_cards,
  musical_note,
  notes,
  saxophone,
  guitar,
  musical_keyboard,
  trumpet,
  violin,
  musical_score,
  running_shirt_with_sash,
  tennis,
  ski,
  basketball,
  checkered_flag,
  snowboarder,
  "woman-running": "\u{1F3C3}\u200D\u2640\uFE0F",
  "man-running": "\u{1F3C3}\u200D\u2642\uFE0F",
  runner,
  running,
  "woman-surfing": "\u{1F3C4}\u200D\u2640\uFE0F",
  "man-surfing": "\u{1F3C4}\u200D\u2642\uFE0F",
  surfer,
  sports_medal,
  trophy,
  horse_racing,
  football,
  rugby_football,
  "woman-swimming": "\u{1F3CA}\u200D\u2640\uFE0F",
  "man-swimming": "\u{1F3CA}\u200D\u2642\uFE0F",
  swimmer,
  "woman-lifting-weights": "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
  "man-lifting-weights": "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
  weight_lifter,
  "woman-golfing": "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
  "man-golfing": "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
  golfer,
  racing_motorcycle,
  racing_car,
  cricket_bat_and_ball,
  volleyball,
  field_hockey_stick_and_ball,
  ice_hockey_stick_and_puck,
  table_tennis_paddle_and_ball,
  snow_capped_mountain,
  camping,
  beach_with_umbrella,
  building_construction,
  house_buildings,
  cityscape,
  derelict_house_building,
  classical_building,
  desert,
  desert_island,
  national_park,
  stadium,
  house,
  house_with_garden,
  office,
  post_office,
  european_post_office,
  hospital,
  bank,
  atm,
  hotel,
  love_hotel,
  convenience_store,
  school,
  department_store,
  factory,
  izakaya_lantern,
  lantern,
  japanese_castle,
  european_castle,
  "rainbow-flag": "\u{1F3F3}\uFE0F\u200D\u{1F308}",
  transgender_flag,
  waving_white_flag,
  pirate_flag,
  "flag-england": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
  "flag-scotland": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
  "flag-wales": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}",
  waving_black_flag,
  rosette,
  label,
  badminton_racquet_and_shuttlecock,
  bow_and_arrow,
  amphora,
  "skin-tone-2": "\u{1F3FB}",
  "skin-tone-3": "\u{1F3FC}",
  "skin-tone-4": "\u{1F3FD}",
  "skin-tone-5": "\u{1F3FE}",
  "skin-tone-6": "\u{1F3FF}",
  rat,
  mouse2,
  ox,
  water_buffalo,
  cow2,
  tiger2,
  leopard,
  rabbit2,
  black_cat,
  cat2,
  dragon,
  crocodile,
  whale2,
  snail,
  snake,
  racehorse,
  ram,
  goat,
  sheep,
  monkey,
  rooster,
  chicken,
  service_dog,
  dog2,
  pig2,
  boar,
  elephant,
  octopus,
  shell,
  bug,
  ant,
  bee,
  honeybee,
  ladybug,
  lady_beetle,
  fish,
  tropical_fish,
  blowfish,
  turtle,
  hatching_chick,
  baby_chick,
  hatched_chick,
  bird,
  penguin,
  koala,
  poodle,
  dromedary_camel,
  camel,
  dolphin,
  flipper,
  mouse,
  cow,
  tiger,
  rabbit,
  cat,
  dragon_face,
  whale,
  horse,
  monkey_face,
  dog,
  pig,
  frog,
  hamster,
  wolf,
  polar_bear,
  bear,
  panda_face,
  pig_nose,
  feet,
  paw_prints,
  chipmunk,
  eyes,
  "eye-in-speech-bubble": "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F",
  eye,
  ear,
  nose,
  lips,
  tongue,
  point_up_2,
  point_down,
  point_left,
  point_right,
  facepunch,
  punch,
  wave,
  ok_hand,
  "+1": "\u{1F44D}",
  thumbsup,
  "-1": "\u{1F44E}",
  thumbsdown,
  clap,
  open_hands,
  crown,
  womans_hat,
  eyeglasses,
  necktie,
  shirt,
  tshirt,
  jeans,
  dress,
  kimono,
  bikini,
  womans_clothes,
  purse,
  handbag,
  pouch,
  mans_shoe,
  shoe,
  athletic_shoe,
  high_heel,
  sandal,
  boot,
  footprints,
  bust_in_silhouette,
  busts_in_silhouette,
  boy,
  girl,
  "male-farmer": "\u{1F468}\u200D\u{1F33E}",
  "male-cook": "\u{1F468}\u200D\u{1F373}",
  man_feeding_baby,
  "male-student": "\u{1F468}\u200D\u{1F393}",
  "male-singer": "\u{1F468}\u200D\u{1F3A4}",
  "male-artist": "\u{1F468}\u200D\u{1F3A8}",
  "male-teacher": "\u{1F468}\u200D\u{1F3EB}",
  "male-factory-worker": "\u{1F468}\u200D\u{1F3ED}",
  "man-boy-boy": "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
  "man-boy": "\u{1F468}\u200D\u{1F466}",
  "man-girl-boy": "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
  "man-girl-girl": "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
  "man-girl": "\u{1F468}\u200D\u{1F467}",
  "man-man-boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
  "man-man-boy-boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
  "man-man-girl": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
  "man-man-girl-boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
  "man-man-girl-girl": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
  "man-woman-boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
  family,
  "man-woman-boy-boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
  "man-woman-girl": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
  "man-woman-girl-boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
  "man-woman-girl-girl": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
  "male-technologist": "\u{1F468}\u200D\u{1F4BB}",
  "male-office-worker": "\u{1F468}\u200D\u{1F4BC}",
  "male-mechanic": "\u{1F468}\u200D\u{1F527}",
  "male-scientist": "\u{1F468}\u200D\u{1F52C}",
  "male-astronaut": "\u{1F468}\u200D\u{1F680}",
  "male-firefighter": "\u{1F468}\u200D\u{1F692}",
  man_with_probing_cane,
  red_haired_man,
  curly_haired_man,
  bald_man,
  white_haired_man,
  man_in_motorized_wheelchair,
  man_in_manual_wheelchair,
  "male-doctor": "\u{1F468}\u200D\u2695\uFE0F",
  "male-judge": "\u{1F468}\u200D\u2696\uFE0F",
  "male-pilot": "\u{1F468}\u200D\u2708\uFE0F",
  "man-heart-man": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
  "man-kiss-man": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
  man,
  "female-farmer": "\u{1F469}\u200D\u{1F33E}",
  "female-cook": "\u{1F469}\u200D\u{1F373}",
  woman_feeding_baby,
  "female-student": "\u{1F469}\u200D\u{1F393}",
  "female-singer": "\u{1F469}\u200D\u{1F3A4}",
  "female-artist": "\u{1F469}\u200D\u{1F3A8}",
  "female-teacher": "\u{1F469}\u200D\u{1F3EB}",
  "female-factory-worker": "\u{1F469}\u200D\u{1F3ED}",
  "woman-boy-boy": "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
  "woman-boy": "\u{1F469}\u200D\u{1F466}",
  "woman-girl-boy": "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
  "woman-girl-girl": "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
  "woman-girl": "\u{1F469}\u200D\u{1F467}",
  "woman-woman-boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
  "woman-woman-boy-boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
  "woman-woman-girl": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
  "woman-woman-girl-boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
  "woman-woman-girl-girl": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
  "female-technologist": "\u{1F469}\u200D\u{1F4BB}",
  "female-office-worker": "\u{1F469}\u200D\u{1F4BC}",
  "female-mechanic": "\u{1F469}\u200D\u{1F527}",
  "female-scientist": "\u{1F469}\u200D\u{1F52C}",
  "female-astronaut": "\u{1F469}\u200D\u{1F680}",
  "female-firefighter": "\u{1F469}\u200D\u{1F692}",
  woman_with_probing_cane,
  red_haired_woman,
  curly_haired_woman,
  bald_woman,
  white_haired_woman,
  woman_in_motorized_wheelchair,
  woman_in_manual_wheelchair,
  "female-doctor": "\u{1F469}\u200D\u2695\uFE0F",
  "female-judge": "\u{1F469}\u200D\u2696\uFE0F",
  "female-pilot": "\u{1F469}\u200D\u2708\uFE0F",
  "woman-heart-man": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
  "woman-heart-woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
  "woman-kiss-man": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
  "woman-kiss-woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
  woman,
  man_and_woman_holding_hands,
  woman_and_man_holding_hands,
  couple,
  two_men_holding_hands,
  men_holding_hands,
  two_women_holding_hands,
  women_holding_hands,
  "female-police-officer": "\u{1F46E}\u200D\u2640\uFE0F",
  "male-police-officer": "\u{1F46E}\u200D\u2642\uFE0F",
  cop,
  "women-with-bunny-ears-partying": "\u{1F46F}\u200D\u2640\uFE0F",
  "woman-with-bunny-ears-partying": "\u{1F46F}\u200D\u2640\uFE0F",
  dancers,
  "men-with-bunny-ears-partying": "\u{1F46F}\u200D\u2642\uFE0F",
  "man-with-bunny-ears-partying": "\u{1F46F}\u200D\u2642\uFE0F",
  woman_with_veil,
  man_with_veil,
  bride_with_veil,
  "blond-haired-woman": "\u{1F471}\u200D\u2640\uFE0F",
  "blond-haired-man": "\u{1F471}\u200D\u2642\uFE0F",
  person_with_blond_hair,
  man_with_gua_pi_mao,
  "woman-wearing-turban": "\u{1F473}\u200D\u2640\uFE0F",
  "man-wearing-turban": "\u{1F473}\u200D\u2642\uFE0F",
  man_with_turban,
  older_man,
  older_woman,
  baby,
  "female-construction-worker": "\u{1F477}\u200D\u2640\uFE0F",
  "male-construction-worker": "\u{1F477}\u200D\u2642\uFE0F",
  construction_worker,
  princess,
  japanese_ogre,
  japanese_goblin,
  ghost,
  angel,
  alien,
  space_invader,
  imp,
  skull,
  "woman-tipping-hand": "\u{1F481}\u200D\u2640\uFE0F",
  information_desk_person,
  "man-tipping-hand": "\u{1F481}\u200D\u2642\uFE0F",
  "female-guard": "\u{1F482}\u200D\u2640\uFE0F",
  "male-guard": "\u{1F482}\u200D\u2642\uFE0F",
  guardsman,
  dancer,
  lipstick,
  nail_care,
  "woman-getting-massage": "\u{1F486}\u200D\u2640\uFE0F",
  massage,
  "man-getting-massage": "\u{1F486}\u200D\u2642\uFE0F",
  "woman-getting-haircut": "\u{1F487}\u200D\u2640\uFE0F",
  haircut,
  "man-getting-haircut": "\u{1F487}\u200D\u2642\uFE0F",
  barber,
  syringe,
  pill,
  kiss,
  love_letter,
  ring,
  gem,
  couplekiss,
  bouquet,
  couple_with_heart,
  wedding,
  heartbeat,
  broken_heart,
  two_hearts,
  sparkling_heart,
  heartpulse,
  cupid,
  blue_heart,
  green_heart,
  yellow_heart,
  purple_heart,
  gift_heart,
  revolving_hearts,
  heart_decoration,
  diamond_shape_with_a_dot_inside,
  bulb,
  anger,
  bomb,
  zzz,
  boom,
  collision,
  sweat_drops,
  droplet,
  dash,
  hankey,
  poop,
  shit,
  muscle,
  dizzy,
  speech_balloon,
  thought_balloon,
  white_flower,
  moneybag,
  currency_exchange,
  heavy_dollar_sign,
  credit_card,
  yen,
  dollar,
  euro,
  pound,
  money_with_wings,
  chart,
  seat,
  computer,
  briefcase,
  minidisc,
  floppy_disk,
  cd,
  dvd,
  file_folder,
  open_file_folder,
  page_with_curl,
  page_facing_up,
  date,
  calendar,
  card_index,
  chart_with_upwards_trend,
  chart_with_downwards_trend,
  bar_chart,
  clipboard,
  pushpin,
  round_pushpin,
  paperclip,
  straight_ruler,
  triangular_ruler,
  bookmark_tabs,
  ledger,
  notebook,
  notebook_with_decorative_cover,
  closed_book,
  book,
  open_book,
  green_book,
  blue_book,
  orange_book,
  books,
  name_badge,
  scroll,
  memo,
  pencil,
  telephone_receiver,
  pager,
  fax,
  satellite_antenna,
  loudspeaker,
  mega,
  outbox_tray,
  inbox_tray,
  "package": "\u{1F4E6}",
  "e-mail": "\u{1F4E7}",
  incoming_envelope,
  envelope_with_arrow,
  mailbox_closed,
  mailbox,
  mailbox_with_mail,
  mailbox_with_no_mail,
  postbox,
  postal_horn,
  newspaper,
  iphone,
  calling,
  vibration_mode,
  mobile_phone_off,
  no_mobile_phones,
  signal_strength,
  camera,
  camera_with_flash,
  video_camera,
  tv,
  radio,
  vhs,
  film_projector,
  prayer_beads,
  twisted_rightwards_arrows,
  repeat: repeat$1,
  repeat_one,
  arrows_clockwise,
  arrows_counterclockwise,
  low_brightness,
  high_brightness,
  mute,
  speaker,
  sound,
  loud_sound,
  battery,
  electric_plug,
  mag,
  mag_right,
  lock_with_ink_pen,
  closed_lock_with_key,
  key,
  lock,
  unlock,
  bell,
  no_bell,
  bookmark,
  link,
  radio_button,
  back,
  end: end2,
  on: on$1,
  soon,
  top,
  underage,
  keycap_ten,
  capital_abcd,
  abcd,
  symbols,
  abc,
  fire,
  flashlight,
  wrench,
  hammer,
  nut_and_bolt,
  hocho,
  knife,
  gun,
  microscope,
  telescope,
  crystal_ball,
  six_pointed_star,
  beginner,
  trident,
  black_square_button,
  white_square_button,
  red_circle,
  large_blue_circle,
  large_orange_diamond,
  large_blue_diamond,
  small_orange_diamond,
  small_blue_diamond,
  small_red_triangle,
  small_red_triangle_down,
  arrow_up_small,
  arrow_down_small,
  om_symbol,
  dove_of_peace,
  kaaba,
  mosque,
  synagogue,
  menorah_with_nine_branches,
  clock1,
  clock2,
  clock3,
  clock4,
  clock5,
  clock6,
  clock7,
  clock8,
  clock9,
  clock10,
  clock11,
  clock12,
  clock130,
  clock230,
  clock330,
  clock430,
  clock530,
  clock630,
  clock730,
  clock830,
  clock930,
  clock1030,
  clock1130,
  clock1230,
  candle,
  mantelpiece_clock,
  hole,
  man_in_business_suit_levitating,
  "female-detective": "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
  "male-detective": "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
  sleuth_or_spy,
  dark_sunglasses,
  spider,
  spider_web,
  joystick,
  man_dancing,
  linked_paperclips,
  lower_left_ballpoint_pen,
  lower_left_fountain_pen,
  lower_left_paintbrush,
  lower_left_crayon,
  raised_hand_with_fingers_splayed,
  middle_finger,
  reversed_hand_with_middle_finger_extended,
  "spock-hand": "\u{1F596}",
  black_heart,
  desktop_computer,
  printer,
  three_button_mouse,
  trackball,
  frame_with_picture,
  card_index_dividers,
  card_file_box,
  file_cabinet,
  wastebasket,
  spiral_note_pad,
  spiral_calendar_pad,
  compression,
  old_key,
  rolled_up_newspaper,
  dagger_knife,
  speaking_head_in_silhouette,
  left_speech_bubble,
  right_anger_bubble,
  ballot_box_with_ballot,
  world_map,
  mount_fuji,
  tokyo_tower,
  statue_of_liberty,
  japan,
  moyai,
  grinning,
  grin,
  joy,
  smiley,
  smile,
  sweat_smile,
  laughing,
  satisfied,
  innocent,
  smiling_imp,
  wink,
  blush,
  yum,
  relieved,
  heart_eyes,
  sunglasses,
  smirk,
  neutral_face,
  expressionless,
  unamused,
  sweat,
  pensive,
  confused,
  confounded,
  kissing,
  kissing_heart,
  kissing_smiling_eyes,
  kissing_closed_eyes,
  stuck_out_tongue,
  stuck_out_tongue_winking_eye,
  stuck_out_tongue_closed_eyes,
  disappointed,
  worried,
  angry,
  rage,
  cry,
  persevere,
  triumph,
  disappointed_relieved,
  frowning,
  anguished,
  fearful,
  weary,
  sleepy,
  tired_face,
  grimacing,
  sob,
  face_exhaling,
  open_mouth,
  hushed,
  cold_sweat,
  scream,
  astonished,
  flushed,
  sleeping,
  face_with_spiral_eyes,
  dizzy_face,
  face_in_clouds,
  no_mouth,
  mask,
  smile_cat,
  joy_cat,
  smiley_cat,
  heart_eyes_cat,
  smirk_cat,
  kissing_cat,
  pouting_cat,
  crying_cat_face,
  scream_cat,
  slightly_frowning_face,
  slightly_smiling_face,
  upside_down_face,
  face_with_rolling_eyes,
  "woman-gesturing-no": "\u{1F645}\u200D\u2640\uFE0F",
  no_good,
  "man-gesturing-no": "\u{1F645}\u200D\u2642\uFE0F",
  "woman-gesturing-ok": "\u{1F646}\u200D\u2640\uFE0F",
  ok_woman,
  "man-gesturing-ok": "\u{1F646}\u200D\u2642\uFE0F",
  "woman-bowing": "\u{1F647}\u200D\u2640\uFE0F",
  "man-bowing": "\u{1F647}\u200D\u2642\uFE0F",
  bow,
  see_no_evil,
  hear_no_evil,
  speak_no_evil,
  "woman-raising-hand": "\u{1F64B}\u200D\u2640\uFE0F",
  raising_hand,
  "man-raising-hand": "\u{1F64B}\u200D\u2642\uFE0F",
  raised_hands,
  "woman-frowning": "\u{1F64D}\u200D\u2640\uFE0F",
  person_frowning,
  "man-frowning": "\u{1F64D}\u200D\u2642\uFE0F",
  "woman-pouting": "\u{1F64E}\u200D\u2640\uFE0F",
  person_with_pouting_face,
  "man-pouting": "\u{1F64E}\u200D\u2642\uFE0F",
  pray,
  rocket,
  helicopter,
  steam_locomotive,
  railway_car,
  bullettrain_side,
  bullettrain_front,
  train2,
  metro,
  light_rail,
  station,
  tram,
  train,
  bus,
  oncoming_bus,
  trolleybus,
  busstop,
  minibus,
  ambulance,
  fire_engine,
  police_car,
  oncoming_police_car,
  taxi,
  oncoming_taxi,
  car,
  red_car,
  oncoming_automobile,
  blue_car,
  truck,
  articulated_lorry,
  tractor,
  monorail,
  mountain_railway,
  suspension_railway,
  mountain_cableway,
  aerial_tramway,
  ship,
  "woman-rowing-boat": "\u{1F6A3}\u200D\u2640\uFE0F",
  "man-rowing-boat": "\u{1F6A3}\u200D\u2642\uFE0F",
  rowboat,
  speedboat,
  traffic_light,
  vertical_traffic_light,
  construction,
  rotating_light,
  triangular_flag_on_post,
  door,
  no_entry_sign,
  smoking,
  no_smoking,
  put_litter_in_its_place,
  do_not_litter,
  potable_water,
  "non-potable_water": "\u{1F6B1}",
  bike,
  no_bicycles,
  "woman-biking": "\u{1F6B4}\u200D\u2640\uFE0F",
  "man-biking": "\u{1F6B4}\u200D\u2642\uFE0F",
  bicyclist,
  "woman-mountain-biking": "\u{1F6B5}\u200D\u2640\uFE0F",
  "man-mountain-biking": "\u{1F6B5}\u200D\u2642\uFE0F",
  mountain_bicyclist,
  "woman-walking": "\u{1F6B6}\u200D\u2640\uFE0F",
  "man-walking": "\u{1F6B6}\u200D\u2642\uFE0F",
  walking,
  no_pedestrians,
  children_crossing,
  mens,
  womens,
  restroom,
  baby_symbol,
  toilet,
  wc,
  shower,
  bath,
  bathtub,
  passport_control,
  customs,
  baggage_claim,
  left_luggage,
  couch_and_lamp,
  sleeping_accommodation,
  shopping_bags,
  bellhop_bell,
  bed,
  place_of_worship,
  octagonal_sign,
  shopping_trolley,
  hindu_temple,
  hut,
  elevator,
  hammer_and_wrench,
  shield,
  oil_drum,
  motorway,
  railway_track,
  motor_boat,
  small_airplane,
  airplane_departure,
  airplane_arriving,
  satellite,
  passenger_ship,
  scooter,
  motor_scooter,
  canoe,
  sled,
  flying_saucer,
  skateboard,
  auto_rickshaw,
  pickup_truck,
  roller_skate,
  large_orange_circle,
  large_yellow_circle,
  large_green_circle,
  large_purple_circle,
  large_brown_circle,
  large_red_square,
  large_blue_square,
  large_orange_square,
  large_yellow_square,
  large_green_square,
  large_purple_square,
  large_brown_square,
  pinched_fingers,
  white_heart,
  brown_heart,
  pinching_hand,
  zipper_mouth_face,
  money_mouth_face,
  face_with_thermometer,
  nerd_face,
  thinking_face,
  face_with_head_bandage,
  robot_face,
  hugging_face,
  the_horns,
  sign_of_the_horns,
  call_me_hand,
  raised_back_of_hand,
  "left-facing_fist": "\u{1F91B}",
  "right-facing_fist": "\u{1F91C}",
  handshake,
  crossed_fingers,
  hand_with_index_and_middle_fingers_crossed,
  i_love_you_hand_sign,
  face_with_cowboy_hat,
  clown_face,
  nauseated_face,
  rolling_on_the_floor_laughing,
  drooling_face,
  lying_face,
  "woman-facepalming": "\u{1F926}\u200D\u2640\uFE0F",
  "man-facepalming": "\u{1F926}\u200D\u2642\uFE0F",
  face_palm,
  sneezing_face,
  face_with_raised_eyebrow,
  face_with_one_eyebrow_raised,
  "star-struck": "\u{1F929}",
  grinning_face_with_star_eyes,
  zany_face,
  grinning_face_with_one_large_and_one_small_eye,
  shushing_face,
  face_with_finger_covering_closed_lips,
  face_with_symbols_on_mouth,
  serious_face_with_symbols_covering_mouth,
  face_with_hand_over_mouth,
  smiling_face_with_smiling_eyes_and_hand_covering_mouth,
  face_vomiting,
  face_with_open_mouth_vomiting,
  exploding_head,
  shocked_face_with_exploding_head,
  pregnant_woman,
  "breast-feeding": "\u{1F931}",
  palms_up_together,
  selfie,
  prince,
  woman_in_tuxedo,
  man_in_tuxedo,
  person_in_tuxedo,
  mrs_claus,
  mother_christmas,
  "woman-shrugging": "\u{1F937}\u200D\u2640\uFE0F",
  "man-shrugging": "\u{1F937}\u200D\u2642\uFE0F",
  shrug,
  "woman-cartwheeling": "\u{1F938}\u200D\u2640\uFE0F",
  "man-cartwheeling": "\u{1F938}\u200D\u2642\uFE0F",
  person_doing_cartwheel,
  "woman-juggling": "\u{1F939}\u200D\u2640\uFE0F",
  "man-juggling": "\u{1F939}\u200D\u2642\uFE0F",
  juggling,
  fencer,
  "woman-wrestling": "\u{1F93C}\u200D\u2640\uFE0F",
  "man-wrestling": "\u{1F93C}\u200D\u2642\uFE0F",
  wrestlers,
  "woman-playing-water-polo": "\u{1F93D}\u200D\u2640\uFE0F",
  "man-playing-water-polo": "\u{1F93D}\u200D\u2642\uFE0F",
  water_polo,
  "woman-playing-handball": "\u{1F93E}\u200D\u2640\uFE0F",
  "man-playing-handball": "\u{1F93E}\u200D\u2642\uFE0F",
  handball,
  diving_mask,
  wilted_flower,
  drum_with_drumsticks,
  clinking_glasses,
  tumbler_glass,
  spoon,
  goal_net,
  first_place_medal,
  second_place_medal,
  third_place_medal,
  boxing_glove,
  martial_arts_uniform,
  curling_stone,
  lacrosse,
  softball,
  flying_disc,
  croissant,
  avocado,
  cucumber,
  bacon,
  potato,
  carrot,
  baguette_bread,
  green_salad,
  shallow_pan_of_food,
  stuffed_flatbread,
  egg,
  glass_of_milk,
  peanuts,
  kiwifruit,
  pancakes,
  dumpling,
  fortune_cookie,
  takeout_box,
  chopsticks,
  bowl_with_spoon,
  cup_with_straw,
  coconut,
  broccoli,
  pie,
  pretzel,
  cut_of_meat,
  sandwich,
  canned_food,
  leafy_green,
  mango,
  moon_cake,
  bagel,
  smiling_face_with_3_hearts,
  yawning_face,
  smiling_face_with_tear,
  partying_face,
  woozy_face,
  hot_face,
  cold_face,
  ninja,
  disguised_face,
  pleading_face,
  sari,
  lab_coat,
  goggles,
  hiking_boot,
  womans_flat_shoe,
  crab,
  lion_face,
  scorpion,
  turkey,
  unicorn_face,
  eagle,
  duck,
  bat,
  shark,
  owl,
  fox_face,
  butterfly,
  deer,
  gorilla,
  lizard,
  rhinoceros,
  shrimp,
  squid,
  giraffe_face,
  zebra_face,
  hedgehog,
  sauropod,
  "t-rex": "\u{1F996}",
  cricket,
  kangaroo,
  llama,
  peacock,
  hippopotamus,
  parrot,
  raccoon,
  lobster,
  mosquito,
  microbe,
  badger,
  swan,
  mammoth,
  dodo,
  sloth,
  otter,
  orangutan,
  skunk,
  flamingo,
  oyster,
  beaver,
  bison,
  seal,
  guide_dog,
  probing_cane,
  bone,
  leg,
  foot,
  tooth,
  female_superhero,
  male_superhero,
  superhero,
  female_supervillain,
  male_supervillain,
  supervillain,
  safety_vest,
  ear_with_hearing_aid,
  motorized_wheelchair,
  manual_wheelchair,
  mechanical_arm,
  mechanical_leg,
  cheese_wedge,
  cupcake,
  salt,
  beverage_box,
  garlic,
  onion,
  falafel,
  waffle,
  butter,
  mate_drink,
  ice_cube,
  bubble_tea,
  woman_standing,
  man_standing,
  standing_person,
  woman_kneeling,
  man_kneeling,
  kneeling_person,
  deaf_woman,
  deaf_man,
  deaf_person,
  face_with_monocle,
  farmer,
  cook,
  person_feeding_baby,
  mx_claus,
  student,
  singer,
  artist,
  teacher,
  factory_worker,
  technologist,
  office_worker,
  mechanic,
  scientist,
  astronaut,
  firefighter,
  people_holding_hands,
  person_with_probing_cane,
  red_haired_person,
  curly_haired_person,
  bald_person,
  white_haired_person,
  person_in_motorized_wheelchair,
  person_in_manual_wheelchair,
  health_worker,
  judge,
  pilot,
  adult,
  child: child3,
  older_adult,
  woman_with_beard,
  man_with_beard,
  bearded_person,
  person_with_headscarf,
  woman_in_steamy_room,
  man_in_steamy_room,
  person_in_steamy_room,
  woman_climbing,
  person_climbing,
  man_climbing,
  woman_in_lotus_position,
  person_in_lotus_position,
  man_in_lotus_position,
  female_mage,
  mage,
  male_mage,
  female_fairy,
  fairy,
  male_fairy,
  female_vampire,
  vampire,
  male_vampire,
  mermaid,
  merman,
  merperson,
  female_elf,
  male_elf,
  elf,
  female_genie,
  male_genie,
  genie,
  female_zombie,
  male_zombie,
  zombie,
  brain,
  orange_heart,
  billed_cap,
  scarf,
  gloves,
  coat,
  socks,
  red_envelope,
  firecracker,
  jigsaw,
  test_tube,
  petri_dish,
  dna,
  compass,
  abacus,
  fire_extinguisher,
  toolbox,
  bricks,
  magnet,
  luggage,
  lotion_bottle,
  thread,
  yarn,
  safety_pin,
  teddy_bear,
  broom,
  basket,
  roll_of_paper,
  soap,
  sponge,
  receipt,
  nazar_amulet,
  ballet_shoes,
  "one-piece_swimsuit": "\u{1FA71}",
  briefs,
  shorts,
  thong_sandal,
  drop_of_blood,
  adhesive_bandage,
  stethoscope,
  "yo-yo": "\u{1FA80}",
  kite,
  parachute,
  boomerang,
  magic_wand,
  pinata,
  nesting_dolls,
  ringed_planet,
  chair,
  razor,
  axe,
  diya_lamp,
  banjo,
  military_helmet,
  accordion,
  long_drum,
  coin,
  carpentry_saw,
  screwdriver,
  ladder,
  hook,
  mirror,
  window: window$1,
  plunger,
  sewing_needle,
  knot,
  bucket,
  mouse_trap,
  toothbrush,
  headstone,
  placard,
  rock,
  fly,
  worm,
  beetle,
  cockroach,
  potted_plant,
  wood,
  feather,
  anatomical_heart,
  lungs,
  people_hugging,
  blueberries,
  bell_pepper,
  olive,
  flatbread,
  tamale,
  fondue,
  teapot,
  bangbang,
  interrobang,
  tm,
  information_source,
  left_right_arrow,
  arrow_up_down,
  arrow_upper_left,
  arrow_upper_right,
  arrow_lower_right,
  arrow_lower_left,
  leftwards_arrow_with_hook,
  arrow_right_hook,
  watch,
  hourglass,
  keyboard,
  eject,
  fast_forward,
  rewind,
  arrow_double_up,
  arrow_double_down,
  black_right_pointing_double_triangle_with_vertical_bar,
  black_left_pointing_double_triangle_with_vertical_bar,
  black_right_pointing_triangle_with_double_vertical_bar,
  alarm_clock,
  stopwatch,
  timer_clock,
  hourglass_flowing_sand,
  double_vertical_bar,
  black_square_for_stop,
  black_circle_for_record,
  m: m$1,
  black_small_square,
  white_small_square,
  arrow_forward,
  arrow_backward,
  white_medium_square,
  black_medium_square,
  white_medium_small_square,
  black_medium_small_square,
  sunny,
  cloud,
  umbrella,
  snowman,
  comet,
  phone,
  telephone,
  ballot_box_with_check,
  shamrock,
  point_up,
  skull_and_crossbones,
  radioactive_sign,
  biohazard_sign,
  orthodox_cross,
  star_and_crescent,
  peace_symbol,
  yin_yang,
  wheel_of_dharma,
  white_frowning_face,
  relaxed,
  female_sign,
  male_sign,
  gemini,
  cancer,
  leo,
  virgo,
  libra,
  scorpius,
  chess_pawn,
  spades,
  clubs,
  hearts,
  diamonds,
  hotsprings,
  recycle,
  infinity,
  wheelchair,
  hammer_and_pick,
  crossed_swords,
  medical_symbol,
  staff_of_aesculapius,
  scales,
  alembic,
  gear,
  atom_symbol,
  fleur_de_lis,
  warning,
  zap,
  transgender_symbol,
  white_circle,
  black_circle,
  coffin,
  funeral_urn,
  soccer,
  baseball,
  snowman_without_snow,
  partly_sunny,
  thunder_cloud_and_rain,
  ophiuchus,
  pick,
  helmet_with_white_cross,
  chains,
  no_entry,
  shinto_shrine,
  church,
  mountain,
  umbrella_on_ground,
  fountain,
  golf,
  ferry,
  boat,
  sailboat,
  skier,
  ice_skate,
  "woman-bouncing-ball": "\u26F9\uFE0F\u200D\u2640\uFE0F",
  "man-bouncing-ball": "\u26F9\uFE0F\u200D\u2642\uFE0F",
  person_with_ball,
  tent,
  fuelpump,
  scissors,
  airplane,
  email,
  envelope,
  fist,
  hand,
  raised_hand,
  v: v$1,
  writing_hand,
  pencil2,
  black_nib,
  heavy_check_mark,
  heavy_multiplication_x,
  latin_cross,
  star_of_david,
  eight_spoked_asterisk,
  eight_pointed_black_star,
  snowflake,
  sparkle,
  x: x$1,
  negative_squared_cross_mark,
  heavy_heart_exclamation_mark_ornament,
  heart_on_fire,
  mending_heart,
  heart,
  arrow_right,
  curly_loop,
  loop,
  arrow_heading_up,
  arrow_heading_down,
  arrow_left,
  arrow_up,
  arrow_down,
  black_large_square,
  white_large_square,
  star,
  o: o$1,
  wavy_dash,
  part_alternation_mark,
  congratulations,
  secret
};
var toArray = toArray_1;
var emojiByName = require$$1;
var emojiNameRegex = /:([a-zA-Z0-9_\-\+]+):/g;
var trimSpaceRegex = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
function stripColons(str) {
  var colonIndex = str.indexOf(":");
  if (colonIndex > -1) {
    if (colonIndex === str.length - 1) {
      str = str.substring(0, colonIndex);
      return stripColons(str);
    } else {
      str = str.substr(colonIndex + 1);
      return stripColons(str);
    }
  }
  return str;
}
function wrapColons(str) {
  return typeof str === "string" && str.length > 0 ? ":" + str + ":" : str;
}
function ensureColons(str) {
  return typeof str === "string" && str[0] !== ":" ? wrapColons(str) : str;
}
var NON_SPACING_MARK = String.fromCharCode(65039);
var nonSpacingRegex = new RegExp(NON_SPACING_MARK, "g");
function stripNSB(code2) {
  return code2.replace(nonSpacingRegex, "");
}
var emojiByCode = Object.keys(emojiByName).reduce(function(h2, k2) {
  h2[stripNSB(emojiByName[k2])] = k2;
  return h2;
}, {});
var Emoji = {
  emoji: emojiByName
};
Emoji._get = function _get(emoji2) {
  if (emojiByCode[stripNSB(emoji2)]) {
    return emoji2;
  } else if (emojiByName.hasOwnProperty(emoji2)) {
    return emojiByName[emoji2];
  }
  return ensureColons(emoji2);
};
Emoji.get = function get4(emoji2) {
  emoji2 = stripColons(emoji2);
  return Emoji._get(emoji2);
};
Emoji.find = function find3(nameOrCode) {
  return Emoji.findByName(nameOrCode) || Emoji.findByCode(nameOrCode);
};
Emoji.findByName = function findByName(name) {
  var stripped = stripColons(name);
  var emoji2 = emojiByName[stripped];
  return emoji2 ? { emoji: emoji2, key: stripped } : void 0;
};
Emoji.findByCode = function findByCode(code2) {
  var stripped = stripNSB(code2);
  var name = emojiByCode[stripped];
  return name ? { emoji: emojiByName[name], key: name } : void 0;
};
Emoji.hasEmoji = function hasEmoji(nameOrCode) {
  return Emoji.hasEmojiByName(nameOrCode) || Emoji.hasEmojiByCode(nameOrCode);
};
Emoji.hasEmojiByName = function hasEmojiByName(name) {
  var result2 = Emoji.findByName(name);
  return !!result2 && result2.key === stripColons(name);
};
Emoji.hasEmojiByCode = function hasEmojiByCode(code2) {
  var result2 = Emoji.findByCode(code2);
  return !!result2 && stripNSB(result2.emoji) === stripNSB(code2);
};
Emoji.which = function which(emoji_code, includeColons) {
  var code2 = stripNSB(emoji_code);
  var word = emojiByCode[code2];
  return includeColons ? wrapColons(word) : word;
};
Emoji.emojify = function emojify(str, on_missing, format) {
  if (!str)
    return "";
  return str.split(emojiNameRegex).map(function parseEmoji(s2, i2) {
    if (i2 % 2 === 0)
      return s2;
    var emoji2 = Emoji._get(s2);
    var isMissing = emoji2.indexOf(":") > -1;
    if (isMissing && typeof on_missing === "function") {
      return on_missing(s2);
    }
    if (!isMissing && typeof format === "function") {
      return format(emoji2, s2);
    }
    return emoji2;
  }).join("");
};
Emoji.random = function random() {
  var emojiKeys = Object.keys(emojiByName);
  var randomIndex = Math.floor(Math.random() * emojiKeys.length);
  var key2 = emojiKeys[randomIndex];
  var emoji2 = Emoji._get(key2);
  return { key: key2, emoji: emoji2 };
};
Emoji.search = function search2(str) {
  var emojiKeys = Object.keys(emojiByName);
  var matcher = stripColons(str);
  var matchingKeys = emojiKeys.filter(function(key2) {
    return key2.toString().indexOf(matcher) === 0;
  });
  return matchingKeys.map(function(key2) {
    return {
      key: key2,
      emoji: Emoji._get(key2)
    };
  });
};
Emoji.unemojify = function unemojify(str) {
  if (!str)
    return "";
  var words = toArray(str);
  return words.map(function(word) {
    return Emoji.which(word, true) || word;
  }).join("");
};
Emoji.replace = function replace3(str, replacement, cleanSpaces) {
  if (!str)
    return "";
  var replace4 = typeof replacement === "function" ? replacement : function() {
    return replacement;
  };
  var words = toArray(str);
  var replaced = words.map(function(word, idx) {
    var emoji2 = Emoji.findByCode(word);
    if (emoji2 && cleanSpaces && words[idx + 1] === " ") {
      words[idx + 1] = "";
    }
    return emoji2 ? replace4(emoji2) : word;
  }).join("");
  return cleanSpaces ? replaced.replace(trimSpaceRegex, "") : replaced;
};
Emoji.strip = function strip(str) {
  return Emoji.replace(str, "", true);
};
var emoji$2 = Emoji;
var nodeEmoji = emoji$2;
var require$$2 = [
  {
    name: "angry",
    emoji: "\u{1F620}",
    tags: [
      "mad",
      "annoyed"
    ],
    description: "angry face",
    emoticons: [
      ">:(",
      ">:[",
      ">:-(",
      ">:-[",
      ">=(",
      ">=[",
      ">=-(",
      ">=-["
    ]
  },
  {
    name: "blush",
    emoji: "\u{1F60A}",
    tags: [
      "proud"
    ],
    description: "smiling face with smiling eyes",
    emoticons: [
      ':")',
      ':"]',
      ':"D',
      ':-")',
      ':-"]',
      ':-"D',
      '=")',
      '="]',
      '="D',
      '=-")',
      '=-"]',
      '=-"D'
    ]
  },
  {
    name: "broken_heart",
    emoji: "\u{1F494}",
    tags: [],
    description: "broken heart",
    emoticons: [
      "<\\3",
      "</3"
    ]
  },
  {
    name: "confused",
    emoji: "\u{1F615}",
    tags: [],
    description: "confused face",
    emoticons: [
      ":/",
      ":\\",
      ":-/",
      ":-\\",
      "=/",
      "=\\",
      "=-/",
      "=-\\"
    ]
  },
  {
    name: "cry",
    emoji: "\u{1F622}",
    tags: [
      "sad",
      "tear"
    ],
    description: "crying face",
    emoticons: [
      ":,(",
      ":,[",
      ":,|",
      ":,-(",
      ":,-[",
      ":,-|",
      ":'(",
      ":'[",
      ":'|",
      ":'-(",
      ":'-[",
      ":'-|",
      "=,(",
      "=,[",
      "=,|",
      "=,-(",
      "=,-[",
      "=,-|",
      "='(",
      "='[",
      "='|",
      "='-(",
      "='-[",
      "='-|"
    ]
  },
  {
    name: "frowning",
    emoji: "\u{1F626}",
    tags: [],
    description: "frowning face with open mouth",
    emoticons: [
      ":(",
      ":[",
      ":-(",
      ":-[",
      "=(",
      "=[",
      "=-(",
      "=-["
    ]
  },
  {
    name: "heart",
    emoji: "\u2764\uFE0F",
    tags: [
      "love"
    ],
    description: "red heart",
    emoticons: [
      "<3"
    ]
  },
  {
    name: "imp",
    emoji: "\u{1F47F}",
    tags: [
      "angry",
      "devil",
      "evil",
      "horns"
    ],
    description: "angry face with horns",
    emoticons: [
      "]:(",
      "]:[",
      "]:-(",
      "]:-[",
      "]=(",
      "]=[",
      "]=-(",
      "]=-["
    ]
  },
  {
    name: "innocent",
    emoji: "\u{1F607}",
    tags: [
      "angel"
    ],
    description: "smiling face with halo",
    emoticons: [
      "o:)",
      "o:]",
      "o:D",
      "o:-)",
      "o:-]",
      "o:-D",
      "o=)",
      "o=]",
      "o=D",
      "o=-)",
      "o=-]",
      "o=-D",
      "O:)",
      "O:]",
      "O:D",
      "O:-)",
      "O:-]",
      "O:-D",
      "O=)",
      "O=]",
      "O=D",
      "O=-)",
      "O=-]",
      "O=-D",
      "0:)",
      "0:]",
      "0:D",
      "0:-)",
      "0:-]",
      "0:-D",
      "0=)",
      "0=]",
      "0=D",
      "0=-)",
      "0=-]",
      "0=-D"
    ]
  },
  {
    name: "joy",
    emoji: "\u{1F602}",
    tags: [
      "tears"
    ],
    description: "face with tears of joy",
    emoticons: [
      ":,)",
      ":,]",
      ":,D",
      ":,-)",
      ":,-]",
      ":,-D",
      ":')",
      ":']",
      ":'D",
      ":'-)",
      ":'-]",
      ":'-D",
      "=,)",
      "=,]",
      "=,D",
      "=,-)",
      "=,-]",
      "=,-D",
      "=')",
      "=']",
      "='D",
      "='-)",
      "='-]",
      "='-D"
    ]
  },
  {
    name: "kissing",
    emoji: "\u{1F617}",
    tags: [],
    description: "kissing face",
    emoticons: [
      ":*",
      ":-*",
      "=*",
      "=-*"
    ]
  },
  {
    name: "laughing",
    emoji: "\u{1F606}",
    tags: [
      "happy",
      "haha"
    ],
    description: "grinning squinting face",
    emoticons: [
      "x)",
      "x]",
      "xD",
      "x-)",
      "x-]",
      "x-D",
      "X)",
      "X]",
      "X-)",
      "X-]",
      "X-D"
    ]
  },
  {
    name: "man",
    emoji: "\u{1F468}",
    tags: [
      "mustache",
      "father",
      "dad"
    ],
    description: "man",
    emoticons: [
      ":3",
      ":-3",
      "=3",
      "=-3",
      ";3",
      ";-3",
      "x3",
      "x-3",
      "X3",
      "X-3"
    ]
  },
  {
    name: "neutral_face",
    emoji: "\u{1F610}",
    tags: [
      "meh"
    ],
    description: "neutral face",
    emoticons: [
      ":|",
      ":-|",
      "=|",
      "=-|"
    ]
  },
  {
    name: "no_mouth",
    emoji: "\u{1F636}",
    tags: [
      "mute",
      "silence"
    ],
    description: "face without mouth",
    emoticons: [
      ":-"
    ]
  },
  {
    name: "open_mouth",
    emoji: "\u{1F62E}",
    tags: [
      "surprise",
      "impressed",
      "wow"
    ],
    description: "face with open mouth",
    emoticons: [
      ":o",
      ":O",
      ":0",
      ":-o",
      ":-O",
      ":-0",
      "=o",
      "=O",
      "=0",
      "=-o",
      "=-O",
      "=-0"
    ]
  },
  {
    name: "rage",
    emoji: "\u{1F621}",
    tags: [
      "angry"
    ],
    description: "pouting face",
    emoticons: [
      ":@",
      ":-@",
      "=@",
      "=-@"
    ]
  },
  {
    name: "smile",
    emoji: "\u{1F604}",
    tags: [
      "happy",
      "joy",
      "laugh",
      "pleased"
    ],
    description: "grinning face with smiling eyes",
    emoticons: [
      ":D",
      ":-D",
      "=D",
      "=-D"
    ]
  },
  {
    name: "smiley",
    emoji: "\u{1F603}",
    tags: [
      "happy",
      "joy",
      "haha"
    ],
    description: "grinning face with big eyes",
    emoticons: [
      ":)",
      ":]",
      ":-)",
      ":-]",
      "=)",
      "=]",
      "=-)",
      "=-]"
    ]
  },
  {
    name: "smiling_imp",
    emoji: "\u{1F608}",
    tags: [
      "devil",
      "evil",
      "horns"
    ],
    description: "smiling face with horns",
    emoticons: [
      "]:)",
      "]:]",
      "]:D",
      "]:-)",
      "]:-]",
      "]:-D",
      "]=)",
      "]=]",
      "]=D",
      "]=-)",
      "]=-]",
      "]=-D"
    ]
  },
  {
    name: "sob",
    emoji: "\u{1F62D}",
    tags: [
      "sad",
      "cry",
      "bawling"
    ],
    description: "loudly crying face",
    emoticons: [
      ":,'(",
      ":,'[",
      ":,'-(",
      ":,'-[",
      ":',(",
      ":',[",
      ":',-(",
      ":',-[",
      "=,'(",
      "=,'[",
      "=,'-(",
      "=,'-[",
      "=',(",
      "=',[",
      "=',-(",
      "=',-["
    ]
  },
  {
    name: "stuck_out_tongue",
    emoji: "\u{1F61B}",
    tags: [],
    description: "face with tongue",
    emoticons: [
      ":p",
      ":P",
      ":d",
      ":-p",
      ":-P",
      ":-d",
      "=p",
      "=P",
      "=d",
      "=-p",
      "=-P",
      "=-d"
    ]
  },
  {
    name: "stuck_out_tongue_closed_eyes",
    emoji: "\u{1F61D}",
    tags: [
      "prank"
    ],
    description: "squinting face with tongue",
    emoticons: [
      "xP",
      "x-p",
      "x-P",
      "x-d",
      "Xp",
      "Xd",
      "X-p",
      "X-P",
      "X-d"
    ]
  },
  {
    name: "stuck_out_tongue_winking_eye",
    emoji: "\u{1F61C}",
    tags: [
      "prank",
      "silly"
    ],
    description: "winking face with tongue",
    emoticons: [
      ";p",
      ";P",
      ";d",
      ";-p",
      ";-P",
      ";-d"
    ]
  },
  {
    name: "sunglasses",
    emoji: "\u{1F60E}",
    tags: [
      "cool"
    ],
    description: "smiling face with sunglasses",
    emoticons: [
      "8)",
      "8]",
      "8D",
      "8-)",
      "8-]",
      "8-D",
      "B)",
      "B]",
      "B-)",
      "B-]",
      "B-D"
    ]
  },
  {
    name: "sweat",
    emoji: "\u{1F613}",
    tags: [],
    description: "downcast face with sweat",
    emoticons: [
      ",:(",
      ",:[",
      ",:-(",
      ",:-[",
      ",=(",
      ",=[",
      ",=-(",
      ",=-[",
      "':(",
      "':[",
      "':-(",
      "':-[",
      "'=(",
      "'=[",
      "'=-(",
      "'=-["
    ]
  },
  {
    name: "sweat_smile",
    emoji: "\u{1F605}",
    tags: [
      "hot"
    ],
    description: "grinning face with sweat",
    emoticons: [
      ",:)",
      ",:]",
      ",:D",
      ",:-)",
      ",:-]",
      ",:-D",
      ",=)",
      ",=]",
      ",=D",
      ",=-)",
      ",=-]",
      ",=-D",
      "':)",
      "':]",
      "':D",
      "':-)",
      "':-]",
      "':-D",
      "'=)",
      "'=]",
      "'=D",
      "'=-)",
      "'=-]",
      "'=-D"
    ]
  },
  {
    name: "unamused",
    emoji: "\u{1F612}",
    tags: [
      "meh"
    ],
    description: "unamused face",
    emoticons: [
      ":$",
      ":s",
      ":z",
      ":S",
      ":Z",
      ":-$",
      ":-s",
      ":-z",
      ":-S",
      ":-Z",
      "=$",
      "=s",
      "=z",
      "=S",
      "=Z",
      "=-$",
      "=-s",
      "=-z",
      "=-S",
      "=-Z"
    ]
  },
  {
    name: "wink",
    emoji: "\u{1F609}",
    tags: [
      "flirt"
    ],
    description: "winking face",
    emoticons: [
      ";)",
      ";]",
      ";D",
      ";-)",
      ";-]",
      ";-D"
    ]
  }
];
const visit = unistUtilVisit;
const emoji$1 = nodeEmoji;
const emoticon = require$$2;
const RE_EMOJI = /:\+1:|:-1:|:[\w-]+:/g;
const RE_SHORT = /[$@|*'",;.=:\-)([\]\\/<>038BOopPsSdDxXzZ]{2,5}/g;
const DEFAULT_SETTINGS = {
  padSpaceAfter: false,
  emoticon: false
};
function plugin(options) {
  const settings = Object.assign({}, DEFAULT_SETTINGS, options);
  const pad = !!settings.padSpaceAfter;
  const emoticonEnable = !!settings.emoticon;
  function getEmojiByShortCode(match) {
    const iconFull = emoticon.find((e3) => e3.emoticons.includes(match));
    const iconPart = emoticon.find((e3) => e3.emoticons.includes(match.slice(0, -1)));
    const trimmedChar = iconPart ? match.slice(-1) : "";
    const addPad = pad ? " " : "";
    let icon2 = iconFull ? iconFull.emoji + addPad : iconPart && iconPart.emoji + addPad + trimmedChar;
    return icon2 || match;
  }
  function getEmoji(match) {
    const got = emoji$1.get(match);
    if (pad && got !== match) {
      return got + " ";
    }
    return got;
  }
  function transformer(tree) {
    visit(tree, "text", function(node5) {
      node5.value = node5.value.replace(RE_EMOJI, getEmoji);
      if (emoticonEnable) {
        node5.value = node5.value.replace(RE_SHORT, getEmojiByShortCode);
      }
    });
  }
  return transformer;
}
var remarkEmoji = plugin;
const commands2Tuples = (commands2) => Object.entries(commands2).filter((x2) => !!x2);
const getShortCuts = (name, defaultKey, userKeymap) => {
  var _a;
  return (_a = userKeymap === null || userKeymap === void 0 ? void 0 : userKeymap[name]) !== null && _a !== void 0 ? _a : defaultKey;
};
const getKeymap = (getCommand, userKeymap) => ([name, { defaultKey, commandKey, args }]) => [getShortCuts(name, defaultKey, userKeymap)].flat().map((shortcut) => [shortcut, getCommand(commandKey)(args)]);
const tuple2Keymap = (tuples, getCommand, userKeymap) => tuples.flatMap(getKeymap(getCommand, userKeymap));
const createKeymap = (commands2, userKeymap) => !commands2 ? () => ({}) : (_type, _schema, getCommand) => Object.fromEntries(tuple2Keymap(commands2Tuples(commands2), getCommand, userKeymap));
const createNode = (factory2) => {
  const origin = (options) => {
    const getClassName = (attrs, defaultValue) => {
      var _a, _b;
      return (_b = (_a = options === null || options === void 0 ? void 0 : options.className) === null || _a === void 0 ? void 0 : _a.call(options, attrs)) !== null && _b !== void 0 ? _b : defaultValue;
    };
    const node5 = factory2(options, {
      getClassName
    });
    const keymap2 = createKeymap(node5.shortcuts, options === null || options === void 0 ? void 0 : options.keymap);
    const plugin2 = nodeFactory(Object.assign(Object.assign({ view: options === null || options === void 0 ? void 0 : options.view }, node5), { keymap: keymap2 }));
    plugin2.origin = origin;
    return plugin2;
  };
  return origin;
};
const calculateNodePosition = (view, target, handler) => {
  var _a;
  const state = view.state;
  const { from: from5 } = state.selection;
  const node5 = view.domAtPos(from5).node;
  if (!(node5 instanceof HTMLElement)) {
    throw new Error();
  }
  const selectedNodeRect = node5.getBoundingClientRect();
  const targetNodeRect = target.getBoundingClientRect();
  const parentNodeRect = (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  if (!parentNodeRect) {
    throw new Error();
  }
  const [top2, left] = handler(selectedNodeRect, targetNodeRect, parentNodeRect);
  target.style.top = top2 + "px";
  target.style.left = left + "px";
};
const part = /:\+1|:-1|:[\w-]+/;
const full = /:\+1:|:-1:|:[\w-]+:/;
const input = /(:([^:\s]+):)$/;
/*! Copyright Twitter Inc. and other contributors. Licensed under MIT */
var twemoji = function() {
  var twemoji2 = { base: "https://twemoji.maxcdn.com/v/13.1.0/", ext: ".png", size: "72x72", className: "emoji", convert: { fromCodePoint, toCodePoint }, onerror: function onerror() {
    if (this.parentNode) {
      this.parentNode.replaceChild(createText(this.alt, false), this);
    }
  }, parse: parse4, replace: replace4, test }, escaper = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, re2 = /(?:\ud83d\udc68\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83e\uddd1\ud83c[\udffc-\udfff]|\ud83e\uddd1\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83e\uddd1\ud83c[\udffb\udffd-\udfff]|\ud83e\uddd1\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83e\uddd1\ud83c[\udffb\udffc\udffe\udfff]|\ud83e\uddd1\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83e\uddd1\ud83c[\udffb-\udffd\udfff]|\ud83e\uddd1\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83e\uddd1\ud83c[\udffb-\udffe]|\ud83d\udc68\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffc-\udfff]|\ud83d\udc68\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffd-\udfff]|\ud83d\udc68\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc68\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffd\udfff]|\ud83d\udc68\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc68\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffe]|\ud83d\udc69\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffc-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffc-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffd-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb\udffd-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc69\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc69\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffd\udfff]|\ud83d\udc69\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb-\udffd\udfff]|\ud83d\udc69\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc68\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83d\udc69\ud83c[\udffb-\udfff]|\ud83d\udc69\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffe]|\ud83d\udc69\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb-\udffe]|\ud83e\uddd1\ud83c\udffb\u200d\u2764\ufe0f\u200d\ud83e\uddd1\ud83c[\udffc-\udfff]|\ud83e\uddd1\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffc\u200d\u2764\ufe0f\u200d\ud83e\uddd1\ud83c[\udffb\udffd-\udfff]|\ud83e\uddd1\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffd\u200d\u2764\ufe0f\u200d\ud83e\uddd1\ud83c[\udffb\udffc\udffe\udfff]|\ud83e\uddd1\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffe\u200d\u2764\ufe0f\u200d\ud83e\uddd1\ud83c[\udffb-\udffd\udfff]|\ud83e\uddd1\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udfff\u200d\u2764\ufe0f\u200d\ud83e\uddd1\ud83c[\udffb-\udffe]|\ud83e\uddd1\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d[\udc68\udc69]|\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc68|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d[\udc68\udc69]|\ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1|\ud83d\udc6b\ud83c[\udffb-\udfff]|\ud83d\udc6c\ud83c[\udffb-\udfff]|\ud83d\udc6d\ud83c[\udffb-\udfff]|\ud83d\udc8f\ud83c[\udffb-\udfff]|\ud83d\udc91\ud83c[\udffb-\udfff]|\ud83d[\udc6b-\udc6d\udc8f\udc91])|(?:\ud83d[\udc68\udc69]|\ud83e\uddd1)(?:\ud83c[\udffb-\udfff])?\u200d(?:\u2695\ufe0f|\u2696\ufe0f|\u2708\ufe0f|\ud83c[\udf3e\udf73\udf7c\udf84\udf93\udfa4\udfa8\udfeb\udfed]|\ud83d[\udcbb\udcbc\udd27\udd2c\ude80\ude92]|\ud83e[\uddaf-\uddb3\uddbc\uddbd])|(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75]|\u26f9)((?:\ud83c[\udffb-\udfff]|\ufe0f)\u200d[\u2640\u2642]\ufe0f)|(?:\ud83c[\udfc3\udfc4\udfca]|\ud83d[\udc6e\udc70\udc71\udc73\udc77\udc81\udc82\udc86\udc87\ude45-\ude47\ude4b\ude4d\ude4e\udea3\udeb4-\udeb6]|\ud83e[\udd26\udd35\udd37-\udd39\udd3d\udd3e\uddb8\uddb9\uddcd-\uddcf\uddd4\uddd6-\udddd])(?:\ud83c[\udffb-\udfff])?\u200d[\u2640\u2642]\ufe0f|(?:\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f|\ud83c\udff3\ufe0f\u200d\ud83c\udf08|\ud83d\ude36\u200d\ud83c\udf2b\ufe0f|\u2764\ufe0f\u200d\ud83d\udd25|\u2764\ufe0f\u200d\ud83e\ude79|\ud83c\udff4\u200d\u2620\ufe0f|\ud83d\udc15\u200d\ud83e\uddba|\ud83d\udc3b\u200d\u2744\ufe0f|\ud83d\udc41\u200d\ud83d\udde8|\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc6f\u200d\u2640\ufe0f|\ud83d\udc6f\u200d\u2642\ufe0f|\ud83d\ude2e\u200d\ud83d\udca8|\ud83d\ude35\u200d\ud83d\udcab|\ud83e\udd3c\u200d\u2640\ufe0f|\ud83e\udd3c\u200d\u2642\ufe0f|\ud83e\uddde\u200d\u2640\ufe0f|\ud83e\uddde\u200d\u2642\ufe0f|\ud83e\udddf\u200d\u2640\ufe0f|\ud83e\udddf\u200d\u2642\ufe0f|\ud83d\udc08\u200d\u2b1b)|[#*0-9]\ufe0f?\u20e3|(?:[\u2122\u265f]\ufe0f)|(?:\ud83c[\udc04\udd70\udd71\udd7e\udd7f\ude02\ude1a\ude2f\ude37\udf21\udf24-\udf2c\udf36\udf7d\udf96\udf97\udf99-\udf9b\udf9e\udf9f\udfcd\udfce\udfd4-\udfdf\udff3\udff5\udff7]|\ud83d[\udc3f\udc41\udcfd\udd49\udd4a\udd6f\udd70\udd73\udd76-\udd79\udd87\udd8a-\udd8d\udda5\udda8\uddb1\uddb2\uddbc\uddc2-\uddc4\uddd1-\uddd3\udddc-\uddde\udde1\udde3\udde8\uddef\uddf3\uddfa\udecb\udecd-\udecf\udee0-\udee5\udee9\udef0\udef3]|[\u203c\u2049\u2139\u2194-\u2199\u21a9\u21aa\u231a\u231b\u2328\u23cf\u23ed-\u23ef\u23f1\u23f2\u23f8-\u23fa\u24c2\u25aa\u25ab\u25b6\u25c0\u25fb-\u25fe\u2600-\u2604\u260e\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638-\u263a\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267b\u267f\u2692-\u2697\u2699\u269b\u269c\u26a0\u26a1\u26a7\u26aa\u26ab\u26b0\u26b1\u26bd\u26be\u26c4\u26c5\u26c8\u26cf\u26d1\u26d3\u26d4\u26e9\u26ea\u26f0-\u26f5\u26f8\u26fa\u26fd\u2702\u2708\u2709\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u2764\u27a1\u2934\u2935\u2b05-\u2b07\u2b1b\u2b1c\u2b50\u2b55\u3030\u303d\u3297\u3299])(?:\ufe0f|(?!\ufe0e))|(?:(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75\udd90]|[\u261d\u26f7\u26f9\u270c\u270d])(?:\ufe0f|(?!\ufe0e))|(?:\ud83c[\udf85\udfc2-\udfc4\udfc7\udfca]|\ud83d[\udc42\udc43\udc46-\udc50\udc66-\udc69\udc6e\udc70-\udc78\udc7c\udc81-\udc83\udc85-\udc87\udcaa\udd7a\udd95\udd96\ude45-\ude47\ude4b-\ude4f\udea3\udeb4-\udeb6\udec0\udecc]|\ud83e[\udd0c\udd0f\udd18-\udd1c\udd1e\udd1f\udd26\udd30-\udd39\udd3d\udd3e\udd77\uddb5\uddb6\uddb8\uddb9\uddbb\uddcd-\uddcf\uddd1-\udddd]|[\u270a\u270b]))(?:\ud83c[\udffb-\udfff])?|(?:\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc77\udb40\udc6c\udb40\udc73\udb40\udc7f|\ud83c\udde6\ud83c[\udde8-\uddec\uddee\uddf1\uddf2\uddf4\uddf6-\uddfa\uddfc\uddfd\uddff]|\ud83c\udde7\ud83c[\udde6\udde7\udde9-\uddef\uddf1-\uddf4\uddf6-\uddf9\uddfb\uddfc\uddfe\uddff]|\ud83c\udde8\ud83c[\udde6\udde8\udde9\uddeb-\uddee\uddf0-\uddf5\uddf7\uddfa-\uddff]|\ud83c\udde9\ud83c[\uddea\uddec\uddef\uddf0\uddf2\uddf4\uddff]|\ud83c\uddea\ud83c[\udde6\udde8\uddea\uddec\udded\uddf7-\uddfa]|\ud83c\uddeb\ud83c[\uddee-\uddf0\uddf2\uddf4\uddf7]|\ud83c\uddec\ud83c[\udde6\udde7\udde9-\uddee\uddf1-\uddf3\uddf5-\uddfa\uddfc\uddfe]|\ud83c\udded\ud83c[\uddf0\uddf2\uddf3\uddf7\uddf9\uddfa]|\ud83c\uddee\ud83c[\udde8-\uddea\uddf1-\uddf4\uddf6-\uddf9]|\ud83c\uddef\ud83c[\uddea\uddf2\uddf4\uddf5]|\ud83c\uddf0\ud83c[\uddea\uddec-\uddee\uddf2\uddf3\uddf5\uddf7\uddfc\uddfe\uddff]|\ud83c\uddf1\ud83c[\udde6-\udde8\uddee\uddf0\uddf7-\uddfb\uddfe]|\ud83c\uddf2\ud83c[\udde6\udde8-\udded\uddf0-\uddff]|\ud83c\uddf3\ud83c[\udde6\udde8\uddea-\uddec\uddee\uddf1\uddf4\uddf5\uddf7\uddfa\uddff]|\ud83c\uddf4\ud83c\uddf2|\ud83c\uddf5\ud83c[\udde6\uddea-\udded\uddf0-\uddf3\uddf7-\uddf9\uddfc\uddfe]|\ud83c\uddf6\ud83c\udde6|\ud83c\uddf7\ud83c[\uddea\uddf4\uddf8\uddfa\uddfc]|\ud83c\uddf8\ud83c[\udde6-\uddea\uddec-\uddf4\uddf7-\uddf9\uddfb\uddfd-\uddff]|\ud83c\uddf9\ud83c[\udde6\udde8\udde9\uddeb-\udded\uddef-\uddf4\uddf7\uddf9\uddfb\uddfc\uddff]|\ud83c\uddfa\ud83c[\udde6\uddec\uddf2\uddf3\uddf8\uddfe\uddff]|\ud83c\uddfb\ud83c[\udde6\udde8\uddea\uddec\uddee\uddf3\uddfa]|\ud83c\uddfc\ud83c[\uddeb\uddf8]|\ud83c\uddfd\ud83c\uddf0|\ud83c\uddfe\ud83c[\uddea\uddf9]|\ud83c\uddff\ud83c[\udde6\uddf2\uddfc]|\ud83c[\udccf\udd8e\udd91-\udd9a\udde6-\uddff\ude01\ude32-\ude36\ude38-\ude3a\ude50\ude51\udf00-\udf20\udf2d-\udf35\udf37-\udf7c\udf7e-\udf84\udf86-\udf93\udfa0-\udfc1\udfc5\udfc6\udfc8\udfc9\udfcf-\udfd3\udfe0-\udff0\udff4\udff8-\udfff]|\ud83d[\udc00-\udc3e\udc40\udc44\udc45\udc51-\udc65\udc6a\udc6f\udc79-\udc7b\udc7d-\udc80\udc84\udc88-\udc8e\udc90\udc92-\udca9\udcab-\udcfc\udcff-\udd3d\udd4b-\udd4e\udd50-\udd67\udda4\uddfb-\ude44\ude48-\ude4a\ude80-\udea2\udea4-\udeb3\udeb7-\udebf\udec1-\udec5\uded0-\uded2\uded5-\uded7\udeeb\udeec\udef4-\udefc\udfe0-\udfeb]|\ud83e[\udd0d\udd0e\udd10-\udd17\udd1d\udd20-\udd25\udd27-\udd2f\udd3a\udd3c\udd3f-\udd45\udd47-\udd76\udd78\udd7a-\uddb4\uddb7\uddba\uddbc-\uddcb\uddd0\uddde-\uddff\ude70-\ude74\ude78-\ude7a\ude80-\ude86\ude90-\udea8\udeb0-\udeb6\udec0-\udec2\uded0-\uded6]|[\u23e9-\u23ec\u23f0\u23f3\u267e\u26ce\u2705\u2728\u274c\u274e\u2753-\u2755\u2795-\u2797\u27b0\u27bf\ue50a])|\ufe0f/g, UFE0Fg = /\uFE0F/g, U200D = String.fromCharCode(8205), rescaper = /[&<>'"]/g, shouldntBeParsed = /^(?:iframe|noframes|noscript|script|select|style|textarea)$/, fromCharCode2 = String.fromCharCode;
  return twemoji2;
  function createText(text3, clean) {
    return document.createTextNode(clean ? text3.replace(UFE0Fg, "") : text3);
  }
  function escapeHTML(s2) {
    return s2.replace(rescaper, replacer);
  }
  function defaultImageSrcGenerator(icon2, options) {
    return "".concat(options.base, options.size, "/", icon2, options.ext);
  }
  function grabAllTextNodes(node5, allText) {
    var childNodes = node5.childNodes, length = childNodes.length, subnode, nodeType2;
    while (length--) {
      subnode = childNodes[length];
      nodeType2 = subnode.nodeType;
      if (nodeType2 === 3) {
        allText.push(subnode);
      } else if (nodeType2 === 1 && !("ownerSVGElement" in subnode) && !shouldntBeParsed.test(subnode.nodeName.toLowerCase())) {
        grabAllTextNodes(subnode, allText);
      }
    }
    return allText;
  }
  function grabTheRightIcon(rawText) {
    return toCodePoint(rawText.indexOf(U200D) < 0 ? rawText.replace(UFE0Fg, "") : rawText);
  }
  function parseNode(node5, options) {
    var allText = grabAllTextNodes(node5, []), length = allText.length, attrib, attrname, modified, fragment, subnode, text3, match, i2, index3, img, rawText, iconId, src;
    while (length--) {
      modified = false;
      fragment = document.createDocumentFragment();
      subnode = allText[length];
      text3 = subnode.nodeValue;
      i2 = 0;
      while (match = re2.exec(text3)) {
        index3 = match.index;
        if (index3 !== i2) {
          fragment.appendChild(createText(text3.slice(i2, index3), true));
        }
        rawText = match[0];
        iconId = grabTheRightIcon(rawText);
        i2 = index3 + rawText.length;
        src = options.callback(iconId, options);
        if (iconId && src) {
          img = new Image();
          img.onerror = options.onerror;
          img.setAttribute("draggable", "false");
          attrib = options.attributes(rawText, iconId);
          for (attrname in attrib) {
            if (attrib.hasOwnProperty(attrname) && attrname.indexOf("on") !== 0 && !img.hasAttribute(attrname)) {
              img.setAttribute(attrname, attrib[attrname]);
            }
          }
          img.className = options.className;
          img.alt = rawText;
          img.src = src;
          modified = true;
          fragment.appendChild(img);
        }
        if (!img)
          fragment.appendChild(createText(rawText, false));
        img = null;
      }
      if (modified) {
        if (i2 < text3.length) {
          fragment.appendChild(createText(text3.slice(i2), true));
        }
        subnode.parentNode.replaceChild(fragment, subnode);
      }
    }
    return node5;
  }
  function parseString(str, options) {
    return replace4(str, function(rawText) {
      var ret = rawText, iconId = grabTheRightIcon(rawText), src = options.callback(iconId, options), attrib, attrname;
      if (iconId && src) {
        ret = "<img ".concat('class="', options.className, '" ', 'draggable="false" ', 'alt="', rawText, '"', ' src="', src, '"');
        attrib = options.attributes(rawText, iconId);
        for (attrname in attrib) {
          if (attrib.hasOwnProperty(attrname) && attrname.indexOf("on") !== 0 && ret.indexOf(" " + attrname + "=") === -1) {
            ret = ret.concat(" ", attrname, '="', escapeHTML(attrib[attrname]), '"');
          }
        }
        ret = ret.concat("/>");
      }
      return ret;
    });
  }
  function replacer(m2) {
    return escaper[m2];
  }
  function returnNull() {
    return null;
  }
  function toSizeSquaredAsset(value) {
    return typeof value === "number" ? value + "x" + value : value;
  }
  function fromCodePoint(codepoint) {
    var code2 = typeof codepoint === "string" ? parseInt(codepoint, 16) : codepoint;
    if (code2 < 65536) {
      return fromCharCode2(code2);
    }
    code2 -= 65536;
    return fromCharCode2(55296 + (code2 >> 10), 56320 + (code2 & 1023));
  }
  function parse4(what, how) {
    if (!how || typeof how === "function") {
      how = { callback: how };
    }
    return (typeof what === "string" ? parseString : parseNode)(what, { callback: how.callback || defaultImageSrcGenerator, attributes: typeof how.attributes === "function" ? how.attributes : returnNull, base: typeof how.base === "string" ? how.base : twemoji2.base, ext: how.ext || twemoji2.ext, size: how.folder || toSizeSquaredAsset(how.size || twemoji2.size), className: how.className || twemoji2.className, onerror: how.onerror || twemoji2.onerror });
  }
  function replace4(text3, callback) {
    return String(text3).replace(re2, callback);
  }
  function test(text3) {
    re2.lastIndex = 0;
    var result2 = re2.test(text3);
    re2.lastIndex = 0;
    return result2;
  }
  function toCodePoint(unicodeSurrogates, sep) {
    var r2 = [], c2 = 0, p2 = 0, i2 = 0;
    while (i2 < unicodeSurrogates.length) {
      c2 = unicodeSurrogates.charCodeAt(i2++);
      if (p2) {
        r2.push((65536 + (p2 - 55296 << 10) + (c2 - 56320)).toString(16));
        p2 = 0;
      } else if (55296 <= c2 && c2 <= 56319) {
        p2 = c2;
      } else {
        r2.push(c2.toString(16));
      }
    }
    return r2.join(sep || "-");
  }
}();
const parse3 = (emoji2) => twemoji.parse(emoji2, { attributes: (text3) => ({ title: text3 }) });
const checkTrigger$1 = (view, from5, to2, text3, setRange, setSearch) => {
  if (view.composing)
    return false;
  const { state } = view;
  const $from = state.doc.resolve(from5);
  if ($from.parent.type.spec.code)
    return false;
  const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - 10), $from.parentOffset, void 0, "\uFFFC") + text3;
  if (full.test(textBefore)) {
    return false;
  }
  const regex2 = part.exec(textBefore);
  if (regex2 && textBefore.endsWith(regex2[0])) {
    const match = regex2[0];
    setRange(from5 - (match.length - text3.length), to2);
    setSearch(match);
    return true;
  }
  return false;
};
const renderDropdownList = (list2, dropDown, $active, onConfirm, setActive) => {
  dropDown.innerHTML = "";
  list2.forEach(({ emoji: emoji2, key: key2 }, i2) => {
    const container = document.createElement("div");
    container.className = "milkdown-emoji-filter_item";
    const emojiSpan = document.createElement("span");
    emojiSpan.innerHTML = parse3(emoji2);
    emojiSpan.className = "milkdown-emoji-filter_item-emoji";
    const keySpan = document.createElement("span");
    keySpan.textContent = ":" + key2 + ":";
    keySpan.className = "milkdown-emoji-filter_item-key";
    container.appendChild(emojiSpan);
    container.appendChild(keySpan);
    dropDown.appendChild(container);
    if (i2 === 0) {
      container.classList.add("active");
      setActive(container);
    }
    container.addEventListener("mouseenter", (e3) => {
      if ($active) {
        $active.classList.remove("active");
      }
      const { target } = e3;
      if (!(target instanceof HTMLElement))
        return;
      target.classList.add("active");
      setActive(target);
    });
    container.addEventListener("mouseleave", (e3) => {
      const { target } = e3;
      if (!(target instanceof HTMLElement))
        return;
      target.classList.remove("active");
    });
    container.addEventListener("mousedown", (e3) => {
      onConfirm();
      e3.preventDefault();
    });
  });
};
const filterPlugin = () => {
  let trigger = false;
  let _from = 0;
  let _search = "";
  let $active = null;
  const off = () => {
    trigger = false;
    _from = 0;
    _search = "";
    $active = null;
  };
  return new Plugin({
    props: {
      handleKeyDown(_2, event) {
        if (["Delete", "Backspace"].includes(event.key)) {
          _search = _search.slice(0, -1);
          if (_search.length <= 1) {
            off();
          }
          return false;
        }
        if (!trigger)
          return false;
        if (!["ArrowUp", "ArrowDown", "Enter"].includes(event.key)) {
          return false;
        }
        return true;
      },
      handleTextInput(view, from5, to2, text3) {
        trigger = checkTrigger$1(view, from5, to2, text3, (from6) => {
          _from = from6;
        }, (search3) => {
          _search = search3;
        });
        if (!trigger) {
          off();
        }
        return false;
      }
    },
    view: (editorView2) => {
      const { parentNode: parentNode2 } = editorView2.dom;
      if (!parentNode2) {
        throw new Error();
      }
      const dropDown = document.createElement("div");
      dropDown.className = "milkdown-emoji-filter hide";
      const replace4 = () => {
        var _a;
        if (!$active)
          return;
        const { tr } = editorView2.state;
        const node5 = editorView2.state.schema.node("emoji", { html: (_a = $active.firstElementChild) === null || _a === void 0 ? void 0 : _a.innerHTML });
        editorView2.dispatch(tr.delete(_from, _from + _search.length).insert(_from, node5));
        off();
        dropDown.classList.add("hide");
      };
      parentNode2.appendChild(dropDown);
      parentNode2.addEventListener("keydown", (e3) => {
        if (!trigger || !(e3 instanceof KeyboardEvent))
          return;
        const { key: key2 } = e3;
        if (key2 === "Enter") {
          replace4();
          return;
        }
        if (["ArrowDown", "ArrowUp"].includes(key2)) {
          const next = key2 === "ArrowDown" ? ($active === null || $active === void 0 ? void 0 : $active.nextElementSibling) || dropDown.firstElementChild : ($active === null || $active === void 0 ? void 0 : $active.previousElementSibling) || dropDown.lastElementChild;
          if ($active) {
            $active.classList.remove("active");
          }
          if (!next)
            return;
          next.classList.add("active");
          $active = next;
          return;
        }
      });
      parentNode2.addEventListener("mousedown", (e3) => {
        if (!trigger)
          return;
        e3.stopPropagation();
        off();
        dropDown.classList.add("hide");
      });
      return {
        update: (view) => {
          if (!trigger) {
            dropDown.classList.add("hide");
            return null;
          }
          const result2 = nodeEmoji.search(_search).slice(0, 5);
          const { node: node5 } = view.domAtPos(_from);
          if (result2.length === 0 || !node5) {
            dropDown.classList.add("hide");
            return null;
          }
          dropDown.classList.remove("hide");
          renderDropdownList(result2, dropDown, $active, replace4, (a2) => {
            $active = a2;
          });
          calculateNodePosition(view, dropDown, (selected, target, parent) => {
            const start4 = view.coordsAtPos(_from);
            let left = start4.left - parent.left;
            let top2 = selected.bottom - parent.top + 14;
            if (left < 0) {
              left = 0;
            }
            if (window.innerHeight - start4.bottom < target.height) {
              top2 = selected.top - parent.top - target.height - 14;
            }
            return [top2, left];
          });
          return null;
        }
      };
    }
  });
};
const filter = prosePluginFactory(filterPlugin());
const emojiNode = createNode(() => ({
  id: "emoji",
  schema: {
    group: "inline",
    inline: true,
    selectable: false,
    marks: "",
    attrs: {
      html: {
        default: ""
      }
    },
    parseDOM: [
      {
        tag: 'span[data-type="emoji"]',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) {
            throw new Error();
          }
          return { html: dom.innerHTML };
        }
      }
    ],
    toDOM: (node5) => {
      const span = document.createElement("span");
      span.dataset.type = "emoji";
      span.className = "emoji";
      span.innerHTML = node5.attrs.html;
      return { dom: span };
    }
  },
  parser: {
    match: ({ type }) => type === "emoji",
    runner: (state, node5, type) => {
      state.addNode(type, { html: node5.value });
    }
  },
  serializer: {
    match: (node5) => node5.type.name === "emoji",
    runner: (state, node5) => {
      const span = document.createElement("span");
      span.innerHTML = node5.attrs.html;
      const img = span.querySelector("img");
      const title = img === null || img === void 0 ? void 0 : img.title;
      span.remove();
      state.addNode("text", void 0, title);
    }
  },
  inputRules: (nodeType2) => [
    new InputRule(input, (state, match, start4, end3) => {
      const content3 = match[0];
      if (!content3)
        return null;
      const got = nodeEmoji.get(content3);
      if (!got || content3.includes(got))
        return null;
      const html2 = parse3(got);
      return state.tr.replaceRangeWith(start4, end3, nodeType2.create({ html: html2 })).scrollIntoView();
    })
  ]
}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function e(e3, o3, n2, i2) {
  return new (n2 || (n2 = Promise))(function(a2, r2) {
    function t2(e4) {
      try {
        m2(i2.next(e4));
      } catch (e5) {
        r2(e5);
      }
    }
    function s2(e4) {
      try {
        m2(i2.throw(e4));
      } catch (e5) {
        r2(e5);
      }
    }
    function m2(e4) {
      var o4;
      e4.done ? a2(e4.value) : (o4 = e4.value, o4 instanceof n2 ? o4 : new n2(function(e5) {
        e5(o4);
      })).then(t2, s2);
    }
    m2((i2 = i2.apply(e3, o3 || [])).next());
  });
}
!function(e3, o3) {
  o3 === void 0 && (o3 = {});
  var n2 = o3.insertAt;
  if (e3 && typeof document != "undefined") {
    var i2 = document.head || document.getElementsByTagName("head")[0], a2 = document.createElement("style");
    a2.type = "text/css", n2 === "top" && i2.firstChild ? i2.insertBefore(a2, i2.firstChild) : i2.appendChild(a2), a2.styleSheet ? a2.styleSheet.cssText = e3 : a2.appendChild(document.createTextNode(e3));
  }
}('@keyframes show {\n  0% {\n    opacity: 0;\n    transform: scale3d(0.8, 0.8, 0.8);\n  }\n\n  50% {\n    transform: scale3d(1.05, 1.05, 1.05);\n  }\n\n  100% {\n    transform: scale3d(1, 1, 1);\n  }\n}\n\n@keyframes hide {\n  0% {\n    opacity: 1;\n    transform: scale3d(1, 1, 1);\n  }\n\n  100% {\n    opacity: 0;\n    transform: scale3d(0.8, 0.8, 0.8);\n  }\n}\n\n@keyframes grow {\n  0% {\n    opacity: 0;\n    transform: scale3d(0.8, 0.8, 0.8); \n  }\n\n  100% { \n    opacity: 1;\n    transform: scale3d(1, 1, 1); \n  }\n}\n\n@keyframes shrink {\n  0% { \n    opacity: 1;\n    transform: scale3d(1, 1, 1);\n  }\n\n  100% { \n    opacity: 0;\n    transform: scale3d(0.8, 0.8, 0.8); \n  }\n}\n\n@keyframes fade-in {\n  0% { opacity: 0; }\n  100% { opacity: 1; }\n}\n\n@keyframes fade-out {\n  0% { opacity: 1; }\n  100% { opacity: 0; }\n}\n\n.emoji-picker {\n  --animation-duration: 0.2s;\n  --animation-easing: ease-in-out;\n\n  --emoji-size: 1.8em;\n  --emoji-size-multiplier: 1.5;\n  --emoji-preview-size: 2em;\n  --emoji-per-row: 8;\n  --row-count: 6;\n\n  --content-height: calc((var(--emoji-size) * var(--emoji-size-multiplier)) * var(--row-count) + var(--category-name-size) + var(--category-button-height) + 0.5em);\n\n  --category-name-size: 0.85em;\n\n  --category-button-height: 2em;\n  --category-button-size: 1.1em;\n  --category-border-bottom-size: 4px;\n\n  --focus-indicator-color: #999999;\n\n  --search-height: 2em;\n\n  --blue-color: #4F81E5;\n\n  --border-color: #CCCCCC;\n  --background-color: #FFFFFF;\n  --text-color: #000000;\n  --secondary-text-color: #666666;\n  --hover-color: #E8F4F9;\n  --search-focus-border-color: var(--blue-color);\n  --search-icon-color: #CCCCCC;\n  --overlay-background-color: rgba(0, 0, 0, 0.8);\n  --popup-background-color: #FFFFFF;\n  --category-button-color: #666666;\n  --category-button-active-color: var(--blue-color);\n\n  --dark-border-color: #666666;\n  --dark-background-color: #333333;\n  --dark-text-color: #FFFFFF;\n  --dark-secondary-text-color: #999999;\n  --dark-hover-color: #666666;\n  --dark-search-background-color: #666666;\n  --dark-search-border-color: #999999;\n  --dark-search-placeholder-color: #999999;\n  --dark-search-focus-border-color: #DBE5F9;\n  --dark-popup-background-color: #333333;\n  --dark-category-button-color: #FFFFFF;\n\n  --font: Arial, Helvetica, sans-serif;\n  --font-size: 16px;\n}\n\n.emoji-picker {\n  font-size: var(--font-size);\n  border: 1px solid var(--border-color);\n  border-radius: 5px;\n  background: var(--background-color);\n  width: calc(var(--emoji-per-row) * var(--emoji-size) * var(--emoji-size-multiplier) + 1em + 1.5rem);\n  font-family: var(--font);\n  overflow: hidden;\n  animation: show var(--animation-duration) var(--animation-easing);\n}\n\n.emoji-picker * {\n  font-family: var(--font);\n  box-sizing: content-box;\n}\n\n.emoji-picker__overlay {\n  background: rgba(0, 0, 0, 0.75);\n  z-index: 1000;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.emoji-picker.hiding {\n  animation: hide var(--animation-duration) var(--animation-easing);\n}\n\n.emoji-picker.dark {\n  background: var(--dark-background-color);\n  color: var(--dark-text-color);\n  border-color: var(--dark-border-color);\n}\n\n.emoji-picker__content {\n  padding: 0.5em;\n  height: var(--content-height);\n  position: relative;\n}\n\n.emoji-picker__preview {\n  height: var(--emoji-preview-size);\n  padding: 0.5em;\n  border-top: 1px solid var(--border-color);\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n\n.emoji-picker.dark .emoji-picker__preview {\n  border-top-color: var(--dark-border-color);\n}\n\n.emoji-picker__preview-emoji {\n  font-size: var(--emoji-preview-size);\n  margin-right: 0.25em;\n  font-family: "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "EmojiOne Color", "Android Emoji";\n}\n\n.emoji-picker__preview-emoji img.emoji {\n  height: 1em;\n  width: 1em;\n  margin: 0 .05em 0 .1em;\n  vertical-align: -0.1em;\n}\n\n.emoji-picker__preview-name {\n  color: var(--text-color);\n  font-size: 0.85em;\n  overflow-wrap: break-word;\n  word-break: break-all;\n}\n\n.emoji-picker.dark .emoji-picker__preview-name {\n  color: var(--dark-text-color);\n}\n\n.emoji-picker__container {\n  display: grid;\n  justify-content: center;\n  grid-template-columns: repeat(var(--emoji-per-row), calc(var(--emoji-size) * var(--emoji-size-multiplier)));\n  grid-auto-rows: calc(var(--emoji-size) * var(--emoji-size-multiplier));\n}\n\n.emoji-picker__container.search-results {\n  height: var(--content-height);\n  overflow-y: auto;\n}\n\n.emoji-picker__custom-emoji {\n  width: 1em;\n  height: 1em;\n}\n\n.emoji-picker__emoji {\n  background: transparent;\n  border: none;\n  cursor: pointer;\n  overflow: hidden;\n  font-size: var(--emoji-size);\n  width: 1.5em;\n  height: 1.5em;\n  padding: 0;\n  margin: 0;\n  outline: none;\n  font-family: "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "EmojiOne Color", "Android Emoji";\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.emoji-picker__emoji img.emoji {\n  height: 1em;\n  width: 1em;\n  margin: 0 .05em 0 .1em;\n  vertical-align: -0.1em;\n}\n\n.emoji-picker__emoji:focus, .emoji-picker__emoji:hover {\n  background: var(--hover-color);\n}\n\n.emoji-picker__emoji:focus {\n  outline: 1px dotted var(--focus-indicator-color);\n}\n\n.emoji-picker.dark .emoji-picker__emoji:focus, .emoji-picker.dark .emoji-picker__emoji:hover {\n  background: var(--dark-hover-color);\n}\n\n.emoji-picker__plugin-container {\n  margin: 0.5em;\n  display: flex;\n  flex-direction: row;\n}\n\n.emoji-picker__search-container {\n  margin: 0.5em;\n  position: relative;\n  height: var(--search-height);\n  display: flex;\n}\n\n.emoji-picker__search {\n  box-sizing: border-box;\n  width: 100%;\n  border-radius: 3px;\n  border: 1px solid var(--border-color);\n  padding-right: 2em;\n  padding: 0.5em 2.25em 0.5em 0.5em;\n  font-size: 0.85em;\n  outline: none;\n}\n\n.emoji-picker.dark .emoji-picker__search {\n  background: var(--dark-search-background-color);\n  color: var(--dark-text-color);\n  border-color: var(--dark-search-border-color);\n}\n\n.emoji-picker.dark .emoji-picker__search::placeholder {\n  color: var(--dark-search-placeholder-color);\n}\n\n.emoji-picker__search:focus {\n  border: 1px solid var(--search-focus-border-color);\n}\n\n.emoji-picker.dark .emoji-picker__search:focus {\n  border-color: var(--dark-search-focus-border-color);\n}\n\n.emoji-picker__search-icon {\n  position: absolute;\n  color: var(--search-icon-color);\n  width: 1em;\n  height: 1em;\n  right: 0.75em;\n  top: calc(50% - 0.5em);\n}\n\n.emoji-picker__search-icon img {\n  width: 1em;\n  height: 1em;\n}\n\n.emoji-picker__search-not-found {\n  color: var(--secondary-text-color);\n  text-align: center;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n\n.emoji-picker__search-not-found h2 {\n  color: var(--secondary-text-color);\n}\n\n.emoji-picker.dark .emoji-picker__search-not-found {\n  color: var(--dark-secondary-text-color);\n}\n\n.emoji-picker.dark .emoji-picker__search-not-found h2 {\n  color: var(--dark-secondary-text-color);\n}\n\n.emoji-picker__search-not-found-icon {\n  font-size: 3em;\n}\n\n.emoji-picker__search-not-found-icon img {\n  width: 1em;\n  height: 1em;\n}\n\n.emoji-picker__search-not-found h2 {\n  margin: 0.5em 0;\n  font-size: 1em;\n}\n\n.emoji-picker__variant-overlay {\n  background: var(--overlay-background-color);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 5px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  animation: fade-in var(--animation-duration) var(--animation-easing);\n}\n\n.emoji-picker__variant-overlay.hiding {\n  animation: fade-out var(--animation-duration) var(--animation-easing);\n}\n\n.emoji-picker__variant-popup {\n  background: var(--popup-background-color);\n  margin: 0.5em;\n  padding: 0.5em;\n  text-align: center;\n  border-radius: 5px;\n  animation: grow var(--animation-duration) var(--animation-easing);\n  user-select: none;\n}\n\n.emoji-picker__variant-overlay.hiding .emoji-picker__variant-popup {\n  animation: shrink var(--animation-duration) var(--animation-easing);\n}\n\n.emoji-picker.dark .emoji-picker__variant-popup {\n  background: var(--dark-popup-background-color);\n}\n\n.emoji-picker__emojis {\n  overflow-y: auto;\n  position: relative;\n  height: calc((var(--emoji-size) * var(--emoji-size-multiplier)) * var(--row-count) + var(--category-name-size));\n}\n\n.emoji-picker__emojis.hiding {\n  animation: fade-out 0.05s var(--animation-easing);\n}\n\n.emoji-picker__emojis h2.emoji-picker__category-name {\n  font-size: 0.85em;\n  color: var(--secondary-text-color);\n  text-transform: uppercase;\n  margin: 0.25em 0;\n  text-align: left;\n}\n\n.emoji-picker.dark h2.emoji-picker__category-name {\n  color: var(--dark-secondary-text-color);\n}\n\n.emoji-picker__category-buttons {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-around;\n  height: var(--category-button-height);\n  margin-bottom: 0.5em;\n}\n\nbutton.emoji-picker__category-button {\n  flex-grow: 1;\n  background: transparent;\n  padding: 0;\n  border: none;\n  cursor: pointer;\n  font-size: var(--category-button-size);\n  vertical-align: middle;\n  color: var(--category-button-color);\n  border-bottom: var(--category-border-bottom-size) solid transparent;\n  outline: none;\n}\n\nbutton.emoji-picker__category-button img {\n  width: var(--category-button-size);\n  height: var(--category-button-size);\n}\n\n.emoji-picker.keyboard button.emoji-picker__category-button:focus {\n  outline: 1px dotted var(--focus-indicator-color);\n}\n\n.emoji-picker.dark button.emoji-picker__category-button.active {\n  color: var(--category-button-active-color);\n}\n\n.emoji-picker.dark button.emoji-picker__category-button {\n  color: var(--dark-category-button-color);\n}\n\nbutton.emoji-picker__category-button.active {\n  color: var(--category-button-active-color);\n  border-bottom: var(--category-border-bottom-size) solid var(--category-button-active-color);\n}\n\n@media (prefers-color-scheme: dark) {\n  .emoji-picker.auto {\n    background: var(--dark-background-color);\n    color: var(--dark-text-color);\n    border-color: var(--dark-border-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__preview {\n    border-top-color: var(--dark-border-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__preview-name {\n    color: var(--dark-text-color);\n  }\n\n  .emoji-picker.auto button.emoji-picker__category-button {\n    color: var(--dark-category-button-color);\n  }\n\n  .emoji-picker.auto button.emoji-picker__category-button.active {\n    color: var(--category-button-active-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__emoji:focus, .emoji-picker.auto .emoji-picker__emoji:hover {\n    background: var(--dark-hover-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__search {\n    background: var(--dark-search-background-color);\n    color: var(--dark-text-color);\n    border-color: var(--dark-search-border-color);\n  }\n \n  .emoji-picker.auto h2.emoji-picker__category-name {\n    color: var(--dark-secondary-text-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__search::placeholder {\n    color: var(--dark-search-placeholder-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__search:focus {\n    border-color: var(--dark-search-focus-border-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__search-not-found {\n    color: var(--dark-secondary-text-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__search-not-found h2 {\n    color: var(--dark-secondary-text-color);\n  }\n\n  .emoji-picker.auto .emoji-picker__variant-popup {\n    background: var(--dark-popup-background-color);\n  }\n}');
var o = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'], n = o.join(","), i = typeof Element == "undefined" ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
function a(e3, o3) {
  o3 = o3 || {};
  var a2, t2, s2, d2 = [], g2 = [], u2 = e3.querySelectorAll(n);
  for (o3.includeContainer && i.call(e3, n) && (u2 = Array.prototype.slice.apply(u2)).unshift(e3), a2 = 0; a2 < u2.length; a2++)
    r(t2 = u2[a2]) && ((s2 = m(t2)) === 0 ? d2.push(t2) : g2.push({ documentOrder: a2, tabIndex: s2, node: t2 }));
  return g2.sort(c).map(function(e4) {
    return e4.node;
  }).concat(d2);
}
function r(e3) {
  return !(!t(e3) || function(e4) {
    return function(e5) {
      return d(e5) && e5.type === "radio";
    }(e4) && !function(e5) {
      if (!e5.name)
        return true;
      var o3 = function(e6) {
        for (var o4 = 0; o4 < e6.length; o4++)
          if (e6[o4].checked)
            return e6[o4];
      }(e5.ownerDocument.querySelectorAll('input[type="radio"][name="' + e5.name + '"]'));
      return !o3 || o3 === e5;
    }(e4);
  }(e3) || m(e3) < 0);
}
function t(e3) {
  return !(e3.disabled || function(e4) {
    return d(e4) && e4.type === "hidden";
  }(e3) || function(e4) {
    return e4.offsetParent === null || getComputedStyle(e4).visibility === "hidden";
  }(e3));
}
a.isTabbable = function(e3) {
  if (!e3)
    throw new Error("No node provided");
  return i.call(e3, n) !== false && r(e3);
}, a.isFocusable = function(e3) {
  if (!e3)
    throw new Error("No node provided");
  return i.call(e3, s) !== false && t(e3);
};
var s = o.concat("iframe").join(",");
function m(e3) {
  var o3 = parseInt(e3.getAttribute("tabindex"), 10);
  return isNaN(o3) ? function(e4) {
    return e4.contentEditable === "true";
  }(e3) ? 0 : e3.tabIndex : o3;
}
function c(e3, o3) {
  return e3.tabIndex === o3.tabIndex ? e3.documentOrder - o3.documentOrder : e3.tabIndex - o3.tabIndex;
}
function d(e3) {
  return e3.tagName === "INPUT";
}
var g, u = a, l = function() {
  for (var e3 = {}, o3 = 0; o3 < arguments.length; o3++) {
    var n2 = arguments[o3];
    for (var i2 in n2)
      v.call(n2, i2) && (e3[i2] = n2[i2]);
  }
  return e3;
}, v = Object.prototype.hasOwnProperty;
var f, y = (f = [], { activateTrap: function(e3) {
  if (f.length > 0) {
    var o3 = f[f.length - 1];
    o3 !== e3 && o3.pause();
  }
  var n2 = f.indexOf(e3);
  n2 === -1 || f.splice(n2, 1), f.push(e3);
}, deactivateTrap: function(e3) {
  var o3 = f.indexOf(e3);
  o3 !== -1 && f.splice(o3, 1), f.length > 0 && f[f.length - 1].unpause();
} });
function j(e3) {
  return setTimeout(e3, 0);
}
var h = function(e3, o3) {
  var n2 = document, i2 = typeof e3 == "string" ? n2.querySelector(e3) : e3, a2 = l({ returnFocusOnDeactivate: true, escapeDeactivates: true }, o3), r2 = { firstTabbableNode: null, lastTabbableNode: null, nodeFocusedBeforeActivation: null, mostRecentlyFocusedNode: null, active: false, paused: false }, t2 = { activate: function(e4) {
    if (r2.active)
      return;
    w2(), r2.active = true, r2.paused = false, r2.nodeFocusedBeforeActivation = n2.activeElement;
    var o4 = e4 && e4.onActivate ? e4.onActivate : a2.onActivate;
    o4 && o4();
    return m2(), t2;
  }, deactivate: s2, pause: function() {
    if (r2.paused || !r2.active)
      return;
    r2.paused = true, c2();
  }, unpause: function() {
    if (!r2.paused || !r2.active)
      return;
    r2.paused = false, w2(), m2();
  } };
  return t2;
  function s2(e4) {
    if (r2.active) {
      clearTimeout(g), c2(), r2.active = false, r2.paused = false, y.deactivateTrap(t2);
      var o4 = e4 && e4.onDeactivate !== void 0 ? e4.onDeactivate : a2.onDeactivate;
      return o4 && o4(), (e4 && e4.returnFocus !== void 0 ? e4.returnFocus : a2.returnFocusOnDeactivate) && j(function() {
        var e5;
        k2((e5 = r2.nodeFocusedBeforeActivation, d2("setReturnFocus") || e5));
      }), t2;
    }
  }
  function m2() {
    if (r2.active)
      return y.activateTrap(t2), g = j(function() {
        k2(v2());
      }), n2.addEventListener("focusin", h2, true), n2.addEventListener("mousedown", f2, { capture: true, passive: false }), n2.addEventListener("touchstart", f2, { capture: true, passive: false }), n2.addEventListener("click", b2, { capture: true, passive: false }), n2.addEventListener("keydown", p2, { capture: true, passive: false }), t2;
  }
  function c2() {
    if (r2.active)
      return n2.removeEventListener("focusin", h2, true), n2.removeEventListener("mousedown", f2, true), n2.removeEventListener("touchstart", f2, true), n2.removeEventListener("click", b2, true), n2.removeEventListener("keydown", p2, true), t2;
  }
  function d2(e4) {
    var o4 = a2[e4], i3 = o4;
    if (!o4)
      return null;
    if (typeof o4 == "string" && !(i3 = n2.querySelector(o4)))
      throw new Error("`" + e4 + "` refers to no known node");
    if (typeof o4 == "function" && !(i3 = o4()))
      throw new Error("`" + e4 + "` did not return a node");
    return i3;
  }
  function v2() {
    var e4;
    if (!(e4 = d2("initialFocus") !== null ? d2("initialFocus") : i2.contains(n2.activeElement) ? n2.activeElement : r2.firstTabbableNode || d2("fallbackFocus")))
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return e4;
  }
  function f2(e4) {
    i2.contains(e4.target) || (a2.clickOutsideDeactivates ? s2({ returnFocus: !u.isFocusable(e4.target) }) : a2.allowOutsideClick && a2.allowOutsideClick(e4) || e4.preventDefault());
  }
  function h2(e4) {
    i2.contains(e4.target) || e4.target instanceof Document || (e4.stopImmediatePropagation(), k2(r2.mostRecentlyFocusedNode || v2()));
  }
  function p2(e4) {
    if (a2.escapeDeactivates !== false && function(e5) {
      return e5.key === "Escape" || e5.key === "Esc" || e5.keyCode === 27;
    }(e4))
      return e4.preventDefault(), void s2();
    (function(e5) {
      return e5.key === "Tab" || e5.keyCode === 9;
    })(e4) && function(e5) {
      if (w2(), e5.shiftKey && e5.target === r2.firstTabbableNode)
        return e5.preventDefault(), void k2(r2.lastTabbableNode);
      if (!e5.shiftKey && e5.target === r2.lastTabbableNode)
        e5.preventDefault(), k2(r2.firstTabbableNode);
    }(e4);
  }
  function b2(e4) {
    a2.clickOutsideDeactivates || i2.contains(e4.target) || a2.allowOutsideClick && a2.allowOutsideClick(e4) || (e4.preventDefault(), e4.stopImmediatePropagation());
  }
  function w2() {
    var e4 = u(i2);
    r2.firstTabbableNode = e4[0] || v2(), r2.lastTabbableNode = e4[e4.length - 1] || v2();
  }
  function k2(e4) {
    e4 !== n2.activeElement && (e4 && e4.focus ? (e4.focus(), r2.mostRecentlyFocusedNode = e4, function(e5) {
      return e5.tagName && e5.tagName.toLowerCase() === "input" && typeof e5.select == "function";
    }(e4) && e4.select()) : k2(v2()));
  }
};
function p() {
}
p.prototype = { on: function(e3, o3, n2) {
  var i2 = this.e || (this.e = {});
  return (i2[e3] || (i2[e3] = [])).push({ fn: o3, ctx: n2 }), this;
}, once: function(e3, o3, n2) {
  var i2 = this;
  function a2() {
    i2.off(e3, a2), o3.apply(n2, arguments);
  }
  return a2._ = o3, this.on(e3, a2, n2);
}, emit: function(e3) {
  for (var o3 = [].slice.call(arguments, 1), n2 = ((this.e || (this.e = {}))[e3] || []).slice(), i2 = 0, a2 = n2.length; i2 < a2; i2++)
    n2[i2].fn.apply(n2[i2].ctx, o3);
  return this;
}, off: function(e3, o3) {
  var n2 = this.e || (this.e = {}), i2 = n2[e3], a2 = [];
  if (i2 && o3)
    for (var r2 = 0, t2 = i2.length; r2 < t2; r2++)
      i2[r2].fn !== o3 && i2[r2].fn._ !== o3 && a2.push(i2[r2]);
  return a2.length ? n2[e3] = a2 : delete n2[e3], this;
} };
var b = p;
function w(e3) {
  var o3 = e3.getBoundingClientRect();
  return { width: o3.width, height: o3.height, top: o3.top, right: o3.right, bottom: o3.bottom, left: o3.left, x: o3.left, y: o3.top };
}
function k(e3) {
  if (e3.toString() !== "[object Window]") {
    var o3 = e3.ownerDocument;
    return o3 ? o3.defaultView : window;
  }
  return e3;
}
function x(e3) {
  var o3 = k(e3);
  return { scrollLeft: o3.pageXOffset, scrollTop: o3.pageYOffset };
}
function C(e3) {
  return e3 instanceof k(e3).Element || e3 instanceof Element;
}
function E(e3) {
  return e3 instanceof k(e3).HTMLElement || e3 instanceof HTMLElement;
}
function _(e3) {
  return e3 ? (e3.nodeName || "").toLowerCase() : null;
}
function z(e3) {
  return (C(e3) ? e3.ownerDocument : e3.document).documentElement;
}
function O(e3) {
  return w(z(e3)).left + x(e3).scrollLeft;
}
function I(e3) {
  return k(e3).getComputedStyle(e3);
}
function S(e3) {
  var o3 = I(e3), n2 = o3.overflow, i2 = o3.overflowX, a2 = o3.overflowY;
  return /auto|scroll|overlay|hidden/.test(n2 + a2 + i2);
}
function P(e3, o3, n2) {
  n2 === void 0 && (n2 = false);
  var i2, a2, r2 = z(o3), t2 = w(e3), s2 = { scrollLeft: 0, scrollTop: 0 }, m2 = { x: 0, y: 0 };
  return n2 || ((_(o3) !== "body" || S(r2)) && (s2 = (i2 = o3) !== k(i2) && E(i2) ? { scrollLeft: (a2 = i2).scrollLeft, scrollTop: a2.scrollTop } : x(i2)), E(o3) ? ((m2 = w(o3)).x += o3.clientLeft, m2.y += o3.clientTop) : r2 && (m2.x = O(r2))), { x: t2.left + s2.scrollLeft - m2.x, y: t2.top + s2.scrollTop - m2.y, width: t2.width, height: t2.height };
}
function M(e3) {
  return { x: e3.offsetLeft, y: e3.offsetTop, width: e3.offsetWidth, height: e3.offsetHeight };
}
function A(e3) {
  return _(e3) === "html" ? e3 : e3.assignedSlot || e3.parentNode || e3.host || z(e3);
}
function L(e3) {
  return ["html", "body", "#document"].indexOf(_(e3)) >= 0 ? e3.ownerDocument.body : E(e3) && S(e3) ? e3 : L(A(e3));
}
function T(e3, o3) {
  o3 === void 0 && (o3 = []);
  var n2 = L(e3), i2 = _(n2) === "body", a2 = k(n2), r2 = i2 ? [a2].concat(a2.visualViewport || [], S(n2) ? n2 : []) : n2, t2 = o3.concat(r2);
  return i2 ? t2 : t2.concat(T(A(r2)));
}
function N(e3) {
  return ["table", "td", "th"].indexOf(_(e3)) >= 0;
}
function F(e3) {
  return E(e3) && I(e3).position !== "fixed" ? e3.offsetParent : null;
}
function B(e3) {
  for (var o3 = k(e3), n2 = F(e3); n2 && N(n2); )
    n2 = F(n2);
  return n2 && _(n2) === "body" && I(n2).position === "static" ? o3 : n2 || o3;
}
p.TinyEmitter = b;
var D = "top", R = "bottom", q = "right", V = "left", H = [D, R, q, V], U = H.reduce(function(e3, o3) {
  return e3.concat([o3 + "-start", o3 + "-end"]);
}, []), W = [].concat(H, ["auto"]).reduce(function(e3, o3) {
  return e3.concat([o3, o3 + "-start", o3 + "-end"]);
}, []), K = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
function J(e3) {
  var o3 = new Map(), n2 = new Set(), i2 = [];
  function a2(e4) {
    n2.add(e4.name), [].concat(e4.requires || [], e4.requiresIfExists || []).forEach(function(e5) {
      if (!n2.has(e5)) {
        var i3 = o3.get(e5);
        i3 && a2(i3);
      }
    }), i2.push(e4);
  }
  return e3.forEach(function(e4) {
    o3.set(e4.name, e4);
  }), e3.forEach(function(e4) {
    n2.has(e4.name) || a2(e4);
  }), i2;
}
function G(e3) {
  return e3.split("-")[0];
}
var X = { placement: "bottom", modifiers: [], strategy: "absolute" };
function Y() {
  for (var e3 = arguments.length, o3 = new Array(e3), n2 = 0; n2 < e3; n2++)
    o3[n2] = arguments[n2];
  return !o3.some(function(e4) {
    return !(e4 && typeof e4.getBoundingClientRect == "function");
  });
}
function $(e3) {
  e3 === void 0 && (e3 = {});
  var o3 = e3, n2 = o3.defaultModifiers, i2 = n2 === void 0 ? [] : n2, a2 = o3.defaultOptions, r2 = a2 === void 0 ? X : a2;
  return function(e4, o4, n3) {
    n3 === void 0 && (n3 = r2);
    var a3, t2, s2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, X, {}, r2), modifiersData: {}, elements: { reference: e4, popper: o4 }, attributes: {}, styles: {} }, m2 = [], c2 = false, d2 = { state: s2, setOptions: function(n4) {
      g2(), s2.options = Object.assign({}, r2, {}, s2.options, {}, n4), s2.scrollParents = { reference: C(e4) ? T(e4) : e4.contextElement ? T(e4.contextElement) : [], popper: T(o4) };
      var a4, t3, c3 = function(e5) {
        var o5 = J(e5);
        return K.reduce(function(e6, n5) {
          return e6.concat(o5.filter(function(e7) {
            return e7.phase === n5;
          }));
        }, []);
      }((a4 = [].concat(i2, s2.options.modifiers), t3 = a4.reduce(function(e5, o5) {
        var n5 = e5[o5.name];
        return e5[o5.name] = n5 ? Object.assign({}, n5, {}, o5, { options: Object.assign({}, n5.options, {}, o5.options), data: Object.assign({}, n5.data, {}, o5.data) }) : o5, e5;
      }, {}), Object.keys(t3).map(function(e5) {
        return t3[e5];
      })));
      return s2.orderedModifiers = c3.filter(function(e5) {
        return e5.enabled;
      }), s2.orderedModifiers.forEach(function(e5) {
        var o5 = e5.name, n5 = e5.options, i3 = n5 === void 0 ? {} : n5, a5 = e5.effect;
        if (typeof a5 == "function") {
          var r3 = a5({ state: s2, name: o5, instance: d2, options: i3 }), t4 = function() {
          };
          m2.push(r3 || t4);
        }
      }), d2.update();
    }, forceUpdate: function() {
      if (!c2) {
        var e5 = s2.elements, o5 = e5.reference, n4 = e5.popper;
        if (Y(o5, n4)) {
          s2.rects = { reference: P(o5, B(n4), s2.options.strategy === "fixed"), popper: M(n4) }, s2.reset = false, s2.placement = s2.options.placement, s2.orderedModifiers.forEach(function(e6) {
            return s2.modifiersData[e6.name] = Object.assign({}, e6.data);
          });
          for (var i3 = 0; i3 < s2.orderedModifiers.length; i3++)
            if (s2.reset !== true) {
              var a4 = s2.orderedModifiers[i3], r3 = a4.fn, t3 = a4.options, m3 = t3 === void 0 ? {} : t3, g3 = a4.name;
              typeof r3 == "function" && (s2 = r3({ state: s2, options: m3, name: g3, instance: d2 }) || s2);
            } else
              s2.reset = false, i3 = -1;
        }
      }
    }, update: (a3 = function() {
      return new Promise(function(e5) {
        d2.forceUpdate(), e5(s2);
      });
    }, function() {
      return t2 || (t2 = new Promise(function(e5) {
        Promise.resolve().then(function() {
          t2 = void 0, e5(a3());
        });
      })), t2;
    }), destroy: function() {
      g2(), c2 = true;
    } };
    if (!Y(e4, o4))
      return d2;
    function g2() {
      m2.forEach(function(e5) {
        return e5();
      }), m2 = [];
    }
    return d2.setOptions(n3).then(function(e5) {
      !c2 && n3.onFirstUpdate && n3.onFirstUpdate(e5);
    }), d2;
  };
}
var Z = { passive: true };
function Q(e3) {
  return e3.split("-")[1];
}
function ee(e3) {
  return ["top", "bottom"].indexOf(e3) >= 0 ? "x" : "y";
}
function oe(e3) {
  var o3, n2 = e3.reference, i2 = e3.element, a2 = e3.placement, r2 = a2 ? G(a2) : null, t2 = a2 ? Q(a2) : null, s2 = n2.x + n2.width / 2 - i2.width / 2, m2 = n2.y + n2.height / 2 - i2.height / 2;
  switch (r2) {
    case D:
      o3 = { x: s2, y: n2.y - i2.height };
      break;
    case R:
      o3 = { x: s2, y: n2.y + n2.height };
      break;
    case q:
      o3 = { x: n2.x + n2.width, y: m2 };
      break;
    case V:
      o3 = { x: n2.x - i2.width, y: m2 };
      break;
    default:
      o3 = { x: n2.x, y: n2.y };
  }
  var c2 = r2 ? ee(r2) : null;
  if (c2 != null) {
    var d2 = c2 === "y" ? "height" : "width";
    switch (t2) {
      case "start":
        o3[c2] = Math.floor(o3[c2]) - Math.floor(n2[d2] / 2 - i2[d2] / 2);
        break;
      case "end":
        o3[c2] = Math.floor(o3[c2]) + Math.ceil(n2[d2] / 2 - i2[d2] / 2);
    }
  }
  return o3;
}
var ne = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function ie(e3) {
  var o3, n2 = e3.popper, i2 = e3.popperRect, a2 = e3.placement, r2 = e3.offsets, t2 = e3.position, s2 = e3.gpuAcceleration, m2 = e3.adaptive, c2 = function(e4) {
    var o4 = e4.x, n3 = e4.y, i3 = window.devicePixelRatio || 1;
    return { x: Math.round(o4 * i3) / i3 || 0, y: Math.round(n3 * i3) / i3 || 0 };
  }(r2), d2 = c2.x, g2 = c2.y, u2 = r2.hasOwnProperty("x"), l2 = r2.hasOwnProperty("y"), v2 = V, f2 = D, y2 = window;
  if (m2) {
    var j2 = B(n2);
    j2 === k(n2) && (j2 = z(n2)), a2 === D && (f2 = R, g2 -= j2.clientHeight - i2.height, g2 *= s2 ? 1 : -1), a2 === V && (v2 = q, d2 -= j2.clientWidth - i2.width, d2 *= s2 ? 1 : -1);
  }
  var h2, p2 = Object.assign({ position: t2 }, m2 && ne);
  return s2 ? Object.assign({}, p2, ((h2 = {})[f2] = l2 ? "0" : "", h2[v2] = u2 ? "0" : "", h2.transform = (y2.devicePixelRatio || 1) < 2 ? "translate(" + d2 + "px, " + g2 + "px)" : "translate3d(" + d2 + "px, " + g2 + "px, 0)", h2)) : Object.assign({}, p2, ((o3 = {})[f2] = l2 ? g2 + "px" : "", o3[v2] = u2 ? d2 + "px" : "", o3.transform = "", o3));
}
var ae = { left: "right", right: "left", bottom: "top", top: "bottom" };
function re(e3) {
  return e3.replace(/left|right|bottom|top/g, function(e4) {
    return ae[e4];
  });
}
var te = { start: "end", end: "start" };
function se(e3) {
  return e3.replace(/start|end/g, function(e4) {
    return te[e4];
  });
}
function me(e3) {
  return parseFloat(e3) || 0;
}
function ce(e3) {
  var o3 = k(e3), n2 = function(e4) {
    var o4 = E(e4) ? I(e4) : {};
    return { top: me(o4.borderTopWidth), right: me(o4.borderRightWidth), bottom: me(o4.borderBottomWidth), left: me(o4.borderLeftWidth) };
  }(e3), i2 = _(e3) === "html", a2 = O(e3), r2 = e3.clientWidth + n2.right, t2 = e3.clientHeight + n2.bottom;
  return i2 && o3.innerHeight - e3.clientHeight > 50 && (t2 = o3.innerHeight - n2.bottom), { top: i2 ? 0 : e3.clientTop, right: e3.clientLeft > n2.left ? n2.right : i2 ? o3.innerWidth - r2 - a2 : e3.offsetWidth - r2, bottom: i2 ? o3.innerHeight - t2 : e3.offsetHeight - t2, left: i2 ? a2 : e3.clientLeft };
}
function de(e3, o3) {
  var n2 = Boolean(o3.getRootNode && o3.getRootNode().host);
  if (e3.contains(o3))
    return true;
  if (n2) {
    var i2 = o3;
    do {
      if (i2 && e3.isSameNode(i2))
        return true;
      i2 = i2.parentNode || i2.host;
    } while (i2);
  }
  return false;
}
function ge(e3) {
  return Object.assign({}, e3, { left: e3.x, top: e3.y, right: e3.x + e3.width, bottom: e3.y + e3.height });
}
function ue(e3, o3) {
  return o3 === "viewport" ? ge(function(e4) {
    var o4 = k(e4), n2 = o4.visualViewport, i2 = o4.innerWidth, a2 = o4.innerHeight;
    return n2 && /iPhone|iPod|iPad/.test(navigator.platform) && (i2 = n2.width, a2 = n2.height), { width: i2, height: a2, x: 0, y: 0 };
  }(e3)) : E(o3) ? w(o3) : ge(function(e4) {
    var o4 = k(e4), n2 = x(e4), i2 = P(z(e4), o4);
    return i2.height = Math.max(i2.height, o4.innerHeight), i2.width = Math.max(i2.width, o4.innerWidth), i2.x = -n2.scrollLeft, i2.y = -n2.scrollTop, i2;
  }(z(e3)));
}
function le(e3, o3, n2) {
  var i2 = o3 === "clippingParents" ? function(e4) {
    var o4 = T(e4), n3 = ["absolute", "fixed"].indexOf(I(e4).position) >= 0 && E(e4) ? B(e4) : e4;
    return C(n3) ? o4.filter(function(e5) {
      return C(e5) && de(e5, n3);
    }) : [];
  }(e3) : [].concat(o3), a2 = [].concat(i2, [n2]), r2 = a2[0], t2 = a2.reduce(function(o4, n3) {
    var i3 = ue(e3, n3), a3 = ce(E(n3) ? n3 : z(e3));
    return o4.top = Math.max(i3.top + a3.top, o4.top), o4.right = Math.min(i3.right - a3.right, o4.right), o4.bottom = Math.min(i3.bottom - a3.bottom, o4.bottom), o4.left = Math.max(i3.left + a3.left, o4.left), o4;
  }, ue(e3, r2));
  return t2.width = t2.right - t2.left, t2.height = t2.bottom - t2.top, t2.x = t2.left, t2.y = t2.top, t2;
}
function ve(e3) {
  return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, {}, e3);
}
function fe(e3, o3) {
  return o3.reduce(function(o4, n2) {
    return o4[n2] = e3, o4;
  }, {});
}
function ye(e3, o3) {
  o3 === void 0 && (o3 = {});
  var n2 = o3, i2 = n2.placement, a2 = i2 === void 0 ? e3.placement : i2, r2 = n2.boundary, t2 = r2 === void 0 ? "clippingParents" : r2, s2 = n2.rootBoundary, m2 = s2 === void 0 ? "viewport" : s2, c2 = n2.elementContext, d2 = c2 === void 0 ? "popper" : c2, g2 = n2.altBoundary, u2 = g2 !== void 0 && g2, l2 = n2.padding, v2 = l2 === void 0 ? 0 : l2, f2 = ve(typeof v2 != "number" ? v2 : fe(v2, H)), y2 = d2 === "popper" ? "reference" : "popper", j2 = e3.elements.reference, h2 = e3.rects.popper, p2 = e3.elements[u2 ? y2 : d2], b2 = le(C(p2) ? p2 : p2.contextElement || z(e3.elements.popper), t2, m2), k2 = w(j2), x2 = oe({ reference: k2, element: h2, strategy: "absolute", placement: a2 }), E2 = ge(Object.assign({}, h2, {}, x2)), _2 = d2 === "popper" ? E2 : k2, O2 = { top: b2.top - _2.top + f2.top, bottom: _2.bottom - b2.bottom + f2.bottom, left: b2.left - _2.left + f2.left, right: _2.right - b2.right + f2.right }, I2 = e3.modifiersData.offset;
  if (d2 === "popper" && I2) {
    var S2 = I2[a2];
    Object.keys(O2).forEach(function(e4) {
      var o4 = [q, R].indexOf(e4) >= 0 ? 1 : -1, n3 = [D, R].indexOf(e4) >= 0 ? "y" : "x";
      O2[e4] += S2[n3] * o4;
    });
  }
  return O2;
}
function je(e3, o3) {
  o3 === void 0 && (o3 = {});
  var n2 = o3, i2 = n2.placement, a2 = n2.boundary, r2 = n2.rootBoundary, t2 = n2.padding, s2 = n2.flipVariations, m2 = n2.allowedAutoPlacements, c2 = m2 === void 0 ? W : m2, d2 = Q(i2), g2 = (d2 ? s2 ? U : U.filter(function(e4) {
    return Q(e4) === d2;
  }) : H).filter(function(e4) {
    return c2.indexOf(e4) >= 0;
  }).reduce(function(o4, n3) {
    return o4[n3] = ye(e3, { placement: n3, boundary: a2, rootBoundary: r2, padding: t2 })[G(n3)], o4;
  }, {});
  return Object.keys(g2).sort(function(e4, o4) {
    return g2[e4] - g2[o4];
  });
}
function he(e3, o3, n2) {
  return Math.max(e3, Math.min(o3, n2));
}
function pe(e3, o3, n2) {
  return n2 === void 0 && (n2 = { x: 0, y: 0 }), { top: e3.top - o3.height - n2.y, right: e3.right - o3.width + n2.x, bottom: e3.bottom - o3.height + n2.y, left: e3.left - o3.width - n2.x };
}
function be(e3) {
  return [D, q, R, V].some(function(o3) {
    return e3[o3] >= 0;
  });
}
var we = $({ defaultModifiers: [{ name: "eventListeners", enabled: true, phase: "write", fn: function() {
}, effect: function(e3) {
  var o3 = e3.state, n2 = e3.instance, i2 = e3.options, a2 = i2.scroll, r2 = a2 === void 0 || a2, t2 = i2.resize, s2 = t2 === void 0 || t2, m2 = k(o3.elements.popper), c2 = [].concat(o3.scrollParents.reference, o3.scrollParents.popper);
  return r2 && c2.forEach(function(e4) {
    e4.addEventListener("scroll", n2.update, Z);
  }), s2 && m2.addEventListener("resize", n2.update, Z), function() {
    r2 && c2.forEach(function(e4) {
      e4.removeEventListener("scroll", n2.update, Z);
    }), s2 && m2.removeEventListener("resize", n2.update, Z);
  };
}, data: {} }, { name: "popperOffsets", enabled: true, phase: "read", fn: function(e3) {
  var o3 = e3.state, n2 = e3.name;
  o3.modifiersData[n2] = oe({ reference: o3.rects.reference, element: o3.rects.popper, strategy: "absolute", placement: o3.placement });
}, data: {} }, { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(e3) {
  var o3 = e3.state, n2 = e3.options, i2 = n2.gpuAcceleration, a2 = i2 === void 0 || i2, r2 = n2.adaptive, t2 = r2 === void 0 || r2, s2 = { placement: G(o3.placement), popper: o3.elements.popper, popperRect: o3.rects.popper, gpuAcceleration: a2 };
  o3.modifiersData.popperOffsets != null && (o3.styles.popper = Object.assign({}, o3.styles.popper, {}, ie(Object.assign({}, s2, { offsets: o3.modifiersData.popperOffsets, position: o3.options.strategy, adaptive: t2 })))), o3.modifiersData.arrow != null && (o3.styles.arrow = Object.assign({}, o3.styles.arrow, {}, ie(Object.assign({}, s2, { offsets: o3.modifiersData.arrow, position: "absolute", adaptive: false })))), o3.attributes.popper = Object.assign({}, o3.attributes.popper, { "data-popper-placement": o3.placement });
}, data: {} }, { name: "applyStyles", enabled: true, phase: "write", fn: function(e3) {
  var o3 = e3.state;
  Object.keys(o3.elements).forEach(function(e4) {
    var n2 = o3.styles[e4] || {}, i2 = o3.attributes[e4] || {}, a2 = o3.elements[e4];
    E(a2) && _(a2) && (Object.assign(a2.style, n2), Object.keys(i2).forEach(function(e5) {
      var o4 = i2[e5];
      o4 === false ? a2.removeAttribute(e5) : a2.setAttribute(e5, o4 === true ? "" : o4);
    }));
  });
}, effect: function(e3) {
  var o3 = e3.state, n2 = { popper: { position: o3.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(o3.elements.popper.style, n2.popper), o3.elements.arrow && Object.assign(o3.elements.arrow.style, n2.arrow), function() {
    Object.keys(o3.elements).forEach(function(e4) {
      var i2 = o3.elements[e4], a2 = o3.attributes[e4] || {}, r2 = Object.keys(o3.styles.hasOwnProperty(e4) ? o3.styles[e4] : n2[e4]).reduce(function(e5, o4) {
        return e5[o4] = "", e5;
      }, {});
      E(i2) && _(i2) && (Object.assign(i2.style, r2), Object.keys(a2).forEach(function(e5) {
        i2.removeAttribute(e5);
      }));
    });
  };
}, requires: ["computeStyles"] }, { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(e3) {
  var o3 = e3.state, n2 = e3.options, i2 = e3.name, a2 = n2.offset, r2 = a2 === void 0 ? [0, 0] : a2, t2 = W.reduce(function(e4, n3) {
    return e4[n3] = function(e5, o4, n4) {
      var i3 = G(e5), a3 = [V, D].indexOf(i3) >= 0 ? -1 : 1, r3 = typeof n4 == "function" ? n4(Object.assign({}, o4, { placement: e5 })) : n4, t3 = r3[0], s3 = r3[1];
      return t3 = t3 || 0, s3 = (s3 || 0) * a3, [V, q].indexOf(i3) >= 0 ? { x: s3, y: t3 } : { x: t3, y: s3 };
    }(n3, o3.rects, r2), e4;
  }, {}), s2 = t2[o3.placement], m2 = s2.x, c2 = s2.y;
  o3.modifiersData.popperOffsets != null && (o3.modifiersData.popperOffsets.x += m2, o3.modifiersData.popperOffsets.y += c2), o3.modifiersData[i2] = t2;
} }, { name: "flip", enabled: true, phase: "main", fn: function(e3) {
  var o3 = e3.state, n2 = e3.options, i2 = e3.name;
  if (!o3.modifiersData[i2]._skip) {
    for (var a2 = n2.mainAxis, r2 = a2 === void 0 || a2, t2 = n2.altAxis, s2 = t2 === void 0 || t2, m2 = n2.fallbackPlacements, c2 = n2.padding, d2 = n2.boundary, g2 = n2.rootBoundary, u2 = n2.altBoundary, l2 = n2.flipVariations, v2 = l2 === void 0 || l2, f2 = n2.allowedAutoPlacements, y2 = o3.options.placement, j2 = G(y2), h2 = m2 || (j2 === y2 || !v2 ? [re(y2)] : function(e4) {
      if (G(e4) === "auto")
        return [];
      var o4 = re(e4);
      return [se(e4), o4, se(o4)];
    }(y2)), p2 = [y2].concat(h2).reduce(function(e4, n3) {
      return e4.concat(G(n3) === "auto" ? je(o3, { placement: n3, boundary: d2, rootBoundary: g2, padding: c2, flipVariations: v2, allowedAutoPlacements: f2 }) : n3);
    }, []), b2 = o3.rects.reference, w2 = o3.rects.popper, k2 = new Map(), x2 = true, C2 = p2[0], E2 = 0; E2 < p2.length; E2++) {
      var _2 = p2[E2], z2 = G(_2), O2 = Q(_2) === "start", I2 = [D, R].indexOf(z2) >= 0, S2 = I2 ? "width" : "height", P2 = ye(o3, { placement: _2, boundary: d2, rootBoundary: g2, altBoundary: u2, padding: c2 }), M2 = I2 ? O2 ? q : V : O2 ? R : D;
      b2[S2] > w2[S2] && (M2 = re(M2));
      var A2 = re(M2), L2 = [];
      if (r2 && L2.push(P2[z2] <= 0), s2 && L2.push(P2[M2] <= 0, P2[A2] <= 0), L2.every(function(e4) {
        return e4;
      })) {
        C2 = _2, x2 = false;
        break;
      }
      k2.set(_2, L2);
    }
    if (x2)
      for (var T2 = function(e4) {
        var o4 = p2.find(function(o5) {
          var n3 = k2.get(o5);
          if (n3)
            return n3.slice(0, e4).every(function(e5) {
              return e5;
            });
        });
        if (o4)
          return C2 = o4, "break";
      }, N2 = v2 ? 3 : 1; N2 > 0; N2--) {
        if (T2(N2) === "break")
          break;
      }
    o3.placement !== C2 && (o3.modifiersData[i2]._skip = true, o3.placement = C2, o3.reset = true);
  }
}, requiresIfExists: ["offset"], data: { _skip: false } }, { name: "preventOverflow", enabled: true, phase: "main", fn: function(e3) {
  var o3 = e3.state, n2 = e3.options, i2 = e3.name, a2 = n2.mainAxis, r2 = a2 === void 0 || a2, t2 = n2.altAxis, s2 = t2 !== void 0 && t2, m2 = n2.boundary, c2 = n2.rootBoundary, d2 = n2.altBoundary, g2 = n2.padding, u2 = n2.tether, l2 = u2 === void 0 || u2, v2 = n2.tetherOffset, f2 = v2 === void 0 ? 0 : v2, y2 = ye(o3, { boundary: m2, rootBoundary: c2, padding: g2, altBoundary: d2 }), j2 = G(o3.placement), h2 = Q(o3.placement), p2 = !h2, b2 = ee(j2), w2 = b2 === "x" ? "y" : "x", k2 = o3.modifiersData.popperOffsets, x2 = o3.rects.reference, C2 = o3.rects.popper, E2 = typeof f2 == "function" ? f2(Object.assign({}, o3.rects, { placement: o3.placement })) : f2, _2 = { x: 0, y: 0 };
  if (k2) {
    if (r2) {
      var z2 = b2 === "y" ? D : V, O2 = b2 === "y" ? R : q, I2 = b2 === "y" ? "height" : "width", S2 = k2[b2], P2 = k2[b2] + y2[z2], A2 = k2[b2] - y2[O2], L2 = l2 ? -C2[I2] / 2 : 0, T2 = h2 === "start" ? x2[I2] : C2[I2], N2 = h2 === "start" ? -C2[I2] : -x2[I2], F2 = o3.elements.arrow, H2 = l2 && F2 ? M(F2) : { width: 0, height: 0 }, U2 = o3.modifiersData["arrow#persistent"] ? o3.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, W2 = U2[z2], K2 = U2[O2], J2 = he(0, x2[I2], H2[I2]), X2 = p2 ? x2[I2] / 2 - L2 - J2 - W2 - E2 : T2 - J2 - W2 - E2, Y2 = p2 ? -x2[I2] / 2 + L2 + J2 + K2 + E2 : N2 + J2 + K2 + E2, $2 = o3.elements.arrow && B(o3.elements.arrow), Z2 = $2 ? b2 === "y" ? $2.clientTop || 0 : $2.clientLeft || 0 : 0, oe2 = o3.modifiersData.offset ? o3.modifiersData.offset[o3.placement][b2] : 0, ne2 = k2[b2] + X2 - oe2 - Z2, ie2 = k2[b2] + Y2 - oe2, ae2 = he(l2 ? Math.min(P2, ne2) : P2, S2, l2 ? Math.max(A2, ie2) : A2);
      k2[b2] = ae2, _2[b2] = ae2 - S2;
    }
    if (s2) {
      var re2 = b2 === "x" ? D : V, te2 = b2 === "x" ? R : q, se2 = k2[w2], me2 = he(se2 + y2[re2], se2, se2 - y2[te2]);
      k2[w2] = me2, _2[w2] = me2 - se2;
    }
    o3.modifiersData[i2] = _2;
  }
}, requiresIfExists: ["offset"] }, { name: "arrow", enabled: true, phase: "main", fn: function(e3) {
  var o3, n2 = e3.state, i2 = e3.name, a2 = n2.elements.arrow, r2 = n2.modifiersData.popperOffsets, t2 = G(n2.placement), s2 = ee(t2), m2 = [V, q].indexOf(t2) >= 0 ? "height" : "width";
  if (a2 && r2) {
    var c2 = n2.modifiersData[i2 + "#persistent"].padding, d2 = M(a2), g2 = s2 === "y" ? D : V, u2 = s2 === "y" ? R : q, l2 = n2.rects.reference[m2] + n2.rects.reference[s2] - r2[s2] - n2.rects.popper[m2], v2 = r2[s2] - n2.rects.reference[s2], f2 = B(a2), y2 = f2 ? s2 === "y" ? f2.clientHeight || 0 : f2.clientWidth || 0 : 0, j2 = l2 / 2 - v2 / 2, h2 = c2[g2], p2 = y2 - d2[m2] - c2[u2], b2 = y2 / 2 - d2[m2] / 2 + j2, w2 = he(h2, b2, p2), k2 = s2;
    n2.modifiersData[i2] = ((o3 = {})[k2] = w2, o3.centerOffset = w2 - b2, o3);
  }
}, effect: function(e3) {
  var o3 = e3.state, n2 = e3.options, i2 = e3.name, a2 = n2.element, r2 = a2 === void 0 ? "[data-popper-arrow]" : a2, t2 = n2.padding, s2 = t2 === void 0 ? 0 : t2;
  r2 != null && (typeof r2 != "string" || (r2 = o3.elements.popper.querySelector(r2))) && de(o3.elements.popper, r2) && (o3.elements.arrow = r2, o3.modifiersData[i2 + "#persistent"] = { padding: ve(typeof s2 != "number" ? s2 : fe(s2, H)) });
}, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }, { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(e3) {
  var o3 = e3.state, n2 = e3.name, i2 = o3.rects.reference, a2 = o3.rects.popper, r2 = o3.modifiersData.preventOverflow, t2 = ye(o3, { elementContext: "reference" }), s2 = ye(o3, { altBoundary: true }), m2 = pe(t2, i2), c2 = pe(s2, a2, r2), d2 = be(m2), g2 = be(c2);
  o3.modifiersData[n2] = { referenceClippingOffsets: m2, popperEscapeOffsets: c2, isReferenceHidden: d2, hasPopperEscaped: g2 }, o3.attributes.popper = Object.assign({}, o3.attributes.popper, { "data-popper-reference-hidden": d2, "data-popper-escaped": g2 });
} }] }), ke = function() {
  var e3 = { base: "https://twemoji.maxcdn.com/v/13.0.0/", ext: ".png", size: "72x72", className: "emoji", convert: { fromCodePoint: function(e4) {
    var o4 = typeof e4 == "string" ? parseInt(e4, 16) : e4;
    if (o4 < 65536)
      return s2(o4);
    return s2(55296 + ((o4 -= 65536) >> 10), 56320 + (1023 & o4));
  }, toCodePoint: j2 }, onerror: function() {
    this.parentNode && this.parentNode.replaceChild(m2(this.alt, false), this);
  }, parse: function(o4, n3) {
    n3 && typeof n3 != "function" || (n3 = { callback: n3 });
    return (typeof o4 == "string" ? l2 : u2)(o4, { callback: n3.callback || c2, attributes: typeof n3.attributes == "function" ? n3.attributes : f2, base: typeof n3.base == "string" ? n3.base : e3.base, ext: n3.ext || e3.ext, size: n3.folder || (i3 = n3.size || e3.size, typeof i3 == "number" ? i3 + "x" + i3 : i3), className: n3.className || e3.className, onerror: n3.onerror || e3.onerror });
    var i3;
  }, replace: y2, test: function(e4) {
    n2.lastIndex = 0;
    var o4 = n2.test(e4);
    return n2.lastIndex = 0, o4;
  } }, o3 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, n2 = /(?:\ud83d\udc68\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffc-\udfff]|\ud83d\udc68\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffd-\udfff]|\ud83d\udc68\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc68\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffd\udfff]|\ud83d\udc68\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffe]|\ud83d\udc69\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffc-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffc-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffd-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb\udffd-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc69\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc69\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffd\udfff]|\ud83d\udc69\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb-\udffd\udfff]|\ud83d\udc69\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffe]|\ud83d\udc69\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb-\udffe]|\ud83e\uddd1\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1|\ud83d\udc6b\ud83c[\udffb-\udfff]|\ud83d\udc6c\ud83c[\udffb-\udfff]|\ud83d\udc6d\ud83c[\udffb-\udfff]|\ud83d[\udc6b-\udc6d])|(?:\ud83d[\udc68\udc69]|\ud83e\uddd1)(?:\ud83c[\udffb-\udfff])?\u200d(?:\u2695\ufe0f|\u2696\ufe0f|\u2708\ufe0f|\ud83c[\udf3e\udf73\udf7c\udf84\udf93\udfa4\udfa8\udfeb\udfed]|\ud83d[\udcbb\udcbc\udd27\udd2c\ude80\ude92]|\ud83e[\uddaf-\uddb3\uddbc\uddbd])|(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75]|\u26f9)((?:\ud83c[\udffb-\udfff]|\ufe0f)\u200d[\u2640\u2642]\ufe0f)|(?:\ud83c[\udfc3\udfc4\udfca]|\ud83d[\udc6e\udc70\udc71\udc73\udc77\udc81\udc82\udc86\udc87\ude45-\ude47\ude4b\ude4d\ude4e\udea3\udeb4-\udeb6]|\ud83e[\udd26\udd35\udd37-\udd39\udd3d\udd3e\uddb8\uddb9\uddcd-\uddcf\uddd6-\udddd])(?:\ud83c[\udffb-\udfff])?\u200d[\u2640\u2642]\ufe0f|(?:\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f|\ud83c\udff3\ufe0f\u200d\ud83c\udf08|\ud83c\udff4\u200d\u2620\ufe0f|\ud83d\udc15\u200d\ud83e\uddba|\ud83d\udc3b\u200d\u2744\ufe0f|\ud83d\udc41\u200d\ud83d\udde8|\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc6f\u200d\u2640\ufe0f|\ud83d\udc6f\u200d\u2642\ufe0f|\ud83e\udd3c\u200d\u2640\ufe0f|\ud83e\udd3c\u200d\u2642\ufe0f|\ud83e\uddde\u200d\u2640\ufe0f|\ud83e\uddde\u200d\u2642\ufe0f|\ud83e\udddf\u200d\u2640\ufe0f|\ud83e\udddf\u200d\u2642\ufe0f|\ud83d\udc08\u200d\u2b1b)|[#*0-9]\ufe0f?\u20e3|(?:[\u2122\u265f]\ufe0f)|(?:\ud83c[\udc04\udd70\udd71\udd7e\udd7f\ude02\ude1a\ude2f\ude37\udf21\udf24-\udf2c\udf36\udf7d\udf96\udf97\udf99-\udf9b\udf9e\udf9f\udfcd\udfce\udfd4-\udfdf\udff3\udff5\udff7]|\ud83d[\udc3f\udc41\udcfd\udd49\udd4a\udd6f\udd70\udd73\udd76-\udd79\udd87\udd8a-\udd8d\udda5\udda8\uddb1\uddb2\uddbc\uddc2-\uddc4\uddd1-\uddd3\udddc-\uddde\udde1\udde3\udde8\uddef\uddf3\uddfa\udecb\udecd-\udecf\udee0-\udee5\udee9\udef0\udef3]|[\u203c\u2049\u2139\u2194-\u2199\u21a9\u21aa\u231a\u231b\u2328\u23cf\u23ed-\u23ef\u23f1\u23f2\u23f8-\u23fa\u24c2\u25aa\u25ab\u25b6\u25c0\u25fb-\u25fe\u2600-\u2604\u260e\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638-\u263a\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267b\u267f\u2692-\u2697\u2699\u269b\u269c\u26a0\u26a1\u26a7\u26aa\u26ab\u26b0\u26b1\u26bd\u26be\u26c4\u26c5\u26c8\u26cf\u26d1\u26d3\u26d4\u26e9\u26ea\u26f0-\u26f5\u26f8\u26fa\u26fd\u2702\u2708\u2709\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u2764\u27a1\u2934\u2935\u2b05-\u2b07\u2b1b\u2b1c\u2b50\u2b55\u3030\u303d\u3297\u3299])(?:\ufe0f|(?!\ufe0e))|(?:(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75\udd90]|[\u261d\u26f7\u26f9\u270c\u270d])(?:\ufe0f|(?!\ufe0e))|(?:\ud83c[\udf85\udfc2-\udfc4\udfc7\udfca]|\ud83d[\udc42\udc43\udc46-\udc50\udc66-\udc69\udc6e\udc70-\udc78\udc7c\udc81-\udc83\udc85-\udc87\udcaa\udd7a\udd95\udd96\ude45-\ude47\ude4b-\ude4f\udea3\udeb4-\udeb6\udec0\udecc]|\ud83e[\udd0c\udd0f\udd18-\udd1c\udd1e\udd1f\udd26\udd30-\udd39\udd3d\udd3e\udd77\uddb5\uddb6\uddb8\uddb9\uddbb\uddcd-\uddcf\uddd1-\udddd]|[\u270a\u270b]))(?:\ud83c[\udffb-\udfff])?|(?:\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc77\udb40\udc6c\udb40\udc73\udb40\udc7f|\ud83c\udde6\ud83c[\udde8-\uddec\uddee\uddf1\uddf2\uddf4\uddf6-\uddfa\uddfc\uddfd\uddff]|\ud83c\udde7\ud83c[\udde6\udde7\udde9-\uddef\uddf1-\uddf4\uddf6-\uddf9\uddfb\uddfc\uddfe\uddff]|\ud83c\udde8\ud83c[\udde6\udde8\udde9\uddeb-\uddee\uddf0-\uddf5\uddf7\uddfa-\uddff]|\ud83c\udde9\ud83c[\uddea\uddec\uddef\uddf0\uddf2\uddf4\uddff]|\ud83c\uddea\ud83c[\udde6\udde8\uddea\uddec\udded\uddf7-\uddfa]|\ud83c\uddeb\ud83c[\uddee-\uddf0\uddf2\uddf4\uddf7]|\ud83c\uddec\ud83c[\udde6\udde7\udde9-\uddee\uddf1-\uddf3\uddf5-\uddfa\uddfc\uddfe]|\ud83c\udded\ud83c[\uddf0\uddf2\uddf3\uddf7\uddf9\uddfa]|\ud83c\uddee\ud83c[\udde8-\uddea\uddf1-\uddf4\uddf6-\uddf9]|\ud83c\uddef\ud83c[\uddea\uddf2\uddf4\uddf5]|\ud83c\uddf0\ud83c[\uddea\uddec-\uddee\uddf2\uddf3\uddf5\uddf7\uddfc\uddfe\uddff]|\ud83c\uddf1\ud83c[\udde6-\udde8\uddee\uddf0\uddf7-\uddfb\uddfe]|\ud83c\uddf2\ud83c[\udde6\udde8-\udded\uddf0-\uddff]|\ud83c\uddf3\ud83c[\udde6\udde8\uddea-\uddec\uddee\uddf1\uddf4\uddf5\uddf7\uddfa\uddff]|\ud83c\uddf4\ud83c\uddf2|\ud83c\uddf5\ud83c[\udde6\uddea-\udded\uddf0-\uddf3\uddf7-\uddf9\uddfc\uddfe]|\ud83c\uddf6\ud83c\udde6|\ud83c\uddf7\ud83c[\uddea\uddf4\uddf8\uddfa\uddfc]|\ud83c\uddf8\ud83c[\udde6-\uddea\uddec-\uddf4\uddf7-\uddf9\uddfb\uddfd-\uddff]|\ud83c\uddf9\ud83c[\udde6\udde8\udde9\uddeb-\udded\uddef-\uddf4\uddf7\uddf9\uddfb\uddfc\uddff]|\ud83c\uddfa\ud83c[\udde6\uddec\uddf2\uddf3\uddf8\uddfe\uddff]|\ud83c\uddfb\ud83c[\udde6\udde8\uddea\uddec\uddee\uddf3\uddfa]|\ud83c\uddfc\ud83c[\uddeb\uddf8]|\ud83c\uddfd\ud83c\uddf0|\ud83c\uddfe\ud83c[\uddea\uddf9]|\ud83c\uddff\ud83c[\udde6\uddf2\uddfc]|\ud83c[\udccf\udd8e\udd91-\udd9a\udde6-\uddff\ude01\ude32-\ude36\ude38-\ude3a\ude50\ude51\udf00-\udf20\udf2d-\udf35\udf37-\udf7c\udf7e-\udf84\udf86-\udf93\udfa0-\udfc1\udfc5\udfc6\udfc8\udfc9\udfcf-\udfd3\udfe0-\udff0\udff4\udff8-\udfff]|\ud83d[\udc00-\udc3e\udc40\udc44\udc45\udc51-\udc65\udc6a\udc6f\udc79-\udc7b\udc7d-\udc80\udc84\udc88-\udca9\udcab-\udcfc\udcff-\udd3d\udd4b-\udd4e\udd50-\udd67\udda4\uddfb-\ude44\ude48-\ude4a\ude80-\udea2\udea4-\udeb3\udeb7-\udebf\udec1-\udec5\uded0-\uded2\uded5-\uded7\udeeb\udeec\udef4-\udefc\udfe0-\udfeb]|\ud83e[\udd0d\udd0e\udd10-\udd17\udd1d\udd20-\udd25\udd27-\udd2f\udd3a\udd3c\udd3f-\udd45\udd47-\udd76\udd78\udd7a-\uddb4\uddb7\uddba\uddbc-\uddcb\uddd0\uddde-\uddff\ude70-\ude74\ude78-\ude7a\ude80-\ude86\ude90-\udea8\udeb0-\udeb6\udec0-\udec2\uded0-\uded6]|[\u23e9-\u23ec\u23f0\u23f3\u267e\u26ce\u2705\u2728\u274c\u274e\u2753-\u2755\u2795-\u2797\u27b0\u27bf\ue50a])|\ufe0f/g, i2 = /\uFE0F/g, a2 = String.fromCharCode(8205), r2 = /[&<>'"]/g, t2 = /^(?:iframe|noframes|noscript|script|select|style|textarea)$/, s2 = String.fromCharCode;
  return e3;
  function m2(e4, o4) {
    return document.createTextNode(o4 ? e4.replace(i2, "") : e4);
  }
  function c2(e4, o4) {
    return "".concat(o4.base, o4.size, "/", e4, o4.ext);
  }
  function d2(e4, o4) {
    for (var n3, i3, a3 = e4.childNodes, r3 = a3.length; r3--; )
      (i3 = (n3 = a3[r3]).nodeType) === 3 ? o4.push(n3) : i3 !== 1 || "ownerSVGElement" in n3 || t2.test(n3.nodeName.toLowerCase()) || d2(n3, o4);
    return o4;
  }
  function g2(e4) {
    return j2(e4.indexOf(a2) < 0 ? e4.replace(i2, "") : e4);
  }
  function u2(e4, o4) {
    for (var i3, a3, r3, t3, s3, c3, u3, l3, v3, f3, y3, j3, h2, p2 = d2(e4, []), b2 = p2.length; b2--; ) {
      for (r3 = false, t3 = document.createDocumentFragment(), c3 = (s3 = p2[b2]).nodeValue, l3 = 0; u3 = n2.exec(c3); ) {
        if ((v3 = u3.index) !== l3 && t3.appendChild(m2(c3.slice(l3, v3), true)), j3 = g2(y3 = u3[0]), l3 = v3 + y3.length, h2 = o4.callback(j3, o4), j3 && h2) {
          for (a3 in (f3 = new Image()).onerror = o4.onerror, f3.setAttribute("draggable", "false"), i3 = o4.attributes(y3, j3))
            i3.hasOwnProperty(a3) && a3.indexOf("on") !== 0 && !f3.hasAttribute(a3) && f3.setAttribute(a3, i3[a3]);
          f3.className = o4.className, f3.alt = y3, f3.src = h2, r3 = true, t3.appendChild(f3);
        }
        f3 || t3.appendChild(m2(y3, false)), f3 = null;
      }
      r3 && (l3 < c3.length && t3.appendChild(m2(c3.slice(l3), true)), s3.parentNode.replaceChild(t3, s3));
    }
    return e4;
  }
  function l2(e4, o4) {
    return y2(e4, function(e5) {
      var n3, i3, a3 = e5, t3 = g2(e5), s3 = o4.callback(t3, o4);
      if (t3 && s3) {
        for (i3 in a3 = "<img ".concat('class="', o4.className, '" ', 'draggable="false" ', 'alt="', e5, '"', ' src="', s3, '"'), n3 = o4.attributes(e5, t3))
          n3.hasOwnProperty(i3) && i3.indexOf("on") !== 0 && a3.indexOf(" " + i3 + "=") === -1 && (a3 = a3.concat(" ", i3, '="', n3[i3].replace(r2, v2), '"'));
        a3 = a3.concat("/>");
      }
      return a3;
    });
  }
  function v2(e4) {
    return o3[e4];
  }
  function f2() {
    return null;
  }
  function y2(e4, o4) {
    return String(e4).replace(n2, o4);
  }
  function j2(e4, o4) {
    for (var n3 = [], i3 = 0, a3 = 0, r3 = 0; r3 < e4.length; )
      i3 = e4.charCodeAt(r3++), a3 ? (n3.push((65536 + (a3 - 55296 << 10) + (i3 - 56320)).toString(16)), a3 = 0) : 55296 <= i3 && i3 <= 56319 ? a3 = i3 : n3.push(i3.toString(16));
    return n3.join(o4 || "-");
  }
}(), xe = { categories: ["smileys", "people", "animals", "food", "travel", "activities", "objects", "symbols", "flags"], emoji: [{ emoji: "\u{1F600}", category: 0, name: "grinning face", version: "1.0" }, { emoji: "\u{1F603}", category: 0, name: "grinning face with big eyes", version: "1.0" }, { emoji: "\u{1F604}", category: 0, name: "grinning face with smiling eyes", version: "1.0" }, { emoji: "\u{1F601}", category: 0, name: "beaming face with smiling eyes", version: "1.0" }, { emoji: "\u{1F606}", category: 0, name: "grinning squinting face", version: "1.0" }, { emoji: "\u{1F605}", category: 0, name: "grinning face with sweat", version: "1.0" }, { emoji: "\u{1F923}", category: 0, name: "rolling on the floor laughing", version: "3.0" }, { emoji: "\u{1F602}", category: 0, name: "face with tears of joy", version: "1.0" }, { emoji: "\u{1F642}", category: 0, name: "slightly smiling face", version: "1.0" }, { emoji: "\u{1F643}", category: 0, name: "upside-down face", version: "1.0" }, { emoji: "\u{1F609}", category: 0, name: "winking face", version: "1.0" }, { emoji: "\u{1F60A}", category: 0, name: "smiling face with smiling eyes", version: "1.0" }, { emoji: "\u{1F607}", category: 0, name: "smiling face with halo", version: "1.0" }, { emoji: "\u{1F970}", category: 0, name: "smiling face with hearts", version: "11.0" }, { emoji: "\u{1F60D}", category: 0, name: "smiling face with heart-eyes", version: "1.0" }, { emoji: "\u{1F929}", category: 0, name: "star-struck", version: "5.0" }, { emoji: "\u{1F618}", category: 0, name: "face blowing a kiss", version: "1.0" }, { emoji: "\u{1F617}", category: 0, name: "kissing face", version: "1.0" }, { emoji: "\u263A\uFE0F", category: 0, name: "smiling face", version: "1.0" }, { emoji: "\u{1F61A}", category: 0, name: "kissing face with closed eyes", version: "1.0" }, { emoji: "\u{1F619}", category: 0, name: "kissing face with smiling eyes", version: "1.0" }, { emoji: "\u{1F972}", category: 0, name: "smiling face with tear", version: "13.0" }, { emoji: "\u{1F60B}", category: 0, name: "face savoring food", version: "1.0" }, { emoji: "\u{1F61B}", category: 0, name: "face with tongue", version: "1.0" }, { emoji: "\u{1F61C}", category: 0, name: "winking face with tongue", version: "1.0" }, { emoji: "\u{1F92A}", category: 0, name: "zany face", version: "5.0" }, { emoji: "\u{1F61D}", category: 0, name: "squinting face with tongue", version: "1.0" }, { emoji: "\u{1F911}", category: 0, name: "money-mouth face", version: "1.0" }, { emoji: "\u{1F917}", category: 0, name: "hugging face", version: "1.0" }, { emoji: "\u{1F92D}", category: 0, name: "face with hand over mouth", version: "5.0" }, { emoji: "\u{1F92B}", category: 0, name: "shushing face", version: "5.0" }, { emoji: "\u{1F914}", category: 0, name: "thinking face", version: "1.0" }, { emoji: "\u{1F910}", category: 0, name: "zipper-mouth face", version: "1.0" }, { emoji: "\u{1F928}", category: 0, name: "face with raised eyebrow", version: "5.0" }, { emoji: "\u{1F610}", category: 0, name: "neutral face", version: "1.0" }, { emoji: "\u{1F611}", category: 0, name: "expressionless face", version: "1.0" }, { emoji: "\u{1F636}", category: 0, name: "face without mouth", version: "1.0" }, { emoji: "\u{1F60F}", category: 0, name: "smirking face", version: "1.0" }, { emoji: "\u{1F612}", category: 0, name: "unamused face", version: "1.0" }, { emoji: "\u{1F644}", category: 0, name: "face with rolling eyes", version: "1.0" }, { emoji: "\u{1F62C}", category: 0, name: "grimacing face", version: "1.0" }, { emoji: "\u{1F925}", category: 0, name: "lying face", version: "3.0" }, { emoji: "\u{1F60C}", category: 0, name: "relieved face", version: "1.0" }, { emoji: "\u{1F614}", category: 0, name: "pensive face", version: "1.0" }, { emoji: "\u{1F62A}", category: 0, name: "sleepy face", version: "1.0" }, { emoji: "\u{1F924}", category: 0, name: "drooling face", version: "3.0" }, { emoji: "\u{1F634}", category: 0, name: "sleeping face", version: "1.0" }, { emoji: "\u{1F637}", category: 0, name: "face with medical mask", version: "1.0" }, { emoji: "\u{1F912}", category: 0, name: "face with thermometer", version: "1.0" }, { emoji: "\u{1F915}", category: 0, name: "face with head-bandage", version: "1.0" }, { emoji: "\u{1F922}", category: 0, name: "nauseated face", version: "3.0" }, { emoji: "\u{1F92E}", category: 0, name: "face vomiting", version: "5.0" }, { emoji: "\u{1F927}", category: 0, name: "sneezing face", version: "3.0" }, { emoji: "\u{1F975}", category: 0, name: "hot face", version: "11.0" }, { emoji: "\u{1F976}", category: 0, name: "cold face", version: "11.0" }, { emoji: "\u{1F974}", category: 0, name: "woozy face", version: "11.0" }, { emoji: "\u{1F635}", category: 0, name: "dizzy face", version: "1.0" }, { emoji: "\u{1F92F}", category: 0, name: "exploding head", version: "5.0" }, { emoji: "\u{1F920}", category: 0, name: "cowboy hat face", version: "3.0" }, { emoji: "\u{1F973}", category: 0, name: "partying face", version: "11.0" }, { emoji: "\u{1F978}", category: 0, name: "disguised face", version: "13.0" }, { emoji: "\u{1F60E}", category: 0, name: "smiling face with sunglasses", version: "1.0" }, { emoji: "\u{1F913}", category: 0, name: "nerd face", version: "1.0" }, { emoji: "\u{1F9D0}", category: 0, name: "face with monocle", version: "5.0" }, { emoji: "\u{1F615}", category: 0, name: "confused face", version: "1.0" }, { emoji: "\u{1F61F}", category: 0, name: "worried face", version: "1.0" }, { emoji: "\u{1F641}", category: 0, name: "slightly frowning face", version: "1.0" }, { emoji: "\u2639\uFE0F", category: 0, name: "frowning face", version: "1.0" }, { emoji: "\u{1F62E}", category: 0, name: "face with open mouth", version: "1.0" }, { emoji: "\u{1F62F}", category: 0, name: "hushed face", version: "1.0" }, { emoji: "\u{1F632}", category: 0, name: "astonished face", version: "1.0" }, { emoji: "\u{1F633}", category: 0, name: "flushed face", version: "1.0" }, { emoji: "\u{1F97A}", category: 0, name: "pleading face", version: "11.0" }, { emoji: "\u{1F626}", category: 0, name: "frowning face with open mouth", version: "1.0" }, { emoji: "\u{1F627}", category: 0, name: "anguished face", version: "1.0" }, { emoji: "\u{1F628}", category: 0, name: "fearful face", version: "1.0" }, { emoji: "\u{1F630}", category: 0, name: "anxious face with sweat", version: "1.0" }, { emoji: "\u{1F625}", category: 0, name: "sad but relieved face", version: "1.0" }, { emoji: "\u{1F622}", category: 0, name: "crying face", version: "1.0" }, { emoji: "\u{1F62D}", category: 0, name: "loudly crying face", version: "1.0" }, { emoji: "\u{1F631}", category: 0, name: "face screaming in fear", version: "1.0" }, { emoji: "\u{1F616}", category: 0, name: "confounded face", version: "1.0" }, { emoji: "\u{1F623}", category: 0, name: "persevering face", version: "1.0" }, { emoji: "\u{1F61E}", category: 0, name: "disappointed face", version: "1.0" }, { emoji: "\u{1F613}", category: 0, name: "downcast face with sweat", version: "1.0" }, { emoji: "\u{1F629}", category: 0, name: "weary face", version: "1.0" }, { emoji: "\u{1F62B}", category: 0, name: "tired face", version: "1.0" }, { emoji: "\u{1F971}", category: 0, name: "yawning face", version: "12.0" }, { emoji: "\u{1F624}", category: 0, name: "face with steam from nose", version: "1.0" }, { emoji: "\u{1F621}", category: 0, name: "pouting face", version: "1.0" }, { emoji: "\u{1F620}", category: 0, name: "angry face", version: "1.0" }, { emoji: "\u{1F92C}", category: 0, name: "face with symbols on mouth", version: "5.0" }, { emoji: "\u{1F608}", category: 0, name: "smiling face with horns", version: "1.0" }, { emoji: "\u{1F47F}", category: 0, name: "angry face with horns", version: "1.0" }, { emoji: "\u{1F480}", category: 0, name: "skull", version: "1.0" }, { emoji: "\u2620\uFE0F", category: 0, name: "skull and crossbones", version: "1.0" }, { emoji: "\u{1F4A9}", category: 0, name: "pile of poo", version: "1.0" }, { emoji: "\u{1F921}", category: 0, name: "clown face", version: "3.0" }, { emoji: "\u{1F479}", category: 0, name: "ogre", version: "1.0" }, { emoji: "\u{1F47A}", category: 0, name: "goblin", version: "1.0" }, { emoji: "\u{1F47B}", category: 0, name: "ghost", version: "1.0" }, { emoji: "\u{1F47D}", category: 0, name: "alien", version: "1.0" }, { emoji: "\u{1F47E}", category: 0, name: "alien monster", version: "1.0" }, { emoji: "\u{1F916}", category: 0, name: "robot", version: "1.0" }, { emoji: "\u{1F63A}", category: 0, name: "grinning cat", version: "1.0" }, { emoji: "\u{1F638}", category: 0, name: "grinning cat with smiling eyes", version: "1.0" }, { emoji: "\u{1F639}", category: 0, name: "cat with tears of joy", version: "1.0" }, { emoji: "\u{1F63B}", category: 0, name: "smiling cat with heart-eyes", version: "1.0" }, { emoji: "\u{1F63C}", category: 0, name: "cat with wry smile", version: "1.0" }, { emoji: "\u{1F63D}", category: 0, name: "kissing cat", version: "1.0" }, { emoji: "\u{1F640}", category: 0, name: "weary cat", version: "1.0" }, { emoji: "\u{1F63F}", category: 0, name: "crying cat", version: "1.0" }, { emoji: "\u{1F63E}", category: 0, name: "pouting cat", version: "1.0" }, { emoji: "\u{1F648}", category: 0, name: "see-no-evil monkey", version: "1.0" }, { emoji: "\u{1F649}", category: 0, name: "hear-no-evil monkey", version: "1.0" }, { emoji: "\u{1F64A}", category: 0, name: "speak-no-evil monkey", version: "1.0" }, { emoji: "\u{1F48B}", category: 0, name: "kiss mark", version: "1.0" }, { emoji: "\u{1F48C}", category: 0, name: "love letter", version: "1.0" }, { emoji: "\u{1F498}", category: 0, name: "heart with arrow", version: "1.0" }, { emoji: "\u{1F49D}", category: 0, name: "heart with ribbon", version: "1.0" }, { emoji: "\u{1F496}", category: 0, name: "sparkling heart", version: "1.0" }, { emoji: "\u{1F497}", category: 0, name: "growing heart", version: "1.0" }, { emoji: "\u{1F493}", category: 0, name: "beating heart", version: "1.0" }, { emoji: "\u{1F49E}", category: 0, name: "revolving hearts", version: "1.0" }, { emoji: "\u{1F495}", category: 0, name: "two hearts", version: "1.0" }, { emoji: "\u{1F49F}", category: 0, name: "heart decoration", version: "1.0" }, { emoji: "\u2763\uFE0F", category: 0, name: "heart exclamation", version: "1.0" }, { emoji: "\u{1F494}", category: 0, name: "broken heart", version: "1.0" }, { emoji: "\u2764\uFE0F", category: 0, name: "red heart", version: "1.0" }, { emoji: "\u{1F9E1}", category: 0, name: "orange heart", version: "5.0" }, { emoji: "\u{1F49B}", category: 0, name: "yellow heart", version: "1.0" }, { emoji: "\u{1F49A}", category: 0, name: "green heart", version: "1.0" }, { emoji: "\u{1F499}", category: 0, name: "blue heart", version: "1.0" }, { emoji: "\u{1F49C}", category: 0, name: "purple heart", version: "1.0" }, { emoji: "\u{1F90E}", category: 0, name: "brown heart", version: "12.0" }, { emoji: "\u{1F5A4}", category: 0, name: "black heart", version: "3.0" }, { emoji: "\u{1F90D}", category: 0, name: "white heart", version: "12.0" }, { emoji: "\u{1F4AF}", category: 0, name: "hundred points", version: "1.0" }, { emoji: "\u{1F4A2}", category: 0, name: "anger symbol", version: "1.0" }, { emoji: "\u{1F4A5}", category: 0, name: "collision", version: "1.0" }, { emoji: "\u{1F4AB}", category: 0, name: "dizzy", version: "1.0" }, { emoji: "\u{1F4A6}", category: 0, name: "sweat droplets", version: "1.0" }, { emoji: "\u{1F4A8}", category: 0, name: "dashing away", version: "1.0" }, { emoji: "\u{1F573}\uFE0F", category: 0, name: "hole", version: "1.0" }, { emoji: "\u{1F4A3}", category: 0, name: "bomb", version: "1.0" }, { emoji: "\u{1F4AC}", category: 0, name: "speech balloon", version: "1.0" }, { emoji: "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F", category: 0, name: "eye in speech bubble", version: "2.0" }, { emoji: "\u{1F5E8}\uFE0F", category: 0, name: "left speech bubble", version: "2.0" }, { emoji: "\u{1F5EF}\uFE0F", category: 0, name: "right anger bubble", version: "1.0" }, { emoji: "\u{1F4AD}", category: 0, name: "thought balloon", version: "1.0" }, { emoji: "\u{1F4A4}", category: 0, name: "zzz", version: "1.0" }, { emoji: "\u{1F44B}", category: 1, name: "waving hand", variations: ["\u{1F44B}\u{1F3FB}", "\u{1F44B}\u{1F3FC}", "\u{1F44B}\u{1F3FD}", "\u{1F44B}\u{1F3FE}", "\u{1F44B}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F91A}", category: 1, name: "raised back of hand", variations: ["\u{1F91A}\u{1F3FB}", "\u{1F91A}\u{1F3FC}", "\u{1F91A}\u{1F3FD}", "\u{1F91A}\u{1F3FE}", "\u{1F91A}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F590}\uFE0F", category: 1, name: "hand with fingers splayed", variations: ["\u{1F590}\u{1F3FB}", "\u{1F590}\u{1F3FC}", "\u{1F590}\u{1F3FD}", "\u{1F590}\u{1F3FE}", "\u{1F590}\u{1F3FF}"], version: "1.0" }, { emoji: "\u270B", category: 1, name: "raised hand", variations: ["\u270B\u{1F3FB}", "\u270B\u{1F3FC}", "\u270B\u{1F3FD}", "\u270B\u{1F3FE}", "\u270B\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F596}", category: 1, name: "vulcan salute", variations: ["\u{1F596}\u{1F3FB}", "\u{1F596}\u{1F3FC}", "\u{1F596}\u{1F3FD}", "\u{1F596}\u{1F3FE}", "\u{1F596}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F44C}", category: 1, name: "OK hand", variations: ["\u{1F44C}\u{1F3FB}", "\u{1F44C}\u{1F3FC}", "\u{1F44C}\u{1F3FD}", "\u{1F44C}\u{1F3FE}", "\u{1F44C}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F90C}", category: 1, name: "pinched fingers", variations: ["\u{1F90C}\u{1F3FB}", "\u{1F90C}\u{1F3FC}", "\u{1F90C}\u{1F3FD}", "\u{1F90C}\u{1F3FE}", "\u{1F90C}\u{1F3FF}"], version: "13.0" }, { emoji: "\u{1F90F}", category: 1, name: "pinching hand", variations: ["\u{1F90F}\u{1F3FB}", "\u{1F90F}\u{1F3FC}", "\u{1F90F}\u{1F3FD}", "\u{1F90F}\u{1F3FE}", "\u{1F90F}\u{1F3FF}"], version: "12.0" }, { emoji: "\u270C\uFE0F", category: 1, name: "victory hand", variations: ["\u270C\u{1F3FB}", "\u270C\u{1F3FC}", "\u270C\u{1F3FD}", "\u270C\u{1F3FE}", "\u270C\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F91E}", category: 1, name: "crossed fingers", variations: ["\u{1F91E}\u{1F3FB}", "\u{1F91E}\u{1F3FC}", "\u{1F91E}\u{1F3FD}", "\u{1F91E}\u{1F3FE}", "\u{1F91E}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F91F}", category: 1, name: "love-you gesture", variations: ["\u{1F91F}\u{1F3FB}", "\u{1F91F}\u{1F3FC}", "\u{1F91F}\u{1F3FD}", "\u{1F91F}\u{1F3FE}", "\u{1F91F}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F918}", category: 1, name: "sign of the horns", variations: ["\u{1F918}\u{1F3FB}", "\u{1F918}\u{1F3FC}", "\u{1F918}\u{1F3FD}", "\u{1F918}\u{1F3FE}", "\u{1F918}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F919}", category: 1, name: "call me hand", variations: ["\u{1F919}\u{1F3FB}", "\u{1F919}\u{1F3FC}", "\u{1F919}\u{1F3FD}", "\u{1F919}\u{1F3FE}", "\u{1F919}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F448}", category: 1, name: "backhand index pointing left", variations: ["\u{1F448}\u{1F3FB}", "\u{1F448}\u{1F3FC}", "\u{1F448}\u{1F3FD}", "\u{1F448}\u{1F3FE}", "\u{1F448}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F449}", category: 1, name: "backhand index pointing right", variations: ["\u{1F449}\u{1F3FB}", "\u{1F449}\u{1F3FC}", "\u{1F449}\u{1F3FD}", "\u{1F449}\u{1F3FE}", "\u{1F449}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F446}", category: 1, name: "backhand index pointing up", variations: ["\u{1F446}\u{1F3FB}", "\u{1F446}\u{1F3FC}", "\u{1F446}\u{1F3FD}", "\u{1F446}\u{1F3FE}", "\u{1F446}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F595}", category: 1, name: "middle finger", variations: ["\u{1F595}\u{1F3FB}", "\u{1F595}\u{1F3FC}", "\u{1F595}\u{1F3FD}", "\u{1F595}\u{1F3FE}", "\u{1F595}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F447}", category: 1, name: "backhand index pointing down", variations: ["\u{1F447}\u{1F3FB}", "\u{1F447}\u{1F3FC}", "\u{1F447}\u{1F3FD}", "\u{1F447}\u{1F3FE}", "\u{1F447}\u{1F3FF}"], version: "1.0" }, { emoji: "\u261D\uFE0F", category: 1, name: "index pointing up", variations: ["\u261D\u{1F3FB}", "\u261D\u{1F3FC}", "\u261D\u{1F3FD}", "\u261D\u{1F3FE}", "\u261D\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F44D}", category: 1, name: "thumbs up", variations: ["\u{1F44D}\u{1F3FB}", "\u{1F44D}\u{1F3FC}", "\u{1F44D}\u{1F3FD}", "\u{1F44D}\u{1F3FE}", "\u{1F44D}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F44E}", category: 1, name: "thumbs down", variations: ["\u{1F44E}\u{1F3FB}", "\u{1F44E}\u{1F3FC}", "\u{1F44E}\u{1F3FD}", "\u{1F44E}\u{1F3FE}", "\u{1F44E}\u{1F3FF}"], version: "1.0" }, { emoji: "\u270A", category: 1, name: "raised fist", variations: ["\u270A\u{1F3FB}", "\u270A\u{1F3FC}", "\u270A\u{1F3FD}", "\u270A\u{1F3FE}", "\u270A\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F44A}", category: 1, name: "oncoming fist", variations: ["\u{1F44A}\u{1F3FB}", "\u{1F44A}\u{1F3FC}", "\u{1F44A}\u{1F3FD}", "\u{1F44A}\u{1F3FE}", "\u{1F44A}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F91B}", category: 1, name: "left-facing fist", variations: ["\u{1F91B}\u{1F3FB}", "\u{1F91B}\u{1F3FC}", "\u{1F91B}\u{1F3FD}", "\u{1F91B}\u{1F3FE}", "\u{1F91B}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F91C}", category: 1, name: "right-facing fist", variations: ["\u{1F91C}\u{1F3FB}", "\u{1F91C}\u{1F3FC}", "\u{1F91C}\u{1F3FD}", "\u{1F91C}\u{1F3FE}", "\u{1F91C}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F44F}", category: 1, name: "clapping hands", variations: ["\u{1F44F}\u{1F3FB}", "\u{1F44F}\u{1F3FC}", "\u{1F44F}\u{1F3FD}", "\u{1F44F}\u{1F3FE}", "\u{1F44F}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F64C}", category: 1, name: "raising hands", variations: ["\u{1F64C}\u{1F3FB}", "\u{1F64C}\u{1F3FC}", "\u{1F64C}\u{1F3FD}", "\u{1F64C}\u{1F3FE}", "\u{1F64C}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F450}", category: 1, name: "open hands", variations: ["\u{1F450}\u{1F3FB}", "\u{1F450}\u{1F3FC}", "\u{1F450}\u{1F3FD}", "\u{1F450}\u{1F3FE}", "\u{1F450}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F932}", category: 1, name: "palms up together", variations: ["\u{1F932}\u{1F3FB}", "\u{1F932}\u{1F3FC}", "\u{1F932}\u{1F3FD}", "\u{1F932}\u{1F3FE}", "\u{1F932}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F91D}", category: 1, name: "handshake", version: "3.0" }, { emoji: "\u{1F64F}", category: 1, name: "folded hands", variations: ["\u{1F64F}\u{1F3FB}", "\u{1F64F}\u{1F3FC}", "\u{1F64F}\u{1F3FD}", "\u{1F64F}\u{1F3FE}", "\u{1F64F}\u{1F3FF}"], version: "1.0" }, { emoji: "\u270D\uFE0F", category: 1, name: "writing hand", variations: ["\u270D\u{1F3FB}", "\u270D\u{1F3FC}", "\u270D\u{1F3FD}", "\u270D\u{1F3FE}", "\u270D\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F485}", category: 1, name: "nail polish", variations: ["\u{1F485}\u{1F3FB}", "\u{1F485}\u{1F3FC}", "\u{1F485}\u{1F3FD}", "\u{1F485}\u{1F3FE}", "\u{1F485}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F933}", category: 1, name: "selfie", variations: ["\u{1F933}\u{1F3FB}", "\u{1F933}\u{1F3FC}", "\u{1F933}\u{1F3FD}", "\u{1F933}\u{1F3FE}", "\u{1F933}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F4AA}", category: 1, name: "flexed biceps", variations: ["\u{1F4AA}\u{1F3FB}", "\u{1F4AA}\u{1F3FC}", "\u{1F4AA}\u{1F3FD}", "\u{1F4AA}\u{1F3FE}", "\u{1F4AA}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9BE}", category: 1, name: "mechanical arm", version: "12.0" }, { emoji: "\u{1F9BF}", category: 1, name: "mechanical leg", version: "12.0" }, { emoji: "\u{1F9B5}", category: 1, name: "leg", variations: ["\u{1F9B5}\u{1F3FB}", "\u{1F9B5}\u{1F3FC}", "\u{1F9B5}\u{1F3FD}", "\u{1F9B5}\u{1F3FE}", "\u{1F9B5}\u{1F3FF}"], version: "11.0" }, { emoji: "\u{1F9B6}", category: 1, name: "foot", variations: ["\u{1F9B6}\u{1F3FB}", "\u{1F9B6}\u{1F3FC}", "\u{1F9B6}\u{1F3FD}", "\u{1F9B6}\u{1F3FE}", "\u{1F9B6}\u{1F3FF}"], version: "11.0" }, { emoji: "\u{1F442}", category: 1, name: "ear", variations: ["\u{1F442}\u{1F3FB}", "\u{1F442}\u{1F3FC}", "\u{1F442}\u{1F3FD}", "\u{1F442}\u{1F3FE}", "\u{1F442}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9BB}", category: 1, name: "ear with hearing aid", variations: ["\u{1F9BB}\u{1F3FB}", "\u{1F9BB}\u{1F3FC}", "\u{1F9BB}\u{1F3FD}", "\u{1F9BB}\u{1F3FE}", "\u{1F9BB}\u{1F3FF}"], version: "12.0" }, { emoji: "\u{1F443}", category: 1, name: "nose", variations: ["\u{1F443}\u{1F3FB}", "\u{1F443}\u{1F3FC}", "\u{1F443}\u{1F3FD}", "\u{1F443}\u{1F3FE}", "\u{1F443}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9E0}", category: 1, name: "brain", version: "5.0" }, { emoji: "\u{1FAC0}", category: 1, name: "anatomical heart", version: "13.0" }, { emoji: "\u{1FAC1}", category: 1, name: "lungs", version: "13.0" }, { emoji: "\u{1F9B7}", category: 1, name: "tooth", version: "11.0" }, { emoji: "\u{1F9B4}", category: 1, name: "bone", version: "11.0" }, { emoji: "\u{1F440}", category: 1, name: "eyes", version: "1.0" }, { emoji: "\u{1F441}\uFE0F", category: 1, name: "eye", version: "1.0" }, { emoji: "\u{1F445}", category: 1, name: "tongue", version: "1.0" }, { emoji: "\u{1F444}", category: 1, name: "mouth", version: "1.0" }, { emoji: "\u{1F476}", category: 1, name: "baby", variations: ["\u{1F476}\u{1F3FB}", "\u{1F476}\u{1F3FC}", "\u{1F476}\u{1F3FD}", "\u{1F476}\u{1F3FE}", "\u{1F476}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9D2}", category: 1, name: "child", variations: ["\u{1F9D2}\u{1F3FB}", "\u{1F9D2}\u{1F3FC}", "\u{1F9D2}\u{1F3FD}", "\u{1F9D2}\u{1F3FE}", "\u{1F9D2}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F466}", category: 1, name: "boy", variations: ["\u{1F466}\u{1F3FB}", "\u{1F466}\u{1F3FC}", "\u{1F466}\u{1F3FD}", "\u{1F466}\u{1F3FE}", "\u{1F466}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F467}", category: 1, name: "girl", variations: ["\u{1F467}\u{1F3FB}", "\u{1F467}\u{1F3FC}", "\u{1F467}\u{1F3FD}", "\u{1F467}\u{1F3FE}", "\u{1F467}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9D1}", category: 1, name: "person", variations: ["\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F471}", category: 1, name: "person with blond hair", variations: ["\u{1F471}\u{1F3FB}", "\u{1F471}\u{1F3FC}", "\u{1F471}\u{1F3FD}", "\u{1F471}\u{1F3FE}", "\u{1F471}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F468}", category: 1, name: "man", variations: ["\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9D4}", category: 1, name: "man with beard", variations: ["\u{1F9D4}\u{1F3FB}", "\u{1F9D4}\u{1F3FC}", "\u{1F9D4}\u{1F3FD}", "\u{1F9D4}\u{1F3FE}", "\u{1F9D4}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F468}\u200D\u{1F9B0}", category: 1, name: "man with red hair", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B0}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B0}"], version: "11.0" }, { emoji: "\u{1F468}\u200D\u{1F9B1}", category: 1, name: "man with curly hair", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B1}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B1}"], version: "11.0" }, { emoji: "\u{1F468}\u200D\u{1F9B3}", category: 1, name: "man with white hair", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B3}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B3}"], version: "11.0" }, { emoji: "\u{1F468}\u200D\u{1F9B2}", category: 1, name: "man with no hair", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FC}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FD}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FE}\u200D\u{1F9B2}", "\u{1F468}\u{1F3FF}\u200D\u{1F9B2}"], version: "11.0" }, { emoji: "\u{1F469}", category: 1, name: "woman", variations: ["\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F469}\u200D\u{1F9B0}", category: 1, name: "woman with red hair", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B0}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B0}"], version: "11.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9B0}", category: 1, name: "person with red hair", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B0}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B0}"], version: "12.1" }, { emoji: "\u{1F469}\u200D\u{1F9B1}", category: 1, name: "woman with curly hair", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B1}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B1}"], version: "11.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9B1}", category: 1, name: "person with curly hair", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B1}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B1}"], version: "12.1" }, { emoji: "\u{1F469}\u200D\u{1F9B3}", category: 1, name: "woman with white hair", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B3}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B3}"], version: "11.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9B3}", category: 1, name: "person with white hair", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B3}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B3}"], version: "12.1" }, { emoji: "\u{1F469}\u200D\u{1F9B2}", category: 1, name: "woman with no hair", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FC}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FD}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FE}\u200D\u{1F9B2}", "\u{1F469}\u{1F3FF}\u200D\u{1F9B2}"], version: "11.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9B2}", category: 1, name: "person with no hair", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B2}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B2}"], version: "12.1" }, { emoji: "\u{1F471}\u200D\u2640\uFE0F", category: 1, name: "woman with blond hair", variations: ["\u{1F471}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F471}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F471}\u200D\u2642\uFE0F", category: 1, name: "man with blond hair", variations: ["\u{1F471}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F471}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F9D3}", category: 1, name: "older person", variations: ["\u{1F9D3}\u{1F3FB}", "\u{1F9D3}\u{1F3FC}", "\u{1F9D3}\u{1F3FD}", "\u{1F9D3}\u{1F3FE}", "\u{1F9D3}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F474}", category: 1, name: "old man", variations: ["\u{1F474}\u{1F3FB}", "\u{1F474}\u{1F3FC}", "\u{1F474}\u{1F3FD}", "\u{1F474}\u{1F3FE}", "\u{1F474}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F475}", category: 1, name: "old woman", variations: ["\u{1F475}\u{1F3FB}", "\u{1F475}\u{1F3FC}", "\u{1F475}\u{1F3FD}", "\u{1F475}\u{1F3FE}", "\u{1F475}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F64D}", category: 1, name: "person frowning", variations: ["\u{1F64D}\u{1F3FB}", "\u{1F64D}\u{1F3FC}", "\u{1F64D}\u{1F3FD}", "\u{1F64D}\u{1F3FE}", "\u{1F64D}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F64D}\u200D\u2642\uFE0F", category: 1, name: "man frowning", variations: ["\u{1F64D}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F64D}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F64D}\u200D\u2640\uFE0F", category: 1, name: "woman frowning", variations: ["\u{1F64D}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F64D}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F64E}", category: 1, name: "person pouting", variations: ["\u{1F64E}\u{1F3FB}", "\u{1F64E}\u{1F3FC}", "\u{1F64E}\u{1F3FD}", "\u{1F64E}\u{1F3FE}", "\u{1F64E}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F64E}\u200D\u2642\uFE0F", category: 1, name: "man pouting", variations: ["\u{1F64E}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F64E}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F64E}\u200D\u2640\uFE0F", category: 1, name: "woman pouting", variations: ["\u{1F64E}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F64E}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F645}", category: 1, name: "person gesturing NO", variations: ["\u{1F645}\u{1F3FB}", "\u{1F645}\u{1F3FC}", "\u{1F645}\u{1F3FD}", "\u{1F645}\u{1F3FE}", "\u{1F645}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F645}\u200D\u2642\uFE0F", category: 1, name: "man gesturing NO", variations: ["\u{1F645}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F645}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F645}\u200D\u2640\uFE0F", category: 1, name: "woman gesturing NO", variations: ["\u{1F645}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F645}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F646}", category: 1, name: "person gesturing OK", variations: ["\u{1F646}\u{1F3FB}", "\u{1F646}\u{1F3FC}", "\u{1F646}\u{1F3FD}", "\u{1F646}\u{1F3FE}", "\u{1F646}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F646}\u200D\u2642\uFE0F", category: 1, name: "man gesturing OK", variations: ["\u{1F646}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F646}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F646}\u200D\u2640\uFE0F", category: 1, name: "woman gesturing OK", variations: ["\u{1F646}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F646}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F481}", category: 1, name: "person tipping hand", variations: ["\u{1F481}\u{1F3FB}", "\u{1F481}\u{1F3FC}", "\u{1F481}\u{1F3FD}", "\u{1F481}\u{1F3FE}", "\u{1F481}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F481}\u200D\u2642\uFE0F", category: 1, name: "man tipping hand", variations: ["\u{1F481}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F481}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F481}\u200D\u2640\uFE0F", category: 1, name: "woman tipping hand", variations: ["\u{1F481}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F481}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F64B}", category: 1, name: "person raising hand", variations: ["\u{1F64B}\u{1F3FB}", "\u{1F64B}\u{1F3FC}", "\u{1F64B}\u{1F3FD}", "\u{1F64B}\u{1F3FE}", "\u{1F64B}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F64B}\u200D\u2642\uFE0F", category: 1, name: "man raising hand", variations: ["\u{1F64B}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F64B}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F64B}\u200D\u2640\uFE0F", category: 1, name: "woman raising hand", variations: ["\u{1F64B}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F64B}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F9CF}", category: 1, name: "deaf person", variations: ["\u{1F9CF}\u{1F3FB}", "\u{1F9CF}\u{1F3FC}", "\u{1F9CF}\u{1F3FD}", "\u{1F9CF}\u{1F3FE}", "\u{1F9CF}\u{1F3FF}"], version: "12.0" }, { emoji: "\u{1F9CF}\u200D\u2642\uFE0F", category: 1, name: "deaf man", variations: ["\u{1F9CF}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9CF}\u{1F3FF}\u200D\u2642\uFE0F"], version: "12.0" }, { emoji: "\u{1F9CF}\u200D\u2640\uFE0F", category: 1, name: "deaf woman", variations: ["\u{1F9CF}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9CF}\u{1F3FF}\u200D\u2640\uFE0F"], version: "12.0" }, { emoji: "\u{1F647}", category: 1, name: "person bowing", variations: ["\u{1F647}\u{1F3FB}", "\u{1F647}\u{1F3FC}", "\u{1F647}\u{1F3FD}", "\u{1F647}\u{1F3FE}", "\u{1F647}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F647}\u200D\u2642\uFE0F", category: 1, name: "man bowing", variations: ["\u{1F647}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F647}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F647}\u200D\u2640\uFE0F", category: 1, name: "woman bowing", variations: ["\u{1F647}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F647}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F926}", category: 1, name: "person facepalming", variations: ["\u{1F926}\u{1F3FB}", "\u{1F926}\u{1F3FC}", "\u{1F926}\u{1F3FD}", "\u{1F926}\u{1F3FE}", "\u{1F926}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F926}\u200D\u2642\uFE0F", category: 1, name: "man facepalming", variations: ["\u{1F926}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F926}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F926}\u200D\u2640\uFE0F", category: 1, name: "woman facepalming", variations: ["\u{1F926}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F926}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F937}", category: 1, name: "person shrugging", variations: ["\u{1F937}\u{1F3FB}", "\u{1F937}\u{1F3FC}", "\u{1F937}\u{1F3FD}", "\u{1F937}\u{1F3FE}", "\u{1F937}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F937}\u200D\u2642\uFE0F", category: 1, name: "man shrugging", variations: ["\u{1F937}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F937}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F937}\u200D\u2640\uFE0F", category: 1, name: "woman shrugging", variations: ["\u{1F937}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F937}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u2695\uFE0F", category: 1, name: "health worker", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FC}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FD}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FE}\u200D\u2695\uFE0F", "\u{1F9D1}\u{1F3FF}\u200D\u2695\uFE0F"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u2695\uFE0F", category: 1, name: "man health worker", variations: ["\u{1F468}\u{1F3FB}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FC}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FD}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F", "\u{1F468}\u{1F3FF}\u200D\u2695\uFE0F"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u2695\uFE0F", category: 1, name: "woman health worker", variations: ["\u{1F469}\u{1F3FB}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FC}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FD}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FE}\u200D\u2695\uFE0F", "\u{1F469}\u{1F3FF}\u200D\u2695\uFE0F"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F393}", category: 1, name: "student", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F393}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F393}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F393}", category: 1, name: "man student", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F393}", "\u{1F468}\u{1F3FC}\u200D\u{1F393}", "\u{1F468}\u{1F3FD}\u200D\u{1F393}", "\u{1F468}\u{1F3FE}\u200D\u{1F393}", "\u{1F468}\u{1F3FF}\u200D\u{1F393}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F393}", category: 1, name: "woman student", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F393}", "\u{1F469}\u{1F3FC}\u200D\u{1F393}", "\u{1F469}\u{1F3FD}\u200D\u{1F393}", "\u{1F469}\u{1F3FE}\u200D\u{1F393}", "\u{1F469}\u{1F3FF}\u200D\u{1F393}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F3EB}", category: 1, name: "teacher", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3EB}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3EB}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F3EB}", category: 1, name: "man teacher", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FC}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FD}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FE}\u200D\u{1F3EB}", "\u{1F468}\u{1F3FF}\u200D\u{1F3EB}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F3EB}", category: 1, name: "woman teacher", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FC}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FD}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FE}\u200D\u{1F3EB}", "\u{1F469}\u{1F3FF}\u200D\u{1F3EB}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u2696\uFE0F", category: 1, name: "judge", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FC}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FD}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FE}\u200D\u2696\uFE0F", "\u{1F9D1}\u{1F3FF}\u200D\u2696\uFE0F"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u2696\uFE0F", category: 1, name: "man judge", variations: ["\u{1F468}\u{1F3FB}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FC}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FD}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FE}\u200D\u2696\uFE0F", "\u{1F468}\u{1F3FF}\u200D\u2696\uFE0F"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u2696\uFE0F", category: 1, name: "woman judge", variations: ["\u{1F469}\u{1F3FB}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FC}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FD}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FE}\u200D\u2696\uFE0F", "\u{1F469}\u{1F3FF}\u200D\u2696\uFE0F"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F33E}", category: 1, name: "farmer", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F33E}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F33E}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F33E}", category: 1, name: "man farmer", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F33E}", "\u{1F468}\u{1F3FC}\u200D\u{1F33E}", "\u{1F468}\u{1F3FD}\u200D\u{1F33E}", "\u{1F468}\u{1F3FE}\u200D\u{1F33E}", "\u{1F468}\u{1F3FF}\u200D\u{1F33E}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F33E}", category: 1, name: "woman farmer", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F33E}", "\u{1F469}\u{1F3FC}\u200D\u{1F33E}", "\u{1F469}\u{1F3FD}\u200D\u{1F33E}", "\u{1F469}\u{1F3FE}\u200D\u{1F33E}", "\u{1F469}\u{1F3FF}\u200D\u{1F33E}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F373}", category: 1, name: "cook", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F373}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F373}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F373}", category: 1, name: "man cook", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F373}", "\u{1F468}\u{1F3FC}\u200D\u{1F373}", "\u{1F468}\u{1F3FD}\u200D\u{1F373}", "\u{1F468}\u{1F3FE}\u200D\u{1F373}", "\u{1F468}\u{1F3FF}\u200D\u{1F373}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F373}", category: 1, name: "woman cook", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F373}", "\u{1F469}\u{1F3FC}\u200D\u{1F373}", "\u{1F469}\u{1F3FD}\u200D\u{1F373}", "\u{1F469}\u{1F3FE}\u200D\u{1F373}", "\u{1F469}\u{1F3FF}\u200D\u{1F373}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F527}", category: 1, name: "mechanic", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F527}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F527}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F527}", category: 1, name: "man mechanic", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F527}", "\u{1F468}\u{1F3FC}\u200D\u{1F527}", "\u{1F468}\u{1F3FD}\u200D\u{1F527}", "\u{1F468}\u{1F3FE}\u200D\u{1F527}", "\u{1F468}\u{1F3FF}\u200D\u{1F527}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F527}", category: 1, name: "woman mechanic", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F527}", "\u{1F469}\u{1F3FC}\u200D\u{1F527}", "\u{1F469}\u{1F3FD}\u200D\u{1F527}", "\u{1F469}\u{1F3FE}\u200D\u{1F527}", "\u{1F469}\u{1F3FF}\u200D\u{1F527}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F3ED}", category: 1, name: "factory worker", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3ED}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3ED}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F3ED}", category: 1, name: "man factory worker", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FC}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FD}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FE}\u200D\u{1F3ED}", "\u{1F468}\u{1F3FF}\u200D\u{1F3ED}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F3ED}", category: 1, name: "woman factory worker", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FC}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FD}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FE}\u200D\u{1F3ED}", "\u{1F469}\u{1F3FF}\u200D\u{1F3ED}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F4BC}", category: 1, name: "office worker", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F4BC}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F4BC}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F4BC}", category: 1, name: "man office worker", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FC}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FD}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FE}\u200D\u{1F4BC}", "\u{1F468}\u{1F3FF}\u200D\u{1F4BC}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F4BC}", category: 1, name: "woman office worker", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FC}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FD}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FE}\u200D\u{1F4BC}", "\u{1F469}\u{1F3FF}\u200D\u{1F4BC}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F52C}", category: 1, name: "scientist", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F52C}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F52C}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F52C}", category: 1, name: "man scientist", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F52C}", "\u{1F468}\u{1F3FC}\u200D\u{1F52C}", "\u{1F468}\u{1F3FD}\u200D\u{1F52C}", "\u{1F468}\u{1F3FE}\u200D\u{1F52C}", "\u{1F468}\u{1F3FF}\u200D\u{1F52C}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F52C}", category: 1, name: "woman scientist", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F52C}", "\u{1F469}\u{1F3FC}\u200D\u{1F52C}", "\u{1F469}\u{1F3FD}\u200D\u{1F52C}", "\u{1F469}\u{1F3FE}\u200D\u{1F52C}", "\u{1F469}\u{1F3FF}\u200D\u{1F52C}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F4BB}", category: 1, name: "technologist", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F4BB}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F4BB}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F4BB}", category: 1, name: "man technologist", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FC}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FD}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FE}\u200D\u{1F4BB}", "\u{1F468}\u{1F3FF}\u200D\u{1F4BB}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F4BB}", category: 1, name: "woman technologist", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FC}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FD}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FE}\u200D\u{1F4BB}", "\u{1F469}\u{1F3FF}\u200D\u{1F4BB}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F3A4}", category: 1, name: "singer", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3A4}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3A4}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F3A4}", category: 1, name: "man singer", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FC}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FD}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FE}\u200D\u{1F3A4}", "\u{1F468}\u{1F3FF}\u200D\u{1F3A4}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F3A4}", category: 1, name: "woman singer", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FC}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FD}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FE}\u200D\u{1F3A4}", "\u{1F469}\u{1F3FF}\u200D\u{1F3A4}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F3A8}", category: 1, name: "artist", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F3A8}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F3A8}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F3A8}", category: 1, name: "man artist", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FC}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FD}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FE}\u200D\u{1F3A8}", "\u{1F468}\u{1F3FF}\u200D\u{1F3A8}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F3A8}", category: 1, name: "woman artist", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FC}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FD}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FE}\u200D\u{1F3A8}", "\u{1F469}\u{1F3FF}\u200D\u{1F3A8}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u2708\uFE0F", category: 1, name: "pilot", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FC}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FD}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FE}\u200D\u2708\uFE0F", "\u{1F9D1}\u{1F3FF}\u200D\u2708\uFE0F"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u2708\uFE0F", category: 1, name: "man pilot", variations: ["\u{1F468}\u{1F3FB}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FC}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FD}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FE}\u200D\u2708\uFE0F", "\u{1F468}\u{1F3FF}\u200D\u2708\uFE0F"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u2708\uFE0F", category: 1, name: "woman pilot", variations: ["\u{1F469}\u{1F3FB}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FC}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FD}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FE}\u200D\u2708\uFE0F", "\u{1F469}\u{1F3FF}\u200D\u2708\uFE0F"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F680}", category: 1, name: "astronaut", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F680}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F680}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F680}", category: 1, name: "man astronaut", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F680}", "\u{1F468}\u{1F3FC}\u200D\u{1F680}", "\u{1F468}\u{1F3FD}\u200D\u{1F680}", "\u{1F468}\u{1F3FE}\u200D\u{1F680}", "\u{1F468}\u{1F3FF}\u200D\u{1F680}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F680}", category: 1, name: "woman astronaut", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F680}", "\u{1F469}\u{1F3FC}\u200D\u{1F680}", "\u{1F469}\u{1F3FD}\u200D\u{1F680}", "\u{1F469}\u{1F3FE}\u200D\u{1F680}", "\u{1F469}\u{1F3FF}\u200D\u{1F680}"], version: "4.0" }, { emoji: "\u{1F9D1}\u200D\u{1F692}", category: 1, name: "firefighter", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F692}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F692}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F692}", category: 1, name: "man firefighter", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F692}", "\u{1F468}\u{1F3FC}\u200D\u{1F692}", "\u{1F468}\u{1F3FD}\u200D\u{1F692}", "\u{1F468}\u{1F3FE}\u200D\u{1F692}", "\u{1F468}\u{1F3FF}\u200D\u{1F692}"], version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F692}", category: 1, name: "woman firefighter", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F692}", "\u{1F469}\u{1F3FC}\u200D\u{1F692}", "\u{1F469}\u{1F3FD}\u200D\u{1F692}", "\u{1F469}\u{1F3FE}\u200D\u{1F692}", "\u{1F469}\u{1F3FF}\u200D\u{1F692}"], version: "4.0" }, { emoji: "\u{1F46E}", category: 1, name: "police officer", variations: ["\u{1F46E}\u{1F3FB}", "\u{1F46E}\u{1F3FC}", "\u{1F46E}\u{1F3FD}", "\u{1F46E}\u{1F3FE}", "\u{1F46E}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F46E}\u200D\u2642\uFE0F", category: 1, name: "man police officer", variations: ["\u{1F46E}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F46E}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F46E}\u200D\u2640\uFE0F", category: 1, name: "woman police officer", variations: ["\u{1F46E}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F46E}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F575}\uFE0F", category: 1, name: "detective", variations: ["\u{1F575}\u{1F3FB}", "\u{1F575}\u{1F3FC}", "\u{1F575}\u{1F3FD}", "\u{1F575}\u{1F3FE}", "\u{1F575}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F575}\uFE0F\u200D\u2642\uFE0F", category: 1, name: "man detective", variations: ["\u{1F575}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F575}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F575}\uFE0F\u200D\u2640\uFE0F", category: 1, name: "woman detective", variations: ["\u{1F575}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F575}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F482}", category: 1, name: "guard", variations: ["\u{1F482}\u{1F3FB}", "\u{1F482}\u{1F3FC}", "\u{1F482}\u{1F3FD}", "\u{1F482}\u{1F3FE}", "\u{1F482}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F482}\u200D\u2642\uFE0F", category: 1, name: "man guard", variations: ["\u{1F482}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F482}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F482}\u200D\u2640\uFE0F", category: 1, name: "woman guard", variations: ["\u{1F482}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F482}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F977}", category: 1, name: "ninja", variations: ["\u{1F977}\u{1F3FB}", "\u{1F977}\u{1F3FC}", "\u{1F977}\u{1F3FD}", "\u{1F977}\u{1F3FE}", "\u{1F977}\u{1F3FF}"], version: "13.0" }, { emoji: "\u{1F477}", category: 1, name: "construction worker", variations: ["\u{1F477}\u{1F3FB}", "\u{1F477}\u{1F3FC}", "\u{1F477}\u{1F3FD}", "\u{1F477}\u{1F3FE}", "\u{1F477}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F477}\u200D\u2642\uFE0F", category: 1, name: "man construction worker", variations: ["\u{1F477}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F477}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F477}\u200D\u2640\uFE0F", category: 1, name: "woman construction worker", variations: ["\u{1F477}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F477}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F934}", category: 1, name: "prince", variations: ["\u{1F934}\u{1F3FB}", "\u{1F934}\u{1F3FC}", "\u{1F934}\u{1F3FD}", "\u{1F934}\u{1F3FE}", "\u{1F934}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F478}", category: 1, name: "princess", variations: ["\u{1F478}\u{1F3FB}", "\u{1F478}\u{1F3FC}", "\u{1F478}\u{1F3FD}", "\u{1F478}\u{1F3FE}", "\u{1F478}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F473}", category: 1, name: "person wearing turban", variations: ["\u{1F473}\u{1F3FB}", "\u{1F473}\u{1F3FC}", "\u{1F473}\u{1F3FD}", "\u{1F473}\u{1F3FE}", "\u{1F473}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F473}\u200D\u2642\uFE0F", category: 1, name: "man wearing turban", variations: ["\u{1F473}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F473}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F473}\u200D\u2640\uFE0F", category: 1, name: "woman wearing turban", variations: ["\u{1F473}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F473}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F472}", category: 1, name: "person with skullcap", variations: ["\u{1F472}\u{1F3FB}", "\u{1F472}\u{1F3FC}", "\u{1F472}\u{1F3FD}", "\u{1F472}\u{1F3FE}", "\u{1F472}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9D5}", category: 1, name: "woman with headscarf", variations: ["\u{1F9D5}\u{1F3FB}", "\u{1F9D5}\u{1F3FC}", "\u{1F9D5}\u{1F3FD}", "\u{1F9D5}\u{1F3FE}", "\u{1F9D5}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F935}", category: 1, name: "person in tuxedo", variations: ["\u{1F935}\u{1F3FB}", "\u{1F935}\u{1F3FC}", "\u{1F935}\u{1F3FD}", "\u{1F935}\u{1F3FE}", "\u{1F935}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F935}\u200D\u2642\uFE0F", category: 1, name: "man in tuxedo", variations: ["\u{1F935}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F935}\u{1F3FF}\u200D\u2642\uFE0F"], version: "13.0" }, { emoji: "\u{1F935}\u200D\u2640\uFE0F", category: 1, name: "woman in tuxedo", variations: ["\u{1F935}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F935}\u{1F3FF}\u200D\u2640\uFE0F"], version: "13.0" }, { emoji: "\u{1F470}", category: 1, name: "person with veil", variations: ["\u{1F470}\u{1F3FB}", "\u{1F470}\u{1F3FC}", "\u{1F470}\u{1F3FD}", "\u{1F470}\u{1F3FE}", "\u{1F470}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F470}\u200D\u2642\uFE0F", category: 1, name: "man with veil", variations: ["\u{1F470}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F470}\u{1F3FF}\u200D\u2642\uFE0F"], version: "13.0" }, { emoji: "\u{1F470}\u200D\u2640\uFE0F", category: 1, name: "woman with veil", variations: ["\u{1F470}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F470}\u{1F3FF}\u200D\u2640\uFE0F"], version: "13.0" }, { emoji: "\u{1F930}", category: 1, name: "pregnant woman", variations: ["\u{1F930}\u{1F3FB}", "\u{1F930}\u{1F3FC}", "\u{1F930}\u{1F3FD}", "\u{1F930}\u{1F3FE}", "\u{1F930}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F931}", category: 1, name: "breast-feeding", variations: ["\u{1F931}\u{1F3FB}", "\u{1F931}\u{1F3FC}", "\u{1F931}\u{1F3FD}", "\u{1F931}\u{1F3FE}", "\u{1F931}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F469}\u200D\u{1F37C}", category: 1, name: "woman feeding baby", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F37C}", "\u{1F469}\u{1F3FC}\u200D\u{1F37C}", "\u{1F469}\u{1F3FD}\u200D\u{1F37C}", "\u{1F469}\u{1F3FE}\u200D\u{1F37C}", "\u{1F469}\u{1F3FF}\u200D\u{1F37C}"], version: "13.0" }, { emoji: "\u{1F468}\u200D\u{1F37C}", category: 1, name: "man feeding baby", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F37C}", "\u{1F468}\u{1F3FC}\u200D\u{1F37C}", "\u{1F468}\u{1F3FD}\u200D\u{1F37C}", "\u{1F468}\u{1F3FE}\u200D\u{1F37C}", "\u{1F468}\u{1F3FF}\u200D\u{1F37C}"], version: "13.0" }, { emoji: "\u{1F9D1}\u200D\u{1F37C}", category: 1, name: "person feeding baby", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F37C}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F37C}"], version: "13.0" }, { emoji: "\u{1F47C}", category: 1, name: "baby angel", variations: ["\u{1F47C}\u{1F3FB}", "\u{1F47C}\u{1F3FC}", "\u{1F47C}\u{1F3FD}", "\u{1F47C}\u{1F3FE}", "\u{1F47C}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F385}", category: 1, name: "Santa Claus", variations: ["\u{1F385}\u{1F3FB}", "\u{1F385}\u{1F3FC}", "\u{1F385}\u{1F3FD}", "\u{1F385}\u{1F3FE}", "\u{1F385}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F936}", category: 1, name: "Mrs. Claus", variations: ["\u{1F936}\u{1F3FB}", "\u{1F936}\u{1F3FC}", "\u{1F936}\u{1F3FD}", "\u{1F936}\u{1F3FE}", "\u{1F936}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F9D1}\u200D\u{1F384}", category: 1, name: "mx claus", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F384}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F384}"], version: "13.0" }, { emoji: "\u{1F9B8}", category: 1, name: "superhero", variations: ["\u{1F9B8}\u{1F3FB}", "\u{1F9B8}\u{1F3FC}", "\u{1F9B8}\u{1F3FD}", "\u{1F9B8}\u{1F3FE}", "\u{1F9B8}\u{1F3FF}"], version: "11.0" }, { emoji: "\u{1F9B8}\u200D\u2642\uFE0F", category: 1, name: "man superhero", variations: ["\u{1F9B8}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9B8}\u{1F3FF}\u200D\u2642\uFE0F"], version: "11.0" }, { emoji: "\u{1F9B8}\u200D\u2640\uFE0F", category: 1, name: "woman superhero", variations: ["\u{1F9B8}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9B8}\u{1F3FF}\u200D\u2640\uFE0F"], version: "11.0" }, { emoji: "\u{1F9B9}", category: 1, name: "supervillain", variations: ["\u{1F9B9}\u{1F3FB}", "\u{1F9B9}\u{1F3FC}", "\u{1F9B9}\u{1F3FD}", "\u{1F9B9}\u{1F3FE}", "\u{1F9B9}\u{1F3FF}"], version: "11.0" }, { emoji: "\u{1F9B9}\u200D\u2642\uFE0F", category: 1, name: "man supervillain", variations: ["\u{1F9B9}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9B9}\u{1F3FF}\u200D\u2642\uFE0F"], version: "11.0" }, { emoji: "\u{1F9B9}\u200D\u2640\uFE0F", category: 1, name: "woman supervillain", variations: ["\u{1F9B9}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9B9}\u{1F3FF}\u200D\u2640\uFE0F"], version: "11.0" }, { emoji: "\u{1F9D9}", category: 1, name: "mage", variations: ["\u{1F9D9}\u{1F3FB}", "\u{1F9D9}\u{1F3FC}", "\u{1F9D9}\u{1F3FD}", "\u{1F9D9}\u{1F3FE}", "\u{1F9D9}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9D9}\u200D\u2642\uFE0F", category: 1, name: "man mage", variations: ["\u{1F9D9}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D9}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9D9}\u200D\u2640\uFE0F", category: 1, name: "woman mage", variations: ["\u{1F9D9}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D9}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DA}", category: 1, name: "fairy", variations: ["\u{1F9DA}\u{1F3FB}", "\u{1F9DA}\u{1F3FC}", "\u{1F9DA}\u{1F3FD}", "\u{1F9DA}\u{1F3FE}", "\u{1F9DA}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9DA}\u200D\u2642\uFE0F", category: 1, name: "man fairy", variations: ["\u{1F9DA}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DA}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DA}\u200D\u2640\uFE0F", category: 1, name: "woman fairy", variations: ["\u{1F9DA}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DA}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DB}", category: 1, name: "vampire", variations: ["\u{1F9DB}\u{1F3FB}", "\u{1F9DB}\u{1F3FC}", "\u{1F9DB}\u{1F3FD}", "\u{1F9DB}\u{1F3FE}", "\u{1F9DB}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9DB}\u200D\u2642\uFE0F", category: 1, name: "man vampire", variations: ["\u{1F9DB}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DB}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DB}\u200D\u2640\uFE0F", category: 1, name: "woman vampire", variations: ["\u{1F9DB}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DB}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DC}", category: 1, name: "merperson", variations: ["\u{1F9DC}\u{1F3FB}", "\u{1F9DC}\u{1F3FC}", "\u{1F9DC}\u{1F3FD}", "\u{1F9DC}\u{1F3FE}", "\u{1F9DC}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9DC}\u200D\u2642\uFE0F", category: 1, name: "merman", variations: ["\u{1F9DC}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DC}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DC}\u200D\u2640\uFE0F", category: 1, name: "mermaid", variations: ["\u{1F9DC}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DC}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DD}", category: 1, name: "elf", variations: ["\u{1F9DD}\u{1F3FB}", "\u{1F9DD}\u{1F3FC}", "\u{1F9DD}\u{1F3FD}", "\u{1F9DD}\u{1F3FE}", "\u{1F9DD}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9DD}\u200D\u2642\uFE0F", category: 1, name: "man elf", variations: ["\u{1F9DD}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9DD}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DD}\u200D\u2640\uFE0F", category: 1, name: "woman elf", variations: ["\u{1F9DD}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9DD}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F9DE}", category: 1, name: "genie", version: "5.0" }, { emoji: "\u{1F9DE}\u200D\u2642\uFE0F", category: 1, name: "man genie", version: "5.0" }, { emoji: "\u{1F9DE}\u200D\u2640\uFE0F", category: 1, name: "woman genie", version: "5.0" }, { emoji: "\u{1F9DF}", category: 1, name: "zombie", version: "5.0" }, { emoji: "\u{1F9DF}\u200D\u2642\uFE0F", category: 1, name: "man zombie", version: "5.0" }, { emoji: "\u{1F9DF}\u200D\u2640\uFE0F", category: 1, name: "woman zombie", version: "5.0" }, { emoji: "\u{1F486}", category: 1, name: "person getting massage", variations: ["\u{1F486}\u{1F3FB}", "\u{1F486}\u{1F3FC}", "\u{1F486}\u{1F3FD}", "\u{1F486}\u{1F3FE}", "\u{1F486}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F486}\u200D\u2642\uFE0F", category: 1, name: "man getting massage", variations: ["\u{1F486}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F486}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F486}\u200D\u2640\uFE0F", category: 1, name: "woman getting massage", variations: ["\u{1F486}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F486}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F487}", category: 1, name: "person getting haircut", variations: ["\u{1F487}\u{1F3FB}", "\u{1F487}\u{1F3FC}", "\u{1F487}\u{1F3FD}", "\u{1F487}\u{1F3FE}", "\u{1F487}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F487}\u200D\u2642\uFE0F", category: 1, name: "man getting haircut", variations: ["\u{1F487}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F487}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F487}\u200D\u2640\uFE0F", category: 1, name: "woman getting haircut", variations: ["\u{1F487}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F487}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F6B6}", category: 1, name: "person walking", variations: ["\u{1F6B6}\u{1F3FB}", "\u{1F6B6}\u{1F3FC}", "\u{1F6B6}\u{1F3FD}", "\u{1F6B6}\u{1F3FE}", "\u{1F6B6}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F6B6}\u200D\u2642\uFE0F", category: 1, name: "man walking", variations: ["\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6B6}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F6B6}\u200D\u2640\uFE0F", category: 1, name: "woman walking", variations: ["\u{1F6B6}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6B6}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F9CD}", category: 1, name: "person standing", variations: ["\u{1F9CD}\u{1F3FB}", "\u{1F9CD}\u{1F3FC}", "\u{1F9CD}\u{1F3FD}", "\u{1F9CD}\u{1F3FE}", "\u{1F9CD}\u{1F3FF}"], version: "12.0" }, { emoji: "\u{1F9CD}\u200D\u2642\uFE0F", category: 1, name: "man standing", variations: ["\u{1F9CD}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9CD}\u{1F3FF}\u200D\u2642\uFE0F"], version: "12.0" }, { emoji: "\u{1F9CD}\u200D\u2640\uFE0F", category: 1, name: "woman standing", variations: ["\u{1F9CD}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9CD}\u{1F3FF}\u200D\u2640\uFE0F"], version: "12.0" }, { emoji: "\u{1F9CE}", category: 1, name: "person kneeling", variations: ["\u{1F9CE}\u{1F3FB}", "\u{1F9CE}\u{1F3FC}", "\u{1F9CE}\u{1F3FD}", "\u{1F9CE}\u{1F3FE}", "\u{1F9CE}\u{1F3FF}"], version: "12.0" }, { emoji: "\u{1F9CE}\u200D\u2642\uFE0F", category: 1, name: "man kneeling", variations: ["\u{1F9CE}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9CE}\u{1F3FF}\u200D\u2642\uFE0F"], version: "12.0" }, { emoji: "\u{1F9CE}\u200D\u2640\uFE0F", category: 1, name: "woman kneeling", variations: ["\u{1F9CE}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9CE}\u{1F3FF}\u200D\u2640\uFE0F"], version: "12.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9AF}", category: 1, name: "person with white cane", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9AF}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9AF}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F9AF}", category: 1, name: "man with white cane", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FC}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FD}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FE}\u200D\u{1F9AF}", "\u{1F468}\u{1F3FF}\u200D\u{1F9AF}"], version: "12.0" }, { emoji: "\u{1F469}\u200D\u{1F9AF}", category: 1, name: "woman with white cane", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FC}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FD}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FE}\u200D\u{1F9AF}", "\u{1F469}\u{1F3FF}\u200D\u{1F9AF}"], version: "12.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9BC}", category: 1, name: "person in motorized wheelchair", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9BC}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9BC}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F9BC}", category: 1, name: "man in motorized wheelchair", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FC}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FD}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FE}\u200D\u{1F9BC}", "\u{1F468}\u{1F3FF}\u200D\u{1F9BC}"], version: "12.0" }, { emoji: "\u{1F469}\u200D\u{1F9BC}", category: 1, name: "woman in motorized wheelchair", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FC}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FD}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FE}\u200D\u{1F9BC}", "\u{1F469}\u{1F3FF}\u200D\u{1F9BC}"], version: "12.0" }, { emoji: "\u{1F9D1}\u200D\u{1F9BD}", category: 1, name: "person in manual wheelchair", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F9BD}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F9BD}"], version: "12.1" }, { emoji: "\u{1F468}\u200D\u{1F9BD}", category: 1, name: "man in manual wheelchair", variations: ["\u{1F468}\u{1F3FB}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FC}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FD}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FE}\u200D\u{1F9BD}", "\u{1F468}\u{1F3FF}\u200D\u{1F9BD}"], version: "12.0" }, { emoji: "\u{1F469}\u200D\u{1F9BD}", category: 1, name: "woman in manual wheelchair", variations: ["\u{1F469}\u{1F3FB}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FC}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FD}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FE}\u200D\u{1F9BD}", "\u{1F469}\u{1F3FF}\u200D\u{1F9BD}"], version: "12.0" }, { emoji: "\u{1F3C3}", category: 1, name: "person running", variations: ["\u{1F3C3}\u{1F3FB}", "\u{1F3C3}\u{1F3FC}", "\u{1F3C3}\u{1F3FD}", "\u{1F3C3}\u{1F3FE}", "\u{1F3C3}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F3C3}\u200D\u2642\uFE0F", category: 1, name: "man running", variations: ["\u{1F3C3}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3C3}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F3C3}\u200D\u2640\uFE0F", category: 1, name: "woman running", variations: ["\u{1F3C3}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3C3}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F483}", category: 1, name: "woman dancing", variations: ["\u{1F483}\u{1F3FB}", "\u{1F483}\u{1F3FC}", "\u{1F483}\u{1F3FD}", "\u{1F483}\u{1F3FE}", "\u{1F483}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F57A}", category: 1, name: "man dancing", variations: ["\u{1F57A}\u{1F3FB}", "\u{1F57A}\u{1F3FC}", "\u{1F57A}\u{1F3FD}", "\u{1F57A}\u{1F3FE}", "\u{1F57A}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F574}\uFE0F", category: 1, name: "person in suit levitating", variations: ["\u{1F574}\u{1F3FB}", "\u{1F574}\u{1F3FC}", "\u{1F574}\u{1F3FD}", "\u{1F574}\u{1F3FE}", "\u{1F574}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F46F}", category: 1, name: "people with bunny ears", version: "1.0" }, { emoji: "\u{1F46F}\u200D\u2642\uFE0F", category: 1, name: "men with bunny ears", version: "4.0" }, { emoji: "\u{1F46F}\u200D\u2640\uFE0F", category: 1, name: "women with bunny ears", version: "4.0" }, { emoji: "\u{1F9D6}", category: 1, name: "person in steamy room", variations: ["\u{1F9D6}\u{1F3FB}", "\u{1F9D6}\u{1F3FC}", "\u{1F9D6}\u{1F3FD}", "\u{1F9D6}\u{1F3FE}", "\u{1F9D6}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9D6}\u200D\u2642\uFE0F", category: 1, name: "man in steamy room", variations: ["\u{1F9D6}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D6}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9D6}\u200D\u2640\uFE0F", category: 1, name: "woman in steamy room", variations: ["\u{1F9D6}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D6}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F9D7}", category: 1, name: "person climbing", variations: ["\u{1F9D7}\u{1F3FB}", "\u{1F9D7}\u{1F3FC}", "\u{1F9D7}\u{1F3FD}", "\u{1F9D7}\u{1F3FE}", "\u{1F9D7}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9D7}\u200D\u2642\uFE0F", category: 1, name: "man climbing", variations: ["\u{1F9D7}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D7}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9D7}\u200D\u2640\uFE0F", category: 1, name: "woman climbing", variations: ["\u{1F9D7}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D7}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F93A}", category: 1, name: "person fencing", version: "3.0" }, { emoji: "\u{1F3C7}", category: 1, name: "horse racing", variations: ["\u{1F3C7}\u{1F3FB}", "\u{1F3C7}\u{1F3FC}", "\u{1F3C7}\u{1F3FD}", "\u{1F3C7}\u{1F3FE}", "\u{1F3C7}\u{1F3FF}"], version: "1.0" }, { emoji: "\u26F7\uFE0F", category: 1, name: "skier", version: "1.0" }, { emoji: "\u{1F3C2}", category: 1, name: "snowboarder", variations: ["\u{1F3C2}\u{1F3FB}", "\u{1F3C2}\u{1F3FC}", "\u{1F3C2}\u{1F3FD}", "\u{1F3C2}\u{1F3FE}", "\u{1F3C2}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F3CC}\uFE0F", category: 1, name: "person golfing", variations: ["\u{1F3CC}\u{1F3FB}", "\u{1F3CC}\u{1F3FC}", "\u{1F3CC}\u{1F3FD}", "\u{1F3CC}\u{1F3FE}", "\u{1F3CC}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F", category: 1, name: "man golfing", variations: ["\u{1F3CC}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3CC}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F", category: 1, name: "woman golfing", variations: ["\u{1F3CC}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3CC}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F3C4}", category: 1, name: "person surfing", variations: ["\u{1F3C4}\u{1F3FB}", "\u{1F3C4}\u{1F3FC}", "\u{1F3C4}\u{1F3FD}", "\u{1F3C4}\u{1F3FE}", "\u{1F3C4}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F3C4}\u200D\u2642\uFE0F", category: 1, name: "man surfing", variations: ["\u{1F3C4}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3C4}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F3C4}\u200D\u2640\uFE0F", category: 1, name: "woman surfing", variations: ["\u{1F3C4}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3C4}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F6A3}", category: 1, name: "person rowing boat", variations: ["\u{1F6A3}\u{1F3FB}", "\u{1F6A3}\u{1F3FC}", "\u{1F6A3}\u{1F3FD}", "\u{1F6A3}\u{1F3FE}", "\u{1F6A3}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F6A3}\u200D\u2642\uFE0F", category: 1, name: "man rowing boat", variations: ["\u{1F6A3}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6A3}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F6A3}\u200D\u2640\uFE0F", category: 1, name: "woman rowing boat", variations: ["\u{1F6A3}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6A3}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F3CA}", category: 1, name: "person swimming", variations: ["\u{1F3CA}\u{1F3FB}", "\u{1F3CA}\u{1F3FC}", "\u{1F3CA}\u{1F3FD}", "\u{1F3CA}\u{1F3FE}", "\u{1F3CA}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F3CA}\u200D\u2642\uFE0F", category: 1, name: "man swimming", variations: ["\u{1F3CA}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3CA}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F3CA}\u200D\u2640\uFE0F", category: 1, name: "woman swimming", variations: ["\u{1F3CA}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3CA}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u26F9\uFE0F", category: 1, name: "person bouncing ball", variations: ["\u26F9\u{1F3FB}", "\u26F9\u{1F3FC}", "\u26F9\u{1F3FD}", "\u26F9\u{1F3FE}", "\u26F9\u{1F3FF}"], version: "1.0" }, { emoji: "\u26F9\uFE0F\u200D\u2642\uFE0F", category: 1, name: "man bouncing ball", variations: ["\u26F9\u{1F3FB}\u200D\u2642\uFE0F", "\u26F9\u{1F3FC}\u200D\u2642\uFE0F", "\u26F9\u{1F3FD}\u200D\u2642\uFE0F", "\u26F9\u{1F3FE}\u200D\u2642\uFE0F", "\u26F9\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u26F9\uFE0F\u200D\u2640\uFE0F", category: 1, name: "woman bouncing ball", variations: ["\u26F9\u{1F3FB}\u200D\u2640\uFE0F", "\u26F9\u{1F3FC}\u200D\u2640\uFE0F", "\u26F9\u{1F3FD}\u200D\u2640\uFE0F", "\u26F9\u{1F3FE}\u200D\u2640\uFE0F", "\u26F9\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F3CB}\uFE0F", category: 1, name: "person lifting weights", variations: ["\u{1F3CB}\u{1F3FB}", "\u{1F3CB}\u{1F3FC}", "\u{1F3CB}\u{1F3FD}", "\u{1F3CB}\u{1F3FE}", "\u{1F3CB}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F", category: 1, name: "man lifting weights", variations: ["\u{1F3CB}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F3CB}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F", category: 1, name: "woman lifting weights", variations: ["\u{1F3CB}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F3CB}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F6B4}", category: 1, name: "person biking", variations: ["\u{1F6B4}\u{1F3FB}", "\u{1F6B4}\u{1F3FC}", "\u{1F6B4}\u{1F3FD}", "\u{1F6B4}\u{1F3FE}", "\u{1F6B4}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F6B4}\u200D\u2642\uFE0F", category: 1, name: "man biking", variations: ["\u{1F6B4}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6B4}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F6B4}\u200D\u2640\uFE0F", category: 1, name: "woman biking", variations: ["\u{1F6B4}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6B4}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F6B5}", category: 1, name: "person mountain biking", variations: ["\u{1F6B5}\u{1F3FB}", "\u{1F6B5}\u{1F3FC}", "\u{1F6B5}\u{1F3FD}", "\u{1F6B5}\u{1F3FE}", "\u{1F6B5}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F6B5}\u200D\u2642\uFE0F", category: 1, name: "man mountain biking", variations: ["\u{1F6B5}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F6B5}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F6B5}\u200D\u2640\uFE0F", category: 1, name: "woman mountain biking", variations: ["\u{1F6B5}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F6B5}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F938}", category: 1, name: "person cartwheeling", variations: ["\u{1F938}\u{1F3FB}", "\u{1F938}\u{1F3FC}", "\u{1F938}\u{1F3FD}", "\u{1F938}\u{1F3FE}", "\u{1F938}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F938}\u200D\u2642\uFE0F", category: 1, name: "man cartwheeling", variations: ["\u{1F938}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F938}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F938}\u200D\u2640\uFE0F", category: 1, name: "woman cartwheeling", variations: ["\u{1F938}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F938}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F93C}", category: 1, name: "people wrestling", version: "3.0" }, { emoji: "\u{1F93C}\u200D\u2642\uFE0F", category: 1, name: "men wrestling", version: "4.0" }, { emoji: "\u{1F93C}\u200D\u2640\uFE0F", category: 1, name: "women wrestling", version: "4.0" }, { emoji: "\u{1F93D}", category: 1, name: "person playing water polo", variations: ["\u{1F93D}\u{1F3FB}", "\u{1F93D}\u{1F3FC}", "\u{1F93D}\u{1F3FD}", "\u{1F93D}\u{1F3FE}", "\u{1F93D}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F93D}\u200D\u2642\uFE0F", category: 1, name: "man playing water polo", variations: ["\u{1F93D}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F93D}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F93D}\u200D\u2640\uFE0F", category: 1, name: "woman playing water polo", variations: ["\u{1F93D}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F93D}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F93E}", category: 1, name: "person playing handball", variations: ["\u{1F93E}\u{1F3FB}", "\u{1F93E}\u{1F3FC}", "\u{1F93E}\u{1F3FD}", "\u{1F93E}\u{1F3FE}", "\u{1F93E}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F93E}\u200D\u2642\uFE0F", category: 1, name: "man playing handball", variations: ["\u{1F93E}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F93E}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F93E}\u200D\u2640\uFE0F", category: 1, name: "woman playing handball", variations: ["\u{1F93E}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F93E}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F939}", category: 1, name: "person juggling", variations: ["\u{1F939}\u{1F3FB}", "\u{1F939}\u{1F3FC}", "\u{1F939}\u{1F3FD}", "\u{1F939}\u{1F3FE}", "\u{1F939}\u{1F3FF}"], version: "3.0" }, { emoji: "\u{1F939}\u200D\u2642\uFE0F", category: 1, name: "man juggling", variations: ["\u{1F939}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F939}\u{1F3FF}\u200D\u2642\uFE0F"], version: "4.0" }, { emoji: "\u{1F939}\u200D\u2640\uFE0F", category: 1, name: "woman juggling", variations: ["\u{1F939}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F939}\u{1F3FF}\u200D\u2640\uFE0F"], version: "4.0" }, { emoji: "\u{1F9D8}", category: 1, name: "person in lotus position", variations: ["\u{1F9D8}\u{1F3FB}", "\u{1F9D8}\u{1F3FC}", "\u{1F9D8}\u{1F3FD}", "\u{1F9D8}\u{1F3FE}", "\u{1F9D8}\u{1F3FF}"], version: "5.0" }, { emoji: "\u{1F9D8}\u200D\u2642\uFE0F", category: 1, name: "man in lotus position", variations: ["\u{1F9D8}\u{1F3FB}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FC}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FD}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FE}\u200D\u2642\uFE0F", "\u{1F9D8}\u{1F3FF}\u200D\u2642\uFE0F"], version: "5.0" }, { emoji: "\u{1F9D8}\u200D\u2640\uFE0F", category: 1, name: "woman in lotus position", variations: ["\u{1F9D8}\u{1F3FB}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FC}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FD}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FE}\u200D\u2640\uFE0F", "\u{1F9D8}\u{1F3FF}\u200D\u2640\uFE0F"], version: "5.0" }, { emoji: "\u{1F6C0}", category: 1, name: "person taking bath", variations: ["\u{1F6C0}\u{1F3FB}", "\u{1F6C0}\u{1F3FC}", "\u{1F6C0}\u{1F3FD}", "\u{1F6C0}\u{1F3FE}", "\u{1F6C0}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F6CC}", category: 1, name: "person in bed", variations: ["\u{1F6CC}\u{1F3FB}", "\u{1F6CC}\u{1F3FC}", "\u{1F6CC}\u{1F3FD}", "\u{1F6CC}\u{1F3FE}", "\u{1F6CC}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}", category: 1, name: "people holding hands", variations: ["\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}", "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}"], version: "12.0" }, { emoji: "\u{1F46D}", category: 1, name: "women holding hands", variations: ["\u{1F46D}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F46D}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F46D}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F46D}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}", "\u{1F46D}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F46B}", category: 1, name: "woman and man holding hands", variations: ["\u{1F46B}\u{1F3FB}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F46B}\u{1F3FC}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F46B}\u{1F3FD}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F46B}\u{1F3FE}", "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F46B}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F46C}", category: 1, name: "men holding hands", variations: ["\u{1F46C}\u{1F3FB}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F46C}\u{1F3FC}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F46C}\u{1F3FD}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F46C}\u{1F3FE}", "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}", "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}", "\u{1F46C}\u{1F3FF}"], version: "1.0" }, { emoji: "\u{1F48F}", category: 1, name: "kiss", variations: ["\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}"], version: "1.0" }, { emoji: "\u{1F491}", category: 1, name: "couple with heart", variations: ["\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}", "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}"], version: "1.0" }, { emoji: "\u{1F46A}", category: 1, name: "family", version: "1.0" }, { emoji: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}", category: 1, name: "family: man, woman, boy", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}", category: 1, name: "family: man, woman, girl", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", category: 1, name: "family: man, woman, girl, boy", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", category: 1, name: "family: man, woman, boy, boy", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", category: 1, name: "family: man, woman, girl, girl", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}", category: 1, name: "family: man, man, boy", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}", category: 1, name: "family: man, man, girl", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", category: 1, name: "family: man, man, girl, boy", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", category: 1, name: "family: man, man, boy, boy", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", category: 1, name: "family: man, man, girl, girl", version: "2.0" }, { emoji: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}", category: 1, name: "family: woman, woman, boy", version: "2.0" }, { emoji: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}", category: 1, name: "family: woman, woman, girl", version: "2.0" }, { emoji: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", category: 1, name: "family: woman, woman, girl, boy", version: "2.0" }, { emoji: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", category: 1, name: "family: woman, woman, boy, boy", version: "2.0" }, { emoji: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", category: 1, name: "family: woman, woman, girl, girl", version: "2.0" }, { emoji: "\u{1F468}\u200D\u{1F466}", category: 1, name: "family: man, boy", version: "4.0" }, { emoji: "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", category: 1, name: "family: man, boy, boy", version: "4.0" }, { emoji: "\u{1F468}\u200D\u{1F467}", category: 1, name: "family: man, girl", version: "4.0" }, { emoji: "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", category: 1, name: "family: man, girl, boy", version: "4.0" }, { emoji: "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", category: 1, name: "family: man, girl, girl", version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F466}", category: 1, name: "family: woman, boy", version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", category: 1, name: "family: woman, boy, boy", version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F467}", category: 1, name: "family: woman, girl", version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", category: 1, name: "family: woman, girl, boy", version: "4.0" }, { emoji: "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", category: 1, name: "family: woman, girl, girl", version: "4.0" }, { emoji: "\u{1F5E3}\uFE0F", category: 1, name: "speaking head", version: "1.0" }, { emoji: "\u{1F464}", category: 1, name: "bust in silhouette", version: "1.0" }, { emoji: "\u{1F465}", category: 1, name: "busts in silhouette", version: "1.0" }, { emoji: "\u{1FAC2}", category: 1, name: "people hugging", version: "13.0" }, { emoji: "\u{1F463}", category: 1, name: "footprints", version: "1.0" }, { emoji: "\u{1F435}", category: 2, name: "monkey face", version: "1.0" }, { emoji: "\u{1F412}", category: 2, name: "monkey", version: "1.0" }, { emoji: "\u{1F98D}", category: 2, name: "gorilla", version: "3.0" }, { emoji: "\u{1F9A7}", category: 2, name: "orangutan", version: "12.0" }, { emoji: "\u{1F436}", category: 2, name: "dog face", version: "1.0" }, { emoji: "\u{1F415}", category: 2, name: "dog", version: "1.0" }, { emoji: "\u{1F9AE}", category: 2, name: "guide dog", version: "12.0" }, { emoji: "\u{1F415}\u200D\u{1F9BA}", category: 2, name: "service dog", version: "12.0" }, { emoji: "\u{1F429}", category: 2, name: "poodle", version: "1.0" }, { emoji: "\u{1F43A}", category: 2, name: "wolf", version: "1.0" }, { emoji: "\u{1F98A}", category: 2, name: "fox", version: "3.0" }, { emoji: "\u{1F99D}", category: 2, name: "raccoon", version: "11.0" }, { emoji: "\u{1F431}", category: 2, name: "cat face", version: "1.0" }, { emoji: "\u{1F408}", category: 2, name: "cat", version: "1.0" }, { emoji: "\u{1F408}\u200D\u2B1B", category: 2, name: "black cat", version: "13.0" }, { emoji: "\u{1F981}", category: 2, name: "lion", version: "1.0" }, { emoji: "\u{1F42F}", category: 2, name: "tiger face", version: "1.0" }, { emoji: "\u{1F405}", category: 2, name: "tiger", version: "1.0" }, { emoji: "\u{1F406}", category: 2, name: "leopard", version: "1.0" }, { emoji: "\u{1F434}", category: 2, name: "horse face", version: "1.0" }, { emoji: "\u{1F40E}", category: 2, name: "horse", version: "1.0" }, { emoji: "\u{1F984}", category: 2, name: "unicorn", version: "1.0" }, { emoji: "\u{1F993}", category: 2, name: "zebra", version: "5.0" }, { emoji: "\u{1F98C}", category: 2, name: "deer", version: "3.0" }, { emoji: "\u{1F9AC}", category: 2, name: "bison", version: "13.0" }, { emoji: "\u{1F42E}", category: 2, name: "cow face", version: "1.0" }, { emoji: "\u{1F402}", category: 2, name: "ox", version: "1.0" }, { emoji: "\u{1F403}", category: 2, name: "water buffalo", version: "1.0" }, { emoji: "\u{1F404}", category: 2, name: "cow", version: "1.0" }, { emoji: "\u{1F437}", category: 2, name: "pig face", version: "1.0" }, { emoji: "\u{1F416}", category: 2, name: "pig", version: "1.0" }, { emoji: "\u{1F417}", category: 2, name: "boar", version: "1.0" }, { emoji: "\u{1F43D}", category: 2, name: "pig nose", version: "1.0" }, { emoji: "\u{1F40F}", category: 2, name: "ram", version: "1.0" }, { emoji: "\u{1F411}", category: 2, name: "ewe", version: "1.0" }, { emoji: "\u{1F410}", category: 2, name: "goat", version: "1.0" }, { emoji: "\u{1F42A}", category: 2, name: "camel", version: "1.0" }, { emoji: "\u{1F42B}", category: 2, name: "two-hump camel", version: "1.0" }, { emoji: "\u{1F999}", category: 2, name: "llama", version: "11.0" }, { emoji: "\u{1F992}", category: 2, name: "giraffe", version: "5.0" }, { emoji: "\u{1F418}", category: 2, name: "elephant", version: "1.0" }, { emoji: "\u{1F9A3}", category: 2, name: "mammoth", version: "13.0" }, { emoji: "\u{1F98F}", category: 2, name: "rhinoceros", version: "3.0" }, { emoji: "\u{1F99B}", category: 2, name: "hippopotamus", version: "11.0" }, { emoji: "\u{1F42D}", category: 2, name: "mouse face", version: "1.0" }, { emoji: "\u{1F401}", category: 2, name: "mouse", version: "1.0" }, { emoji: "\u{1F400}", category: 2, name: "rat", version: "1.0" }, { emoji: "\u{1F439}", category: 2, name: "hamster", version: "1.0" }, { emoji: "\u{1F430}", category: 2, name: "rabbit face", version: "1.0" }, { emoji: "\u{1F407}", category: 2, name: "rabbit", version: "1.0" }, { emoji: "\u{1F43F}\uFE0F", category: 2, name: "chipmunk", version: "1.0" }, { emoji: "\u{1F9AB}", category: 2, name: "beaver", version: "13.0" }, { emoji: "\u{1F994}", category: 2, name: "hedgehog", version: "5.0" }, { emoji: "\u{1F987}", category: 2, name: "bat", version: "3.0" }, { emoji: "\u{1F43B}", category: 2, name: "bear", version: "1.0" }, { emoji: "\u{1F43B}\u200D\u2744\uFE0F", category: 2, name: "polar bear", version: "13.0" }, { emoji: "\u{1F428}", category: 2, name: "koala", version: "1.0" }, { emoji: "\u{1F43C}", category: 2, name: "panda", version: "1.0" }, { emoji: "\u{1F9A5}", category: 2, name: "sloth", version: "12.0" }, { emoji: "\u{1F9A6}", category: 2, name: "otter", version: "12.0" }, { emoji: "\u{1F9A8}", category: 2, name: "skunk", version: "12.0" }, { emoji: "\u{1F998}", category: 2, name: "kangaroo", version: "11.0" }, { emoji: "\u{1F9A1}", category: 2, name: "badger", version: "11.0" }, { emoji: "\u{1F43E}", category: 2, name: "paw prints", version: "1.0" }, { emoji: "\u{1F983}", category: 2, name: "turkey", version: "1.0" }, { emoji: "\u{1F414}", category: 2, name: "chicken", version: "1.0" }, { emoji: "\u{1F413}", category: 2, name: "rooster", version: "1.0" }, { emoji: "\u{1F423}", category: 2, name: "hatching chick", version: "1.0" }, { emoji: "\u{1F424}", category: 2, name: "baby chick", version: "1.0" }, { emoji: "\u{1F425}", category: 2, name: "front-facing baby chick", version: "1.0" }, { emoji: "\u{1F426}", category: 2, name: "bird", version: "1.0" }, { emoji: "\u{1F427}", category: 2, name: "penguin", version: "1.0" }, { emoji: "\u{1F54A}\uFE0F", category: 2, name: "dove", version: "1.0" }, { emoji: "\u{1F985}", category: 2, name: "eagle", version: "3.0" }, { emoji: "\u{1F986}", category: 2, name: "duck", version: "3.0" }, { emoji: "\u{1F9A2}", category: 2, name: "swan", version: "11.0" }, { emoji: "\u{1F989}", category: 2, name: "owl", version: "3.0" }, { emoji: "\u{1F9A4}", category: 2, name: "dodo", version: "13.0" }, { emoji: "\u{1FAB6}", category: 2, name: "feather", version: "13.0" }, { emoji: "\u{1F9A9}", category: 2, name: "flamingo", version: "12.0" }, { emoji: "\u{1F99A}", category: 2, name: "peacock", version: "11.0" }, { emoji: "\u{1F99C}", category: 2, name: "parrot", version: "11.0" }, { emoji: "\u{1F438}", category: 2, name: "frog", version: "1.0" }, { emoji: "\u{1F40A}", category: 2, name: "crocodile", version: "1.0" }, { emoji: "\u{1F422}", category: 2, name: "turtle", version: "1.0" }, { emoji: "\u{1F98E}", category: 2, name: "lizard", version: "3.0" }, { emoji: "\u{1F40D}", category: 2, name: "snake", version: "1.0" }, { emoji: "\u{1F432}", category: 2, name: "dragon face", version: "1.0" }, { emoji: "\u{1F409}", category: 2, name: "dragon", version: "1.0" }, { emoji: "\u{1F995}", category: 2, name: "sauropod", version: "5.0" }, { emoji: "\u{1F996}", category: 2, name: "T-Rex", version: "5.0" }, { emoji: "\u{1F433}", category: 2, name: "spouting whale", version: "1.0" }, { emoji: "\u{1F40B}", category: 2, name: "whale", version: "1.0" }, { emoji: "\u{1F42C}", category: 2, name: "dolphin", version: "1.0" }, { emoji: "\u{1F9AD}", category: 2, name: "seal", version: "13.0" }, { emoji: "\u{1F41F}", category: 2, name: "fish", version: "1.0" }, { emoji: "\u{1F420}", category: 2, name: "tropical fish", version: "1.0" }, { emoji: "\u{1F421}", category: 2, name: "blowfish", version: "1.0" }, { emoji: "\u{1F988}", category: 2, name: "shark", version: "3.0" }, { emoji: "\u{1F419}", category: 2, name: "octopus", version: "1.0" }, { emoji: "\u{1F41A}", category: 2, name: "spiral shell", version: "1.0" }, { emoji: "\u{1F40C}", category: 2, name: "snail", version: "1.0" }, { emoji: "\u{1F98B}", category: 2, name: "butterfly", version: "3.0" }, { emoji: "\u{1F41B}", category: 2, name: "bug", version: "1.0" }, { emoji: "\u{1F41C}", category: 2, name: "ant", version: "1.0" }, { emoji: "\u{1F41D}", category: 2, name: "honeybee", version: "1.0" }, { emoji: "\u{1FAB2}", category: 2, name: "beetle", version: "13.0" }, { emoji: "\u{1F41E}", category: 2, name: "lady beetle", version: "1.0" }, { emoji: "\u{1F997}", category: 2, name: "cricket", version: "5.0" }, { emoji: "\u{1FAB3}", category: 2, name: "cockroach", version: "13.0" }, { emoji: "\u{1F577}\uFE0F", category: 2, name: "spider", version: "1.0" }, { emoji: "\u{1F578}\uFE0F", category: 2, name: "spider web", version: "1.0" }, { emoji: "\u{1F982}", category: 2, name: "scorpion", version: "1.0" }, { emoji: "\u{1F99F}", category: 2, name: "mosquito", version: "11.0" }, { emoji: "\u{1FAB0}", category: 2, name: "fly", version: "13.0" }, { emoji: "\u{1FAB1}", category: 2, name: "worm", version: "13.0" }, { emoji: "\u{1F9A0}", category: 2, name: "microbe", version: "11.0" }, { emoji: "\u{1F490}", category: 2, name: "bouquet", version: "1.0" }, { emoji: "\u{1F338}", category: 2, name: "cherry blossom", version: "1.0" }, { emoji: "\u{1F4AE}", category: 2, name: "white flower", version: "1.0" }, { emoji: "\u{1F3F5}\uFE0F", category: 2, name: "rosette", version: "1.0" }, { emoji: "\u{1F339}", category: 2, name: "rose", version: "1.0" }, { emoji: "\u{1F940}", category: 2, name: "wilted flower", version: "3.0" }, { emoji: "\u{1F33A}", category: 2, name: "hibiscus", version: "1.0" }, { emoji: "\u{1F33B}", category: 2, name: "sunflower", version: "1.0" }, { emoji: "\u{1F33C}", category: 2, name: "blossom", version: "1.0" }, { emoji: "\u{1F337}", category: 2, name: "tulip", version: "1.0" }, { emoji: "\u{1F331}", category: 2, name: "seedling", version: "1.0" }, { emoji: "\u{1FAB4}", category: 2, name: "potted plant", version: "13.0" }, { emoji: "\u{1F332}", category: 2, name: "evergreen tree", version: "1.0" }, { emoji: "\u{1F333}", category: 2, name: "deciduous tree", version: "1.0" }, { emoji: "\u{1F334}", category: 2, name: "palm tree", version: "1.0" }, { emoji: "\u{1F335}", category: 2, name: "cactus", version: "1.0" }, { emoji: "\u{1F33E}", category: 2, name: "sheaf of rice", version: "1.0" }, { emoji: "\u{1F33F}", category: 2, name: "herb", version: "1.0" }, { emoji: "\u2618\uFE0F", category: 2, name: "shamrock", version: "1.0" }, { emoji: "\u{1F340}", category: 2, name: "four leaf clover", version: "1.0" }, { emoji: "\u{1F341}", category: 2, name: "maple leaf", version: "1.0" }, { emoji: "\u{1F342}", category: 2, name: "fallen leaf", version: "1.0" }, { emoji: "\u{1F343}", category: 2, name: "leaf fluttering in wind", version: "1.0" }, { emoji: "\u{1F347}", category: 3, name: "grapes", version: "1.0" }, { emoji: "\u{1F348}", category: 3, name: "melon", version: "1.0" }, { emoji: "\u{1F349}", category: 3, name: "watermelon", version: "1.0" }, { emoji: "\u{1F34A}", category: 3, name: "tangerine", version: "1.0" }, { emoji: "\u{1F34B}", category: 3, name: "lemon", version: "1.0" }, { emoji: "\u{1F34C}", category: 3, name: "banana", version: "1.0" }, { emoji: "\u{1F34D}", category: 3, name: "pineapple", version: "1.0" }, { emoji: "\u{1F96D}", category: 3, name: "mango", version: "11.0" }, { emoji: "\u{1F34E}", category: 3, name: "red apple", version: "1.0" }, { emoji: "\u{1F34F}", category: 3, name: "green apple", version: "1.0" }, { emoji: "\u{1F350}", category: 3, name: "pear", version: "1.0" }, { emoji: "\u{1F351}", category: 3, name: "peach", version: "1.0" }, { emoji: "\u{1F352}", category: 3, name: "cherries", version: "1.0" }, { emoji: "\u{1F353}", category: 3, name: "strawberry", version: "1.0" }, { emoji: "\u{1FAD0}", category: 3, name: "blueberries", version: "13.0" }, { emoji: "\u{1F95D}", category: 3, name: "kiwi fruit", version: "3.0" }, { emoji: "\u{1F345}", category: 3, name: "tomato", version: "1.0" }, { emoji: "\u{1FAD2}", category: 3, name: "olive", version: "13.0" }, { emoji: "\u{1F965}", category: 3, name: "coconut", version: "5.0" }, { emoji: "\u{1F951}", category: 3, name: "avocado", version: "3.0" }, { emoji: "\u{1F346}", category: 3, name: "eggplant", version: "1.0" }, { emoji: "\u{1F954}", category: 3, name: "potato", version: "3.0" }, { emoji: "\u{1F955}", category: 3, name: "carrot", version: "3.0" }, { emoji: "\u{1F33D}", category: 3, name: "ear of corn", version: "1.0" }, { emoji: "\u{1F336}\uFE0F", category: 3, name: "hot pepper", version: "1.0" }, { emoji: "\u{1FAD1}", category: 3, name: "bell pepper", version: "13.0" }, { emoji: "\u{1F952}", category: 3, name: "cucumber", version: "3.0" }, { emoji: "\u{1F96C}", category: 3, name: "leafy green", version: "11.0" }, { emoji: "\u{1F966}", category: 3, name: "broccoli", version: "5.0" }, { emoji: "\u{1F9C4}", category: 3, name: "garlic", version: "12.0" }, { emoji: "\u{1F9C5}", category: 3, name: "onion", version: "12.0" }, { emoji: "\u{1F344}", category: 3, name: "mushroom", version: "1.0" }, { emoji: "\u{1F95C}", category: 3, name: "peanuts", version: "3.0" }, { emoji: "\u{1F330}", category: 3, name: "chestnut", version: "1.0" }, { emoji: "\u{1F35E}", category: 3, name: "bread", version: "1.0" }, { emoji: "\u{1F950}", category: 3, name: "croissant", version: "3.0" }, { emoji: "\u{1F956}", category: 3, name: "baguette bread", version: "3.0" }, { emoji: "\u{1FAD3}", category: 3, name: "flatbread", version: "13.0" }, { emoji: "\u{1F968}", category: 3, name: "pretzel", version: "5.0" }, { emoji: "\u{1F96F}", category: 3, name: "bagel", version: "11.0" }, { emoji: "\u{1F95E}", category: 3, name: "pancakes", version: "3.0" }, { emoji: "\u{1F9C7}", category: 3, name: "waffle", version: "12.0" }, { emoji: "\u{1F9C0}", category: 3, name: "cheese wedge", version: "1.0" }, { emoji: "\u{1F356}", category: 3, name: "meat on bone", version: "1.0" }, { emoji: "\u{1F357}", category: 3, name: "poultry leg", version: "1.0" }, { emoji: "\u{1F969}", category: 3, name: "cut of meat", version: "5.0" }, { emoji: "\u{1F953}", category: 3, name: "bacon", version: "3.0" }, { emoji: "\u{1F354}", category: 3, name: "hamburger", version: "1.0" }, { emoji: "\u{1F35F}", category: 3, name: "french fries", version: "1.0" }, { emoji: "\u{1F355}", category: 3, name: "pizza", version: "1.0" }, { emoji: "\u{1F32D}", category: 3, name: "hot dog", version: "1.0" }, { emoji: "\u{1F96A}", category: 3, name: "sandwich", version: "5.0" }, { emoji: "\u{1F32E}", category: 3, name: "taco", version: "1.0" }, { emoji: "\u{1F32F}", category: 3, name: "burrito", version: "1.0" }, { emoji: "\u{1FAD4}", category: 3, name: "tamale", version: "13.0" }, { emoji: "\u{1F959}", category: 3, name: "stuffed flatbread", version: "3.0" }, { emoji: "\u{1F9C6}", category: 3, name: "falafel", version: "12.0" }, { emoji: "\u{1F95A}", category: 3, name: "egg", version: "3.0" }, { emoji: "\u{1F373}", category: 3, name: "cooking", version: "1.0" }, { emoji: "\u{1F958}", category: 3, name: "shallow pan of food", version: "3.0" }, { emoji: "\u{1F372}", category: 3, name: "pot of food", version: "1.0" }, { emoji: "\u{1FAD5}", category: 3, name: "fondue", version: "13.0" }, { emoji: "\u{1F963}", category: 3, name: "bowl with spoon", version: "5.0" }, { emoji: "\u{1F957}", category: 3, name: "green salad", version: "3.0" }, { emoji: "\u{1F37F}", category: 3, name: "popcorn", version: "1.0" }, { emoji: "\u{1F9C8}", category: 3, name: "butter", version: "12.0" }, { emoji: "\u{1F9C2}", category: 3, name: "salt", version: "11.0" }, { emoji: "\u{1F96B}", category: 3, name: "canned food", version: "5.0" }, { emoji: "\u{1F371}", category: 3, name: "bento box", version: "1.0" }, { emoji: "\u{1F358}", category: 3, name: "rice cracker", version: "1.0" }, { emoji: "\u{1F359}", category: 3, name: "rice ball", version: "1.0" }, { emoji: "\u{1F35A}", category: 3, name: "cooked rice", version: "1.0" }, { emoji: "\u{1F35B}", category: 3, name: "curry rice", version: "1.0" }, { emoji: "\u{1F35C}", category: 3, name: "steaming bowl", version: "1.0" }, { emoji: "\u{1F35D}", category: 3, name: "spaghetti", version: "1.0" }, { emoji: "\u{1F360}", category: 3, name: "roasted sweet potato", version: "1.0" }, { emoji: "\u{1F362}", category: 3, name: "oden", version: "1.0" }, { emoji: "\u{1F363}", category: 3, name: "sushi", version: "1.0" }, { emoji: "\u{1F364}", category: 3, name: "fried shrimp", version: "1.0" }, { emoji: "\u{1F365}", category: 3, name: "fish cake with swirl", version: "1.0" }, { emoji: "\u{1F96E}", category: 3, name: "moon cake", version: "11.0" }, { emoji: "\u{1F361}", category: 3, name: "dango", version: "1.0" }, { emoji: "\u{1F95F}", category: 3, name: "dumpling", version: "5.0" }, { emoji: "\u{1F960}", category: 3, name: "fortune cookie", version: "5.0" }, { emoji: "\u{1F961}", category: 3, name: "takeout box", version: "5.0" }, { emoji: "\u{1F980}", category: 3, name: "crab", version: "1.0" }, { emoji: "\u{1F99E}", category: 3, name: "lobster", version: "11.0" }, { emoji: "\u{1F990}", category: 3, name: "shrimp", version: "3.0" }, { emoji: "\u{1F991}", category: 3, name: "squid", version: "3.0" }, { emoji: "\u{1F9AA}", category: 3, name: "oyster", version: "12.0" }, { emoji: "\u{1F366}", category: 3, name: "soft ice cream", version: "1.0" }, { emoji: "\u{1F367}", category: 3, name: "shaved ice", version: "1.0" }, { emoji: "\u{1F368}", category: 3, name: "ice cream", version: "1.0" }, { emoji: "\u{1F369}", category: 3, name: "doughnut", version: "1.0" }, { emoji: "\u{1F36A}", category: 3, name: "cookie", version: "1.0" }, { emoji: "\u{1F382}", category: 3, name: "birthday cake", version: "1.0" }, { emoji: "\u{1F370}", category: 3, name: "shortcake", version: "1.0" }, { emoji: "\u{1F9C1}", category: 3, name: "cupcake", version: "11.0" }, { emoji: "\u{1F967}", category: 3, name: "pie", version: "5.0" }, { emoji: "\u{1F36B}", category: 3, name: "chocolate bar", version: "1.0" }, { emoji: "\u{1F36C}", category: 3, name: "candy", version: "1.0" }, { emoji: "\u{1F36D}", category: 3, name: "lollipop", version: "1.0" }, { emoji: "\u{1F36E}", category: 3, name: "custard", version: "1.0" }, { emoji: "\u{1F36F}", category: 3, name: "honey pot", version: "1.0" }, { emoji: "\u{1F37C}", category: 3, name: "baby bottle", version: "1.0" }, { emoji: "\u{1F95B}", category: 3, name: "glass of milk", version: "3.0" }, { emoji: "\u2615", category: 3, name: "hot beverage", version: "1.0" }, { emoji: "\u{1FAD6}", category: 3, name: "teapot", version: "13.0" }, { emoji: "\u{1F375}", category: 3, name: "teacup without handle", version: "1.0" }, { emoji: "\u{1F376}", category: 3, name: "sake", version: "1.0" }, { emoji: "\u{1F37E}", category: 3, name: "bottle with popping cork", version: "1.0" }, { emoji: "\u{1F377}", category: 3, name: "wine glass", version: "1.0" }, { emoji: "\u{1F378}", category: 3, name: "cocktail glass", version: "1.0" }, { emoji: "\u{1F379}", category: 3, name: "tropical drink", version: "1.0" }, { emoji: "\u{1F37A}", category: 3, name: "beer mug", version: "1.0" }, { emoji: "\u{1F37B}", category: 3, name: "clinking beer mugs", version: "1.0" }, { emoji: "\u{1F942}", category: 3, name: "clinking glasses", version: "3.0" }, { emoji: "\u{1F943}", category: 3, name: "tumbler glass", version: "3.0" }, { emoji: "\u{1F964}", category: 3, name: "cup with straw", version: "5.0" }, { emoji: "\u{1F9CB}", category: 3, name: "bubble tea", version: "13.0" }, { emoji: "\u{1F9C3}", category: 3, name: "beverage box", version: "12.0" }, { emoji: "\u{1F9C9}", category: 3, name: "mate", version: "12.0" }, { emoji: "\u{1F9CA}", category: 3, name: "ice", version: "12.0" }, { emoji: "\u{1F962}", category: 3, name: "chopsticks", version: "5.0" }, { emoji: "\u{1F37D}\uFE0F", category: 3, name: "fork and knife with plate", version: "1.0" }, { emoji: "\u{1F374}", category: 3, name: "fork and knife", version: "1.0" }, { emoji: "\u{1F944}", category: 3, name: "spoon", version: "3.0" }, { emoji: "\u{1F52A}", category: 3, name: "kitchen knife", version: "1.0" }, { emoji: "\u{1F3FA}", category: 3, name: "amphora", version: "1.0" }, { emoji: "\u{1F30D}", category: 4, name: "globe showing Europe-Africa", version: "1.0" }, { emoji: "\u{1F30E}", category: 4, name: "globe showing Americas", version: "1.0" }, { emoji: "\u{1F30F}", category: 4, name: "globe showing Asia-Australia", version: "1.0" }, { emoji: "\u{1F310}", category: 4, name: "globe with meridians", version: "1.0" }, { emoji: "\u{1F5FA}\uFE0F", category: 4, name: "world map", version: "1.0" }, { emoji: "\u{1F5FE}", category: 4, name: "map of Japan", version: "1.0" }, { emoji: "\u{1F9ED}", category: 4, name: "compass", version: "11.0" }, { emoji: "\u{1F3D4}\uFE0F", category: 4, name: "snow-capped mountain", version: "1.0" }, { emoji: "\u26F0\uFE0F", category: 4, name: "mountain", version: "1.0" }, { emoji: "\u{1F30B}", category: 4, name: "volcano", version: "1.0" }, { emoji: "\u{1F5FB}", category: 4, name: "mount fuji", version: "1.0" }, { emoji: "\u{1F3D5}\uFE0F", category: 4, name: "camping", version: "1.0" }, { emoji: "\u{1F3D6}\uFE0F", category: 4, name: "beach with umbrella", version: "1.0" }, { emoji: "\u{1F3DC}\uFE0F", category: 4, name: "desert", version: "1.0" }, { emoji: "\u{1F3DD}\uFE0F", category: 4, name: "desert island", version: "1.0" }, { emoji: "\u{1F3DE}\uFE0F", category: 4, name: "national park", version: "1.0" }, { emoji: "\u{1F3DF}\uFE0F", category: 4, name: "stadium", version: "1.0" }, { emoji: "\u{1F3DB}\uFE0F", category: 4, name: "classical building", version: "1.0" }, { emoji: "\u{1F3D7}\uFE0F", category: 4, name: "building construction", version: "1.0" }, { emoji: "\u{1F9F1}", category: 4, name: "brick", version: "11.0" }, { emoji: "\u{1FAA8}", category: 4, name: "rock", version: "13.0" }, { emoji: "\u{1FAB5}", category: 4, name: "wood", version: "13.0" }, { emoji: "\u{1F6D6}", category: 4, name: "hut", version: "13.0" }, { emoji: "\u{1F3D8}\uFE0F", category: 4, name: "houses", version: "1.0" }, { emoji: "\u{1F3DA}\uFE0F", category: 4, name: "derelict house", version: "1.0" }, { emoji: "\u{1F3E0}", category: 4, name: "house", version: "1.0" }, { emoji: "\u{1F3E1}", category: 4, name: "house with garden", version: "1.0" }, { emoji: "\u{1F3E2}", category: 4, name: "office building", version: "1.0" }, { emoji: "\u{1F3E3}", category: 4, name: "Japanese post office", version: "1.0" }, { emoji: "\u{1F3E4}", category: 4, name: "post office", version: "1.0" }, { emoji: "\u{1F3E5}", category: 4, name: "hospital", version: "1.0" }, { emoji: "\u{1F3E6}", category: 4, name: "bank", version: "1.0" }, { emoji: "\u{1F3E8}", category: 4, name: "hotel", version: "1.0" }, { emoji: "\u{1F3E9}", category: 4, name: "love hotel", version: "1.0" }, { emoji: "\u{1F3EA}", category: 4, name: "convenience store", version: "1.0" }, { emoji: "\u{1F3EB}", category: 4, name: "school", version: "1.0" }, { emoji: "\u{1F3EC}", category: 4, name: "department store", version: "1.0" }, { emoji: "\u{1F3ED}", category: 4, name: "factory", version: "1.0" }, { emoji: "\u{1F3EF}", category: 4, name: "Japanese castle", version: "1.0" }, { emoji: "\u{1F3F0}", category: 4, name: "castle", version: "1.0" }, { emoji: "\u{1F492}", category: 4, name: "wedding", version: "1.0" }, { emoji: "\u{1F5FC}", category: 4, name: "Tokyo tower", version: "1.0" }, { emoji: "\u{1F5FD}", category: 4, name: "Statue of Liberty", version: "1.0" }, { emoji: "\u26EA", category: 4, name: "church", version: "1.0" }, { emoji: "\u{1F54C}", category: 4, name: "mosque", version: "1.0" }, { emoji: "\u{1F6D5}", category: 4, name: "hindu temple", version: "12.0" }, { emoji: "\u{1F54D}", category: 4, name: "synagogue", version: "1.0" }, { emoji: "\u26E9\uFE0F", category: 4, name: "shinto shrine", version: "1.0" }, { emoji: "\u{1F54B}", category: 4, name: "kaaba", version: "1.0" }, { emoji: "\u26F2", category: 4, name: "fountain", version: "1.0" }, { emoji: "\u26FA", category: 4, name: "tent", version: "1.0" }, { emoji: "\u{1F301}", category: 4, name: "foggy", version: "1.0" }, { emoji: "\u{1F303}", category: 4, name: "night with stars", version: "1.0" }, { emoji: "\u{1F3D9}\uFE0F", category: 4, name: "cityscape", version: "1.0" }, { emoji: "\u{1F304}", category: 4, name: "sunrise over mountains", version: "1.0" }, { emoji: "\u{1F305}", category: 4, name: "sunrise", version: "1.0" }, { emoji: "\u{1F306}", category: 4, name: "cityscape at dusk", version: "1.0" }, { emoji: "\u{1F307}", category: 4, name: "sunset", version: "1.0" }, { emoji: "\u{1F309}", category: 4, name: "bridge at night", version: "1.0" }, { emoji: "\u2668\uFE0F", category: 4, name: "hot springs", version: "1.0" }, { emoji: "\u{1F3A0}", category: 4, name: "carousel horse", version: "1.0" }, { emoji: "\u{1F3A1}", category: 4, name: "ferris wheel", version: "1.0" }, { emoji: "\u{1F3A2}", category: 4, name: "roller coaster", version: "1.0" }, { emoji: "\u{1F488}", category: 4, name: "barber pole", version: "1.0" }, { emoji: "\u{1F3AA}", category: 4, name: "circus tent", version: "1.0" }, { emoji: "\u{1F682}", category: 4, name: "locomotive", version: "1.0" }, { emoji: "\u{1F683}", category: 4, name: "railway car", version: "1.0" }, { emoji: "\u{1F684}", category: 4, name: "high-speed train", version: "1.0" }, { emoji: "\u{1F685}", category: 4, name: "bullet train", version: "1.0" }, { emoji: "\u{1F686}", category: 4, name: "train", version: "1.0" }, { emoji: "\u{1F687}", category: 4, name: "metro", version: "1.0" }, { emoji: "\u{1F688}", category: 4, name: "light rail", version: "1.0" }, { emoji: "\u{1F689}", category: 4, name: "station", version: "1.0" }, { emoji: "\u{1F68A}", category: 4, name: "tram", version: "1.0" }, { emoji: "\u{1F69D}", category: 4, name: "monorail", version: "1.0" }, { emoji: "\u{1F69E}", category: 4, name: "mountain railway", version: "1.0" }, { emoji: "\u{1F68B}", category: 4, name: "tram car", version: "1.0" }, { emoji: "\u{1F68C}", category: 4, name: "bus", version: "1.0" }, { emoji: "\u{1F68D}", category: 4, name: "oncoming bus", version: "1.0" }, { emoji: "\u{1F68E}", category: 4, name: "trolleybus", version: "1.0" }, { emoji: "\u{1F690}", category: 4, name: "minibus", version: "1.0" }, { emoji: "\u{1F691}", category: 4, name: "ambulance", version: "1.0" }, { emoji: "\u{1F692}", category: 4, name: "fire engine", version: "1.0" }, { emoji: "\u{1F693}", category: 4, name: "police car", version: "1.0" }, { emoji: "\u{1F694}", category: 4, name: "oncoming police car", version: "1.0" }, { emoji: "\u{1F695}", category: 4, name: "taxi", version: "1.0" }, { emoji: "\u{1F696}", category: 4, name: "oncoming taxi", version: "1.0" }, { emoji: "\u{1F697}", category: 4, name: "automobile", version: "1.0" }, { emoji: "\u{1F698}", category: 4, name: "oncoming automobile", version: "1.0" }, { emoji: "\u{1F699}", category: 4, name: "sport utility vehicle", version: "1.0" }, { emoji: "\u{1F6FB}", category: 4, name: "pickup truck", version: "13.0" }, { emoji: "\u{1F69A}", category: 4, name: "delivery truck", version: "1.0" }, { emoji: "\u{1F69B}", category: 4, name: "articulated lorry", version: "1.0" }, { emoji: "\u{1F69C}", category: 4, name: "tractor", version: "1.0" }, { emoji: "\u{1F3CE}\uFE0F", category: 4, name: "racing car", version: "1.0" }, { emoji: "\u{1F3CD}\uFE0F", category: 4, name: "motorcycle", version: "1.0" }, { emoji: "\u{1F6F5}", category: 4, name: "motor scooter", version: "3.0" }, { emoji: "\u{1F9BD}", category: 4, name: "manual wheelchair", version: "12.0" }, { emoji: "\u{1F9BC}", category: 4, name: "motorized wheelchair", version: "12.0" }, { emoji: "\u{1F6FA}", category: 4, name: "auto rickshaw", version: "12.0" }, { emoji: "\u{1F6B2}", category: 4, name: "bicycle", version: "1.0" }, { emoji: "\u{1F6F4}", category: 4, name: "kick scooter", version: "3.0" }, { emoji: "\u{1F6F9}", category: 4, name: "skateboard", version: "11.0" }, { emoji: "\u{1F6FC}", category: 4, name: "roller skate", version: "13.0" }, { emoji: "\u{1F68F}", category: 4, name: "bus stop", version: "1.0" }, { emoji: "\u{1F6E3}\uFE0F", category: 4, name: "motorway", version: "1.0" }, { emoji: "\u{1F6E4}\uFE0F", category: 4, name: "railway track", version: "1.0" }, { emoji: "\u{1F6E2}\uFE0F", category: 4, name: "oil drum", version: "1.0" }, { emoji: "\u26FD", category: 4, name: "fuel pump", version: "1.0" }, { emoji: "\u{1F6A8}", category: 4, name: "police car light", version: "1.0" }, { emoji: "\u{1F6A5}", category: 4, name: "horizontal traffic light", version: "1.0" }, { emoji: "\u{1F6A6}", category: 4, name: "vertical traffic light", version: "1.0" }, { emoji: "\u{1F6D1}", category: 4, name: "stop sign", version: "3.0" }, { emoji: "\u{1F6A7}", category: 4, name: "construction", version: "1.0" }, { emoji: "\u2693", category: 4, name: "anchor", version: "1.0" }, { emoji: "\u26F5", category: 4, name: "sailboat", version: "1.0" }, { emoji: "\u{1F6F6}", category: 4, name: "canoe", version: "3.0" }, { emoji: "\u{1F6A4}", category: 4, name: "speedboat", version: "1.0" }, { emoji: "\u{1F6F3}\uFE0F", category: 4, name: "passenger ship", version: "1.0" }, { emoji: "\u26F4\uFE0F", category: 4, name: "ferry", version: "1.0" }, { emoji: "\u{1F6E5}\uFE0F", category: 4, name: "motor boat", version: "1.0" }, { emoji: "\u{1F6A2}", category: 4, name: "ship", version: "1.0" }, { emoji: "\u2708\uFE0F", category: 4, name: "airplane", version: "1.0" }, { emoji: "\u{1F6E9}\uFE0F", category: 4, name: "small airplane", version: "1.0" }, { emoji: "\u{1F6EB}", category: 4, name: "airplane departure", version: "1.0" }, { emoji: "\u{1F6EC}", category: 4, name: "airplane arrival", version: "1.0" }, { emoji: "\u{1FA82}", category: 4, name: "parachute", version: "12.0" }, { emoji: "\u{1F4BA}", category: 4, name: "seat", version: "1.0" }, { emoji: "\u{1F681}", category: 4, name: "helicopter", version: "1.0" }, { emoji: "\u{1F69F}", category: 4, name: "suspension railway", version: "1.0" }, { emoji: "\u{1F6A0}", category: 4, name: "mountain cableway", version: "1.0" }, { emoji: "\u{1F6A1}", category: 4, name: "aerial tramway", version: "1.0" }, { emoji: "\u{1F6F0}\uFE0F", category: 4, name: "satellite", version: "1.0" }, { emoji: "\u{1F680}", category: 4, name: "rocket", version: "1.0" }, { emoji: "\u{1F6F8}", category: 4, name: "flying saucer", version: "5.0" }, { emoji: "\u{1F6CE}\uFE0F", category: 4, name: "bellhop bell", version: "1.0" }, { emoji: "\u{1F9F3}", category: 4, name: "luggage", version: "11.0" }, { emoji: "\u231B", category: 4, name: "hourglass done", version: "1.0" }, { emoji: "\u23F3", category: 4, name: "hourglass not done", version: "1.0" }, { emoji: "\u231A", category: 4, name: "watch", version: "1.0" }, { emoji: "\u23F0", category: 4, name: "alarm clock", version: "1.0" }, { emoji: "\u23F1\uFE0F", category: 4, name: "stopwatch", version: "1.0" }, { emoji: "\u23F2\uFE0F", category: 4, name: "timer clock", version: "1.0" }, { emoji: "\u{1F570}\uFE0F", category: 4, name: "mantelpiece clock", version: "1.0" }, { emoji: "\u{1F55B}", category: 4, name: "twelve o\u2019clock", version: "1.0" }, { emoji: "\u{1F567}", category: 4, name: "twelve-thirty", version: "1.0" }, { emoji: "\u{1F550}", category: 4, name: "one o\u2019clock", version: "1.0" }, { emoji: "\u{1F55C}", category: 4, name: "one-thirty", version: "1.0" }, { emoji: "\u{1F551}", category: 4, name: "two o\u2019clock", version: "1.0" }, { emoji: "\u{1F55D}", category: 4, name: "two-thirty", version: "1.0" }, { emoji: "\u{1F552}", category: 4, name: "three o\u2019clock", version: "1.0" }, { emoji: "\u{1F55E}", category: 4, name: "three-thirty", version: "1.0" }, { emoji: "\u{1F553}", category: 4, name: "four o\u2019clock", version: "1.0" }, { emoji: "\u{1F55F}", category: 4, name: "four-thirty", version: "1.0" }, { emoji: "\u{1F554}", category: 4, name: "five o\u2019clock", version: "1.0" }, { emoji: "\u{1F560}", category: 4, name: "five-thirty", version: "1.0" }, { emoji: "\u{1F555}", category: 4, name: "six o\u2019clock", version: "1.0" }, { emoji: "\u{1F561}", category: 4, name: "six-thirty", version: "1.0" }, { emoji: "\u{1F556}", category: 4, name: "seven o\u2019clock", version: "1.0" }, { emoji: "\u{1F562}", category: 4, name: "seven-thirty", version: "1.0" }, { emoji: "\u{1F557}", category: 4, name: "eight o\u2019clock", version: "1.0" }, { emoji: "\u{1F563}", category: 4, name: "eight-thirty", version: "1.0" }, { emoji: "\u{1F558}", category: 4, name: "nine o\u2019clock", version: "1.0" }, { emoji: "\u{1F564}", category: 4, name: "nine-thirty", version: "1.0" }, { emoji: "\u{1F559}", category: 4, name: "ten o\u2019clock", version: "1.0" }, { emoji: "\u{1F565}", category: 4, name: "ten-thirty", version: "1.0" }, { emoji: "\u{1F55A}", category: 4, name: "eleven o\u2019clock", version: "1.0" }, { emoji: "\u{1F566}", category: 4, name: "eleven-thirty", version: "1.0" }, { emoji: "\u{1F311}", category: 4, name: "new moon", version: "1.0" }, { emoji: "\u{1F312}", category: 4, name: "waxing crescent moon", version: "1.0" }, { emoji: "\u{1F313}", category: 4, name: "first quarter moon", version: "1.0" }, { emoji: "\u{1F314}", category: 4, name: "waxing gibbous moon", version: "1.0" }, { emoji: "\u{1F315}", category: 4, name: "full moon", version: "1.0" }, { emoji: "\u{1F316}", category: 4, name: "waning gibbous moon", version: "1.0" }, { emoji: "\u{1F317}", category: 4, name: "last quarter moon", version: "1.0" }, { emoji: "\u{1F318}", category: 4, name: "waning crescent moon", version: "1.0" }, { emoji: "\u{1F319}", category: 4, name: "crescent moon", version: "1.0" }, { emoji: "\u{1F31A}", category: 4, name: "new moon face", version: "1.0" }, { emoji: "\u{1F31B}", category: 4, name: "first quarter moon face", version: "1.0" }, { emoji: "\u{1F31C}", category: 4, name: "last quarter moon face", version: "1.0" }, { emoji: "\u{1F321}\uFE0F", category: 4, name: "thermometer", version: "1.0" }, { emoji: "\u2600\uFE0F", category: 4, name: "sun", version: "1.0" }, { emoji: "\u{1F31D}", category: 4, name: "full moon face", version: "1.0" }, { emoji: "\u{1F31E}", category: 4, name: "sun with face", version: "1.0" }, { emoji: "\u{1FA90}", category: 4, name: "ringed planet", version: "12.0" }, { emoji: "\u2B50", category: 4, name: "star", version: "1.0" }, { emoji: "\u{1F31F}", category: 4, name: "glowing star", version: "1.0" }, { emoji: "\u{1F320}", category: 4, name: "shooting star", version: "1.0" }, { emoji: "\u{1F30C}", category: 4, name: "milky way", version: "1.0" }, { emoji: "\u2601\uFE0F", category: 4, name: "cloud", version: "1.0" }, { emoji: "\u26C5", category: 4, name: "sun behind cloud", version: "1.0" }, { emoji: "\u26C8\uFE0F", category: 4, name: "cloud with lightning and rain", version: "1.0" }, { emoji: "\u{1F324}\uFE0F", category: 4, name: "sun behind small cloud", version: "1.0" }, { emoji: "\u{1F325}\uFE0F", category: 4, name: "sun behind large cloud", version: "1.0" }, { emoji: "\u{1F326}\uFE0F", category: 4, name: "sun behind rain cloud", version: "1.0" }, { emoji: "\u{1F327}\uFE0F", category: 4, name: "cloud with rain", version: "1.0" }, { emoji: "\u{1F328}\uFE0F", category: 4, name: "cloud with snow", version: "1.0" }, { emoji: "\u{1F329}\uFE0F", category: 4, name: "cloud with lightning", version: "1.0" }, { emoji: "\u{1F32A}\uFE0F", category: 4, name: "tornado", version: "1.0" }, { emoji: "\u{1F32B}\uFE0F", category: 4, name: "fog", version: "1.0" }, { emoji: "\u{1F32C}\uFE0F", category: 4, name: "wind face", version: "1.0" }, { emoji: "\u{1F300}", category: 4, name: "cyclone", version: "1.0" }, { emoji: "\u{1F308}", category: 4, name: "rainbow", version: "1.0" }, { emoji: "\u{1F302}", category: 4, name: "closed umbrella", version: "1.0" }, { emoji: "\u2602\uFE0F", category: 4, name: "umbrella", version: "1.0" }, { emoji: "\u2614", category: 4, name: "umbrella with rain drops", version: "1.0" }, { emoji: "\u26F1\uFE0F", category: 4, name: "umbrella on ground", version: "1.0" }, { emoji: "\u26A1", category: 4, name: "high voltage", version: "1.0" }, { emoji: "\u2744\uFE0F", category: 4, name: "snowflake", version: "1.0" }, { emoji: "\u2603\uFE0F", category: 4, name: "snowman", version: "1.0" }, { emoji: "\u26C4", category: 4, name: "snowman without snow", version: "1.0" }, { emoji: "\u2604\uFE0F", category: 4, name: "comet", version: "1.0" }, { emoji: "\u{1F525}", category: 4, name: "fire", version: "1.0" }, { emoji: "\u{1F4A7}", category: 4, name: "droplet", version: "1.0" }, { emoji: "\u{1F30A}", category: 4, name: "water wave", version: "1.0" }, { emoji: "\u{1F383}", category: 5, name: "jack-o-lantern", version: "1.0" }, { emoji: "\u{1F384}", category: 5, name: "Christmas tree", version: "1.0" }, { emoji: "\u{1F386}", category: 5, name: "fireworks", version: "1.0" }, { emoji: "\u{1F387}", category: 5, name: "sparkler", version: "1.0" }, { emoji: "\u{1F9E8}", category: 5, name: "firecracker", version: "11.0" }, { emoji: "\u2728", category: 5, name: "sparkles", version: "1.0" }, { emoji: "\u{1F388}", category: 5, name: "balloon", version: "1.0" }, { emoji: "\u{1F389}", category: 5, name: "party popper", version: "1.0" }, { emoji: "\u{1F38A}", category: 5, name: "confetti ball", version: "1.0" }, { emoji: "\u{1F38B}", category: 5, name: "tanabata tree", version: "1.0" }, { emoji: "\u{1F38D}", category: 5, name: "pine decoration", version: "1.0" }, { emoji: "\u{1F38E}", category: 5, name: "Japanese dolls", version: "1.0" }, { emoji: "\u{1F38F}", category: 5, name: "carp streamer", version: "1.0" }, { emoji: "\u{1F390}", category: 5, name: "wind chime", version: "1.0" }, { emoji: "\u{1F391}", category: 5, name: "moon viewing ceremony", version: "1.0" }, { emoji: "\u{1F9E7}", category: 5, name: "red envelope", version: "11.0" }, { emoji: "\u{1F380}", category: 5, name: "ribbon", version: "1.0" }, { emoji: "\u{1F381}", category: 5, name: "wrapped gift", version: "1.0" }, { emoji: "\u{1F397}\uFE0F", category: 5, name: "reminder ribbon", version: "1.0" }, { emoji: "\u{1F39F}\uFE0F", category: 5, name: "admission tickets", version: "1.0" }, { emoji: "\u{1F3AB}", category: 5, name: "ticket", version: "1.0" }, { emoji: "\u{1F396}\uFE0F", category: 5, name: "military medal", version: "1.0" }, { emoji: "\u{1F3C6}", category: 5, name: "trophy", version: "1.0" }, { emoji: "\u{1F3C5}", category: 5, name: "sports medal", version: "1.0" }, { emoji: "\u{1F947}", category: 5, name: "1st place medal", version: "3.0" }, { emoji: "\u{1F948}", category: 5, name: "2nd place medal", version: "3.0" }, { emoji: "\u{1F949}", category: 5, name: "3rd place medal", version: "3.0" }, { emoji: "\u26BD", category: 5, name: "soccer ball", version: "1.0" }, { emoji: "\u26BE", category: 5, name: "baseball", version: "1.0" }, { emoji: "\u{1F94E}", category: 5, name: "softball", version: "11.0" }, { emoji: "\u{1F3C0}", category: 5, name: "basketball", version: "1.0" }, { emoji: "\u{1F3D0}", category: 5, name: "volleyball", version: "1.0" }, { emoji: "\u{1F3C8}", category: 5, name: "american football", version: "1.0" }, { emoji: "\u{1F3C9}", category: 5, name: "rugby football", version: "1.0" }, { emoji: "\u{1F3BE}", category: 5, name: "tennis", version: "1.0" }, { emoji: "\u{1F94F}", category: 5, name: "flying disc", version: "11.0" }, { emoji: "\u{1F3B3}", category: 5, name: "bowling", version: "1.0" }, { emoji: "\u{1F3CF}", category: 5, name: "cricket game", version: "1.0" }, { emoji: "\u{1F3D1}", category: 5, name: "field hockey", version: "1.0" }, { emoji: "\u{1F3D2}", category: 5, name: "ice hockey", version: "1.0" }, { emoji: "\u{1F94D}", category: 5, name: "lacrosse", version: "11.0" }, { emoji: "\u{1F3D3}", category: 5, name: "ping pong", version: "1.0" }, { emoji: "\u{1F3F8}", category: 5, name: "badminton", version: "1.0" }, { emoji: "\u{1F94A}", category: 5, name: "boxing glove", version: "3.0" }, { emoji: "\u{1F94B}", category: 5, name: "martial arts uniform", version: "3.0" }, { emoji: "\u{1F945}", category: 5, name: "goal net", version: "3.0" }, { emoji: "\u26F3", category: 5, name: "flag in hole", version: "1.0" }, { emoji: "\u26F8\uFE0F", category: 5, name: "ice skate", version: "1.0" }, { emoji: "\u{1F3A3}", category: 5, name: "fishing pole", version: "1.0" }, { emoji: "\u{1F93F}", category: 5, name: "diving mask", version: "12.0" }, { emoji: "\u{1F3BD}", category: 5, name: "running shirt", version: "1.0" }, { emoji: "\u{1F3BF}", category: 5, name: "skis", version: "1.0" }, { emoji: "\u{1F6F7}", category: 5, name: "sled", version: "5.0" }, { emoji: "\u{1F94C}", category: 5, name: "curling stone", version: "5.0" }, { emoji: "\u{1F3AF}", category: 5, name: "direct hit", version: "1.0" }, { emoji: "\u{1FA80}", category: 5, name: "yo-yo", version: "12.0" }, { emoji: "\u{1FA81}", category: 5, name: "kite", version: "12.0" }, { emoji: "\u{1F3B1}", category: 5, name: "pool 8 ball", version: "1.0" }, { emoji: "\u{1F52E}", category: 5, name: "crystal ball", version: "1.0" }, { emoji: "\u{1FA84}", category: 5, name: "magic wand", version: "13.0" }, { emoji: "\u{1F9FF}", category: 5, name: "nazar amulet", version: "11.0" }, { emoji: "\u{1F3AE}", category: 5, name: "video game", version: "1.0" }, { emoji: "\u{1F579}\uFE0F", category: 5, name: "joystick", version: "1.0" }, { emoji: "\u{1F3B0}", category: 5, name: "slot machine", version: "1.0" }, { emoji: "\u{1F3B2}", category: 5, name: "game die", version: "1.0" }, { emoji: "\u{1F9E9}", category: 5, name: "puzzle piece", version: "11.0" }, { emoji: "\u{1F9F8}", category: 5, name: "teddy bear", version: "11.0" }, { emoji: "\u{1FA85}", category: 5, name: "pi\xF1ata", version: "13.0" }, { emoji: "\u{1FA86}", category: 5, name: "nesting dolls", version: "13.0" }, { emoji: "\u2660\uFE0F", category: 5, name: "spade suit", version: "1.0" }, { emoji: "\u2665\uFE0F", category: 5, name: "heart suit", version: "1.0" }, { emoji: "\u2666\uFE0F", category: 5, name: "diamond suit", version: "1.0" }, { emoji: "\u2663\uFE0F", category: 5, name: "club suit", version: "1.0" }, { emoji: "\u265F\uFE0F", category: 5, name: "chess pawn", version: "11.0" }, { emoji: "\u{1F0CF}", category: 5, name: "joker", version: "1.0" }, { emoji: "\u{1F004}", category: 5, name: "mahjong red dragon", version: "1.0" }, { emoji: "\u{1F3B4}", category: 5, name: "flower playing cards", version: "1.0" }, { emoji: "\u{1F3AD}", category: 5, name: "performing arts", version: "1.0" }, { emoji: "\u{1F5BC}\uFE0F", category: 5, name: "framed picture", version: "1.0" }, { emoji: "\u{1F3A8}", category: 5, name: "artist palette", version: "1.0" }, { emoji: "\u{1F9F5}", category: 5, name: "thread", version: "11.0" }, { emoji: "\u{1FAA1}", category: 5, name: "sewing needle", version: "13.0" }, { emoji: "\u{1F9F6}", category: 5, name: "yarn", version: "11.0" }, { emoji: "\u{1FAA2}", category: 5, name: "knot", version: "13.0" }, { emoji: "\u{1F453}", category: 6, name: "glasses", version: "1.0" }, { emoji: "\u{1F576}\uFE0F", category: 6, name: "sunglasses", version: "1.0" }, { emoji: "\u{1F97D}", category: 6, name: "goggles", version: "11.0" }, { emoji: "\u{1F97C}", category: 6, name: "lab coat", version: "11.0" }, { emoji: "\u{1F9BA}", category: 6, name: "safety vest", version: "12.0" }, { emoji: "\u{1F454}", category: 6, name: "necktie", version: "1.0" }, { emoji: "\u{1F455}", category: 6, name: "t-shirt", version: "1.0" }, { emoji: "\u{1F456}", category: 6, name: "jeans", version: "1.0" }, { emoji: "\u{1F9E3}", category: 6, name: "scarf", version: "5.0" }, { emoji: "\u{1F9E4}", category: 6, name: "gloves", version: "5.0" }, { emoji: "\u{1F9E5}", category: 6, name: "coat", version: "5.0" }, { emoji: "\u{1F9E6}", category: 6, name: "socks", version: "5.0" }, { emoji: "\u{1F457}", category: 6, name: "dress", version: "1.0" }, { emoji: "\u{1F458}", category: 6, name: "kimono", version: "1.0" }, { emoji: "\u{1F97B}", category: 6, name: "sari", version: "12.0" }, { emoji: "\u{1FA71}", category: 6, name: "one-piece swimsuit", version: "12.0" }, { emoji: "\u{1FA72}", category: 6, name: "briefs", version: "12.0" }, { emoji: "\u{1FA73}", category: 6, name: "shorts", version: "12.0" }, { emoji: "\u{1F459}", category: 6, name: "bikini", version: "1.0" }, { emoji: "\u{1F45A}", category: 6, name: "woman\u2019s clothes", version: "1.0" }, { emoji: "\u{1F45B}", category: 6, name: "purse", version: "1.0" }, { emoji: "\u{1F45C}", category: 6, name: "handbag", version: "1.0" }, { emoji: "\u{1F45D}", category: 6, name: "clutch bag", version: "1.0" }, { emoji: "\u{1F6CD}\uFE0F", category: 6, name: "shopping bags", version: "1.0" }, { emoji: "\u{1F392}", category: 6, name: "backpack", version: "1.0" }, { emoji: "\u{1FA74}", category: 6, name: "thong sandal", version: "13.0" }, { emoji: "\u{1F45E}", category: 6, name: "man\u2019s shoe", version: "1.0" }, { emoji: "\u{1F45F}", category: 6, name: "running shoe", version: "1.0" }, { emoji: "\u{1F97E}", category: 6, name: "hiking boot", version: "11.0" }, { emoji: "\u{1F97F}", category: 6, name: "flat shoe", version: "11.0" }, { emoji: "\u{1F460}", category: 6, name: "high-heeled shoe", version: "1.0" }, { emoji: "\u{1F461}", category: 6, name: "woman\u2019s sandal", version: "1.0" }, { emoji: "\u{1FA70}", category: 6, name: "ballet shoes", version: "12.0" }, { emoji: "\u{1F462}", category: 6, name: "woman\u2019s boot", version: "1.0" }, { emoji: "\u{1F451}", category: 6, name: "crown", version: "1.0" }, { emoji: "\u{1F452}", category: 6, name: "woman\u2019s hat", version: "1.0" }, { emoji: "\u{1F3A9}", category: 6, name: "top hat", version: "1.0" }, { emoji: "\u{1F393}", category: 6, name: "graduation cap", version: "1.0" }, { emoji: "\u{1F9E2}", category: 6, name: "billed cap", version: "5.0" }, { emoji: "\u{1FA96}", category: 6, name: "military helmet", version: "13.0" }, { emoji: "\u26D1\uFE0F", category: 6, name: "rescue worker\u2019s helmet", version: "1.0" }, { emoji: "\u{1F4FF}", category: 6, name: "prayer beads", version: "1.0" }, { emoji: "\u{1F484}", category: 6, name: "lipstick", version: "1.0" }, { emoji: "\u{1F48D}", category: 6, name: "ring", version: "1.0" }, { emoji: "\u{1F48E}", category: 6, name: "gem stone", version: "1.0" }, { emoji: "\u{1F507}", category: 6, name: "muted speaker", version: "1.0" }, { emoji: "\u{1F508}", category: 6, name: "speaker low volume", version: "1.0" }, { emoji: "\u{1F509}", category: 6, name: "speaker medium volume", version: "1.0" }, { emoji: "\u{1F50A}", category: 6, name: "speaker high volume", version: "1.0" }, { emoji: "\u{1F4E2}", category: 6, name: "loudspeaker", version: "1.0" }, { emoji: "\u{1F4E3}", category: 6, name: "megaphone", version: "1.0" }, { emoji: "\u{1F4EF}", category: 6, name: "postal horn", version: "1.0" }, { emoji: "\u{1F514}", category: 6, name: "bell", version: "1.0" }, { emoji: "\u{1F515}", category: 6, name: "bell with slash", version: "1.0" }, { emoji: "\u{1F3BC}", category: 6, name: "musical score", version: "1.0" }, { emoji: "\u{1F3B5}", category: 6, name: "musical note", version: "1.0" }, { emoji: "\u{1F3B6}", category: 6, name: "musical notes", version: "1.0" }, { emoji: "\u{1F399}\uFE0F", category: 6, name: "studio microphone", version: "1.0" }, { emoji: "\u{1F39A}\uFE0F", category: 6, name: "level slider", version: "1.0" }, { emoji: "\u{1F39B}\uFE0F", category: 6, name: "control knobs", version: "1.0" }, { emoji: "\u{1F3A4}", category: 6, name: "microphone", version: "1.0" }, { emoji: "\u{1F3A7}", category: 6, name: "headphone", version: "1.0" }, { emoji: "\u{1F4FB}", category: 6, name: "radio", version: "1.0" }, { emoji: "\u{1F3B7}", category: 6, name: "saxophone", version: "1.0" }, { emoji: "\u{1FA97}", category: 6, name: "accordion", version: "13.0" }, { emoji: "\u{1F3B8}", category: 6, name: "guitar", version: "1.0" }, { emoji: "\u{1F3B9}", category: 6, name: "musical keyboard", version: "1.0" }, { emoji: "\u{1F3BA}", category: 6, name: "trumpet", version: "1.0" }, { emoji: "\u{1F3BB}", category: 6, name: "violin", version: "1.0" }, { emoji: "\u{1FA95}", category: 6, name: "banjo", version: "12.0" }, { emoji: "\u{1F941}", category: 6, name: "drum", version: "3.0" }, { emoji: "\u{1FA98}", category: 6, name: "long drum", version: "13.0" }, { emoji: "\u{1F4F1}", category: 6, name: "mobile phone", version: "1.0" }, { emoji: "\u{1F4F2}", category: 6, name: "mobile phone with arrow", version: "1.0" }, { emoji: "\u260E\uFE0F", category: 6, name: "telephone", version: "1.0" }, { emoji: "\u{1F4DE}", category: 6, name: "telephone receiver", version: "1.0" }, { emoji: "\u{1F4DF}", category: 6, name: "pager", version: "1.0" }, { emoji: "\u{1F4E0}", category: 6, name: "fax machine", version: "1.0" }, { emoji: "\u{1F50B}", category: 6, name: "battery", version: "1.0" }, { emoji: "\u{1F50C}", category: 6, name: "electric plug", version: "1.0" }, { emoji: "\u{1F4BB}", category: 6, name: "laptop", version: "1.0" }, { emoji: "\u{1F5A5}\uFE0F", category: 6, name: "desktop computer", version: "1.0" }, { emoji: "\u{1F5A8}\uFE0F", category: 6, name: "printer", version: "1.0" }, { emoji: "\u2328\uFE0F", category: 6, name: "keyboard", version: "1.0" }, { emoji: "\u{1F5B1}\uFE0F", category: 6, name: "computer mouse", version: "1.0" }, { emoji: "\u{1F5B2}\uFE0F", category: 6, name: "trackball", version: "1.0" }, { emoji: "\u{1F4BD}", category: 6, name: "computer disk", version: "1.0" }, { emoji: "\u{1F4BE}", category: 6, name: "floppy disk", version: "1.0" }, { emoji: "\u{1F4BF}", category: 6, name: "optical disk", version: "1.0" }, { emoji: "\u{1F4C0}", category: 6, name: "dvd", version: "1.0" }, { emoji: "\u{1F9EE}", category: 6, name: "abacus", version: "11.0" }, { emoji: "\u{1F3A5}", category: 6, name: "movie camera", version: "1.0" }, { emoji: "\u{1F39E}\uFE0F", category: 6, name: "film frames", version: "1.0" }, { emoji: "\u{1F4FD}\uFE0F", category: 6, name: "film projector", version: "1.0" }, { emoji: "\u{1F3AC}", category: 6, name: "clapper board", version: "1.0" }, { emoji: "\u{1F4FA}", category: 6, name: "television", version: "1.0" }, { emoji: "\u{1F4F7}", category: 6, name: "camera", version: "1.0" }, { emoji: "\u{1F4F8}", category: 6, name: "camera with flash", version: "1.0" }, { emoji: "\u{1F4F9}", category: 6, name: "video camera", version: "1.0" }, { emoji: "\u{1F4FC}", category: 6, name: "videocassette", version: "1.0" }, { emoji: "\u{1F50D}", category: 6, name: "magnifying glass tilted left", version: "1.0" }, { emoji: "\u{1F50E}", category: 6, name: "magnifying glass tilted right", version: "1.0" }, { emoji: "\u{1F56F}\uFE0F", category: 6, name: "candle", version: "1.0" }, { emoji: "\u{1F4A1}", category: 6, name: "light bulb", version: "1.0" }, { emoji: "\u{1F526}", category: 6, name: "flashlight", version: "1.0" }, { emoji: "\u{1F3EE}", category: 6, name: "red paper lantern", version: "1.0" }, { emoji: "\u{1FA94}", category: 6, name: "diya lamp", version: "12.0" }, { emoji: "\u{1F4D4}", category: 6, name: "notebook with decorative cover", version: "1.0" }, { emoji: "\u{1F4D5}", category: 6, name: "closed book", version: "1.0" }, { emoji: "\u{1F4D6}", category: 6, name: "open book", version: "1.0" }, { emoji: "\u{1F4D7}", category: 6, name: "green book", version: "1.0" }, { emoji: "\u{1F4D8}", category: 6, name: "blue book", version: "1.0" }, { emoji: "\u{1F4D9}", category: 6, name: "orange book", version: "1.0" }, { emoji: "\u{1F4DA}", category: 6, name: "books", version: "1.0" }, { emoji: "\u{1F4D3}", category: 6, name: "notebook", version: "1.0" }, { emoji: "\u{1F4D2}", category: 6, name: "ledger", version: "1.0" }, { emoji: "\u{1F4C3}", category: 6, name: "page with curl", version: "1.0" }, { emoji: "\u{1F4DC}", category: 6, name: "scroll", version: "1.0" }, { emoji: "\u{1F4C4}", category: 6, name: "page facing up", version: "1.0" }, { emoji: "\u{1F4F0}", category: 6, name: "newspaper", version: "1.0" }, { emoji: "\u{1F5DE}\uFE0F", category: 6, name: "rolled-up newspaper", version: "1.0" }, { emoji: "\u{1F4D1}", category: 6, name: "bookmark tabs", version: "1.0" }, { emoji: "\u{1F516}", category: 6, name: "bookmark", version: "1.0" }, { emoji: "\u{1F3F7}\uFE0F", category: 6, name: "label", version: "1.0" }, { emoji: "\u{1F4B0}", category: 6, name: "money bag", version: "1.0" }, { emoji: "\u{1FA99}", category: 6, name: "coin", version: "13.0" }, { emoji: "\u{1F4B4}", category: 6, name: "yen banknote", version: "1.0" }, { emoji: "\u{1F4B5}", category: 6, name: "dollar banknote", version: "1.0" }, { emoji: "\u{1F4B6}", category: 6, name: "euro banknote", version: "1.0" }, { emoji: "\u{1F4B7}", category: 6, name: "pound banknote", version: "1.0" }, { emoji: "\u{1F4B8}", category: 6, name: "money with wings", version: "1.0" }, { emoji: "\u{1F4B3}", category: 6, name: "credit card", version: "1.0" }, { emoji: "\u{1F9FE}", category: 6, name: "receipt", version: "11.0" }, { emoji: "\u{1F4B9}", category: 6, name: "chart increasing with yen", version: "1.0" }, { emoji: "\u2709\uFE0F", category: 6, name: "envelope", version: "1.0" }, { emoji: "\u{1F4E7}", category: 6, name: "e-mail", version: "1.0" }, { emoji: "\u{1F4E8}", category: 6, name: "incoming envelope", version: "1.0" }, { emoji: "\u{1F4E9}", category: 6, name: "envelope with arrow", version: "1.0" }, { emoji: "\u{1F4E4}", category: 6, name: "outbox tray", version: "1.0" }, { emoji: "\u{1F4E5}", category: 6, name: "inbox tray", version: "1.0" }, { emoji: "\u{1F4E6}", category: 6, name: "package", version: "1.0" }, { emoji: "\u{1F4EB}", category: 6, name: "closed mailbox with raised flag", version: "1.0" }, { emoji: "\u{1F4EA}", category: 6, name: "closed mailbox with lowered flag", version: "1.0" }, { emoji: "\u{1F4EC}", category: 6, name: "open mailbox with raised flag", version: "1.0" }, { emoji: "\u{1F4ED}", category: 6, name: "open mailbox with lowered flag", version: "1.0" }, { emoji: "\u{1F4EE}", category: 6, name: "postbox", version: "1.0" }, { emoji: "\u{1F5F3}\uFE0F", category: 6, name: "ballot box with ballot", version: "1.0" }, { emoji: "\u270F\uFE0F", category: 6, name: "pencil", version: "1.0" }, { emoji: "\u2712\uFE0F", category: 6, name: "black nib", version: "1.0" }, { emoji: "\u{1F58B}\uFE0F", category: 6, name: "fountain pen", version: "1.0" }, { emoji: "\u{1F58A}\uFE0F", category: 6, name: "pen", version: "1.0" }, { emoji: "\u{1F58C}\uFE0F", category: 6, name: "paintbrush", version: "1.0" }, { emoji: "\u{1F58D}\uFE0F", category: 6, name: "crayon", version: "1.0" }, { emoji: "\u{1F4DD}", category: 6, name: "memo", version: "1.0" }, { emoji: "\u{1F4BC}", category: 6, name: "briefcase", version: "1.0" }, { emoji: "\u{1F4C1}", category: 6, name: "file folder", version: "1.0" }, { emoji: "\u{1F4C2}", category: 6, name: "open file folder", version: "1.0" }, { emoji: "\u{1F5C2}\uFE0F", category: 6, name: "card index dividers", version: "1.0" }, { emoji: "\u{1F4C5}", category: 6, name: "calendar", version: "1.0" }, { emoji: "\u{1F4C6}", category: 6, name: "tear-off calendar", version: "1.0" }, { emoji: "\u{1F5D2}\uFE0F", category: 6, name: "spiral notepad", version: "1.0" }, { emoji: "\u{1F5D3}\uFE0F", category: 6, name: "spiral calendar", version: "1.0" }, { emoji: "\u{1F4C7}", category: 6, name: "card index", version: "1.0" }, { emoji: "\u{1F4C8}", category: 6, name: "chart increasing", version: "1.0" }, { emoji: "\u{1F4C9}", category: 6, name: "chart decreasing", version: "1.0" }, { emoji: "\u{1F4CA}", category: 6, name: "bar chart", version: "1.0" }, { emoji: "\u{1F4CB}", category: 6, name: "clipboard", version: "1.0" }, { emoji: "\u{1F4CC}", category: 6, name: "pushpin", version: "1.0" }, { emoji: "\u{1F4CD}", category: 6, name: "round pushpin", version: "1.0" }, { emoji: "\u{1F4CE}", category: 6, name: "paperclip", version: "1.0" }, { emoji: "\u{1F587}\uFE0F", category: 6, name: "linked paperclips", version: "1.0" }, { emoji: "\u{1F4CF}", category: 6, name: "straight ruler", version: "1.0" }, { emoji: "\u{1F4D0}", category: 6, name: "triangular ruler", version: "1.0" }, { emoji: "\u2702\uFE0F", category: 6, name: "scissors", version: "1.0" }, { emoji: "\u{1F5C3}\uFE0F", category: 6, name: "card file box", version: "1.0" }, { emoji: "\u{1F5C4}\uFE0F", category: 6, name: "file cabinet", version: "1.0" }, { emoji: "\u{1F5D1}\uFE0F", category: 6, name: "wastebasket", version: "1.0" }, { emoji: "\u{1F512}", category: 6, name: "locked", version: "1.0" }, { emoji: "\u{1F513}", category: 6, name: "unlocked", version: "1.0" }, { emoji: "\u{1F50F}", category: 6, name: "locked with pen", version: "1.0" }, { emoji: "\u{1F510}", category: 6, name: "locked with key", version: "1.0" }, { emoji: "\u{1F511}", category: 6, name: "key", version: "1.0" }, { emoji: "\u{1F5DD}\uFE0F", category: 6, name: "old key", version: "1.0" }, { emoji: "\u{1F528}", category: 6, name: "hammer", version: "1.0" }, { emoji: "\u{1FA93}", category: 6, name: "axe", version: "12.0" }, { emoji: "\u26CF\uFE0F", category: 6, name: "pick", version: "1.0" }, { emoji: "\u2692\uFE0F", category: 6, name: "hammer and pick", version: "1.0" }, { emoji: "\u{1F6E0}\uFE0F", category: 6, name: "hammer and wrench", version: "1.0" }, { emoji: "\u{1F5E1}\uFE0F", category: 6, name: "dagger", version: "1.0" }, { emoji: "\u2694\uFE0F", category: 6, name: "crossed swords", version: "1.0" }, { emoji: "\u{1F52B}", category: 6, name: "pistol", version: "1.0" }, { emoji: "\u{1FA83}", category: 6, name: "boomerang", version: "13.0" }, { emoji: "\u{1F3F9}", category: 6, name: "bow and arrow", version: "1.0" }, { emoji: "\u{1F6E1}\uFE0F", category: 6, name: "shield", version: "1.0" }, { emoji: "\u{1FA9A}", category: 6, name: "carpentry saw", version: "13.0" }, { emoji: "\u{1F527}", category: 6, name: "wrench", version: "1.0" }, { emoji: "\u{1FA9B}", category: 6, name: "screwdriver", version: "13.0" }, { emoji: "\u{1F529}", category: 6, name: "nut and bolt", version: "1.0" }, { emoji: "\u2699\uFE0F", category: 6, name: "gear", version: "1.0" }, { emoji: "\u{1F5DC}\uFE0F", category: 6, name: "clamp", version: "1.0" }, { emoji: "\u2696\uFE0F", category: 6, name: "balance scale", version: "1.0" }, { emoji: "\u{1F9AF}", category: 6, name: "white cane", version: "12.0" }, { emoji: "\u{1F517}", category: 6, name: "link", version: "1.0" }, { emoji: "\u26D3\uFE0F", category: 6, name: "chains", version: "1.0" }, { emoji: "\u{1FA9D}", category: 6, name: "hook", version: "13.0" }, { emoji: "\u{1F9F0}", category: 6, name: "toolbox", version: "11.0" }, { emoji: "\u{1F9F2}", category: 6, name: "magnet", version: "11.0" }, { emoji: "\u{1FA9C}", category: 6, name: "ladder", version: "13.0" }, { emoji: "\u2697\uFE0F", category: 6, name: "alembic", version: "1.0" }, { emoji: "\u{1F9EA}", category: 6, name: "test tube", version: "11.0" }, { emoji: "\u{1F9EB}", category: 6, name: "petri dish", version: "11.0" }, { emoji: "\u{1F9EC}", category: 6, name: "dna", version: "11.0" }, { emoji: "\u{1F52C}", category: 6, name: "microscope", version: "1.0" }, { emoji: "\u{1F52D}", category: 6, name: "telescope", version: "1.0" }, { emoji: "\u{1F4E1}", category: 6, name: "satellite antenna", version: "1.0" }, { emoji: "\u{1F489}", category: 6, name: "syringe", version: "1.0" }, { emoji: "\u{1FA78}", category: 6, name: "drop of blood", version: "12.0" }, { emoji: "\u{1F48A}", category: 6, name: "pill", version: "1.0" }, { emoji: "\u{1FA79}", category: 6, name: "adhesive bandage", version: "12.0" }, { emoji: "\u{1FA7A}", category: 6, name: "stethoscope", version: "12.0" }, { emoji: "\u{1F6AA}", category: 6, name: "door", version: "1.0" }, { emoji: "\u{1F6D7}", category: 6, name: "elevator", version: "13.0" }, { emoji: "\u{1FA9E}", category: 6, name: "mirror", version: "13.0" }, { emoji: "\u{1FA9F}", category: 6, name: "window", version: "13.0" }, { emoji: "\u{1F6CF}\uFE0F", category: 6, name: "bed", version: "1.0" }, { emoji: "\u{1F6CB}\uFE0F", category: 6, name: "couch and lamp", version: "1.0" }, { emoji: "\u{1FA91}", category: 6, name: "chair", version: "12.0" }, { emoji: "\u{1F6BD}", category: 6, name: "toilet", version: "1.0" }, { emoji: "\u{1FAA0}", category: 6, name: "plunger", version: "13.0" }, { emoji: "\u{1F6BF}", category: 6, name: "shower", version: "1.0" }, { emoji: "\u{1F6C1}", category: 6, name: "bathtub", version: "1.0" }, { emoji: "\u{1FAA4}", category: 6, name: "mouse trap", version: "13.0" }, { emoji: "\u{1FA92}", category: 6, name: "razor", version: "12.0" }, { emoji: "\u{1F9F4}", category: 6, name: "lotion bottle", version: "11.0" }, { emoji: "\u{1F9F7}", category: 6, name: "safety pin", version: "11.0" }, { emoji: "\u{1F9F9}", category: 6, name: "broom", version: "11.0" }, { emoji: "\u{1F9FA}", category: 6, name: "basket", version: "11.0" }, { emoji: "\u{1F9FB}", category: 6, name: "roll of paper", version: "11.0" }, { emoji: "\u{1FAA3}", category: 6, name: "bucket", version: "13.0" }, { emoji: "\u{1F9FC}", category: 6, name: "soap", version: "11.0" }, { emoji: "\u{1FAA5}", category: 6, name: "toothbrush", version: "13.0" }, { emoji: "\u{1F9FD}", category: 6, name: "sponge", version: "11.0" }, { emoji: "\u{1F9EF}", category: 6, name: "fire extinguisher", version: "11.0" }, { emoji: "\u{1F6D2}", category: 6, name: "shopping cart", version: "3.0" }, { emoji: "\u{1F6AC}", category: 6, name: "cigarette", version: "1.0" }, { emoji: "\u26B0\uFE0F", category: 6, name: "coffin", version: "1.0" }, { emoji: "\u{1FAA6}", category: 6, name: "headstone", version: "13.0" }, { emoji: "\u26B1\uFE0F", category: 6, name: "funeral urn", version: "1.0" }, { emoji: "\u{1F5FF}", category: 6, name: "moai", version: "1.0" }, { emoji: "\u{1FAA7}", category: 6, name: "placard", version: "13.0" }, { emoji: "\u{1F3E7}", category: 7, name: "ATM sign", version: "1.0" }, { emoji: "\u{1F6AE}", category: 7, name: "litter in bin sign", version: "1.0" }, { emoji: "\u{1F6B0}", category: 7, name: "potable water", version: "1.0" }, { emoji: "\u267F", category: 7, name: "wheelchair symbol", version: "1.0" }, { emoji: "\u{1F6B9}", category: 7, name: "men\u2019s room", version: "1.0" }, { emoji: "\u{1F6BA}", category: 7, name: "women\u2019s room", version: "1.0" }, { emoji: "\u{1F6BB}", category: 7, name: "restroom", version: "1.0" }, { emoji: "\u{1F6BC}", category: 7, name: "baby symbol", version: "1.0" }, { emoji: "\u{1F6BE}", category: 7, name: "water closet", version: "1.0" }, { emoji: "\u{1F6C2}", category: 7, name: "passport control", version: "1.0" }, { emoji: "\u{1F6C3}", category: 7, name: "customs", version: "1.0" }, { emoji: "\u{1F6C4}", category: 7, name: "baggage claim", version: "1.0" }, { emoji: "\u{1F6C5}", category: 7, name: "left luggage", version: "1.0" }, { emoji: "\u26A0\uFE0F", category: 7, name: "warning", version: "1.0" }, { emoji: "\u{1F6B8}", category: 7, name: "children crossing", version: "1.0" }, { emoji: "\u26D4", category: 7, name: "no entry", version: "1.0" }, { emoji: "\u{1F6AB}", category: 7, name: "prohibited", version: "1.0" }, { emoji: "\u{1F6B3}", category: 7, name: "no bicycles", version: "1.0" }, { emoji: "\u{1F6AD}", category: 7, name: "no smoking", version: "1.0" }, { emoji: "\u{1F6AF}", category: 7, name: "no littering", version: "1.0" }, { emoji: "\u{1F6B1}", category: 7, name: "non-potable water", version: "1.0" }, { emoji: "\u{1F6B7}", category: 7, name: "no pedestrians", version: "1.0" }, { emoji: "\u{1F4F5}", category: 7, name: "no mobile phones", version: "1.0" }, { emoji: "\u{1F51E}", category: 7, name: "no one under eighteen", version: "1.0" }, { emoji: "\u2622\uFE0F", category: 7, name: "radioactive", version: "1.0" }, { emoji: "\u2623\uFE0F", category: 7, name: "biohazard", version: "1.0" }, { emoji: "\u2B06\uFE0F", category: 7, name: "up arrow", version: "1.0" }, { emoji: "\u2197\uFE0F", category: 7, name: "up-right arrow", version: "1.0" }, { emoji: "\u27A1\uFE0F", category: 7, name: "right arrow", version: "1.0" }, { emoji: "\u2198\uFE0F", category: 7, name: "down-right arrow", version: "1.0" }, { emoji: "\u2B07\uFE0F", category: 7, name: "down arrow", version: "1.0" }, { emoji: "\u2199\uFE0F", category: 7, name: "down-left arrow", version: "1.0" }, { emoji: "\u2B05\uFE0F", category: 7, name: "left arrow", version: "1.0" }, { emoji: "\u2196\uFE0F", category: 7, name: "up-left arrow", version: "1.0" }, { emoji: "\u2195\uFE0F", category: 7, name: "up-down arrow", version: "1.0" }, { emoji: "\u2194\uFE0F", category: 7, name: "left-right arrow", version: "1.0" }, { emoji: "\u21A9\uFE0F", category: 7, name: "right arrow curving left", version: "1.0" }, { emoji: "\u21AA\uFE0F", category: 7, name: "left arrow curving right", version: "1.0" }, { emoji: "\u2934\uFE0F", category: 7, name: "right arrow curving up", version: "1.0" }, { emoji: "\u2935\uFE0F", category: 7, name: "right arrow curving down", version: "1.0" }, { emoji: "\u{1F503}", category: 7, name: "clockwise vertical arrows", version: "1.0" }, { emoji: "\u{1F504}", category: 7, name: "counterclockwise arrows button", version: "1.0" }, { emoji: "\u{1F519}", category: 7, name: "BACK arrow", version: "1.0" }, { emoji: "\u{1F51A}", category: 7, name: "END arrow", version: "1.0" }, { emoji: "\u{1F51B}", category: 7, name: "ON! arrow", version: "1.0" }, { emoji: "\u{1F51C}", category: 7, name: "SOON arrow", version: "1.0" }, { emoji: "\u{1F51D}", category: 7, name: "TOP arrow", version: "1.0" }, { emoji: "\u{1F6D0}", category: 7, name: "place of worship", version: "1.0" }, { emoji: "\u269B\uFE0F", category: 7, name: "atom symbol", version: "1.0" }, { emoji: "\u{1F549}\uFE0F", category: 7, name: "om", version: "1.0" }, { emoji: "\u2721\uFE0F", category: 7, name: "star of David", version: "1.0" }, { emoji: "\u2638\uFE0F", category: 7, name: "wheel of dharma", version: "1.0" }, { emoji: "\u262F\uFE0F", category: 7, name: "yin yang", version: "1.0" }, { emoji: "\u271D\uFE0F", category: 7, name: "latin cross", version: "1.0" }, { emoji: "\u2626\uFE0F", category: 7, name: "orthodox cross", version: "1.0" }, { emoji: "\u262A\uFE0F", category: 7, name: "star and crescent", version: "1.0" }, { emoji: "\u262E\uFE0F", category: 7, name: "peace symbol", version: "1.0" }, { emoji: "\u{1F54E}", category: 7, name: "menorah", version: "1.0" }, { emoji: "\u{1F52F}", category: 7, name: "dotted six-pointed star", version: "1.0" }, { emoji: "\u2648", category: 7, name: "Aries", version: "1.0" }, { emoji: "\u2649", category: 7, name: "Taurus", version: "1.0" }, { emoji: "\u264A", category: 7, name: "Gemini", version: "1.0" }, { emoji: "\u264B", category: 7, name: "Cancer", version: "1.0" }, { emoji: "\u264C", category: 7, name: "Leo", version: "1.0" }, { emoji: "\u264D", category: 7, name: "Virgo", version: "1.0" }, { emoji: "\u264E", category: 7, name: "Libra", version: "1.0" }, { emoji: "\u264F", category: 7, name: "Scorpio", version: "1.0" }, { emoji: "\u2650", category: 7, name: "Sagittarius", version: "1.0" }, { emoji: "\u2651", category: 7, name: "Capricorn", version: "1.0" }, { emoji: "\u2652", category: 7, name: "Aquarius", version: "1.0" }, { emoji: "\u2653", category: 7, name: "Pisces", version: "1.0" }, { emoji: "\u26CE", category: 7, name: "Ophiuchus", version: "1.0" }, { emoji: "\u{1F500}", category: 7, name: "shuffle tracks button", version: "1.0" }, { emoji: "\u{1F501}", category: 7, name: "repeat button", version: "1.0" }, { emoji: "\u{1F502}", category: 7, name: "repeat single button", version: "1.0" }, { emoji: "\u25B6\uFE0F", category: 7, name: "play button", version: "1.0" }, { emoji: "\u23E9", category: 7, name: "fast-forward button", version: "1.0" }, { emoji: "\u23ED\uFE0F", category: 7, name: "next track button", version: "1.0" }, { emoji: "\u23EF\uFE0F", category: 7, name: "play or pause button", version: "1.0" }, { emoji: "\u25C0\uFE0F", category: 7, name: "reverse button", version: "1.0" }, { emoji: "\u23EA", category: 7, name: "fast reverse button", version: "1.0" }, { emoji: "\u23EE\uFE0F", category: 7, name: "last track button", version: "1.0" }, { emoji: "\u{1F53C}", category: 7, name: "upwards button", version: "1.0" }, { emoji: "\u23EB", category: 7, name: "fast up button", version: "1.0" }, { emoji: "\u{1F53D}", category: 7, name: "downwards button", version: "1.0" }, { emoji: "\u23EC", category: 7, name: "fast down button", version: "1.0" }, { emoji: "\u23F8\uFE0F", category: 7, name: "pause button", version: "1.0" }, { emoji: "\u23F9\uFE0F", category: 7, name: "stop button", version: "1.0" }, { emoji: "\u23FA\uFE0F", category: 7, name: "record button", version: "1.0" }, { emoji: "\u23CF\uFE0F", category: 7, name: "eject button", version: "1.0" }, { emoji: "\u{1F3A6}", category: 7, name: "cinema", version: "1.0" }, { emoji: "\u{1F505}", category: 7, name: "dim button", version: "1.0" }, { emoji: "\u{1F506}", category: 7, name: "bright button", version: "1.0" }, { emoji: "\u{1F4F6}", category: 7, name: "antenna bars", version: "1.0" }, { emoji: "\u{1F4F3}", category: 7, name: "vibration mode", version: "1.0" }, { emoji: "\u{1F4F4}", category: 7, name: "mobile phone off", version: "1.0" }, { emoji: "\u2640\uFE0F", category: 7, name: "female sign", version: "4.0" }, { emoji: "\u2642\uFE0F", category: 7, name: "male sign", version: "4.0" }, { emoji: "\u26A7\uFE0F", category: 7, name: "transgender symbol", version: "13.0" }, { emoji: "\u2716\uFE0F", category: 7, name: "multiply", version: "1.0" }, { emoji: "\u2795", category: 7, name: "plus", version: "1.0" }, { emoji: "\u2796", category: 7, name: "minus", version: "1.0" }, { emoji: "\u2797", category: 7, name: "divide", version: "1.0" }, { emoji: "\u267E\uFE0F", category: 7, name: "infinity", version: "11.0" }, { emoji: "\u203C\uFE0F", category: 7, name: "double exclamation mark", version: "1.0" }, { emoji: "\u2049\uFE0F", category: 7, name: "exclamation question mark", version: "1.0" }, { emoji: "\u2753", category: 7, name: "question mark", version: "1.0" }, { emoji: "\u2754", category: 7, name: "white question mark", version: "1.0" }, { emoji: "\u2755", category: 7, name: "white exclamation mark", version: "1.0" }, { emoji: "\u2757", category: 7, name: "exclamation mark", version: "1.0" }, { emoji: "\u3030\uFE0F", category: 7, name: "wavy dash", version: "1.0" }, { emoji: "\u{1F4B1}", category: 7, name: "currency exchange", version: "1.0" }, { emoji: "\u{1F4B2}", category: 7, name: "heavy dollar sign", version: "1.0" }, { emoji: "\u2695\uFE0F", category: 7, name: "medical symbol", version: "4.0" }, { emoji: "\u267B\uFE0F", category: 7, name: "recycling symbol", version: "1.0" }, { emoji: "\u269C\uFE0F", category: 7, name: "fleur-de-lis", version: "1.0" }, { emoji: "\u{1F531}", category: 7, name: "trident emblem", version: "1.0" }, { emoji: "\u{1F4DB}", category: 7, name: "name badge", version: "1.0" }, { emoji: "\u{1F530}", category: 7, name: "Japanese symbol for beginner", version: "1.0" }, { emoji: "\u2B55", category: 7, name: "hollow red circle", version: "1.0" }, { emoji: "\u2705", category: 7, name: "check mark button", version: "1.0" }, { emoji: "\u2611\uFE0F", category: 7, name: "check box with check", version: "1.0" }, { emoji: "\u2714\uFE0F", category: 7, name: "check mark", version: "1.0" }, { emoji: "\u274C", category: 7, name: "cross mark", version: "1.0" }, { emoji: "\u274E", category: 7, name: "cross mark button", version: "1.0" }, { emoji: "\u27B0", category: 7, name: "curly loop", version: "1.0" }, { emoji: "\u27BF", category: 7, name: "double curly loop", version: "1.0" }, { emoji: "\u303D\uFE0F", category: 7, name: "part alternation mark", version: "1.0" }, { emoji: "\u2733\uFE0F", category: 7, name: "eight-spoked asterisk", version: "1.0" }, { emoji: "\u2734\uFE0F", category: 7, name: "eight-pointed star", version: "1.0" }, { emoji: "\u2747\uFE0F", category: 7, name: "sparkle", version: "1.0" }, { emoji: "\xA9\uFE0F", category: 7, name: "copyright", version: "1.0" }, { emoji: "\xAE\uFE0F", category: 7, name: "registered", version: "1.0" }, { emoji: "\u2122\uFE0F", category: 7, name: "trade mark", version: "1.0" }, { emoji: "#\uFE0F\u20E3", category: 7, name: "keycap: #", version: "1.0" }, { emoji: "*\uFE0F\u20E3", category: 7, name: "keycap: *", version: "2.0" }, { emoji: "0\uFE0F\u20E3", category: 7, name: "keycap: 0", version: "1.0" }, { emoji: "1\uFE0F\u20E3", category: 7, name: "keycap: 1", version: "1.0" }, { emoji: "2\uFE0F\u20E3", category: 7, name: "keycap: 2", version: "1.0" }, { emoji: "3\uFE0F\u20E3", category: 7, name: "keycap: 3", version: "1.0" }, { emoji: "4\uFE0F\u20E3", category: 7, name: "keycap: 4", version: "1.0" }, { emoji: "5\uFE0F\u20E3", category: 7, name: "keycap: 5", version: "1.0" }, { emoji: "6\uFE0F\u20E3", category: 7, name: "keycap: 6", version: "1.0" }, { emoji: "7\uFE0F\u20E3", category: 7, name: "keycap: 7", version: "1.0" }, { emoji: "8\uFE0F\u20E3", category: 7, name: "keycap: 8", version: "1.0" }, { emoji: "9\uFE0F\u20E3", category: 7, name: "keycap: 9", version: "1.0" }, { emoji: "\u{1F51F}", category: 7, name: "keycap: 10", version: "1.0" }, { emoji: "\u{1F520}", category: 7, name: "input latin uppercase", version: "1.0" }, { emoji: "\u{1F521}", category: 7, name: "input latin lowercase", version: "1.0" }, { emoji: "\u{1F522}", category: 7, name: "input numbers", version: "1.0" }, { emoji: "\u{1F523}", category: 7, name: "input symbols", version: "1.0" }, { emoji: "\u{1F524}", category: 7, name: "input latin letters", version: "1.0" }, { emoji: "\u{1F170}\uFE0F", category: 7, name: "A button (blood type)", version: "1.0" }, { emoji: "\u{1F18E}", category: 7, name: "AB button (blood type)", version: "1.0" }, { emoji: "\u{1F171}\uFE0F", category: 7, name: "B button (blood type)", version: "1.0" }, { emoji: "\u{1F191}", category: 7, name: "CL button", version: "1.0" }, { emoji: "\u{1F192}", category: 7, name: "COOL button", version: "1.0" }, { emoji: "\u{1F193}", category: 7, name: "FREE button", version: "1.0" }, { emoji: "\u2139\uFE0F", category: 7, name: "information", version: "1.0" }, { emoji: "\u{1F194}", category: 7, name: "ID button", version: "1.0" }, { emoji: "\u24C2\uFE0F", category: 7, name: "circled M", version: "1.0" }, { emoji: "\u{1F195}", category: 7, name: "NEW button", version: "1.0" }, { emoji: "\u{1F196}", category: 7, name: "NG button", version: "1.0" }, { emoji: "\u{1F17E}\uFE0F", category: 7, name: "O button (blood type)", version: "1.0" }, { emoji: "\u{1F197}", category: 7, name: "OK button", version: "1.0" }, { emoji: "\u{1F17F}\uFE0F", category: 7, name: "P button", version: "1.0" }, { emoji: "\u{1F198}", category: 7, name: "SOS button", version: "1.0" }, { emoji: "\u{1F199}", category: 7, name: "UP! button", version: "1.0" }, { emoji: "\u{1F19A}", category: 7, name: "VS button", version: "1.0" }, { emoji: "\u{1F201}", category: 7, name: "Japanese \u201Chere\u201D button", version: "1.0" }, { emoji: "\u{1F202}\uFE0F", category: 7, name: "Japanese \u201Cservice charge\u201D button", version: "1.0" }, { emoji: "\u{1F237}\uFE0F", category: 7, name: "Japanese \u201Cmonthly amount\u201D button", version: "1.0" }, { emoji: "\u{1F236}", category: 7, name: "Japanese \u201Cnot free of charge\u201D button", version: "1.0" }, { emoji: "\u{1F22F}", category: 7, name: "Japanese \u201Creserved\u201D button", version: "1.0" }, { emoji: "\u{1F250}", category: 7, name: "Japanese \u201Cbargain\u201D button", version: "1.0" }, { emoji: "\u{1F239}", category: 7, name: "Japanese \u201Cdiscount\u201D button", version: "1.0" }, { emoji: "\u{1F21A}", category: 7, name: "Japanese \u201Cfree of charge\u201D button", version: "1.0" }, { emoji: "\u{1F232}", category: 7, name: "Japanese \u201Cprohibited\u201D button", version: "1.0" }, { emoji: "\u{1F251}", category: 7, name: "Japanese \u201Cacceptable\u201D button", version: "1.0" }, { emoji: "\u{1F238}", category: 7, name: "Japanese \u201Capplication\u201D button", version: "1.0" }, { emoji: "\u{1F234}", category: 7, name: "Japanese \u201Cpassing grade\u201D button", version: "1.0" }, { emoji: "\u{1F233}", category: 7, name: "Japanese \u201Cvacancy\u201D button", version: "1.0" }, { emoji: "\u3297\uFE0F", category: 7, name: "Japanese \u201Ccongratulations\u201D button", version: "1.0" }, { emoji: "\u3299\uFE0F", category: 7, name: "Japanese \u201Csecret\u201D button", version: "1.0" }, { emoji: "\u{1F23A}", category: 7, name: "Japanese \u201Copen for business\u201D button", version: "1.0" }, { emoji: "\u{1F235}", category: 7, name: "Japanese \u201Cno vacancy\u201D button", version: "1.0" }, { emoji: "\u{1F534}", category: 7, name: "red circle", version: "1.0" }, { emoji: "\u{1F7E0}", category: 7, name: "orange circle", version: "12.0" }, { emoji: "\u{1F7E1}", category: 7, name: "yellow circle", version: "12.0" }, { emoji: "\u{1F7E2}", category: 7, name: "green circle", version: "12.0" }, { emoji: "\u{1F535}", category: 7, name: "blue circle", version: "1.0" }, { emoji: "\u{1F7E3}", category: 7, name: "purple circle", version: "12.0" }, { emoji: "\u{1F7E4}", category: 7, name: "brown circle", version: "12.0" }, { emoji: "\u26AB", category: 7, name: "black circle", version: "1.0" }, { emoji: "\u26AA", category: 7, name: "white circle", version: "1.0" }, { emoji: "\u{1F7E5}", category: 7, name: "red square", version: "12.0" }, { emoji: "\u{1F7E7}", category: 7, name: "orange square", version: "12.0" }, { emoji: "\u{1F7E8}", category: 7, name: "yellow square", version: "12.0" }, { emoji: "\u{1F7E9}", category: 7, name: "green square", version: "12.0" }, { emoji: "\u{1F7E6}", category: 7, name: "blue square", version: "12.0" }, { emoji: "\u{1F7EA}", category: 7, name: "purple square", version: "12.0" }, { emoji: "\u{1F7EB}", category: 7, name: "brown square", version: "12.0" }, { emoji: "\u2B1B", category: 7, name: "black large square", version: "1.0" }, { emoji: "\u2B1C", category: 7, name: "white large square", version: "1.0" }, { emoji: "\u25FC\uFE0F", category: 7, name: "black medium square", version: "1.0" }, { emoji: "\u25FB\uFE0F", category: 7, name: "white medium square", version: "1.0" }, { emoji: "\u25FE", category: 7, name: "black medium-small square", version: "1.0" }, { emoji: "\u25FD", category: 7, name: "white medium-small square", version: "1.0" }, { emoji: "\u25AA\uFE0F", category: 7, name: "black small square", version: "1.0" }, { emoji: "\u25AB\uFE0F", category: 7, name: "white small square", version: "1.0" }, { emoji: "\u{1F536}", category: 7, name: "large orange diamond", version: "1.0" }, { emoji: "\u{1F537}", category: 7, name: "large blue diamond", version: "1.0" }, { emoji: "\u{1F538}", category: 7, name: "small orange diamond", version: "1.0" }, { emoji: "\u{1F539}", category: 7, name: "small blue diamond", version: "1.0" }, { emoji: "\u{1F53A}", category: 7, name: "red triangle pointed up", version: "1.0" }, { emoji: "\u{1F53B}", category: 7, name: "red triangle pointed down", version: "1.0" }, { emoji: "\u{1F4A0}", category: 7, name: "diamond with a dot", version: "1.0" }, { emoji: "\u{1F518}", category: 7, name: "radio button", version: "1.0" }, { emoji: "\u{1F533}", category: 7, name: "white square button", version: "1.0" }, { emoji: "\u{1F532}", category: 7, name: "black square button", version: "1.0" }, { emoji: "\u{1F3C1}", category: 8, name: "chequered flag", version: "1.0" }, { emoji: "\u{1F6A9}", category: 8, name: "triangular flag", version: "1.0" }, { emoji: "\u{1F38C}", category: 8, name: "crossed flags", version: "1.0" }, { emoji: "\u{1F3F4}", category: 8, name: "black flag", version: "1.0" }, { emoji: "\u{1F3F3}\uFE0F", category: 8, name: "white flag", version: "1.0" }, { emoji: "\u{1F3F3}\uFE0F\u200D\u{1F308}", category: 8, name: "rainbow flag", version: "4.0" }, { emoji: "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F", category: 8, name: "transgender flag", version: "13.0" }, { emoji: "\u{1F3F4}\u200D\u2620\uFE0F", category: 8, name: "pirate flag", version: "11.0" }, { emoji: "\u{1F1E6}\u{1F1E8}", category: 8, name: "flag: Ascension Island", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1E9}", category: 8, name: "flag: Andorra", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1EA}", category: 8, name: "flag: United Arab Emirates", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1EB}", category: 8, name: "flag: Afghanistan", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1EC}", category: 8, name: "flag: Antigua & Barbuda", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1EE}", category: 8, name: "flag: Anguilla", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F1}", category: 8, name: "flag: Albania", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F2}", category: 8, name: "flag: Armenia", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F4}", category: 8, name: "flag: Angola", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F6}", category: 8, name: "flag: Antarctica", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F7}", category: 8, name: "flag: Argentina", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F8}", category: 8, name: "flag: American Samoa", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1F9}", category: 8, name: "flag: Austria", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1FA}", category: 8, name: "flag: Australia", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1FC}", category: 8, name: "flag: Aruba", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1FD}", category: 8, name: "flag: \xC5land Islands", version: "2.0" }, { emoji: "\u{1F1E6}\u{1F1FF}", category: 8, name: "flag: Azerbaijan", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1E6}", category: 8, name: "flag: Bosnia & Herzegovina", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1E7}", category: 8, name: "flag: Barbados", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1E9}", category: 8, name: "flag: Bangladesh", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1EA}", category: 8, name: "flag: Belgium", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1EB}", category: 8, name: "flag: Burkina Faso", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1EC}", category: 8, name: "flag: Bulgaria", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1ED}", category: 8, name: "flag: Bahrain", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1EE}", category: 8, name: "flag: Burundi", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1EF}", category: 8, name: "flag: Benin", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F1}", category: 8, name: "flag: St. Barth\xE9lemy", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F2}", category: 8, name: "flag: Bermuda", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F3}", category: 8, name: "flag: Brunei", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F4}", category: 8, name: "flag: Bolivia", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F6}", category: 8, name: "flag: Caribbean Netherlands", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F7}", category: 8, name: "flag: Brazil", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F8}", category: 8, name: "flag: Bahamas", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1F9}", category: 8, name: "flag: Bhutan", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1FB}", category: 8, name: "flag: Bouvet Island", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1FC}", category: 8, name: "flag: Botswana", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1FE}", category: 8, name: "flag: Belarus", version: "2.0" }, { emoji: "\u{1F1E7}\u{1F1FF}", category: 8, name: "flag: Belize", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1E6}", category: 8, name: "flag: Canada", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1E8}", category: 8, name: "flag: Cocos (Keeling) Islands", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1E9}", category: 8, name: "flag: Congo - Kinshasa", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1EB}", category: 8, name: "flag: Central African Republic", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1EC}", category: 8, name: "flag: Congo - Brazzaville", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1ED}", category: 8, name: "flag: Switzerland", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1EE}", category: 8, name: "flag: C\xF4te d\u2019Ivoire", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1F0}", category: 8, name: "flag: Cook Islands", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1F1}", category: 8, name: "flag: Chile", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1F2}", category: 8, name: "flag: Cameroon", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1F3}", category: 8, name: "flag: China", version: "1.0" }, { emoji: "\u{1F1E8}\u{1F1F4}", category: 8, name: "flag: Colombia", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1F5}", category: 8, name: "flag: Clipperton Island", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1F7}", category: 8, name: "flag: Costa Rica", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1FA}", category: 8, name: "flag: Cuba", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1FB}", category: 8, name: "flag: Cape Verde", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1FC}", category: 8, name: "flag: Cura\xE7ao", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1FD}", category: 8, name: "flag: Christmas Island", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1FE}", category: 8, name: "flag: Cyprus", version: "2.0" }, { emoji: "\u{1F1E8}\u{1F1FF}", category: 8, name: "flag: Czechia", version: "2.0" }, { emoji: "\u{1F1E9}\u{1F1EA}", category: 8, name: "flag: Germany", version: "1.0" }, { emoji: "\u{1F1E9}\u{1F1EC}", category: 8, name: "flag: Diego Garcia", version: "2.0" }, { emoji: "\u{1F1E9}\u{1F1EF}", category: 8, name: "flag: Djibouti", version: "2.0" }, { emoji: "\u{1F1E9}\u{1F1F0}", category: 8, name: "flag: Denmark", version: "2.0" }, { emoji: "\u{1F1E9}\u{1F1F2}", category: 8, name: "flag: Dominica", version: "2.0" }, { emoji: "\u{1F1E9}\u{1F1F4}", category: 8, name: "flag: Dominican Republic", version: "2.0" }, { emoji: "\u{1F1E9}\u{1F1FF}", category: 8, name: "flag: Algeria", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1E6}", category: 8, name: "flag: Ceuta & Melilla", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1E8}", category: 8, name: "flag: Ecuador", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1EA}", category: 8, name: "flag: Estonia", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1EC}", category: 8, name: "flag: Egypt", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1ED}", category: 8, name: "flag: Western Sahara", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1F7}", category: 8, name: "flag: Eritrea", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1F8}", category: 8, name: "flag: Spain", version: "1.0" }, { emoji: "\u{1F1EA}\u{1F1F9}", category: 8, name: "flag: Ethiopia", version: "2.0" }, { emoji: "\u{1F1EA}\u{1F1FA}", category: 8, name: "flag: European Union", version: "2.0" }, { emoji: "\u{1F1EB}\u{1F1EE}", category: 8, name: "flag: Finland", version: "2.0" }, { emoji: "\u{1F1EB}\u{1F1EF}", category: 8, name: "flag: Fiji", version: "2.0" }, { emoji: "\u{1F1EB}\u{1F1F0}", category: 8, name: "flag: Falkland Islands", version: "2.0" }, { emoji: "\u{1F1EB}\u{1F1F2}", category: 8, name: "flag: Micronesia", version: "2.0" }, { emoji: "\u{1F1EB}\u{1F1F4}", category: 8, name: "flag: Faroe Islands", version: "2.0" }, { emoji: "\u{1F1EB}\u{1F1F7}", category: 8, name: "flag: France", version: "1.0" }, { emoji: "\u{1F1EC}\u{1F1E6}", category: 8, name: "flag: Gabon", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1E7}", category: 8, name: "flag: United Kingdom", version: "1.0" }, { emoji: "\u{1F1EC}\u{1F1E9}", category: 8, name: "flag: Grenada", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1EA}", category: 8, name: "flag: Georgia", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1EB}", category: 8, name: "flag: French Guiana", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1EC}", category: 8, name: "flag: Guernsey", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1ED}", category: 8, name: "flag: Ghana", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1EE}", category: 8, name: "flag: Gibraltar", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F1}", category: 8, name: "flag: Greenland", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F2}", category: 8, name: "flag: Gambia", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F3}", category: 8, name: "flag: Guinea", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F5}", category: 8, name: "flag: Guadeloupe", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F6}", category: 8, name: "flag: Equatorial Guinea", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F7}", category: 8, name: "flag: Greece", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F8}", category: 8, name: "flag: South Georgia & South Sandwich Islands", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1F9}", category: 8, name: "flag: Guatemala", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1FA}", category: 8, name: "flag: Guam", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1FC}", category: 8, name: "flag: Guinea-Bissau", version: "2.0" }, { emoji: "\u{1F1EC}\u{1F1FE}", category: 8, name: "flag: Guyana", version: "2.0" }, { emoji: "\u{1F1ED}\u{1F1F0}", category: 8, name: "flag: Hong Kong SAR China", version: "2.0" }, { emoji: "\u{1F1ED}\u{1F1F2}", category: 8, name: "flag: Heard & McDonald Islands", version: "2.0" }, { emoji: "\u{1F1ED}\u{1F1F3}", category: 8, name: "flag: Honduras", version: "2.0" }, { emoji: "\u{1F1ED}\u{1F1F7}", category: 8, name: "flag: Croatia", version: "2.0" }, { emoji: "\u{1F1ED}\u{1F1F9}", category: 8, name: "flag: Haiti", version: "2.0" }, { emoji: "\u{1F1ED}\u{1F1FA}", category: 8, name: "flag: Hungary", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1E8}", category: 8, name: "flag: Canary Islands", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1E9}", category: 8, name: "flag: Indonesia", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1EA}", category: 8, name: "flag: Ireland", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F1}", category: 8, name: "flag: Israel", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F2}", category: 8, name: "flag: Isle of Man", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F3}", category: 8, name: "flag: India", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F4}", category: 8, name: "flag: British Indian Ocean Territory", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F6}", category: 8, name: "flag: Iraq", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F7}", category: 8, name: "flag: Iran", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F8}", category: 8, name: "flag: Iceland", version: "2.0" }, { emoji: "\u{1F1EE}\u{1F1F9}", category: 8, name: "flag: Italy", version: "1.0" }, { emoji: "\u{1F1EF}\u{1F1EA}", category: 8, name: "flag: Jersey", version: "2.0" }, { emoji: "\u{1F1EF}\u{1F1F2}", category: 8, name: "flag: Jamaica", version: "2.0" }, { emoji: "\u{1F1EF}\u{1F1F4}", category: 8, name: "flag: Jordan", version: "2.0" }, { emoji: "\u{1F1EF}\u{1F1F5}", category: 8, name: "flag: Japan", version: "1.0" }, { emoji: "\u{1F1F0}\u{1F1EA}", category: 8, name: "flag: Kenya", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1EC}", category: 8, name: "flag: Kyrgyzstan", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1ED}", category: 8, name: "flag: Cambodia", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1EE}", category: 8, name: "flag: Kiribati", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1F2}", category: 8, name: "flag: Comoros", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1F3}", category: 8, name: "flag: St. Kitts & Nevis", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1F5}", category: 8, name: "flag: North Korea", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1F7}", category: 8, name: "flag: South Korea", version: "1.0" }, { emoji: "\u{1F1F0}\u{1F1FC}", category: 8, name: "flag: Kuwait", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1FE}", category: 8, name: "flag: Cayman Islands", version: "2.0" }, { emoji: "\u{1F1F0}\u{1F1FF}", category: 8, name: "flag: Kazakhstan", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1E6}", category: 8, name: "flag: Laos", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1E7}", category: 8, name: "flag: Lebanon", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1E8}", category: 8, name: "flag: St. Lucia", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1EE}", category: 8, name: "flag: Liechtenstein", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1F0}", category: 8, name: "flag: Sri Lanka", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1F7}", category: 8, name: "flag: Liberia", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1F8}", category: 8, name: "flag: Lesotho", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1F9}", category: 8, name: "flag: Lithuania", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1FA}", category: 8, name: "flag: Luxembourg", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1FB}", category: 8, name: "flag: Latvia", version: "2.0" }, { emoji: "\u{1F1F1}\u{1F1FE}", category: 8, name: "flag: Libya", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1E6}", category: 8, name: "flag: Morocco", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1E8}", category: 8, name: "flag: Monaco", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1E9}", category: 8, name: "flag: Moldova", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1EA}", category: 8, name: "flag: Montenegro", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1EB}", category: 8, name: "flag: St. Martin", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1EC}", category: 8, name: "flag: Madagascar", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1ED}", category: 8, name: "flag: Marshall Islands", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F0}", category: 8, name: "flag: North Macedonia", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F1}", category: 8, name: "flag: Mali", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F2}", category: 8, name: "flag: Myanmar (Burma)", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F3}", category: 8, name: "flag: Mongolia", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F4}", category: 8, name: "flag: Macao SAR China", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F5}", category: 8, name: "flag: Northern Mariana Islands", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F6}", category: 8, name: "flag: Martinique", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F7}", category: 8, name: "flag: Mauritania", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F8}", category: 8, name: "flag: Montserrat", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1F9}", category: 8, name: "flag: Malta", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1FA}", category: 8, name: "flag: Mauritius", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1FB}", category: 8, name: "flag: Maldives", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1FC}", category: 8, name: "flag: Malawi", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1FD}", category: 8, name: "flag: Mexico", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1FE}", category: 8, name: "flag: Malaysia", version: "2.0" }, { emoji: "\u{1F1F2}\u{1F1FF}", category: 8, name: "flag: Mozambique", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1E6}", category: 8, name: "flag: Namibia", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1E8}", category: 8, name: "flag: New Caledonia", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1EA}", category: 8, name: "flag: Niger", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1EB}", category: 8, name: "flag: Norfolk Island", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1EC}", category: 8, name: "flag: Nigeria", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1EE}", category: 8, name: "flag: Nicaragua", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1F1}", category: 8, name: "flag: Netherlands", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1F4}", category: 8, name: "flag: Norway", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1F5}", category: 8, name: "flag: Nepal", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1F7}", category: 8, name: "flag: Nauru", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1FA}", category: 8, name: "flag: Niue", version: "2.0" }, { emoji: "\u{1F1F3}\u{1F1FF}", category: 8, name: "flag: New Zealand", version: "2.0" }, { emoji: "\u{1F1F4}\u{1F1F2}", category: 8, name: "flag: Oman", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1E6}", category: 8, name: "flag: Panama", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1EA}", category: 8, name: "flag: Peru", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1EB}", category: 8, name: "flag: French Polynesia", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1EC}", category: 8, name: "flag: Papua New Guinea", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1ED}", category: 8, name: "flag: Philippines", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F0}", category: 8, name: "flag: Pakistan", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F1}", category: 8, name: "flag: Poland", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F2}", category: 8, name: "flag: St. Pierre & Miquelon", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F3}", category: 8, name: "flag: Pitcairn Islands", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F7}", category: 8, name: "flag: Puerto Rico", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F8}", category: 8, name: "flag: Palestinian Territories", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1F9}", category: 8, name: "flag: Portugal", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1FC}", category: 8, name: "flag: Palau", version: "2.0" }, { emoji: "\u{1F1F5}\u{1F1FE}", category: 8, name: "flag: Paraguay", version: "2.0" }, { emoji: "\u{1F1F6}\u{1F1E6}", category: 8, name: "flag: Qatar", version: "2.0" }, { emoji: "\u{1F1F7}\u{1F1EA}", category: 8, name: "flag: R\xE9union", version: "2.0" }, { emoji: "\u{1F1F7}\u{1F1F4}", category: 8, name: "flag: Romania", version: "2.0" }, { emoji: "\u{1F1F7}\u{1F1F8}", category: 8, name: "flag: Serbia", version: "2.0" }, { emoji: "\u{1F1F7}\u{1F1FA}", category: 8, name: "flag: Russia", version: "1.0" }, { emoji: "\u{1F1F7}\u{1F1FC}", category: 8, name: "flag: Rwanda", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1E6}", category: 8, name: "flag: Saudi Arabia", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1E7}", category: 8, name: "flag: Solomon Islands", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1E8}", category: 8, name: "flag: Seychelles", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1E9}", category: 8, name: "flag: Sudan", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1EA}", category: 8, name: "flag: Sweden", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1EC}", category: 8, name: "flag: Singapore", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1ED}", category: 8, name: "flag: St. Helena", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1EE}", category: 8, name: "flag: Slovenia", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1EF}", category: 8, name: "flag: Svalbard & Jan Mayen", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F0}", category: 8, name: "flag: Slovakia", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F1}", category: 8, name: "flag: Sierra Leone", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F2}", category: 8, name: "flag: San Marino", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F3}", category: 8, name: "flag: Senegal", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F4}", category: 8, name: "flag: Somalia", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F7}", category: 8, name: "flag: Suriname", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F8}", category: 8, name: "flag: South Sudan", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1F9}", category: 8, name: "flag: S\xE3o Tom\xE9 & Pr\xEDncipe", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1FB}", category: 8, name: "flag: El Salvador", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1FD}", category: 8, name: "flag: Sint Maarten", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1FE}", category: 8, name: "flag: Syria", version: "2.0" }, { emoji: "\u{1F1F8}\u{1F1FF}", category: 8, name: "flag: Eswatini", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1E6}", category: 8, name: "flag: Tristan da Cunha", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1E8}", category: 8, name: "flag: Turks & Caicos Islands", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1E9}", category: 8, name: "flag: Chad", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1EB}", category: 8, name: "flag: French Southern Territories", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1EC}", category: 8, name: "flag: Togo", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1ED}", category: 8, name: "flag: Thailand", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1EF}", category: 8, name: "flag: Tajikistan", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F0}", category: 8, name: "flag: Tokelau", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F1}", category: 8, name: "flag: Timor-Leste", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F2}", category: 8, name: "flag: Turkmenistan", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F3}", category: 8, name: "flag: Tunisia", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F4}", category: 8, name: "flag: Tonga", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F7}", category: 8, name: "flag: Turkey", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1F9}", category: 8, name: "flag: Trinidad & Tobago", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1FB}", category: 8, name: "flag: Tuvalu", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1FC}", category: 8, name: "flag: Taiwan", version: "2.0" }, { emoji: "\u{1F1F9}\u{1F1FF}", category: 8, name: "flag: Tanzania", version: "2.0" }, { emoji: "\u{1F1FA}\u{1F1E6}", category: 8, name: "flag: Ukraine", version: "2.0" }, { emoji: "\u{1F1FA}\u{1F1EC}", category: 8, name: "flag: Uganda", version: "2.0" }, { emoji: "\u{1F1FA}\u{1F1F2}", category: 8, name: "flag: U.S. Outlying Islands", version: "2.0" }, { emoji: "\u{1F1FA}\u{1F1F3}", category: 8, name: "flag: United Nations", version: "4.0" }, { emoji: "\u{1F1FA}\u{1F1F8}", category: 8, name: "flag: United States", version: "1.0" }, { emoji: "\u{1F1FA}\u{1F1FE}", category: 8, name: "flag: Uruguay", version: "2.0" }, { emoji: "\u{1F1FA}\u{1F1FF}", category: 8, name: "flag: Uzbekistan", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1E6}", category: 8, name: "flag: Vatican City", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1E8}", category: 8, name: "flag: St. Vincent & Grenadines", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1EA}", category: 8, name: "flag: Venezuela", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1EC}", category: 8, name: "flag: British Virgin Islands", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1EE}", category: 8, name: "flag: U.S. Virgin Islands", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1F3}", category: 8, name: "flag: Vietnam", version: "2.0" }, { emoji: "\u{1F1FB}\u{1F1FA}", category: 8, name: "flag: Vanuatu", version: "2.0" }, { emoji: "\u{1F1FC}\u{1F1EB}", category: 8, name: "flag: Wallis & Futuna", version: "2.0" }, { emoji: "\u{1F1FC}\u{1F1F8}", category: 8, name: "flag: Samoa", version: "2.0" }, { emoji: "\u{1F1FD}\u{1F1F0}", category: 8, name: "flag: Kosovo", version: "2.0" }, { emoji: "\u{1F1FE}\u{1F1EA}", category: 8, name: "flag: Yemen", version: "2.0" }, { emoji: "\u{1F1FE}\u{1F1F9}", category: 8, name: "flag: Mayotte", version: "2.0" }, { emoji: "\u{1F1FF}\u{1F1E6}", category: 8, name: "flag: South Africa", version: "2.0" }, { emoji: "\u{1F1FF}\u{1F1F2}", category: 8, name: "flag: Zambia", version: "2.0" }, { emoji: "\u{1F1FF}\u{1F1FC}", category: 8, name: "flag: Zimbabwe", version: "2.0" }, { emoji: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}", category: 8, name: "flag: England", version: "5.0" }, { emoji: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}", category: 8, name: "flag: Scotland", version: "5.0" }, { emoji: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}", category: 8, name: "flag: Wales", version: "5.0" }] };
const Ce = "emoji-picker__emoji";
function Ee(e3, o3) {
  const n2 = document.createElement(e3);
  return o3 && (n2.className = o3), n2;
}
function _e(e3) {
  for (; e3.firstChild; )
    e3.removeChild(e3.firstChild);
}
function ze(e3, o3) {
  e3.dataset.loaded || (e3.dataset.custom ? function(e4) {
    const o4 = Ee("img", "emoji-picker__custom-emoji");
    e4.dataset.emoji && (o4.src = e4.dataset.emoji, e4.innerText = "", e4.appendChild(o4));
  }(e3) : o3.style === "twemoji" && function(e4, o4) {
    e4.dataset.emoji && (e4.innerHTML = ke.parse(e4.dataset.emoji, o4.twemojiOptions));
  }(e3, o3), e3.dataset.loaded = "true", e3.style.opacity = "1");
}
class Oe {
  constructor(e3, o3) {
    this.events = e3, this.options = o3;
  }
  render() {
    const e3 = Ee("div", "emoji-picker__preview");
    return this.emoji = Ee("div", "emoji-picker__preview-emoji"), e3.appendChild(this.emoji), this.name = Ee("div", "emoji-picker__preview-name"), e3.appendChild(this.name), this.events.on("showPreview", (e4) => this.showPreview(e4)), this.events.on("hidePreview", () => this.hidePreview()), e3;
  }
  showPreview(e3) {
    let o3 = e3.emoji;
    e3.custom ? o3 = `<img class="emoji-picker__custom-emoji" src="${e3.emoji}">` : this.options.style === "twemoji" && (o3 = ke.parse(e3.emoji, this.options.twemojiOptions)), this.emoji.innerHTML = o3, this.name.innerHTML = e3.name;
  }
  hidePreview() {
    this.emoji.innerHTML = "", this.name.innerHTML = "";
  }
}
function Ie(e3, o3) {
  for (var n2 = 0; n2 < o3.length; n2++) {
    var i2 = o3[n2];
    i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
  }
}
function Se(e3, o3, n2) {
  return o3 in e3 ? Object.defineProperty(e3, o3, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[o3] = n2, e3;
}
function Pe(e3) {
  for (var o3 = 1; o3 < arguments.length; o3++) {
    var n2 = arguments[o3] != null ? arguments[o3] : {}, i2 = Object.keys(n2);
    typeof Object.getOwnPropertySymbols == "function" && (i2 = i2.concat(Object.getOwnPropertySymbols(n2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(n2, e4).enumerable;
    }))), i2.forEach(function(o4) {
      Se(e3, o4, n2[o4]);
    });
  }
  return e3;
}
function Me(e3, o3) {
  return function(e4) {
    if (Array.isArray(e4))
      return e4;
  }(e3) || function(e4, o4) {
    var n2 = [], i2 = true, a2 = false, r2 = void 0;
    try {
      for (var t2, s2 = e4[Symbol.iterator](); !(i2 = (t2 = s2.next()).done) && (n2.push(t2.value), !o4 || n2.length !== o4); i2 = true)
        ;
    } catch (e5) {
      a2 = true, r2 = e5;
    } finally {
      try {
        i2 || s2.return == null || s2.return();
      } finally {
        if (a2)
          throw r2;
      }
    }
    return n2;
  }(e3, o3) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
var Ae = function() {
}, Le = {}, Te = {}, Ne = { mark: Ae, measure: Ae };
try {
  typeof window != "undefined" && (Le = window), typeof document != "undefined" && (Te = document), typeof MutationObserver != "undefined" && MutationObserver, typeof performance != "undefined" && (Ne = performance);
} catch (e3) {
}
var Fe = (Le.navigator || {}).userAgent, Be = Fe === void 0 ? "" : Fe, De = Le, Re = Te, qe = Ne, Ve = (De.document, !!Re.documentElement && !!Re.head && typeof Re.addEventListener == "function" && typeof Re.createElement == "function"), He = (~Be.indexOf("MSIE") || Be.indexOf("Trident/"), "group"), Ue = "primary", We = "secondary", Ke = De.FontAwesomeConfig || {};
if (Re && typeof Re.querySelector == "function") {
  [["data-family-prefix", "familyPrefix"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach(function(e3) {
    var o3 = Me(e3, 2), n2 = o3[0], i2 = o3[1], a2 = function(e4) {
      return e4 === "" || e4 !== "false" && (e4 === "true" || e4);
    }(function(e4) {
      var o4 = Re.querySelector("script[" + e4 + "]");
      if (o4)
        return o4.getAttribute(e4);
    }(n2));
    a2 != null && (Ke[i2] = a2);
  });
}
var Je = Pe({}, { familyPrefix: "fa", replacementClass: "svg-inline--fa", autoReplaceSvg: true, autoAddCss: true, autoA11y: true, searchPseudoElements: false, observeMutations: true, mutateApproach: "async", keepOriginalSource: true, measurePerformance: false, showMissingIcons: true }, Ke);
Je.autoReplaceSvg || (Je.observeMutations = false);
var Ge = Pe({}, Je);
De.FontAwesomeConfig = Ge;
var Xe = De || {};
Xe.___FONT_AWESOME___ || (Xe.___FONT_AWESOME___ = {}), Xe.___FONT_AWESOME___.styles || (Xe.___FONT_AWESOME___.styles = {}), Xe.___FONT_AWESOME___.hooks || (Xe.___FONT_AWESOME___.hooks = {}), Xe.___FONT_AWESOME___.shims || (Xe.___FONT_AWESOME___.shims = []);
var Ye = Xe.___FONT_AWESOME___, $e = [];
Ve && ((Re.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Re.readyState) || Re.addEventListener("DOMContentLoaded", function e2() {
  Re.removeEventListener("DOMContentLoaded", e2), $e.map(function(e3) {
    return e3();
  });
}));
typeof global != "undefined" && global.process !== void 0 && global.process.emit, typeof setImmediate == "undefined" ? setTimeout : setImmediate;
var Ze = { size: 16, x: 0, y: 0, rotate: 0, flipX: false, flipY: false };
function Qe() {
  for (var e3 = 12, o3 = ""; e3-- > 0; )
    o3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[62 * Math.random() | 0];
  return o3;
}
function eo(e3) {
  return "".concat(e3).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function oo(e3) {
  return Object.keys(e3 || {}).reduce(function(o3, n2) {
    return o3 + "".concat(n2, ": ").concat(e3[n2], ";");
  }, "");
}
function no(e3) {
  return e3.size !== Ze.size || e3.x !== Ze.x || e3.y !== Ze.y || e3.rotate !== Ze.rotate || e3.flipX || e3.flipY;
}
function io(e3) {
  var o3 = e3.transform, n2 = e3.containerWidth, i2 = e3.iconWidth, a2 = { transform: "translate(".concat(n2 / 2, " 256)") }, r2 = "translate(".concat(32 * o3.x, ", ").concat(32 * o3.y, ") "), t2 = "scale(".concat(o3.size / 16 * (o3.flipX ? -1 : 1), ", ").concat(o3.size / 16 * (o3.flipY ? -1 : 1), ") "), s2 = "rotate(".concat(o3.rotate, " 0 0)");
  return { outer: a2, inner: { transform: "".concat(r2, " ").concat(t2, " ").concat(s2) }, path: { transform: "translate(".concat(i2 / 2 * -1, " -256)") } };
}
var ao = { x: 0, y: 0, width: "100%", height: "100%" };
function ro(e3) {
  var o3 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return e3.attributes && (e3.attributes.fill || o3) && (e3.attributes.fill = "black"), e3;
}
function to(e3) {
  var o3 = e3.icons, n2 = o3.main, i2 = o3.mask, a2 = e3.prefix, r2 = e3.iconName, t2 = e3.transform, s2 = e3.symbol, m2 = e3.title, c2 = e3.maskId, d2 = e3.titleId, g2 = e3.extra, u2 = e3.watchable, l2 = u2 !== void 0 && u2, v2 = i2.found ? i2 : n2, f2 = v2.width, y2 = v2.height, j2 = "fa-w-".concat(Math.ceil(f2 / y2 * 16)), h2 = [Ge.replacementClass, r2 ? "".concat(Ge.familyPrefix, "-").concat(r2) : "", j2].filter(function(e4) {
    return g2.classes.indexOf(e4) === -1;
  }).concat(g2.classes).join(" "), p2 = { children: [], attributes: Pe({}, g2.attributes, { "data-prefix": a2, "data-icon": r2, class: h2, role: g2.attributes.role || "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 ".concat(f2, " ").concat(y2) }) };
  l2 && (p2.attributes["data-fa-i2svg"] = ""), m2 && p2.children.push({ tag: "title", attributes: { id: p2.attributes["aria-labelledby"] || "title-".concat(d2 || Qe()) }, children: [m2] });
  var b2 = Pe({}, p2, { prefix: a2, iconName: r2, main: n2, mask: i2, maskId: c2, transform: t2, symbol: s2, styles: g2.styles }), w2 = i2.found && n2.found ? function(e4) {
    var o4, n3 = e4.children, i3 = e4.attributes, a3 = e4.main, r3 = e4.mask, t3 = e4.maskId, s3 = e4.transform, m3 = a3.width, c3 = a3.icon, d3 = r3.width, g3 = r3.icon, u3 = io({ transform: s3, containerWidth: d3, iconWidth: m3 }), l3 = { tag: "rect", attributes: Pe({}, ao, { fill: "white" }) }, v3 = c3.children ? { children: c3.children.map(ro) } : {}, f3 = { tag: "g", attributes: Pe({}, u3.inner), children: [ro(Pe({ tag: c3.tag, attributes: Pe({}, c3.attributes, u3.path) }, v3))] }, y3 = { tag: "g", attributes: Pe({}, u3.outer), children: [f3] }, j3 = "mask-".concat(t3 || Qe()), h3 = "clip-".concat(t3 || Qe()), p3 = { tag: "mask", attributes: Pe({}, ao, { id: j3, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [l3, y3] }, b3 = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: h3 }, children: (o4 = g3, o4.tag === "g" ? o4.children : [o4]) }, p3] };
    return n3.push(b3, { tag: "rect", attributes: Pe({ fill: "currentColor", "clip-path": "url(#".concat(h3, ")"), mask: "url(#".concat(j3, ")") }, ao) }), { children: n3, attributes: i3 };
  }(b2) : function(e4) {
    var o4 = e4.children, n3 = e4.attributes, i3 = e4.main, a3 = e4.transform, r3 = oo(e4.styles);
    if (r3.length > 0 && (n3.style = r3), no(a3)) {
      var t3 = io({ transform: a3, containerWidth: i3.width, iconWidth: i3.width });
      o4.push({ tag: "g", attributes: Pe({}, t3.outer), children: [{ tag: "g", attributes: Pe({}, t3.inner), children: [{ tag: i3.icon.tag, children: i3.icon.children, attributes: Pe({}, i3.icon.attributes, t3.path) }] }] });
    } else
      o4.push(i3.icon);
    return { children: o4, attributes: n3 };
  }(b2), k2 = w2.children, x2 = w2.attributes;
  return b2.children = k2, b2.attributes = x2, s2 ? function(e4) {
    var o4 = e4.prefix, n3 = e4.iconName, i3 = e4.children, a3 = e4.attributes, r3 = e4.symbol;
    return [{ tag: "svg", attributes: { style: "display: none;" }, children: [{ tag: "symbol", attributes: Pe({}, a3, { id: r3 === true ? "".concat(o4, "-").concat(Ge.familyPrefix, "-").concat(n3) : r3 }), children: i3 }] }];
  }(b2) : function(e4) {
    var o4 = e4.children, n3 = e4.main, i3 = e4.mask, a3 = e4.attributes, r3 = e4.styles, t3 = e4.transform;
    if (no(t3) && n3.found && !i3.found) {
      var s3 = { x: n3.width / n3.height / 2, y: 0.5 };
      a3.style = oo(Pe({}, r3, { "transform-origin": "".concat(s3.x + t3.x / 16, "em ").concat(s3.y + t3.y / 16, "em") }));
    }
    return [{ tag: "svg", attributes: a3, children: o4 }];
  }(b2);
}
var mo = (Ge.measurePerformance && qe && qe.mark && qe.measure, function(e3, o3, n2, i2) {
  var a2, r2, t2, s2 = Object.keys(e3), m2 = s2.length, c2 = i2 !== void 0 ? function(e4, o4) {
    return function(n3, i3, a3, r3) {
      return e4.call(o4, n3, i3, a3, r3);
    };
  }(o3, i2) : o3;
  for (n2 === void 0 ? (a2 = 1, t2 = e3[s2[0]]) : (a2 = 0, t2 = n2); a2 < m2; a2++)
    t2 = c2(t2, e3[r2 = s2[a2]], r2, e3);
  return t2;
});
function co(e3, o3) {
  var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i2 = n2.skipHooks, a2 = i2 !== void 0 && i2, r2 = Object.keys(o3).reduce(function(e4, n3) {
    var i3 = o3[n3];
    return !!i3.icon ? e4[i3.iconName] = i3.icon : e4[n3] = i3, e4;
  }, {});
  typeof Ye.hooks.addPack != "function" || a2 ? Ye.styles[e3] = Pe({}, Ye.styles[e3] || {}, r2) : Ye.hooks.addPack(e3, r2), e3 === "fas" && co("fa", o3);
}
var go = Ye.styles, uo = Ye.shims, lo = function() {
  var e3 = function(e4) {
    return mo(go, function(o4, n2, i2) {
      return o4[i2] = mo(n2, e4, {}), o4;
    }, {});
  };
  e3(function(e4, o4, n2) {
    return o4[3] && (e4[o4[3]] = n2), e4;
  }), e3(function(e4, o4, n2) {
    var i2 = o4[2];
    return e4[n2] = n2, i2.forEach(function(o5) {
      e4[o5] = n2;
    }), e4;
  });
  var o3 = "far" in go;
  mo(uo, function(e4, n2) {
    var i2 = n2[0], a2 = n2[1], r2 = n2[2];
    return a2 !== "far" || o3 || (a2 = "fas"), e4[i2] = { prefix: a2, iconName: r2 }, e4;
  }, {});
};
lo();
Ye.styles;
function vo(e3, o3, n2) {
  if (e3 && e3[o3] && e3[o3][n2])
    return { prefix: o3, iconName: n2, icon: e3[o3][n2] };
}
function fo(e3) {
  var o3 = e3.tag, n2 = e3.attributes, i2 = n2 === void 0 ? {} : n2, a2 = e3.children, r2 = a2 === void 0 ? [] : a2;
  return typeof e3 == "string" ? eo(e3) : "<".concat(o3, " ").concat(function(e4) {
    return Object.keys(e4 || {}).reduce(function(o4, n3) {
      return o4 + "".concat(n3, '="').concat(eo(e4[n3]), '" ');
    }, "").trim();
  }(i2), ">").concat(r2.map(fo).join(""), "</").concat(o3, ">");
}
function yo(e3) {
  this.name = "MissingIcon", this.message = e3 || "Icon unavailable", this.stack = new Error().stack;
}
yo.prototype = Object.create(Error.prototype), yo.prototype.constructor = yo;
var jo = { fill: "currentColor" }, ho = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" }, po = (Pe({}, jo, { d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z" }), Pe({}, ho, { attributeName: "opacity" }));
Pe({}, jo, { cx: "256", cy: "364", r: "28" }), Pe({}, ho, { attributeName: "r", values: "28;14;28;28;14;28;" }), Pe({}, po, { values: "1;0;1;1;0;1;" }), Pe({}, jo, { opacity: "1", d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z" }), Pe({}, po, { values: "1;0;0;0;0;1;" }), Pe({}, jo, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z" }), Pe({}, po, { values: "0;0;1;1;0;0;" }), Ye.styles;
function bo(e3) {
  var o3 = e3[0], n2 = e3[1], i2 = Me(e3.slice(4), 1)[0];
  return { found: true, width: o3, height: n2, icon: Array.isArray(i2) ? { tag: "g", attributes: { class: "".concat(Ge.familyPrefix, "-").concat(He) }, children: [{ tag: "path", attributes: { class: "".concat(Ge.familyPrefix, "-").concat(We), fill: "currentColor", d: i2[0] } }, { tag: "path", attributes: { class: "".concat(Ge.familyPrefix, "-").concat(Ue), fill: "currentColor", d: i2[1] } }] } : { tag: "path", attributes: { fill: "currentColor", d: i2 } } };
}
Ye.styles;
function wo() {
  Ge.autoAddCss && !_o && (!function(e3) {
    if (e3 && Ve) {
      var o3 = Re.createElement("style");
      o3.setAttribute("type", "text/css"), o3.innerHTML = e3;
      for (var n2 = Re.head.childNodes, i2 = null, a2 = n2.length - 1; a2 > -1; a2--) {
        var r2 = n2[a2], t2 = (r2.tagName || "").toUpperCase();
        ["STYLE", "LINK"].indexOf(t2) > -1 && (i2 = r2);
      }
      Re.head.insertBefore(o3, i2);
    }
  }(function() {
    var e3 = "fa", o3 = "svg-inline--fa", n2 = Ge.familyPrefix, i2 = Ge.replacementClass, a2 = 'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}';
    if (n2 !== e3 || i2 !== o3) {
      var r2 = new RegExp("\\.".concat(e3, "\\-"), "g"), t2 = new RegExp("\\--".concat(e3, "\\-"), "g"), s2 = new RegExp("\\.".concat(o3), "g");
      a2 = a2.replace(r2, ".".concat(n2, "-")).replace(t2, "--".concat(n2, "-")).replace(s2, ".".concat(i2));
    }
    return a2;
  }()), _o = true);
}
function ko(e3, o3) {
  return Object.defineProperty(e3, "abstract", { get: o3 }), Object.defineProperty(e3, "html", { get: function() {
    return e3.abstract.map(function(e4) {
      return fo(e4);
    });
  } }), Object.defineProperty(e3, "node", { get: function() {
    if (Ve) {
      var o4 = Re.createElement("div");
      return o4.innerHTML = e3.html, o4.children;
    }
  } }), e3;
}
function xo(e3) {
  var o3 = e3.prefix, n2 = o3 === void 0 ? "fa" : o3, i2 = e3.iconName;
  if (i2)
    return vo(Eo.definitions, n2, i2) || vo(Ye.styles, n2, i2);
}
var Co, Eo = new (function() {
  function e3() {
    !function(e4, o4) {
      if (!(e4 instanceof o4))
        throw new TypeError("Cannot call a class as a function");
    }(this, e3), this.definitions = {};
  }
  var o3, n2;
  return o3 = e3, (n2 = [{ key: "add", value: function() {
    for (var e4 = this, o4 = arguments.length, n3 = new Array(o4), i2 = 0; i2 < o4; i2++)
      n3[i2] = arguments[i2];
    var a2 = n3.reduce(this._pullDefinitions, {});
    Object.keys(a2).forEach(function(o5) {
      e4.definitions[o5] = Pe({}, e4.definitions[o5] || {}, a2[o5]), co(o5, a2[o5]), lo();
    });
  } }, { key: "reset", value: function() {
    this.definitions = {};
  } }, { key: "_pullDefinitions", value: function(e4, o4) {
    var n3 = o4.prefix && o4.iconName && o4.icon ? { 0: o4 } : o4;
    return Object.keys(n3).map(function(o5) {
      var i2 = n3[o5], a2 = i2.prefix, r2 = i2.iconName, t2 = i2.icon;
      e4[a2] || (e4[a2] = {}), e4[a2][r2] = t2;
    }), e4;
  } }]) && Ie(o3.prototype, n2), e3;
}())(), _o = false, zo = (Co = function(e3) {
  var o3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = o3.transform, i2 = n2 === void 0 ? Ze : n2, a2 = o3.symbol, r2 = a2 !== void 0 && a2, t2 = o3.mask, s2 = t2 === void 0 ? null : t2, m2 = o3.maskId, c2 = m2 === void 0 ? null : m2, d2 = o3.title, g2 = d2 === void 0 ? null : d2, u2 = o3.titleId, l2 = u2 === void 0 ? null : u2, v2 = o3.classes, f2 = v2 === void 0 ? [] : v2, y2 = o3.attributes, j2 = y2 === void 0 ? {} : y2, h2 = o3.styles, p2 = h2 === void 0 ? {} : h2;
  if (e3) {
    var b2 = e3.prefix, w2 = e3.iconName, k2 = e3.icon;
    return ko(Pe({ type: "icon" }, e3), function() {
      return wo(), Ge.autoA11y && (g2 ? j2["aria-labelledby"] = "".concat(Ge.replacementClass, "-title-").concat(l2 || Qe()) : (j2["aria-hidden"] = "true", j2.focusable = "false")), to({ icons: { main: bo(k2), mask: s2 ? bo(s2.icon) : { found: false, width: null, height: null, icon: {} } }, prefix: b2, iconName: w2, transform: Pe({}, Ze, i2), symbol: r2, title: g2, maskId: c2, titleId: l2, extra: { attributes: j2, styles: p2, classes: f2 } });
    });
  }
}, function(e3) {
  var o3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = (e3 || {}).icon ? e3 : xo(e3 || {}), i2 = o3.mask;
  return i2 && (i2 = (i2 || {}).icon ? i2 : xo(i2 || {})), Co(n2, Pe({}, o3, { mask: i2 }));
});
Eo.add({ prefix: "far", iconName: "building", icon: [448, 512, [], "f1ad", "M128 148v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12zm140 12h40c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12zm-128 96h40c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12zm128 0h40c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12zm-76 84v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm76 12h40c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12zm180 124v36H0v-36c0-6.6 5.4-12 12-12h19.5V24c0-13.3 10.7-24 24-24h337c13.3 0 24 10.7 24 24v440H436c6.6 0 12 5.4 12 12zM79.5 463H192v-67c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v67h112.5V49L80 48l-.5 415z"] }, { prefix: "fas", iconName: "cat", icon: [512, 512, [], "f6be", "M290.59 192c-20.18 0-106.82 1.98-162.59 85.95V192c0-52.94-43.06-96-96-96-17.67 0-32 14.33-32 32s14.33 32 32 32c17.64 0 32 14.36 32 32v256c0 35.3 28.7 64 64 64h176c8.84 0 16-7.16 16-16v-16c0-17.67-14.33-32-32-32h-32l128-96v144c0 8.84 7.16 16 16 16h32c8.84 0 16-7.16 16-16V289.86c-10.29 2.67-20.89 4.54-32 4.54-61.81 0-113.52-44.05-125.41-102.4zM448 96h-64l-64-64v134.4c0 53.02 42.98 96 96 96s96-42.98 96-96V32l-64 64zm-72 80c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16zm80 0c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z"] }, { prefix: "fas", iconName: "coffee", icon: [640, 512, [], "f0f4", "M192 384h192c53 0 96-43 96-96h32c70.6 0 128-57.4 128-128S582.6 32 512 32H120c-13.3 0-24 10.7-24 24v232c0 53 43 96 96 96zM512 96c35.3 0 64 28.7 64 64s-28.7 64-64 64h-32V96h32zm47.7 384H48.3c-47.6 0-61-64-36-64h583.3c25 0 11.8 64-35.9 64z"] }, { prefix: "far", iconName: "flag", icon: [512, 512, [], "f024", "M336.174 80c-49.132 0-93.305-32-161.913-32-31.301 0-58.303 6.482-80.721 15.168a48.04 48.04 0 0 0 2.142-20.727C93.067 19.575 74.167 1.594 51.201.104 23.242-1.71 0 20.431 0 48c0 17.764 9.657 33.262 24 41.562V496c0 8.837 7.163 16 16 16h16c8.837 0 16-7.163 16-16v-83.443C109.869 395.28 143.259 384 199.826 384c49.132 0 93.305 32 161.913 32 58.479 0 101.972-22.617 128.548-39.981C503.846 367.161 512 352.051 512 335.855V95.937c0-34.459-35.264-57.768-66.904-44.117C409.193 67.309 371.641 80 336.174 80zM464 336c-21.783 15.412-60.824 32-102.261 32-59.945 0-102.002-32-161.913-32-43.361 0-96.379 9.403-127.826 24V128c21.784-15.412 60.824-32 102.261-32 59.945 0 102.002 32 161.913 32 43.271 0 96.32-17.366 127.826-32v240z"] }, { prefix: "far", iconName: "frown", icon: [496, 512, [], "f119", "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160-64c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32zm-80 128c-40.2 0-78 17.7-103.8 48.6-8.5 10.2-7.1 25.3 3.1 33.8 10.2 8.4 25.3 7.1 33.8-3.1 16.6-19.9 41-31.4 66.9-31.4s50.3 11.4 66.9 31.4c8.1 9.7 23.1 11.9 33.8 3.1 10.2-8.5 11.5-23.6 3.1-33.8C326 321.7 288.2 304 248 304z"] }, { prefix: "fas", iconName: "futbol", icon: [512, 512, [], "f1e3", "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zm-48 0l-.003-.282-26.064 22.741-62.679-58.5 16.454-84.355 34.303 3.072c-24.889-34.216-60.004-60.089-100.709-73.141l13.651 31.939L256 139l-74.953-41.525 13.651-31.939c-40.631 13.028-75.78 38.87-100.709 73.141l34.565-3.073 16.192 84.355-62.678 58.5-26.064-22.741-.003.282c0 43.015 13.497 83.952 38.472 117.991l7.704-33.897 85.138 10.447 36.301 77.826-29.902 17.786c40.202 13.122 84.29 13.148 124.572 0l-29.902-17.786 36.301-77.826 85.138-10.447 7.704 33.897C442.503 339.952 456 299.015 456 256zm-248.102 69.571l-29.894-91.312L256 177.732l77.996 56.527-29.622 91.312h-96.476z"] }, { prefix: "fas", iconName: "history", icon: [512, 512, [], "f1da", "M504 255.531c.253 136.64-111.18 248.372-247.82 248.468-59.015.042-113.223-20.53-155.822-54.911-11.077-8.94-11.905-25.541-1.839-35.607l11.267-11.267c8.609-8.609 22.353-9.551 31.891-1.984C173.062 425.135 212.781 440 256 440c101.705 0 184-82.311 184-184 0-101.705-82.311-184-184-184-48.814 0-93.149 18.969-126.068 49.932l50.754 50.754c10.08 10.08 2.941 27.314-11.313 27.314H24c-8.837 0-16-7.163-16-16V38.627c0-14.254 17.234-21.393 27.314-11.314l49.372 49.372C129.209 34.136 189.552 8 256 8c136.81 0 247.747 110.78 248 247.531zm-180.912 78.784l9.823-12.63c8.138-10.463 6.253-25.542-4.21-33.679L288 256.349V152c0-13.255-10.745-24-24-24h-16c-13.255 0-24 10.745-24 24v135.651l65.409 50.874c10.463 8.137 25.541 6.253 33.679-4.21z"] }, { prefix: "fas", iconName: "icons", icon: [512, 512, [], "f86d", "M116.65 219.35a15.68 15.68 0 0 0 22.65 0l96.75-99.83c28.15-29 26.5-77.1-4.91-103.88C203.75-7.7 163-3.5 137.86 22.44L128 32.58l-9.85-10.14C93.05-3.5 52.25-7.7 24.86 15.64c-31.41 26.78-33 74.85-5 103.88zm143.92 100.49h-48l-7.08-14.24a27.39 27.39 0 0 0-25.66-17.78h-71.71a27.39 27.39 0 0 0-25.66 17.78l-7 14.24h-48A27.45 27.45 0 0 0 0 347.3v137.25A27.44 27.44 0 0 0 27.43 512h233.14A27.45 27.45 0 0 0 288 484.55V347.3a27.45 27.45 0 0 0-27.43-27.46zM144 468a52 52 0 1 1 52-52 52 52 0 0 1-52 52zm355.4-115.9h-60.58l22.36-50.75c2.1-6.65-3.93-13.21-12.18-13.21h-75.59c-6.3 0-11.66 3.9-12.5 9.1l-16.8 106.93c-1 6.3 4.88 11.89 12.5 11.89h62.31l-24.2 83c-1.89 6.65 4.2 12.9 12.23 12.9a13.26 13.26 0 0 0 10.92-5.25l92.4-138.91c4.88-6.91-1.16-15.7-10.87-15.7zM478.08.33L329.51 23.17C314.87 25.42 304 38.92 304 54.83V161.6a83.25 83.25 0 0 0-16-1.7c-35.35 0-64 21.48-64 48s28.65 48 64 48c35.2 0 63.73-21.32 64-47.66V99.66l112-17.22v47.18a83.25 83.25 0 0 0-16-1.7c-35.35 0-64 21.48-64 48s28.65 48 64 48c35.2 0 63.73-21.32 64-47.66V32c0-19.48-16-34.42-33.92-31.67z"] }, { prefix: "far", iconName: "lightbulb", icon: [352, 512, [], "f0eb", "M176 80c-52.94 0-96 43.06-96 96 0 8.84 7.16 16 16 16s16-7.16 16-16c0-35.3 28.72-64 64-64 8.84 0 16-7.16 16-16s-7.16-16-16-16zM96.06 459.17c0 3.15.93 6.22 2.68 8.84l24.51 36.84c2.97 4.46 7.97 7.14 13.32 7.14h78.85c5.36 0 10.36-2.68 13.32-7.14l24.51-36.84c1.74-2.62 2.67-5.7 2.68-8.84l.05-43.18H96.02l.04 43.18zM176 0C73.72 0 0 82.97 0 176c0 44.37 16.45 84.85 43.56 115.78 16.64 18.99 42.74 58.8 52.42 92.16v.06h48v-.12c-.01-4.77-.72-9.51-2.15-14.07-5.59-17.81-22.82-64.77-62.17-109.67-20.54-23.43-31.52-53.15-31.61-84.14-.2-73.64 59.67-128 127.95-128 70.58 0 128 57.42 128 128 0 30.97-11.24 60.85-31.65 84.14-39.11 44.61-56.42 91.47-62.1 109.46a47.507 47.507 0 0 0-2.22 14.3v.1h48v-.05c9.68-33.37 35.78-73.18 52.42-92.16C335.55 260.85 352 220.37 352 176 352 78.8 273.2 0 176 0z"] }, { prefix: "fas", iconName: "music", icon: [512, 512, [], "f001", "M470.38 1.51L150.41 96A32 32 0 0 0 128 126.51v261.41A139 139 0 0 0 96 384c-53 0-96 28.66-96 64s43 64 96 64 96-28.66 96-64V214.32l256-75v184.61a138.4 138.4 0 0 0-32-3.93c-53 0-96 28.66-96 64s43 64 96 64 96-28.65 96-64V32a32 32 0 0 0-41.62-30.49z"] }, { prefix: "fas", iconName: "search", icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"] }, { prefix: "far", iconName: "smile", icon: [496, 512, [], "f118", "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm4 72.6c-20.8 25-51.5 39.4-84 39.4s-63.2-14.3-84-39.4c-8.5-10.2-23.7-11.5-33.8-3.1-10.2 8.5-11.5 23.6-3.1 33.8 30 36 74.1 56.6 120.9 56.6s90.9-20.6 120.9-56.6c8.5-10.2 7.1-25.3-3.1-33.8-10.1-8.4-25.3-7.1-33.8 3.1z"] }, { prefix: "fas", iconName: "times", icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"] }, { prefix: "fas", iconName: "user", icon: [448, 512, [], "f007", "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"] });
const Oo = zo({ prefix: "far", iconName: "building" }).html[0], Io = zo({ prefix: "fas", iconName: "cat" }).html[0], So = zo({ prefix: "fas", iconName: "coffee" }).html[0], Po = zo({ prefix: "far", iconName: "flag" }).html[0], Mo = zo({ prefix: "fas", iconName: "futbol" }).html[0], Ao = zo({ prefix: "far", iconName: "frown" }).html[0], Lo = zo({ prefix: "fas", iconName: "history" }).html[0], To = zo({ prefix: "fas", iconName: "icons" }).html[0], No = zo({ prefix: "far", iconName: "lightbulb" }).html[0], Fo = zo({ prefix: "fas", iconName: "music" }).html[0], Bo = zo({ prefix: "fas", iconName: "search" }).html[0], Do = zo({ prefix: "far", iconName: "smile" }).html[0], Ro = zo({ prefix: "fas", iconName: "times" }).html[0], qo = zo({ prefix: "fas", iconName: "user" }).html[0];
function Vo(e3) {
  const o3 = document.createElement("img");
  return o3.src = e3, o3;
}
function Ho() {
  const e3 = localStorage.getItem("emojiPicker.recent");
  return (e3 ? JSON.parse(e3) : []).filter((e4) => !!e4.emoji);
}
class Uo {
  constructor(e3, o3, n2, i2, a2, r2 = true) {
    this.emoji = e3, this.showVariants = o3, this.showPreview = n2, this.events = i2, this.options = a2, this.lazy = r2;
  }
  render() {
    this.emojiButton = Ee("button", Ce);
    let e3 = this.emoji.emoji;
    return this.emoji.custom ? e3 = this.lazy ? Do : `<img class="emoji-picker__custom-emoji" src="${this.emoji.emoji}">` : this.options.style === "twemoji" && (e3 = this.lazy ? Do : ke.parse(this.emoji.emoji, this.options.twemojiOptions)), this.emojiButton.innerHTML = e3, this.emojiButton.tabIndex = -1, this.emojiButton.dataset.emoji = this.emoji.emoji, this.emoji.custom && (this.emojiButton.dataset.custom = "true"), this.emojiButton.title = this.emoji.name, this.emojiButton.addEventListener("focus", () => this.onEmojiHover()), this.emojiButton.addEventListener("blur", () => this.onEmojiLeave()), this.emojiButton.addEventListener("click", () => this.onEmojiClick()), this.emojiButton.addEventListener("mouseover", () => this.onEmojiHover()), this.emojiButton.addEventListener("mouseout", () => this.onEmojiLeave()), this.options.style === "twemoji" && this.lazy && (this.emojiButton.style.opacity = "0.25"), this.emojiButton;
  }
  onEmojiClick() {
    this.emoji.variations && this.showVariants && this.options.showVariants || !this.options.showRecents || function(e3, o3) {
      const n2 = Ho(), i2 = { emoji: e3.emoji, name: e3.name, key: e3.key || e3.name, custom: e3.custom };
      localStorage.setItem("emojiPicker.recent", JSON.stringify([i2, ...n2.filter((e4) => !!e4.emoji && e4.key !== i2.key)].slice(0, o3.recentsCount)));
    }(this.emoji, this.options), this.events.emit("emoji", { emoji: this.emoji, showVariants: this.showVariants, button: this.emojiButton });
  }
  onEmojiHover() {
    this.showPreview && this.events.emit("showPreview", this.emoji);
  }
  onEmojiLeave() {
    this.showPreview && this.events.emit("hidePreview");
  }
}
class Wo {
  constructor(e3, o3, n2, i2, a2 = true) {
    this.showVariants = o3, this.events = n2, this.options = i2, this.lazy = a2, this.emojis = e3.filter((e4) => !e4.version || parseFloat(e4.version) <= parseFloat(i2.emojiVersion));
  }
  render() {
    const e3 = Ee("div", "emoji-picker__container");
    return this.emojis.forEach((o3) => e3.appendChild(new Uo(o3, this.showVariants, true, this.events, this.options, this.lazy).render())), e3;
  }
}
var Ko = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
var Jo, Go = (function(e3) {
  var o3, n2;
  o3 = Ko, n2 = function() {
    var e4 = typeof window == "undefined", o4 = new Map(), n3 = new Map(), i2 = [];
    i2.total = 0;
    var a2 = [], r2 = [];
    function t2() {
      o4.clear(), n3.clear(), a2 = [], r2 = [];
    }
    function s2(e5) {
      for (var o5 = -9007199254740991, n4 = e5.length - 1; n4 >= 0; --n4) {
        var i3 = e5[n4];
        if (i3 !== null) {
          var a3 = i3.score;
          a3 > o5 && (o5 = a3);
        }
      }
      return o5 === -9007199254740991 ? null : o5;
    }
    function m2(e5, o5) {
      var n4 = e5[o5];
      if (n4 !== void 0)
        return n4;
      var i3 = o5;
      Array.isArray(o5) || (i3 = o5.split("."));
      for (var a3 = i3.length, r3 = -1; e5 && ++r3 < a3; )
        e5 = e5[i3[r3]];
      return e5;
    }
    function c2(e5) {
      return typeof e5 == "object";
    }
    var d2 = function() {
      var e5 = [], o5 = 0, n4 = {};
      function i3() {
        for (var n5 = 0, i4 = e5[n5], a3 = 1; a3 < o5; ) {
          var r3 = a3 + 1;
          n5 = a3, r3 < o5 && e5[r3].score < e5[a3].score && (n5 = r3), e5[n5 - 1 >> 1] = e5[n5], a3 = 1 + (n5 << 1);
        }
        for (var t3 = n5 - 1 >> 1; n5 > 0 && i4.score < e5[t3].score; t3 = (n5 = t3) - 1 >> 1)
          e5[n5] = e5[t3];
        e5[n5] = i4;
      }
      return n4.add = function(n5) {
        var i4 = o5;
        e5[o5++] = n5;
        for (var a3 = i4 - 1 >> 1; i4 > 0 && n5.score < e5[a3].score; a3 = (i4 = a3) - 1 >> 1)
          e5[i4] = e5[a3];
        e5[i4] = n5;
      }, n4.poll = function() {
        if (o5 !== 0) {
          var n5 = e5[0];
          return e5[0] = e5[--o5], i3(), n5;
        }
      }, n4.peek = function(n5) {
        if (o5 !== 0)
          return e5[0];
      }, n4.replaceTop = function(o6) {
        e5[0] = o6, i3();
      }, n4;
    }, g2 = d2();
    return function u2(l2) {
      var v2 = { single: function(e5, o5, n4) {
        return e5 ? (c2(e5) || (e5 = v2.getPreparedSearch(e5)), o5 ? (c2(o5) || (o5 = v2.getPrepared(o5)), ((n4 && n4.allowTypo !== void 0 ? n4.allowTypo : !l2 || l2.allowTypo === void 0 || l2.allowTypo) ? v2.algorithm : v2.algorithmNoTypo)(e5, o5, e5[0])) : null) : null;
      }, go: function(e5, o5, n4) {
        if (!e5)
          return i2;
        var a3 = (e5 = v2.prepareSearch(e5))[0], r3 = n4 && n4.threshold || l2 && l2.threshold || -9007199254740991, t3 = n4 && n4.limit || l2 && l2.limit || 9007199254740991, d3 = (n4 && n4.allowTypo !== void 0 ? n4.allowTypo : !l2 || l2.allowTypo === void 0 || l2.allowTypo) ? v2.algorithm : v2.algorithmNoTypo, u3 = 0, f2 = 0, y2 = o5.length;
        if (n4 && n4.keys)
          for (var j2 = n4.scoreFn || s2, h2 = n4.keys, p2 = h2.length, b2 = y2 - 1; b2 >= 0; --b2) {
            for (var w2 = o5[b2], k2 = new Array(p2), x2 = p2 - 1; x2 >= 0; --x2)
              (_2 = m2(w2, E2 = h2[x2])) ? (c2(_2) || (_2 = v2.getPrepared(_2)), k2[x2] = d3(e5, _2, a3)) : k2[x2] = null;
            k2.obj = w2;
            var C2 = j2(k2);
            C2 !== null && (C2 < r3 || (k2.score = C2, u3 < t3 ? (g2.add(k2), ++u3) : (++f2, C2 > g2.peek().score && g2.replaceTop(k2))));
          }
        else if (n4 && n4.key) {
          var E2 = n4.key;
          for (b2 = y2 - 1; b2 >= 0; --b2)
            (_2 = m2(w2 = o5[b2], E2)) && (c2(_2) || (_2 = v2.getPrepared(_2)), (z2 = d3(e5, _2, a3)) !== null && (z2.score < r3 || (z2 = { target: z2.target, _targetLowerCodes: null, _nextBeginningIndexes: null, score: z2.score, indexes: z2.indexes, obj: w2 }, u3 < t3 ? (g2.add(z2), ++u3) : (++f2, z2.score > g2.peek().score && g2.replaceTop(z2)))));
        } else
          for (b2 = y2 - 1; b2 >= 0; --b2) {
            var _2, z2;
            (_2 = o5[b2]) && (c2(_2) || (_2 = v2.getPrepared(_2)), (z2 = d3(e5, _2, a3)) !== null && (z2.score < r3 || (u3 < t3 ? (g2.add(z2), ++u3) : (++f2, z2.score > g2.peek().score && g2.replaceTop(z2)))));
          }
        if (u3 === 0)
          return i2;
        var O2 = new Array(u3);
        for (b2 = u3 - 1; b2 >= 0; --b2)
          O2[b2] = g2.poll();
        return O2.total = u3 + f2, O2;
      }, goAsync: function(o5, n4, a3) {
        var r3 = false, t3 = new Promise(function(t4, g3) {
          if (!o5)
            return t4(i2);
          var u3 = (o5 = v2.prepareSearch(o5))[0], f2 = d2(), y2 = n4.length - 1, j2 = a3 && a3.threshold || l2 && l2.threshold || -9007199254740991, h2 = a3 && a3.limit || l2 && l2.limit || 9007199254740991, p2 = (a3 && a3.allowTypo !== void 0 ? a3.allowTypo : !l2 || l2.allowTypo === void 0 || l2.allowTypo) ? v2.algorithm : v2.algorithmNoTypo, b2 = 0, w2 = 0;
          function k2() {
            if (r3)
              return g3("canceled");
            var d3 = Date.now();
            if (a3 && a3.keys)
              for (var l3 = a3.scoreFn || s2, x2 = a3.keys, C2 = x2.length; y2 >= 0; --y2) {
                for (var E2 = n4[y2], _2 = new Array(C2), z2 = C2 - 1; z2 >= 0; --z2)
                  (S2 = m2(E2, I2 = x2[z2])) ? (c2(S2) || (S2 = v2.getPrepared(S2)), _2[z2] = p2(o5, S2, u3)) : _2[z2] = null;
                _2.obj = E2;
                var O2 = l3(_2);
                if (O2 !== null && !(O2 < j2) && (_2.score = O2, b2 < h2 ? (f2.add(_2), ++b2) : (++w2, O2 > f2.peek().score && f2.replaceTop(_2)), y2 % 1e3 == 0 && Date.now() - d3 >= 10))
                  return void (e4 ? setImmediate(k2) : setTimeout(k2));
              }
            else if (a3 && a3.key) {
              for (var I2 = a3.key; y2 >= 0; --y2)
                if ((S2 = m2(E2 = n4[y2], I2)) && (c2(S2) || (S2 = v2.getPrepared(S2)), (P2 = p2(o5, S2, u3)) !== null && !(P2.score < j2) && (P2 = { target: P2.target, _targetLowerCodes: null, _nextBeginningIndexes: null, score: P2.score, indexes: P2.indexes, obj: E2 }, b2 < h2 ? (f2.add(P2), ++b2) : (++w2, P2.score > f2.peek().score && f2.replaceTop(P2)), y2 % 1e3 == 0 && Date.now() - d3 >= 10)))
                  return void (e4 ? setImmediate(k2) : setTimeout(k2));
            } else
              for (; y2 >= 0; --y2) {
                var S2, P2;
                if ((S2 = n4[y2]) && (c2(S2) || (S2 = v2.getPrepared(S2)), (P2 = p2(o5, S2, u3)) !== null && !(P2.score < j2) && (b2 < h2 ? (f2.add(P2), ++b2) : (++w2, P2.score > f2.peek().score && f2.replaceTop(P2)), y2 % 1e3 == 0 && Date.now() - d3 >= 10)))
                  return void (e4 ? setImmediate(k2) : setTimeout(k2));
              }
            if (b2 === 0)
              return t4(i2);
            for (var M2 = new Array(b2), A2 = b2 - 1; A2 >= 0; --A2)
              M2[A2] = f2.poll();
            M2.total = b2 + w2, t4(M2);
          }
          e4 ? setImmediate(k2) : k2();
        });
        return t3.cancel = function() {
          r3 = true;
        }, t3;
      }, highlight: function(e5, o5, n4) {
        if (e5 === null)
          return null;
        o5 === void 0 && (o5 = "<b>"), n4 === void 0 && (n4 = "</b>");
        for (var i3 = "", a3 = 0, r3 = false, t3 = e5.target, s3 = t3.length, m3 = e5.indexes, c3 = 0; c3 < s3; ++c3) {
          var d3 = t3[c3];
          if (m3[a3] === c3) {
            if (r3 || (r3 = true, i3 += o5), ++a3 === m3.length) {
              i3 += d3 + n4 + t3.substr(c3 + 1);
              break;
            }
          } else
            r3 && (r3 = false, i3 += n4);
          i3 += d3;
        }
        return i3;
      }, prepare: function(e5) {
        if (e5)
          return { target: e5, _targetLowerCodes: v2.prepareLowerCodes(e5), _nextBeginningIndexes: null, score: null, indexes: null, obj: null };
      }, prepareSlow: function(e5) {
        if (e5)
          return { target: e5, _targetLowerCodes: v2.prepareLowerCodes(e5), _nextBeginningIndexes: v2.prepareNextBeginningIndexes(e5), score: null, indexes: null, obj: null };
      }, prepareSearch: function(e5) {
        if (e5)
          return v2.prepareLowerCodes(e5);
      }, getPrepared: function(e5) {
        if (e5.length > 999)
          return v2.prepare(e5);
        var n4 = o4.get(e5);
        return n4 !== void 0 || (n4 = v2.prepare(e5), o4.set(e5, n4)), n4;
      }, getPreparedSearch: function(e5) {
        if (e5.length > 999)
          return v2.prepareSearch(e5);
        var o5 = n3.get(e5);
        return o5 !== void 0 || (o5 = v2.prepareSearch(e5), n3.set(e5, o5)), o5;
      }, algorithm: function(e5, o5, n4) {
        for (var i3 = o5._targetLowerCodes, t3 = e5.length, s3 = i3.length, m3 = 0, c3 = 0, d3 = 0, g3 = 0; ; ) {
          if (n4 === i3[c3]) {
            if (a2[g3++] = c3, ++m3 === t3)
              break;
            n4 = e5[d3 === 0 ? m3 : d3 === m3 ? m3 + 1 : d3 === m3 - 1 ? m3 - 1 : m3];
          }
          if (++c3 >= s3)
            for (; ; ) {
              if (m3 <= 1)
                return null;
              if (d3 === 0) {
                if (n4 === e5[--m3])
                  continue;
                d3 = m3;
              } else {
                if (d3 === 1)
                  return null;
                if ((n4 = e5[1 + (m3 = --d3)]) === e5[m3])
                  continue;
              }
              c3 = a2[(g3 = m3) - 1] + 1;
              break;
            }
        }
        m3 = 0;
        var u3 = 0, l3 = false, f2 = 0, y2 = o5._nextBeginningIndexes;
        y2 === null && (y2 = o5._nextBeginningIndexes = v2.prepareNextBeginningIndexes(o5.target));
        var j2 = c3 = a2[0] === 0 ? 0 : y2[a2[0] - 1];
        if (c3 !== s3)
          for (; ; )
            if (c3 >= s3) {
              if (m3 <= 0) {
                if (++u3 > t3 - 2)
                  break;
                if (e5[u3] === e5[u3 + 1])
                  continue;
                c3 = j2;
                continue;
              }
              --m3, c3 = y2[r2[--f2]];
            } else if (e5[u3 === 0 ? m3 : u3 === m3 ? m3 + 1 : u3 === m3 - 1 ? m3 - 1 : m3] === i3[c3]) {
              if (r2[f2++] = c3, ++m3 === t3) {
                l3 = true;
                break;
              }
              ++c3;
            } else
              c3 = y2[c3];
        if (l3)
          var h2 = r2, p2 = f2;
        else
          h2 = a2, p2 = g3;
        for (var b2 = 0, w2 = -1, k2 = 0; k2 < t3; ++k2)
          w2 !== (c3 = h2[k2]) - 1 && (b2 -= c3), w2 = c3;
        for (l3 ? u3 !== 0 && (b2 += -20) : (b2 *= 1e3, d3 !== 0 && (b2 += -20)), b2 -= s3 - t3, o5.score = b2, o5.indexes = new Array(p2), k2 = p2 - 1; k2 >= 0; --k2)
          o5.indexes[k2] = h2[k2];
        return o5;
      }, algorithmNoTypo: function(e5, o5, n4) {
        for (var i3 = o5._targetLowerCodes, t3 = e5.length, s3 = i3.length, m3 = 0, c3 = 0, d3 = 0; ; ) {
          if (n4 === i3[c3]) {
            if (a2[d3++] = c3, ++m3 === t3)
              break;
            n4 = e5[m3];
          }
          if (++c3 >= s3)
            return null;
        }
        m3 = 0;
        var g3 = false, u3 = 0, l3 = o5._nextBeginningIndexes;
        if (l3 === null && (l3 = o5._nextBeginningIndexes = v2.prepareNextBeginningIndexes(o5.target)), (c3 = a2[0] === 0 ? 0 : l3[a2[0] - 1]) !== s3)
          for (; ; )
            if (c3 >= s3) {
              if (m3 <= 0)
                break;
              --m3, c3 = l3[r2[--u3]];
            } else if (e5[m3] === i3[c3]) {
              if (r2[u3++] = c3, ++m3 === t3) {
                g3 = true;
                break;
              }
              ++c3;
            } else
              c3 = l3[c3];
        if (g3)
          var f2 = r2, y2 = u3;
        else
          f2 = a2, y2 = d3;
        for (var j2 = 0, h2 = -1, p2 = 0; p2 < t3; ++p2)
          h2 !== (c3 = f2[p2]) - 1 && (j2 -= c3), h2 = c3;
        for (g3 || (j2 *= 1e3), j2 -= s3 - t3, o5.score = j2, o5.indexes = new Array(y2), p2 = y2 - 1; p2 >= 0; --p2)
          o5.indexes[p2] = f2[p2];
        return o5;
      }, prepareLowerCodes: function(e5) {
        for (var o5 = e5.length, n4 = [], i3 = e5.toLowerCase(), a3 = 0; a3 < o5; ++a3)
          n4[a3] = i3.charCodeAt(a3);
        return n4;
      }, prepareBeginningIndexes: function(e5) {
        for (var o5 = e5.length, n4 = [], i3 = 0, a3 = false, r3 = false, t3 = 0; t3 < o5; ++t3) {
          var s3 = e5.charCodeAt(t3), m3 = s3 >= 65 && s3 <= 90, c3 = m3 || s3 >= 97 && s3 <= 122 || s3 >= 48 && s3 <= 57, d3 = m3 && !a3 || !r3 || !c3;
          a3 = m3, r3 = c3, d3 && (n4[i3++] = t3);
        }
        return n4;
      }, prepareNextBeginningIndexes: function(e5) {
        for (var o5 = e5.length, n4 = v2.prepareBeginningIndexes(e5), i3 = [], a3 = n4[0], r3 = 0, t3 = 0; t3 < o5; ++t3)
          a3 > t3 ? i3[t3] = a3 : (a3 = n4[++r3], i3[t3] = a3 === void 0 ? o5 : a3);
        return i3;
      }, cleanup: t2, new: u2 };
      return v2;
    }();
  }, e3.exports ? e3.exports = n2() : o3.fuzzysort = n2();
}(Jo = { exports: {} }, Jo.exports), Jo.exports);
class Xo {
  constructor(e3, o3) {
    this.message = e3, this.iconUrl = o3;
  }
  render() {
    const e3 = Ee("div", "emoji-picker__search-not-found"), o3 = Ee("div", "emoji-picker__search-not-found-icon");
    this.iconUrl ? o3.appendChild(Vo(this.iconUrl)) : o3.innerHTML = Ao, e3.appendChild(o3);
    const n2 = Ee("h2");
    return n2.innerHTML = this.message, e3.appendChild(n2), e3;
  }
}
class Yo {
  constructor(e3, o3, n2, i2, a2) {
    if (this.events = e3, this.i18n = o3, this.options = n2, this.focusedEmojiIndex = 0, this.emojisPerRow = this.options.emojisPerRow || 8, this.emojiData = i2.filter((e4) => e4.version && parseFloat(e4.version) <= parseFloat(n2.emojiVersion) && e4.category !== void 0 && a2.indexOf(e4.category) >= 0), this.options.custom) {
      const e4 = this.options.custom.map((e5) => Object.assign(Object.assign({}, e5), { custom: true }));
      this.emojiData = [...this.emojiData, ...e4];
    }
    this.events.on("hideVariantPopup", () => {
      setTimeout(() => this.setFocusedEmoji(this.focusedEmojiIndex));
    });
  }
  render() {
    return this.searchContainer = Ee("div", "emoji-picker__search-container"), this.searchField = Ee("input", "emoji-picker__search"), this.searchField.placeholder = this.i18n.search, this.searchContainer.appendChild(this.searchField), this.searchIcon = Ee("span", "emoji-picker__search-icon"), this.options.icons && this.options.icons.search ? this.searchIcon.appendChild(Vo(this.options.icons.search)) : this.searchIcon.innerHTML = Bo, this.searchIcon.addEventListener("click", (e3) => this.onClearSearch(e3)), this.searchContainer.appendChild(this.searchIcon), this.searchField.addEventListener("keydown", (e3) => this.onKeyDown(e3)), this.searchField.addEventListener("keyup", (e3) => this.onKeyUp(e3)), this.searchContainer;
  }
  clear() {
    this.searchField.value = "";
  }
  focus() {
    this.searchField.focus();
  }
  onClearSearch(e3) {
    e3.stopPropagation(), this.searchField.value && (this.searchField.value = "", this.resultsContainer = null, this.options.icons && this.options.icons.search ? (_e(this.searchIcon), this.searchIcon.appendChild(Vo(this.options.icons.search))) : this.searchIcon.innerHTML = Bo, this.searchIcon.style.cursor = "default", this.events.emit("hideSearchResults"), setTimeout(() => this.searchField.focus()));
  }
  setFocusedEmoji(e3) {
    if (this.resultsContainer) {
      const o3 = this.resultsContainer.querySelectorAll("." + Ce);
      o3[this.focusedEmojiIndex].tabIndex = -1, this.focusedEmojiIndex = e3;
      const n2 = o3[this.focusedEmojiIndex];
      n2.tabIndex = 0, n2.focus();
    }
  }
  handleResultsKeydown(e3) {
    if (this.resultsContainer) {
      const o3 = this.resultsContainer.querySelectorAll("." + Ce);
      e3.key === "ArrowRight" ? this.setFocusedEmoji(Math.min(this.focusedEmojiIndex + 1, o3.length - 1)) : e3.key === "ArrowLeft" ? this.setFocusedEmoji(Math.max(0, this.focusedEmojiIndex - 1)) : e3.key === "ArrowDown" ? (e3.preventDefault(), this.focusedEmojiIndex < o3.length - this.emojisPerRow && this.setFocusedEmoji(this.focusedEmojiIndex + this.emojisPerRow)) : e3.key === "ArrowUp" ? (e3.preventDefault(), this.focusedEmojiIndex >= this.emojisPerRow && this.setFocusedEmoji(this.focusedEmojiIndex - this.emojisPerRow)) : e3.key === "Escape" && this.onClearSearch(e3);
    }
  }
  onKeyDown(e3) {
    e3.key === "Escape" && this.searchField.value && this.onClearSearch(e3);
  }
  onKeyUp(e3) {
    if (e3.key !== "Tab" && e3.key !== "Shift")
      if (this.searchField.value) {
        this.options.icons && this.options.icons.clearSearch ? (_e(this.searchIcon), this.searchIcon.appendChild(Vo(this.options.icons.clearSearch))) : this.searchIcon.innerHTML = Ro, this.searchIcon.style.cursor = "pointer";
        const e4 = Go.go(this.searchField.value, this.emojiData, { allowTypo: true, limit: 100, key: "name" }).map((e5) => e5.obj);
        this.events.emit("hidePreview"), e4.length ? (this.resultsContainer = new Wo(e4, true, this.events, this.options, false).render(), this.resultsContainer && (this.resultsContainer.querySelector("." + Ce).tabIndex = 0, this.focusedEmojiIndex = 0, this.resultsContainer.addEventListener("keydown", (e5) => this.handleResultsKeydown(e5)), this.events.emit("showSearchResults", this.resultsContainer))) : this.events.emit("showSearchResults", new Xo(this.i18n.notFound, this.options.icons && this.options.icons.notFound).render());
      } else
        this.options.icons && this.options.icons.search ? (_e(this.searchIcon), this.searchIcon.appendChild(Vo(this.options.icons.search))) : this.searchIcon.innerHTML = Bo, this.searchIcon.style.cursor = "default", this.events.emit("hideSearchResults");
  }
}
class $o {
  constructor(e3, o3, n2) {
    this.events = e3, this.emoji = o3, this.options = n2, this.focusedEmojiIndex = 0;
  }
  getEmoji(e3) {
    return this.popup.querySelectorAll("." + Ce)[e3];
  }
  setFocusedEmoji(e3) {
    this.getEmoji(this.focusedEmojiIndex).tabIndex = -1, this.focusedEmojiIndex = e3;
    const o3 = this.getEmoji(this.focusedEmojiIndex);
    o3.tabIndex = 0, o3.focus();
  }
  render() {
    this.popup = Ee("div", "emoji-picker__variant-popup");
    const e3 = Ee("div", "emoji-picker__variant-overlay");
    e3.addEventListener("click", (e4) => {
      e4.stopPropagation(), this.popup.contains(e4.target) || this.events.emit("hideVariantPopup");
    }), this.popup.appendChild(new Uo(this.emoji, false, false, this.events, this.options, false).render()), (this.emoji.variations || []).forEach((e4, o4) => this.popup.appendChild(new Uo({ name: this.emoji.name, emoji: e4, key: this.emoji.name + o4 }, false, false, this.events, this.options, false).render()));
    const o3 = this.popup.querySelector("." + Ce);
    return this.focusedEmojiIndex = 0, o3.tabIndex = 0, setTimeout(() => o3.focus()), this.popup.addEventListener("keydown", (e4) => {
      e4.key === "ArrowRight" ? this.setFocusedEmoji(Math.min(this.focusedEmojiIndex + 1, this.popup.querySelectorAll("." + Ce).length - 1)) : e4.key === "ArrowLeft" ? this.setFocusedEmoji(Math.max(this.focusedEmojiIndex - 1, 0)) : e4.key === "Escape" && (e4.stopPropagation(), this.events.emit("hideVariantPopup"));
    }), e3.appendChild(this.popup), e3;
  }
}
const Zo = { search: "Search emojis...", categories: { recents: "Recent Emojis", smileys: "Smileys & Emotion", people: "People & Body", animals: "Animals & Nature", food: "Food & Drink", activities: "Activities", travel: "Travel & Places", objects: "Objects", symbols: "Symbols", flags: "Flags", custom: "Custom" }, notFound: "No emojis found" }, Qo = { recents: Lo, smileys: Do, people: qo, animals: Io, food: So, activities: Mo, travel: Oo, objects: No, symbols: Fo, flags: Po, custom: To };
class en {
  constructor(e3, o3, n2) {
    this.options = e3, this.events = o3, this.i18n = n2, this.activeButton = 0, this.buttons = [];
  }
  render() {
    var e3;
    const o3 = Ee("div", "emoji-picker__category-buttons"), n2 = this.options.categories || ((e3 = this.options.emojiData) === null || e3 === void 0 ? void 0 : e3.categories) || xe.categories;
    let i2 = this.options.showRecents ? ["recents", ...n2] : n2;
    return this.options.custom && (i2 = [...i2, "custom"]), i2.forEach((e4) => {
      const n3 = Ee("button", "emoji-picker__category-button");
      this.options.icons && this.options.icons.categories && this.options.icons.categories[e4] ? n3.appendChild(Vo(this.options.icons.categories[e4])) : n3.innerHTML = Qo[e4], n3.tabIndex = -1, n3.title = this.i18n.categories[e4], o3.appendChild(n3), this.buttons.push(n3), n3.addEventListener("click", () => {
        this.events.emit("categoryClicked", e4);
      });
    }), o3.addEventListener("keydown", (e4) => {
      switch (e4.key) {
        case "ArrowRight":
          this.events.emit("categoryClicked", i2[(this.activeButton + 1) % this.buttons.length]);
          break;
        case "ArrowLeft":
          this.events.emit("categoryClicked", i2[this.activeButton === 0 ? this.buttons.length - 1 : this.activeButton - 1]);
          break;
        case "ArrowUp":
        case "ArrowDown":
          e4.stopPropagation(), e4.preventDefault();
      }
    }), o3;
  }
  setActiveButton(e3, o3 = true) {
    let n2 = this.buttons[this.activeButton];
    n2.classList.remove("active"), n2.tabIndex = -1, this.activeButton = e3, n2 = this.buttons[this.activeButton], n2.classList.add("active"), n2.tabIndex = 0, o3 && n2.focus();
  }
}
const on = ["recents", "smileys", "people", "animals", "food", "activities", "travel", "objects", "symbols", "flags", "custom"];
class nn {
  constructor(e3, o3, n2, i2) {
    var a2;
    this.events = e3, this.i18n = o3, this.options = n2, this.emojiCategories = i2, this.currentCategory = 0, this.headers = [], this.focusedIndex = 0, this.handleKeyDown = (e4) => {
      switch (this.emojis.removeEventListener("scroll", this.highlightCategory), e4.key) {
        case "ArrowRight":
          this.focusedEmoji.tabIndex = -1, this.focusedIndex === this.currentEmojiCount - 1 && this.currentCategory < this.categories.length - 1 ? (this.options.showCategoryButtons && this.categoryButtons.setActiveButton(++this.currentCategory), this.setFocusedEmoji(0)) : this.focusedIndex < this.currentEmojiCount - 1 && this.setFocusedEmoji(this.focusedIndex + 1);
          break;
        case "ArrowLeft":
          this.focusedEmoji.tabIndex = -1, this.focusedIndex === 0 && this.currentCategory > 0 ? (this.options.showCategoryButtons && this.categoryButtons.setActiveButton(--this.currentCategory), this.setFocusedEmoji(this.currentEmojiCount - 1)) : this.setFocusedEmoji(Math.max(0, this.focusedIndex - 1));
          break;
        case "ArrowDown":
          e4.preventDefault(), this.focusedEmoji.tabIndex = -1, this.focusedIndex + this.emojisPerRow >= this.currentEmojiCount && this.currentCategory < this.categories.length - 1 ? (this.currentCategory++, this.options.showCategoryButtons && this.categoryButtons.setActiveButton(this.currentCategory), this.setFocusedEmoji(Math.min(this.focusedIndex % this.emojisPerRow, this.currentEmojiCount - 1))) : this.currentEmojiCount - this.focusedIndex > this.emojisPerRow && this.setFocusedEmoji(this.focusedIndex + this.emojisPerRow);
          break;
        case "ArrowUp":
          if (e4.preventDefault(), this.focusedEmoji.tabIndex = -1, this.focusedIndex < this.emojisPerRow && this.currentCategory > 0) {
            const e5 = this.getEmojiCount(this.currentCategory - 1);
            let o4 = e5 % this.emojisPerRow;
            o4 === 0 && (o4 = this.emojisPerRow);
            const n3 = this.focusedIndex, i3 = n3 > o4 - 1 ? e5 - 1 : e5 - o4 + n3;
            this.currentCategory--, this.options.showCategoryButtons && this.categoryButtons.setActiveButton(this.currentCategory), this.setFocusedEmoji(i3);
          } else
            this.setFocusedEmoji(this.focusedIndex >= this.emojisPerRow ? this.focusedIndex - this.emojisPerRow : this.focusedIndex);
      }
      requestAnimationFrame(() => this.emojis.addEventListener("scroll", this.highlightCategory));
    }, this.addCategory = (e4, o4) => {
      const n3 = Ee("h2", "emoji-picker__category-name");
      n3.innerHTML = this.i18n.categories[e4] || Zo.categories[e4], this.emojis.appendChild(n3), this.headers.push(n3), this.emojis.appendChild(new Wo(o4, true, this.events, this.options, e4 !== "recents").render());
    }, this.selectCategory = (e4, o4 = true) => {
      this.emojis.removeEventListener("scroll", this.highlightCategory), this.focusedEmoji && (this.focusedEmoji.tabIndex = -1);
      const n3 = this.categories.indexOf(e4);
      this.currentCategory = n3, this.setFocusedEmoji(0, false), this.options.showCategoryButtons && this.categoryButtons.setActiveButton(this.currentCategory, o4);
      const i3 = this.headerOffsets[n3];
      this.emojis.scrollTop = i3, requestAnimationFrame(() => this.emojis.addEventListener("scroll", this.highlightCategory));
    }, this.highlightCategory = () => {
      if (document.activeElement && document.activeElement.classList.contains("emoji-picker__emoji"))
        return;
      let e4 = this.headerOffsets.findIndex((e5) => e5 >= Math.round(this.emojis.scrollTop));
      this.emojis.scrollTop + this.emojis.offsetHeight === this.emojis.scrollHeight && (e4 = -1), e4 === 0 ? e4 = 1 : e4 < 0 && (e4 = this.headerOffsets.length), this.headerOffsets[e4] === this.emojis.scrollTop && e4++, this.currentCategory = e4 - 1, this.options.showCategoryButtons && this.categoryButtons.setActiveButton(this.currentCategory);
    }, this.emojisPerRow = n2.emojisPerRow || 8, this.categories = ((a2 = n2.emojiData) === null || a2 === void 0 ? void 0 : a2.categories) || n2.categories || xe.categories, n2.showRecents && (this.categories = ["recents", ...this.categories]), n2.custom && (this.categories = [...this.categories, "custom"]), this.categories.sort((e4, o4) => on.indexOf(e4) - on.indexOf(o4));
  }
  updateRecents() {
    if (this.options.showRecents) {
      this.emojiCategories.recents = Ho();
      const e3 = this.emojis.querySelector(".emoji-picker__container");
      e3 && e3.parentNode && e3.parentNode.replaceChild(new Wo(this.emojiCategories.recents, true, this.events, this.options, false).render(), e3);
    }
  }
  render() {
    this.container = Ee("div", "emoji-picker__emoji-area"), this.options.showCategoryButtons && (this.categoryButtons = new en(this.options, this.events, this.i18n), this.container.appendChild(this.categoryButtons.render())), this.emojis = Ee("div", "emoji-picker__emojis"), this.options.showRecents && (this.emojiCategories.recents = Ho()), this.options.custom && (this.emojiCategories.custom = this.options.custom.map((e3) => Object.assign(Object.assign({}, e3), { custom: true }))), this.categories.forEach((e3) => this.addCategory(e3, this.emojiCategories[e3])), requestAnimationFrame(() => {
      setTimeout(() => {
        setTimeout(() => this.emojis.addEventListener("scroll", this.highlightCategory));
      });
    }), this.emojis.addEventListener("keydown", this.handleKeyDown), this.events.on("categoryClicked", this.selectCategory), this.container.appendChild(this.emojis);
    return this.container.querySelectorAll("." + Ce)[0].tabIndex = 0, this.container;
  }
  reset() {
    this.headerOffsets = Array.prototype.map.call(this.headers, (e3) => e3.offsetTop), this.selectCategory(this.options.initialCategory || "smileys", false), this.currentCategory = this.categories.indexOf(this.options.initialCategory || "smileys"), this.options.showCategoryButtons && this.categoryButtons.setActiveButton(this.currentCategory, false);
  }
  get currentCategoryEl() {
    return this.emojis.querySelectorAll(".emoji-picker__container")[this.currentCategory];
  }
  get focusedEmoji() {
    return this.currentCategoryEl.querySelectorAll("." + Ce)[this.focusedIndex];
  }
  get currentEmojiCount() {
    return this.currentCategoryEl.querySelectorAll("." + Ce).length;
  }
  getEmojiCount(e3) {
    return this.emojis.querySelectorAll(".emoji-picker__container")[e3].querySelectorAll("." + Ce).length;
  }
  setFocusedEmoji(e3, o3 = true) {
    this.focusedIndex = e3, this.focusedEmoji && (this.focusedEmoji.tabIndex = 0, o3 && this.focusedEmoji.focus());
  }
}
const an = { position: "auto", autoHide: true, autoFocusSearch: true, showAnimation: true, showPreview: true, showSearch: true, showRecents: true, showVariants: true, showCategoryButtons: true, recentsCount: 50, emojiData: xe, emojiVersion: "12.1", theme: "light", categories: ["smileys", "people", "animals", "food", "activities", "travel", "objects", "symbols", "flags"], style: "native", twemojiOptions: { ext: ".svg", folder: "svg" }, emojisPerRow: 8, rows: 6, emojiSize: "1.8em", initialCategory: "smileys" };
class rn {
  constructor(e3 = {}) {
    this.events = new b(), this.publicEvents = new b(), this.pickerVisible = false, this.options = Object.assign(Object.assign({}, an), e3), this.options.rootElement || (this.options.rootElement = document.body), this.i18n = Object.assign(Object.assign({}, Zo), e3.i18n), this.onDocumentClick = this.onDocumentClick.bind(this), this.onDocumentKeydown = this.onDocumentKeydown.bind(this), this.theme = this.options.theme || "light", this.emojiCategories = function(e4) {
      const o3 = {};
      return e4.emoji.forEach((n2) => {
        let i2 = o3[e4.categories[n2.category || 0]];
        i2 || (i2 = o3[e4.categories[n2.category || 0]] = []), i2.push(n2);
      }), o3;
    }(this.options.emojiData || xe), this.buildPicker();
  }
  on(e3, o3) {
    this.publicEvents.on(e3, o3);
  }
  off(e3, o3) {
    this.publicEvents.off(e3, o3);
  }
  setStyleProperties() {
    this.options.showAnimation || this.pickerEl.style.setProperty("--animation-duration", "0s"), this.options.emojisPerRow && this.pickerEl.style.setProperty("--emoji-per-row", this.options.emojisPerRow.toString()), this.options.rows && this.pickerEl.style.setProperty("--row-count", this.options.rows.toString()), this.options.emojiSize && this.pickerEl.style.setProperty("--emoji-size", this.options.emojiSize), this.options.showCategoryButtons || this.pickerEl.style.setProperty("--category-button-height", "0"), this.options.styleProperties && Object.keys(this.options.styleProperties).forEach((e3) => {
      this.options.styleProperties && this.pickerEl.style.setProperty(e3, this.options.styleProperties[e3]);
    });
  }
  showSearchResults(e3) {
    _e(this.pickerContent), e3.classList.add("search-results"), this.pickerContent.appendChild(e3);
  }
  hideSearchResults() {
    this.pickerContent.firstChild !== this.emojiArea.container && (_e(this.pickerContent), this.pickerContent.appendChild(this.emojiArea.container)), this.emojiArea.reset();
  }
  emitEmoji({ emoji: o3, showVariants: n2 }) {
    return e(this, void 0, void 0, function* () {
      if (o3.variations && n2 && this.options.showVariants)
        this.showVariantPopup(o3);
      else {
        let e3;
        setTimeout(() => this.emojiArea.updateRecents()), e3 = o3.custom ? this.emitCustomEmoji(o3) : this.options.style === "twemoji" ? yield this.emitTwemoji(o3) : this.emitNativeEmoji(o3), this.publicEvents.emit("emoji", e3), this.options.autoHide && this.hidePicker();
      }
    });
  }
  emitNativeEmoji(e3) {
    return { emoji: e3.emoji, name: e3.name };
  }
  emitCustomEmoji(e3) {
    return { url: e3.emoji, name: e3.name, custom: true };
  }
  emitTwemoji(e3) {
    return new Promise((o3) => {
      ke.parse(e3.emoji, Object.assign(Object.assign({}, this.options.twemojiOptions), { callback: (n2, { base: i2, size: a2, ext: r2 }) => {
        const t2 = `${i2}${a2}/${n2}${r2}`;
        return o3({ url: t2, emoji: e3.emoji, name: e3.name }), t2;
      } }));
    });
  }
  buildSearch() {
    var e3;
    this.options.showSearch && (this.search = new Yo(this.events, this.i18n, this.options, ((e3 = this.options.emojiData) === null || e3 === void 0 ? void 0 : e3.emoji) || xe.emoji, (this.options.categories || []).map((e4) => (this.options.emojiData || xe).categories.indexOf(e4))), this.pickerEl.appendChild(this.search.render()));
  }
  buildPreview() {
    this.options.showPreview && this.pickerEl.appendChild(new Oe(this.events, this.options).render());
  }
  initPlugins() {
    if (this.options.plugins) {
      const e3 = Ee("div", "emoji-picker__plugin-container");
      this.options.plugins.forEach((o3) => {
        if (!o3.render)
          throw new Error('Emoji Button plugins must have a "render" function.');
        e3.appendChild(o3.render(this));
      }), this.pickerEl.appendChild(e3);
    }
  }
  initFocusTrap() {
    this.focusTrap = h(this.pickerEl, { clickOutsideDeactivates: true, initialFocus: this.options.showSearch && this.options.autoFocusSearch ? ".emoji-picker__search" : '.emoji-picker__emoji[tabindex="0"]' });
  }
  buildPicker() {
    this.pickerEl = Ee("div", "emoji-picker"), this.pickerEl.classList.add(this.theme), this.setStyleProperties(), this.initFocusTrap(), this.pickerContent = Ee("div", "emoji-picker__content"), this.initPlugins(), this.buildSearch(), this.pickerEl.appendChild(this.pickerContent), this.emojiArea = new nn(this.events, this.i18n, this.options, this.emojiCategories), this.pickerContent.appendChild(this.emojiArea.render()), this.events.on("showSearchResults", this.showSearchResults.bind(this)), this.events.on("hideSearchResults", this.hideSearchResults.bind(this)), this.events.on("emoji", this.emitEmoji.bind(this)), this.buildPreview(), this.wrapper = Ee("div", "emoji-picker__wrapper"), this.wrapper.appendChild(this.pickerEl), this.wrapper.style.display = "none", this.options.zIndex && (this.wrapper.style.zIndex = this.options.zIndex + ""), this.options.rootElement && this.options.rootElement.appendChild(this.wrapper), this.observeForLazyLoad();
  }
  showVariantPopup(e3) {
    const o3 = new $o(this.events, e3, this.options).render();
    o3 && this.pickerEl.appendChild(o3), this.events.on("hideVariantPopup", () => {
      o3 && (o3.classList.add("hiding"), setTimeout(() => {
        o3 && this.pickerEl.removeChild(o3);
      }, 175)), this.events.off("hideVariantPopup");
    });
  }
  observeForLazyLoad() {
    this.observer = new IntersectionObserver(this.handleIntersectionChange.bind(this), { root: this.emojiArea.emojis }), this.emojiArea.emojis.querySelectorAll("." + Ce).forEach((e3) => {
      this.shouldLazyLoad(e3) && this.observer.observe(e3);
    });
  }
  handleIntersectionChange(e3) {
    Array.prototype.filter.call(e3, (e4) => e4.intersectionRatio > 0).map((e4) => e4.target).forEach((e4) => {
      ze(e4, this.options);
    });
  }
  shouldLazyLoad(e3) {
    return this.options.style === "twemoji" || e3.dataset.custom === "true";
  }
  onDocumentClick(e3) {
    this.pickerEl.contains(e3.target) || this.hidePicker();
  }
  destroyPicker() {
    this.events.off("emoji"), this.events.off("hideVariantPopup"), this.options.rootElement && (this.options.rootElement.removeChild(this.wrapper), this.popper && this.popper.destroy()), this.observer && this.observer.disconnect(), this.options.plugins && this.options.plugins.forEach((e3) => {
      e3.destroy && e3.destroy();
    });
  }
  hidePicker() {
    this.hideInProgress = true, this.focusTrap.deactivate(), this.pickerVisible = false, this.overlay && (document.body.removeChild(this.overlay), this.overlay = void 0), this.emojiArea.emojis.removeEventListener("scroll", this.emojiArea.highlightCategory), this.pickerEl.classList.add("hiding"), setTimeout(() => {
      this.wrapper.style.display = "none", this.pickerEl.classList.remove("hiding"), this.pickerContent.firstChild !== this.emojiArea.container && (_e(this.pickerContent), this.pickerContent.appendChild(this.emojiArea.container)), this.search && this.search.clear(), this.events.emit("hideVariantPopup"), this.hideInProgress = false, this.popper && this.popper.destroy(), this.publicEvents.emit("hidden");
    }, this.options.showAnimation ? 170 : 0), setTimeout(() => {
      document.removeEventListener("click", this.onDocumentClick), document.removeEventListener("keydown", this.onDocumentKeydown);
    });
  }
  showPicker(e3) {
    this.hideInProgress ? setTimeout(() => this.showPicker(e3), 100) : (this.pickerVisible = true, this.wrapper.style.display = "block", this.determineDisplay(e3), this.focusTrap.activate(), setTimeout(() => {
      this.addEventListeners(), this.setInitialFocus();
    }), this.emojiArea.reset());
  }
  determineDisplay(e3) {
    window.matchMedia("screen and (max-width: 450px)").matches ? this.showMobileView() : typeof this.options.position == "string" ? this.setRelativePosition(e3) : this.setFixedPosition();
  }
  setInitialFocus() {
    this.pickerEl.querySelector(this.options.showSearch && this.options.autoFocusSearch ? ".emoji-picker__search" : `.${Ce}[tabindex="0"]`).focus();
  }
  addEventListeners() {
    document.addEventListener("click", this.onDocumentClick), document.addEventListener("keydown", this.onDocumentKeydown);
  }
  setRelativePosition(e3) {
    this.popper = we(e3, this.wrapper, { placement: this.options.position });
  }
  setFixedPosition() {
    var e3;
    if ((e3 = this.options) === null || e3 === void 0 ? void 0 : e3.position) {
      this.wrapper.style.position = "fixed";
      const e4 = this.options.position;
      Object.keys(e4).forEach((o3) => {
        this.wrapper.style[o3] = e4[o3];
      });
    }
  }
  showMobileView() {
    const e3 = window.getComputedStyle(this.pickerEl), o3 = document.querySelector("html"), n2 = o3 && o3.clientHeight, i2 = o3 && o3.clientWidth, a2 = parseInt(e3.height), r2 = n2 ? n2 / 2 - a2 / 2 : 0, t2 = parseInt(e3.width), s2 = i2 ? i2 / 2 - t2 / 2 : 0;
    this.wrapper.style.position = "fixed", this.wrapper.style.top = r2 + "px", this.wrapper.style.left = s2 + "px", this.wrapper.style.zIndex = "5000", this.overlay = Ee("div", "emoji-picker__overlay"), document.body.appendChild(this.overlay);
  }
  togglePicker(e3) {
    this.pickerVisible ? this.hidePicker() : this.showPicker(e3);
  }
  isPickerVisible() {
    return this.pickerVisible;
  }
  onDocumentKeydown(e3) {
    e3.key === "Escape" ? this.hidePicker() : e3.key === "Tab" ? this.pickerEl.classList.add("keyboard") : e3.key.match(/^[\w]$/) && this.search && this.search.focus();
  }
  setTheme(e3) {
    e3 !== this.theme && (this.pickerEl.classList.remove(this.theme), this.theme = e3, this.pickerEl.classList.add(e3));
  }
}
const keyword = ":emoji:";
const checkTrigger = (view, from5, to2, text3, setRange) => {
  if (view.composing)
    return false;
  const { state } = view;
  const $from = state.doc.resolve(from5);
  if ($from.parent.type.spec.code)
    return false;
  const textBefore = $from.parent.textBetween($from.parentOffset - keyword.length + 1, $from.parentOffset, void 0, "\uFFFC") + text3;
  if (textBefore === keyword) {
    setRange(from5 - keyword.length + 1, to2 + 1);
    return true;
  }
  return false;
};
const pickerPlugin = () => {
  let trigger = false;
  const holder = document.createElement("span");
  let _from = 0;
  let _to = 0;
  const off = () => {
    trigger = false;
    _from = 0;
    _to = 0;
  };
  const plugin2 = new Plugin({
    props: {
      handleKeyDown() {
        off();
        return false;
      },
      handleClick() {
        off();
        return false;
      },
      handleTextInput(view, from5, to2, text3) {
        trigger = checkTrigger(view, from5, to2, text3, (from6, to3) => {
          _from = from6;
          _to = to3;
        });
        if (!trigger) {
          off();
        }
        return false;
      },
      decorations(state) {
        if (!trigger)
          return null;
        return DecorationSet$1.create(state.doc, [Decoration$1.widget(state.selection.to, holder)]);
      }
    },
    view: (editorView2) => {
      const { parentNode: parentNode2 } = editorView2.dom;
      if (!parentNode2) {
        throw new Error();
      }
      const emojiPicker = new rn({
        autoFocusSearch: false,
        style: "twemoji",
        theme: "dark",
        zIndex: 99
      });
      emojiPicker.on("emoji", (selection) => {
        const start4 = _from;
        const end3 = _to;
        off();
        const html2 = parse3(selection.emoji);
        const node5 = editorView2.state.schema.node("emoji", { html: html2 });
        const { tr } = editorView2.state;
        editorView2.dispatch(tr.replaceRangeWith(start4, end3, node5));
      });
      return {
        update: () => {
          if (!trigger) {
            emojiPicker.hidePicker();
            return null;
          }
          emojiPicker.showPicker(holder);
          return null;
        },
        destroy: () => {
          emojiPicker.destroyPicker();
        }
      };
    }
  });
  return plugin2;
};
const picker = prosePluginFactory(pickerPlugin());
var emojiRegex = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
const regex = emojiRegex();
const isParent = (node5) => !!node5.children;
const isLiteral = (node5) => !!node5.value;
function flatMap(ast, fn) {
  return transform(ast, 0, null)[0];
  function transform(node5, index3, parent) {
    if (isParent(node5)) {
      const out = [];
      for (let i2 = 0, n2 = node5.children.length; i2 < n2; i2++) {
        const xs = transform(node5.children[i2], i2, node5);
        if (xs) {
          for (let j2 = 0, m2 = xs.length; j2 < m2; j2++) {
            out.push(xs[j2]);
          }
        }
      }
      node5.children = out;
    }
    return fn(node5, index3, parent);
  }
}
const twemojiPlugin = () => {
  function transformer(tree) {
    flatMap(tree, (node5) => {
      if (!isLiteral(node5)) {
        return [node5];
      }
      const value = node5.value;
      const output = [];
      let match;
      let str = value;
      while (match = regex.exec(str)) {
        const { index: index3 } = match;
        const emoji2 = match[0];
        if (index3 > 0) {
          output.push(Object.assign(Object.assign({}, node5), { value: str.slice(0, index3) }));
        }
        output.push(Object.assign(Object.assign({}, node5), { value: parse3(emoji2), type: "emoji" }));
        str = str.slice(index3 + emoji2.length);
      }
      if (str.length) {
        output.push(Object.assign(Object.assign({}, node5), { value: str }));
      }
      return output;
    });
  }
  return transformer;
};
const remarkPlugin = remarkPluginFactory([remarkEmoji, twemojiPlugin]);
const emoji = [emojiNode(), remarkPlugin, picker, filter];
var katex$1 = { exports: {} };
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory2) {
    module2.exports = factory2();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return function() {
      var __webpack_require__ = {};
      !function() {
        __webpack_require__.d = function(exports3, definition2) {
          for (var key2 in definition2) {
            if (__webpack_require__.o(definition2, key2) && !__webpack_require__.o(exports3, key2)) {
              Object.defineProperty(exports3, key2, { enumerable: true, get: definition2[key2] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      var __webpack_exports__ = {};
      __webpack_require__.d(__webpack_exports__, {
        "default": function() {
          return katex_webpack;
        }
      });
      var ParseError = function ParseError2(message2, token) {
        this.position = void 0;
        var error = "KaTeX parse error: " + message2;
        var start4;
        var loc = token && token.loc;
        if (loc && loc.start <= loc.end) {
          var input2 = loc.lexer.input;
          start4 = loc.start;
          var end3 = loc.end;
          if (start4 === input2.length) {
            error += " at end of input: ";
          } else {
            error += " at position " + (start4 + 1) + ": ";
          }
          var underlined = input2.slice(start4, end3).replace(/[^]/g, "$&\u0332");
          var left;
          if (start4 > 15) {
            left = "\u2026" + input2.slice(start4 - 15, start4);
          } else {
            left = input2.slice(0, start4);
          }
          var right;
          if (end3 + 15 < input2.length) {
            right = input2.slice(end3, end3 + 15) + "\u2026";
          } else {
            right = input2.slice(end3);
          }
          error += left + underlined + right;
        }
        var self2 = new Error(error);
        self2.name = "ParseError";
        self2.__proto__ = ParseError2.prototype;
        self2.position = start4;
        return self2;
      };
      ParseError.prototype.__proto__ = Error.prototype;
      var src_ParseError = ParseError;
      var contains = function contains2(list2, elem) {
        return list2.indexOf(elem) !== -1;
      };
      var deflt = function deflt2(setting, defaultIfUndefined) {
        return setting === void 0 ? defaultIfUndefined : setting;
      };
      var uppercase = /([A-Z])/g;
      var hyphenate = function hyphenate2(str) {
        return str.replace(uppercase, "-$1").toLowerCase();
      };
      var ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      var ESCAPE_REGEX = /[&><"']/g;
      function utils_escape(text3) {
        return String(text3).replace(ESCAPE_REGEX, function(match) {
          return ESCAPE_LOOKUP[match];
        });
      }
      var getBaseElem = function getBaseElem2(group) {
        if (group.type === "ordgroup") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "color") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "font") {
          return getBaseElem2(group.body);
        } else {
          return group;
        }
      };
      var isCharacterBox = function isCharacterBox2(group) {
        var baseElem = getBaseElem(group);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      };
      var assert = function assert2(value) {
        if (!value) {
          throw new Error("Expected non-null, but got " + String(value));
        }
        return value;
      };
      var protocolFromUrl = function protocolFromUrl2(url) {
        var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
        return protocol != null ? protocol[1] : "_relative";
      };
      var utils = {
        contains,
        deflt,
        escape: utils_escape,
        hyphenate,
        getBaseElem,
        isCharacterBox,
        protocolFromUrl
      };
      var Settings = /* @__PURE__ */ function() {
        function Settings2(options) {
          this.displayMode = void 0;
          this.output = void 0;
          this.leqno = void 0;
          this.fleqn = void 0;
          this.throwOnError = void 0;
          this.errorColor = void 0;
          this.macros = void 0;
          this.minRuleThickness = void 0;
          this.colorIsTextColor = void 0;
          this.strict = void 0;
          this.trust = void 0;
          this.maxSize = void 0;
          this.maxExpand = void 0;
          this.globalGroup = void 0;
          options = options || {};
          this.displayMode = utils.deflt(options.displayMode, false);
          this.output = utils.deflt(options.output, "htmlAndMathml");
          this.leqno = utils.deflt(options.leqno, false);
          this.fleqn = utils.deflt(options.fleqn, false);
          this.throwOnError = utils.deflt(options.throwOnError, true);
          this.errorColor = utils.deflt(options.errorColor, "#cc0000");
          this.macros = options.macros || {};
          this.minRuleThickness = Math.max(0, utils.deflt(options.minRuleThickness, 0));
          this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
          this.strict = utils.deflt(options.strict, "warn");
          this.trust = utils.deflt(options.trust, false);
          this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
          this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1e3));
          this.globalGroup = utils.deflt(options.globalGroup, false);
        }
        var _proto = Settings2.prototype;
        _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        };
        _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        };
        _proto.isTrusted = function isTrusted(context) {
          if (context.url && !context.protocol) {
            context.protocol = utils.protocolFromUrl(context.url);
          }
          var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
          return Boolean(trust);
        };
        return Settings2;
      }();
      var Style = /* @__PURE__ */ function() {
        function Style2(id2, size2, cramped) {
          this.id = void 0;
          this.size = void 0;
          this.cramped = void 0;
          this.id = id2;
          this.size = size2;
          this.cramped = cramped;
        }
        var _proto = Style2.prototype;
        _proto.sup = function sup() {
          return styles[_sup[this.id]];
        };
        _proto.sub = function sub() {
          return styles[_sub[this.id]];
        };
        _proto.fracNum = function fracNum() {
          return styles[_fracNum[this.id]];
        };
        _proto.fracDen = function fracDen() {
          return styles[_fracDen[this.id]];
        };
        _proto.cramp = function cramp() {
          return styles[_cramp[this.id]];
        };
        _proto.text = function text3() {
          return styles[_text[this.id]];
        };
        _proto.isTight = function isTight() {
          return this.size >= 2;
        };
        return Style2;
      }();
      var D2 = 0;
      var Dc = 1;
      var T2 = 2;
      var Tc = 3;
      var S2 = 4;
      var Sc = 5;
      var SS = 6;
      var SSc = 7;
      var styles = [new Style(D2, 0, false), new Style(Dc, 0, true), new Style(T2, 1, false), new Style(Tc, 1, true), new Style(S2, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
      var _sup = [S2, Sc, S2, Sc, SS, SSc, SS, SSc];
      var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
      var _fracNum = [T2, Tc, S2, Sc, SS, SSc, SS, SSc];
      var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
      var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
      var _text = [D2, Dc, T2, Tc, T2, Tc, T2, Tc];
      var src_Style = {
        DISPLAY: styles[D2],
        TEXT: styles[T2],
        SCRIPT: styles[S2],
        SCRIPTSCRIPT: styles[SS]
      };
      var scriptData = [{
        name: "latin",
        blocks: [
          [256, 591],
          [768, 879]
        ]
      }, {
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        name: "cjk",
        blocks: [
          [12288, 12543],
          [19968, 40879],
          [65280, 65376]
        ]
      }, {
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      function scriptFromCodepoint(codepoint) {
        for (var i3 = 0; i3 < scriptData.length; i3++) {
          var script = scriptData[i3];
          for (var _i6 = 0; _i6 < script.blocks.length; _i6++) {
            var block = script.blocks[_i6];
            if (codepoint >= block[0] && codepoint <= block[1]) {
              return script.name;
            }
          }
        }
        return null;
      }
      var allBlocks = [];
      scriptData.forEach(function(s2) {
        return s2.blocks.forEach(function(b2) {
          return allBlocks.push.apply(allBlocks, b2);
        });
      });
      function supportedCodepoint(codepoint) {
        for (var i3 = 0; i3 < allBlocks.length; i3 += 2) {
          if (codepoint >= allBlocks[i3] && codepoint <= allBlocks[i3 + 1]) {
            return true;
          }
        }
        return false;
      }
      var hLinePad = 80;
      var sqrtMain = function sqrtMain2(extraViniculum, hLinePad2) {
        return "M95," + (622 + extraViniculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize1 = function sqrtSize12(extraViniculum, hLinePad2) {
        return "M263," + (601 + extraViniculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize2 = function sqrtSize22(extraViniculum, hLinePad2) {
        return "M983 " + (10 + extraViniculum + hLinePad2) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize3 = function sqrtSize32(extraViniculum, hLinePad2) {
        return "M424," + (2398 + extraViniculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
      };
      var sqrtSize4 = function sqrtSize42(extraViniculum, hLinePad2) {
        return "M473," + (2713 + extraViniculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
      };
      var phasePath = function phasePath2(y2) {
        var x2 = y2 / 2;
        return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
      };
      var sqrtTall = function sqrtTall2(extraViniculum, hLinePad2, viewBoxHeight) {
        var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraViniculum;
        return "M702 " + (extraViniculum + hLinePad2) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraViniculum) + "H742z";
      };
      var sqrtPath = function sqrtPath2(size2, extraViniculum, viewBoxHeight) {
        extraViniculum = 1e3 * extraViniculum;
        var path3 = "";
        switch (size2) {
          case "sqrtMain":
            path3 = sqrtMain(extraViniculum, hLinePad);
            break;
          case "sqrtSize1":
            path3 = sqrtSize1(extraViniculum, hLinePad);
            break;
          case "sqrtSize2":
            path3 = sqrtSize2(extraViniculum, hLinePad);
            break;
          case "sqrtSize3":
            path3 = sqrtSize3(extraViniculum, hLinePad);
            break;
          case "sqrtSize4":
            path3 = sqrtSize4(extraViniculum, hLinePad);
            break;
          case "sqrtTall":
            path3 = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
        }
        return path3;
      };
      var innerPath = function innerPath2(name, height) {
        switch (name) {
          case "\u239C":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "\u2223":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "\u2225":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
          case "\u239F":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "\u23A2":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "\u23A5":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "\u23AA":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "\u23D0":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "\u2016":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      };
      var path2 = {
        doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
      };
      var DocumentFragment = /* @__PURE__ */ function() {
        function DocumentFragment2(children) {
          this.children = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.children = children;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        var _proto = DocumentFragment2.prototype;
        _proto.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto.toNode = function toNode() {
          var frag = document.createDocumentFragment();
          for (var i3 = 0; i3 < this.children.length; i3++) {
            frag.appendChild(this.children[i3].toNode());
          }
          return frag;
        };
        _proto.toMarkup = function toMarkup() {
          var markup = "";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          return markup;
        };
        _proto.toText = function toText() {
          var toText2 = function toText3(child4) {
            return child4.toText();
          };
          return this.children.map(toText2).join("");
        };
        return DocumentFragment2;
      }();
      var createClass = function createClass2(classes) {
        return classes.filter(function(cls) {
          return cls;
        }).join(" ");
      };
      var initNode = function initNode2(classes, options, style) {
        this.classes = classes || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style || {};
        if (options) {
          if (options.style.isTight()) {
            this.classes.push("mtight");
          }
          var color2 = options.getColor();
          if (color2) {
            this.style.color = color2;
          }
        }
      };
      var _toNode = function toNode(tagName) {
        var node5 = document.createElement(tagName);
        node5.className = createClass(this.classes);
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            node5.style[style] = this.style[style];
          }
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node5.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i3 = 0; i3 < this.children.length; i3++) {
          node5.appendChild(this.children[i3].toNode());
        }
        return node5;
      };
      var _toMarkup = function toMarkup(tagName) {
        var markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
        }
        var styles2 = "";
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles2) {
          markup += ' style="' + utils.escape(styles2) + '"';
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (var i3 = 0; i3 < this.children.length; i3++) {
          markup += this.children[i3].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      };
      var Span = /* @__PURE__ */ function() {
        function Span2(classes, children, options, style) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options, style);
          this.children = children || [];
        }
        var _proto = Span2.prototype;
        _proto.setAttribute = function setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        };
        _proto.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto.toNode = function toNode() {
          return _toNode.call(this, "span");
        };
        _proto.toMarkup = function toMarkup() {
          return _toMarkup.call(this, "span");
        };
        return Span2;
      }();
      var Anchor = /* @__PURE__ */ function() {
        function Anchor2(href, classes, children, options) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options);
          this.children = children || [];
          this.setAttribute("href", href);
        }
        var _proto2 = Anchor2.prototype;
        _proto2.setAttribute = function setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        };
        _proto2.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto2.toNode = function toNode() {
          return _toNode.call(this, "a");
        };
        _proto2.toMarkup = function toMarkup() {
          return _toMarkup.call(this, "a");
        };
        return Anchor2;
      }();
      var Img = /* @__PURE__ */ function() {
        function Img2(src, alt, style) {
          this.src = void 0;
          this.alt = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style;
        }
        var _proto3 = Img2.prototype;
        _proto3.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto3.toNode = function toNode() {
          var node5 = document.createElement("img");
          node5.src = this.src;
          node5.alt = this.alt;
          node5.className = "mord";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node5.style[style] = this.style[style];
            }
          }
          return node5;
        };
        _proto3.toMarkup = function toMarkup() {
          var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
          var styles2 = "";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          markup += "'/>";
          return markup;
        };
        return Img2;
      }();
      var iCombinations = {
        "\xEE": "\u0131\u0302",
        "\xEF": "\u0131\u0308",
        "\xED": "\u0131\u0301",
        "\xEC": "\u0131\u0300"
      };
      var SymbolNode = /* @__PURE__ */ function() {
        function SymbolNode2(text3, height, depth, italic, skew, width, classes, style) {
          this.text = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.italic = void 0;
          this.skew = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.classes = void 0;
          this.style = void 0;
          this.text = text3;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style || {};
          this.maxFontSize = 0;
          var script = scriptFromCodepoint(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[]/.test(this.text)) {
            this.text = iCombinations[this.text];
          }
        }
        var _proto4 = SymbolNode2.prototype;
        _proto4.hasClass = function hasClass(className) {
          return utils.contains(this.classes, className);
        };
        _proto4.toNode = function toNode() {
          var node5 = document.createTextNode(this.text);
          var span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = this.italic + "em";
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass(this.classes);
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              span = span || document.createElement("span");
              span.style[style] = this.style[style];
            }
          }
          if (span) {
            span.appendChild(node5);
            return span;
          } else {
            return node5;
          }
        };
        _proto4.toMarkup = function toMarkup() {
          var needsSpan = false;
          var markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils.escape(createClass(this.classes));
            markup += '"';
          }
          var styles2 = "";
          if (this.italic > 0) {
            styles2 += "margin-right:" + this.italic + "em;";
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            needsSpan = true;
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          var escaped = utils.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        };
        return SymbolNode2;
      }();
      var SvgNode = /* @__PURE__ */ function() {
        function SvgNode2(children, attributes) {
          this.children = void 0;
          this.attributes = void 0;
          this.children = children || [];
          this.attributes = attributes || {};
        }
        var _proto5 = SvgNode2.prototype;
        _proto5.toNode = function toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node5 = document.createElementNS(svgNS, "svg");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node5.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i3 = 0; i3 < this.children.length; i3++) {
            node5.appendChild(this.children[i3].toNode());
          }
          return node5;
        };
        _proto5.toMarkup = function toMarkup() {
          var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + "='" + this.attributes[attr] + "'";
            }
          }
          markup += ">";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          markup += "</svg>";
          return markup;
        };
        return SvgNode2;
      }();
      var PathNode = /* @__PURE__ */ function() {
        function PathNode2(pathName, alternate) {
          this.pathName = void 0;
          this.alternate = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        var _proto6 = PathNode2.prototype;
        _proto6.toNode = function toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node5 = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node5.setAttribute("d", this.alternate);
          } else {
            node5.setAttribute("d", path2[this.pathName]);
          }
          return node5;
        };
        _proto6.toMarkup = function toMarkup() {
          if (this.alternate) {
            return "<path d='" + this.alternate + "'/>";
          } else {
            return "<path d='" + path2[this.pathName] + "'/>";
          }
        };
        return PathNode2;
      }();
      var LineNode = /* @__PURE__ */ function() {
        function LineNode2(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        var _proto7 = LineNode2.prototype;
        _proto7.toNode = function toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node5 = document.createElementNS(svgNS, "line");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node5.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node5;
        };
        _proto7.toMarkup = function toMarkup() {
          var markup = "<line";
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + "='" + this.attributes[attr] + "'";
            }
          }
          markup += "/>";
          return markup;
        };
        return LineNode2;
      }();
      function assertSymbolDomNode(group) {
        if (group instanceof SymbolNode) {
          return group;
        } else {
          throw new Error("Expected symbolNode but got " + String(group) + ".");
        }
      }
      function assertSpan(group) {
        if (group instanceof Span) {
          return group;
        } else {
          throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
        }
      }
      var fontMetricsData = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [222e-5, 0.50222, 0, 0, 0.89444],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [222e-5, 0.50222, 0, 0, 0.89444],
          "8801": [222e-5, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.12, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 1],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.67, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [5e-3, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.9, 0, 0, 0.278],
          "8943": [-0.19, 0.31, 0, 0, 1.172],
          "8945": [-0.1, 0.82, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.744, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.744, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 421e-5, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 88e-4, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 316e-5, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 981e-5, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 316e-5, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-99e-5, 0.601, 0, 0, 0.77778],
          "8593": [1e-5, 0.6, 0, 0, 0.66667],
          "8595": [1e-5, 0.6, 0, 0, 0.66667],
          "8657": [1e-5, 0.6, 0, 0, 0.77778],
          "8659": [1e-5, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-599e-5, 0.606, 0, 0, 0.33333],
          "8741": [-599e-5, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-99e-5, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [1e-5, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [1e-5, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-99e-5, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-99e-5, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [1e-5, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [1e-5, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-499e-5, 0.605, 0, 0, 1.05556],
          "57345": [-499e-5, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      var sigmasAndXis = {
        slant: [0.25, 0.25, 0.25],
        space: [0, 0, 0],
        stretch: [0, 0, 0],
        shrink: [0, 0, 0],
        xHeight: [0.431, 0.431, 0.431],
        quad: [1, 1.171, 1.472],
        extraSpace: [0, 0, 0],
        num1: [0.677, 0.732, 0.925],
        num2: [0.394, 0.384, 0.387],
        num3: [0.444, 0.471, 0.504],
        denom1: [0.686, 0.752, 1.025],
        denom2: [0.345, 0.344, 0.532],
        sup1: [0.413, 0.503, 0.504],
        sup2: [0.363, 0.431, 0.404],
        sup3: [0.289, 0.286, 0.294],
        sub1: [0.15, 0.143, 0.2],
        sub2: [0.247, 0.286, 0.4],
        supDrop: [0.386, 0.353, 0.494],
        subDrop: [0.05, 0.071, 0.1],
        delim1: [2.39, 1.7, 1.98],
        delim2: [1.01, 1.157, 1.42],
        axisHeight: [0.25, 0.25, 0.25],
        defaultRuleThickness: [0.04, 0.049, 0.049],
        bigOpSpacing1: [0.111, 0.111, 0.111],
        bigOpSpacing2: [0.166, 0.166, 0.166],
        bigOpSpacing3: [0.2, 0.2, 0.2],
        bigOpSpacing4: [0.6, 0.611, 0.611],
        bigOpSpacing5: [0.1, 0.143, 0.143],
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        ptPerEm: [10, 10, 10],
        doubleRuleSep: [0.2, 0.2, 0.2],
        arrayRuleWidth: [0.04, 0.04, 0.04],
        fboxsep: [0.3, 0.3, 0.3],
        fboxrule: [0.04, 0.04, 0.04]
      };
      var extraCharacterMap = {
        "\xC5": "A",
        "\xC7": "C",
        "\xD0": "D",
        "\xDE": "o",
        "\xE5": "a",
        "\xE7": "c",
        "\xF0": "d",
        "\xFE": "o",
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "B",
        "\u0413": "F",
        "\u0414": "A",
        "\u0415": "E",
        "\u0416": "K",
        "\u0417": "3",
        "\u0418": "N",
        "\u0419": "N",
        "\u041A": "K",
        "\u041B": "N",
        "\u041C": "M",
        "\u041D": "H",
        "\u041E": "O",
        "\u041F": "N",
        "\u0420": "P",
        "\u0421": "C",
        "\u0422": "T",
        "\u0423": "y",
        "\u0424": "O",
        "\u0425": "X",
        "\u0426": "U",
        "\u0427": "h",
        "\u0428": "W",
        "\u0429": "W",
        "\u042A": "B",
        "\u042B": "X",
        "\u042C": "B",
        "\u042D": "3",
        "\u042E": "X",
        "\u042F": "R",
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "a",
        "\u0433": "r",
        "\u0434": "y",
        "\u0435": "e",
        "\u0436": "m",
        "\u0437": "e",
        "\u0438": "n",
        "\u0439": "n",
        "\u043A": "n",
        "\u043B": "n",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "n",
        "\u0440": "p",
        "\u0441": "c",
        "\u0442": "o",
        "\u0443": "y",
        "\u0444": "b",
        "\u0445": "x",
        "\u0446": "n",
        "\u0447": "n",
        "\u0448": "w",
        "\u0449": "w",
        "\u044A": "a",
        "\u044B": "m",
        "\u044C": "a",
        "\u044D": "e",
        "\u044E": "m",
        "\u044F": "r"
      };
      function setFontMetrics(fontName, metrics) {
        fontMetricsData[fontName] = metrics;
      }
      function getCharacterMetrics(character, font, mode) {
        if (!fontMetricsData[font]) {
          throw new Error("Font metrics not found for font: " + font + ".");
        }
        var ch2 = character.charCodeAt(0);
        var metrics = fontMetricsData[font][ch2];
        if (!metrics && character[0] in extraCharacterMap) {
          ch2 = extraCharacterMap[character[0]].charCodeAt(0);
          metrics = fontMetricsData[font][ch2];
        }
        if (!metrics && mode === "text") {
          if (supportedCodepoint(ch2)) {
            metrics = fontMetricsData[font][77];
          }
        }
        if (metrics) {
          return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
          };
        }
      }
      var fontMetricsBySizeIndex = {};
      function getGlobalMetrics(size2) {
        var sizeIndex;
        if (size2 >= 5) {
          sizeIndex = 0;
        } else if (size2 >= 3) {
          sizeIndex = 1;
        } else {
          sizeIndex = 2;
        }
        if (!fontMetricsBySizeIndex[sizeIndex]) {
          var metrics = fontMetricsBySizeIndex[sizeIndex] = {
            cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
          };
          for (var key2 in sigmasAndXis) {
            if (sigmasAndXis.hasOwnProperty(key2)) {
              metrics[key2] = sigmasAndXis[key2][sizeIndex];
            }
          }
        }
        return fontMetricsBySizeIndex[sizeIndex];
      }
      var ATOMS = {
        "bin": 1,
        "close": 1,
        "inner": 1,
        "open": 1,
        "punct": 1,
        "rel": 1
      };
      var NON_ATOMS = {
        "accent-token": 1,
        "mathord": 1,
        "op-token": 1,
        "spacing": 1,
        "textord": 1
      };
      var symbols2 = {
        "math": {},
        "text": {}
      };
      var src_symbols = symbols2;
      function defineSymbol(mode, font, group, replace4, name, acceptUnicodeChar) {
        symbols2[mode][name] = {
          font,
          group,
          replace: replace4
        };
        if (acceptUnicodeChar && replace4) {
          symbols2[mode][replace4] = symbols2[mode][name];
        }
      }
      var math2 = "math";
      var symbols_text = "text";
      var main = "main";
      var ams = "ams";
      var accent = "accent-token";
      var bin = "bin";
      var symbols_close = "close";
      var inner = "inner";
      var mathord = "mathord";
      var op = "op-token";
      var symbols_open = "open";
      var punct = "punct";
      var rel = "rel";
      var spacing = "spacing";
      var textord = "textord";
      defineSymbol(math2, main, rel, "\u2261", "\\equiv", true);
      defineSymbol(math2, main, rel, "\u227A", "\\prec", true);
      defineSymbol(math2, main, rel, "\u227B", "\\succ", true);
      defineSymbol(math2, main, rel, "\u223C", "\\sim", true);
      defineSymbol(math2, main, rel, "\u22A5", "\\perp");
      defineSymbol(math2, main, rel, "\u2AAF", "\\preceq", true);
      defineSymbol(math2, main, rel, "\u2AB0", "\\succeq", true);
      defineSymbol(math2, main, rel, "\u2243", "\\simeq", true);
      defineSymbol(math2, main, rel, "\u2223", "\\mid", true);
      defineSymbol(math2, main, rel, "\u226A", "\\ll", true);
      defineSymbol(math2, main, rel, "\u226B", "\\gg", true);
      defineSymbol(math2, main, rel, "\u224D", "\\asymp", true);
      defineSymbol(math2, main, rel, "\u2225", "\\parallel");
      defineSymbol(math2, main, rel, "\u22C8", "\\bowtie", true);
      defineSymbol(math2, main, rel, "\u2323", "\\smile", true);
      defineSymbol(math2, main, rel, "\u2291", "\\sqsubseteq", true);
      defineSymbol(math2, main, rel, "\u2292", "\\sqsupseteq", true);
      defineSymbol(math2, main, rel, "\u2250", "\\doteq", true);
      defineSymbol(math2, main, rel, "\u2322", "\\frown", true);
      defineSymbol(math2, main, rel, "\u220B", "\\ni", true);
      defineSymbol(math2, main, rel, "\u221D", "\\propto", true);
      defineSymbol(math2, main, rel, "\u22A2", "\\vdash", true);
      defineSymbol(math2, main, rel, "\u22A3", "\\dashv", true);
      defineSymbol(math2, main, rel, "\u220B", "\\owns");
      defineSymbol(math2, main, punct, ".", "\\ldotp");
      defineSymbol(math2, main, punct, "\u22C5", "\\cdotp");
      defineSymbol(math2, main, textord, "#", "\\#");
      defineSymbol(symbols_text, main, textord, "#", "\\#");
      defineSymbol(math2, main, textord, "&", "\\&");
      defineSymbol(symbols_text, main, textord, "&", "\\&");
      defineSymbol(math2, main, textord, "\u2135", "\\aleph", true);
      defineSymbol(math2, main, textord, "\u2200", "\\forall", true);
      defineSymbol(math2, main, textord, "\u210F", "\\hbar", true);
      defineSymbol(math2, main, textord, "\u2203", "\\exists", true);
      defineSymbol(math2, main, textord, "\u2207", "\\nabla", true);
      defineSymbol(math2, main, textord, "\u266D", "\\flat", true);
      defineSymbol(math2, main, textord, "\u2113", "\\ell", true);
      defineSymbol(math2, main, textord, "\u266E", "\\natural", true);
      defineSymbol(math2, main, textord, "\u2663", "\\clubsuit", true);
      defineSymbol(math2, main, textord, "\u2118", "\\wp", true);
      defineSymbol(math2, main, textord, "\u266F", "\\sharp", true);
      defineSymbol(math2, main, textord, "\u2662", "\\diamondsuit", true);
      defineSymbol(math2, main, textord, "\u211C", "\\Re", true);
      defineSymbol(math2, main, textord, "\u2661", "\\heartsuit", true);
      defineSymbol(math2, main, textord, "\u2111", "\\Im", true);
      defineSymbol(math2, main, textord, "\u2660", "\\spadesuit", true);
      defineSymbol(math2, main, textord, "\xA7", "\\S", true);
      defineSymbol(symbols_text, main, textord, "\xA7", "\\S");
      defineSymbol(math2, main, textord, "\xB6", "\\P", true);
      defineSymbol(symbols_text, main, textord, "\xB6", "\\P");
      defineSymbol(math2, main, textord, "\u2020", "\\dag");
      defineSymbol(symbols_text, main, textord, "\u2020", "\\dag");
      defineSymbol(symbols_text, main, textord, "\u2020", "\\textdagger");
      defineSymbol(math2, main, textord, "\u2021", "\\ddag");
      defineSymbol(symbols_text, main, textord, "\u2021", "\\ddag");
      defineSymbol(symbols_text, main, textord, "\u2021", "\\textdaggerdbl");
      defineSymbol(math2, main, symbols_close, "\u23B1", "\\rmoustache", true);
      defineSymbol(math2, main, symbols_open, "\u23B0", "\\lmoustache", true);
      defineSymbol(math2, main, symbols_close, "\u27EF", "\\rgroup", true);
      defineSymbol(math2, main, symbols_open, "\u27EE", "\\lgroup", true);
      defineSymbol(math2, main, bin, "\u2213", "\\mp", true);
      defineSymbol(math2, main, bin, "\u2296", "\\ominus", true);
      defineSymbol(math2, main, bin, "\u228E", "\\uplus", true);
      defineSymbol(math2, main, bin, "\u2293", "\\sqcap", true);
      defineSymbol(math2, main, bin, "\u2217", "\\ast");
      defineSymbol(math2, main, bin, "\u2294", "\\sqcup", true);
      defineSymbol(math2, main, bin, "\u25EF", "\\bigcirc", true);
      defineSymbol(math2, main, bin, "\u2219", "\\bullet");
      defineSymbol(math2, main, bin, "\u2021", "\\ddagger");
      defineSymbol(math2, main, bin, "\u2240", "\\wr", true);
      defineSymbol(math2, main, bin, "\u2A3F", "\\amalg");
      defineSymbol(math2, main, bin, "&", "\\And");
      defineSymbol(math2, main, rel, "\u27F5", "\\longleftarrow", true);
      defineSymbol(math2, main, rel, "\u21D0", "\\Leftarrow", true);
      defineSymbol(math2, main, rel, "\u27F8", "\\Longleftarrow", true);
      defineSymbol(math2, main, rel, "\u27F6", "\\longrightarrow", true);
      defineSymbol(math2, main, rel, "\u21D2", "\\Rightarrow", true);
      defineSymbol(math2, main, rel, "\u27F9", "\\Longrightarrow", true);
      defineSymbol(math2, main, rel, "\u2194", "\\leftrightarrow", true);
      defineSymbol(math2, main, rel, "\u27F7", "\\longleftrightarrow", true);
      defineSymbol(math2, main, rel, "\u21D4", "\\Leftrightarrow", true);
      defineSymbol(math2, main, rel, "\u27FA", "\\Longleftrightarrow", true);
      defineSymbol(math2, main, rel, "\u21A6", "\\mapsto", true);
      defineSymbol(math2, main, rel, "\u27FC", "\\longmapsto", true);
      defineSymbol(math2, main, rel, "\u2197", "\\nearrow", true);
      defineSymbol(math2, main, rel, "\u21A9", "\\hookleftarrow", true);
      defineSymbol(math2, main, rel, "\u21AA", "\\hookrightarrow", true);
      defineSymbol(math2, main, rel, "\u2198", "\\searrow", true);
      defineSymbol(math2, main, rel, "\u21BC", "\\leftharpoonup", true);
      defineSymbol(math2, main, rel, "\u21C0", "\\rightharpoonup", true);
      defineSymbol(math2, main, rel, "\u2199", "\\swarrow", true);
      defineSymbol(math2, main, rel, "\u21BD", "\\leftharpoondown", true);
      defineSymbol(math2, main, rel, "\u21C1", "\\rightharpoondown", true);
      defineSymbol(math2, main, rel, "\u2196", "\\nwarrow", true);
      defineSymbol(math2, main, rel, "\u21CC", "\\rightleftharpoons", true);
      defineSymbol(math2, ams, rel, "\u226E", "\\nless", true);
      defineSymbol(math2, ams, rel, "\uE010", "\\@nleqslant");
      defineSymbol(math2, ams, rel, "\uE011", "\\@nleqq");
      defineSymbol(math2, ams, rel, "\u2A87", "\\lneq", true);
      defineSymbol(math2, ams, rel, "\u2268", "\\lneqq", true);
      defineSymbol(math2, ams, rel, "\uE00C", "\\@lvertneqq");
      defineSymbol(math2, ams, rel, "\u22E6", "\\lnsim", true);
      defineSymbol(math2, ams, rel, "\u2A89", "\\lnapprox", true);
      defineSymbol(math2, ams, rel, "\u2280", "\\nprec", true);
      defineSymbol(math2, ams, rel, "\u22E0", "\\npreceq", true);
      defineSymbol(math2, ams, rel, "\u22E8", "\\precnsim", true);
      defineSymbol(math2, ams, rel, "\u2AB9", "\\precnapprox", true);
      defineSymbol(math2, ams, rel, "\u2241", "\\nsim", true);
      defineSymbol(math2, ams, rel, "\uE006", "\\@nshortmid");
      defineSymbol(math2, ams, rel, "\u2224", "\\nmid", true);
      defineSymbol(math2, ams, rel, "\u22AC", "\\nvdash", true);
      defineSymbol(math2, ams, rel, "\u22AD", "\\nvDash", true);
      defineSymbol(math2, ams, rel, "\u22EA", "\\ntriangleleft");
      defineSymbol(math2, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
      defineSymbol(math2, ams, rel, "\u228A", "\\subsetneq", true);
      defineSymbol(math2, ams, rel, "\uE01A", "\\@varsubsetneq");
      defineSymbol(math2, ams, rel, "\u2ACB", "\\subsetneqq", true);
      defineSymbol(math2, ams, rel, "\uE017", "\\@varsubsetneqq");
      defineSymbol(math2, ams, rel, "\u226F", "\\ngtr", true);
      defineSymbol(math2, ams, rel, "\uE00F", "\\@ngeqslant");
      defineSymbol(math2, ams, rel, "\uE00E", "\\@ngeqq");
      defineSymbol(math2, ams, rel, "\u2A88", "\\gneq", true);
      defineSymbol(math2, ams, rel, "\u2269", "\\gneqq", true);
      defineSymbol(math2, ams, rel, "\uE00D", "\\@gvertneqq");
      defineSymbol(math2, ams, rel, "\u22E7", "\\gnsim", true);
      defineSymbol(math2, ams, rel, "\u2A8A", "\\gnapprox", true);
      defineSymbol(math2, ams, rel, "\u2281", "\\nsucc", true);
      defineSymbol(math2, ams, rel, "\u22E1", "\\nsucceq", true);
      defineSymbol(math2, ams, rel, "\u22E9", "\\succnsim", true);
      defineSymbol(math2, ams, rel, "\u2ABA", "\\succnapprox", true);
      defineSymbol(math2, ams, rel, "\u2246", "\\ncong", true);
      defineSymbol(math2, ams, rel, "\uE007", "\\@nshortparallel");
      defineSymbol(math2, ams, rel, "\u2226", "\\nparallel", true);
      defineSymbol(math2, ams, rel, "\u22AF", "\\nVDash", true);
      defineSymbol(math2, ams, rel, "\u22EB", "\\ntriangleright");
      defineSymbol(math2, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
      defineSymbol(math2, ams, rel, "\uE018", "\\@nsupseteqq");
      defineSymbol(math2, ams, rel, "\u228B", "\\supsetneq", true);
      defineSymbol(math2, ams, rel, "\uE01B", "\\@varsupsetneq");
      defineSymbol(math2, ams, rel, "\u2ACC", "\\supsetneqq", true);
      defineSymbol(math2, ams, rel, "\uE019", "\\@varsupsetneqq");
      defineSymbol(math2, ams, rel, "\u22AE", "\\nVdash", true);
      defineSymbol(math2, ams, rel, "\u2AB5", "\\precneqq", true);
      defineSymbol(math2, ams, rel, "\u2AB6", "\\succneqq", true);
      defineSymbol(math2, ams, rel, "\uE016", "\\@nsubseteqq");
      defineSymbol(math2, ams, bin, "\u22B4", "\\unlhd");
      defineSymbol(math2, ams, bin, "\u22B5", "\\unrhd");
      defineSymbol(math2, ams, rel, "\u219A", "\\nleftarrow", true);
      defineSymbol(math2, ams, rel, "\u219B", "\\nrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21CD", "\\nLeftarrow", true);
      defineSymbol(math2, ams, rel, "\u21CF", "\\nRightarrow", true);
      defineSymbol(math2, ams, rel, "\u21AE", "\\nleftrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
      defineSymbol(math2, ams, rel, "\u25B3", "\\vartriangle");
      defineSymbol(math2, ams, textord, "\u210F", "\\hslash");
      defineSymbol(math2, ams, textord, "\u25BD", "\\triangledown");
      defineSymbol(math2, ams, textord, "\u25CA", "\\lozenge");
      defineSymbol(math2, ams, textord, "\u24C8", "\\circledS");
      defineSymbol(math2, ams, textord, "\xAE", "\\circledR");
      defineSymbol(symbols_text, ams, textord, "\xAE", "\\circledR");
      defineSymbol(math2, ams, textord, "\u2221", "\\measuredangle", true);
      defineSymbol(math2, ams, textord, "\u2204", "\\nexists");
      defineSymbol(math2, ams, textord, "\u2127", "\\mho");
      defineSymbol(math2, ams, textord, "\u2132", "\\Finv", true);
      defineSymbol(math2, ams, textord, "\u2141", "\\Game", true);
      defineSymbol(math2, ams, textord, "\u2035", "\\backprime");
      defineSymbol(math2, ams, textord, "\u25B2", "\\blacktriangle");
      defineSymbol(math2, ams, textord, "\u25BC", "\\blacktriangledown");
      defineSymbol(math2, ams, textord, "\u25A0", "\\blacksquare");
      defineSymbol(math2, ams, textord, "\u29EB", "\\blacklozenge");
      defineSymbol(math2, ams, textord, "\u2605", "\\bigstar");
      defineSymbol(math2, ams, textord, "\u2222", "\\sphericalangle", true);
      defineSymbol(math2, ams, textord, "\u2201", "\\complement", true);
      defineSymbol(math2, ams, textord, "\xF0", "\\eth", true);
      defineSymbol(symbols_text, main, textord, "\xF0", "\xF0");
      defineSymbol(math2, ams, textord, "\u2571", "\\diagup");
      defineSymbol(math2, ams, textord, "\u2572", "\\diagdown");
      defineSymbol(math2, ams, textord, "\u25A1", "\\square");
      defineSymbol(math2, ams, textord, "\u25A1", "\\Box");
      defineSymbol(math2, ams, textord, "\u25CA", "\\Diamond");
      defineSymbol(math2, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(symbols_text, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(math2, ams, textord, "\u2713", "\\checkmark", true);
      defineSymbol(symbols_text, ams, textord, "\u2713", "\\checkmark");
      defineSymbol(math2, ams, textord, "\u2136", "\\beth", true);
      defineSymbol(math2, ams, textord, "\u2138", "\\daleth", true);
      defineSymbol(math2, ams, textord, "\u2137", "\\gimel", true);
      defineSymbol(math2, ams, textord, "\u03DD", "\\digamma", true);
      defineSymbol(math2, ams, textord, "\u03F0", "\\varkappa");
      defineSymbol(math2, ams, symbols_open, "\u250C", "\\@ulcorner", true);
      defineSymbol(math2, ams, symbols_close, "\u2510", "\\@urcorner", true);
      defineSymbol(math2, ams, symbols_open, "\u2514", "\\@llcorner", true);
      defineSymbol(math2, ams, symbols_close, "\u2518", "\\@lrcorner", true);
      defineSymbol(math2, ams, rel, "\u2266", "\\leqq", true);
      defineSymbol(math2, ams, rel, "\u2A7D", "\\leqslant", true);
      defineSymbol(math2, ams, rel, "\u2A95", "\\eqslantless", true);
      defineSymbol(math2, ams, rel, "\u2272", "\\lesssim", true);
      defineSymbol(math2, ams, rel, "\u2A85", "\\lessapprox", true);
      defineSymbol(math2, ams, rel, "\u224A", "\\approxeq", true);
      defineSymbol(math2, ams, bin, "\u22D6", "\\lessdot");
      defineSymbol(math2, ams, rel, "\u22D8", "\\lll", true);
      defineSymbol(math2, ams, rel, "\u2276", "\\lessgtr", true);
      defineSymbol(math2, ams, rel, "\u22DA", "\\lesseqgtr", true);
      defineSymbol(math2, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
      defineSymbol(math2, ams, rel, "\u2251", "\\doteqdot");
      defineSymbol(math2, ams, rel, "\u2253", "\\risingdotseq", true);
      defineSymbol(math2, ams, rel, "\u2252", "\\fallingdotseq", true);
      defineSymbol(math2, ams, rel, "\u223D", "\\backsim", true);
      defineSymbol(math2, ams, rel, "\u22CD", "\\backsimeq", true);
      defineSymbol(math2, ams, rel, "\u2AC5", "\\subseteqq", true);
      defineSymbol(math2, ams, rel, "\u22D0", "\\Subset", true);
      defineSymbol(math2, ams, rel, "\u228F", "\\sqsubset", true);
      defineSymbol(math2, ams, rel, "\u227C", "\\preccurlyeq", true);
      defineSymbol(math2, ams, rel, "\u22DE", "\\curlyeqprec", true);
      defineSymbol(math2, ams, rel, "\u227E", "\\precsim", true);
      defineSymbol(math2, ams, rel, "\u2AB7", "\\precapprox", true);
      defineSymbol(math2, ams, rel, "\u22B2", "\\vartriangleleft");
      defineSymbol(math2, ams, rel, "\u22B4", "\\trianglelefteq");
      defineSymbol(math2, ams, rel, "\u22A8", "\\vDash", true);
      defineSymbol(math2, ams, rel, "\u22AA", "\\Vvdash", true);
      defineSymbol(math2, ams, rel, "\u2323", "\\smallsmile");
      defineSymbol(math2, ams, rel, "\u2322", "\\smallfrown");
      defineSymbol(math2, ams, rel, "\u224F", "\\bumpeq", true);
      defineSymbol(math2, ams, rel, "\u224E", "\\Bumpeq", true);
      defineSymbol(math2, ams, rel, "\u2267", "\\geqq", true);
      defineSymbol(math2, ams, rel, "\u2A7E", "\\geqslant", true);
      defineSymbol(math2, ams, rel, "\u2A96", "\\eqslantgtr", true);
      defineSymbol(math2, ams, rel, "\u2273", "\\gtrsim", true);
      defineSymbol(math2, ams, rel, "\u2A86", "\\gtrapprox", true);
      defineSymbol(math2, ams, bin, "\u22D7", "\\gtrdot");
      defineSymbol(math2, ams, rel, "\u22D9", "\\ggg", true);
      defineSymbol(math2, ams, rel, "\u2277", "\\gtrless", true);
      defineSymbol(math2, ams, rel, "\u22DB", "\\gtreqless", true);
      defineSymbol(math2, ams, rel, "\u2A8C", "\\gtreqqless", true);
      defineSymbol(math2, ams, rel, "\u2256", "\\eqcirc", true);
      defineSymbol(math2, ams, rel, "\u2257", "\\circeq", true);
      defineSymbol(math2, ams, rel, "\u225C", "\\triangleq", true);
      defineSymbol(math2, ams, rel, "\u223C", "\\thicksim");
      defineSymbol(math2, ams, rel, "\u2248", "\\thickapprox");
      defineSymbol(math2, ams, rel, "\u2AC6", "\\supseteqq", true);
      defineSymbol(math2, ams, rel, "\u22D1", "\\Supset", true);
      defineSymbol(math2, ams, rel, "\u2290", "\\sqsupset", true);
      defineSymbol(math2, ams, rel, "\u227D", "\\succcurlyeq", true);
      defineSymbol(math2, ams, rel, "\u22DF", "\\curlyeqsucc", true);
      defineSymbol(math2, ams, rel, "\u227F", "\\succsim", true);
      defineSymbol(math2, ams, rel, "\u2AB8", "\\succapprox", true);
      defineSymbol(math2, ams, rel, "\u22B3", "\\vartriangleright");
      defineSymbol(math2, ams, rel, "\u22B5", "\\trianglerighteq");
      defineSymbol(math2, ams, rel, "\u22A9", "\\Vdash", true);
      defineSymbol(math2, ams, rel, "\u2223", "\\shortmid");
      defineSymbol(math2, ams, rel, "\u2225", "\\shortparallel");
      defineSymbol(math2, ams, rel, "\u226C", "\\between", true);
      defineSymbol(math2, ams, rel, "\u22D4", "\\pitchfork", true);
      defineSymbol(math2, ams, rel, "\u221D", "\\varpropto");
      defineSymbol(math2, ams, rel, "\u25C0", "\\blacktriangleleft");
      defineSymbol(math2, ams, rel, "\u2234", "\\therefore", true);
      defineSymbol(math2, ams, rel, "\u220D", "\\backepsilon");
      defineSymbol(math2, ams, rel, "\u25B6", "\\blacktriangleright");
      defineSymbol(math2, ams, rel, "\u2235", "\\because", true);
      defineSymbol(math2, ams, rel, "\u22D8", "\\llless");
      defineSymbol(math2, ams, rel, "\u22D9", "\\gggtr");
      defineSymbol(math2, ams, bin, "\u22B2", "\\lhd");
      defineSymbol(math2, ams, bin, "\u22B3", "\\rhd");
      defineSymbol(math2, ams, rel, "\u2242", "\\eqsim", true);
      defineSymbol(math2, main, rel, "\u22C8", "\\Join");
      defineSymbol(math2, ams, rel, "\u2251", "\\Doteq", true);
      defineSymbol(math2, ams, bin, "\u2214", "\\dotplus", true);
      defineSymbol(math2, ams, bin, "\u2216", "\\smallsetminus");
      defineSymbol(math2, ams, bin, "\u22D2", "\\Cap", true);
      defineSymbol(math2, ams, bin, "\u22D3", "\\Cup", true);
      defineSymbol(math2, ams, bin, "\u2A5E", "\\doublebarwedge", true);
      defineSymbol(math2, ams, bin, "\u229F", "\\boxminus", true);
      defineSymbol(math2, ams, bin, "\u229E", "\\boxplus", true);
      defineSymbol(math2, ams, bin, "\u22C7", "\\divideontimes", true);
      defineSymbol(math2, ams, bin, "\u22C9", "\\ltimes", true);
      defineSymbol(math2, ams, bin, "\u22CA", "\\rtimes", true);
      defineSymbol(math2, ams, bin, "\u22CB", "\\leftthreetimes", true);
      defineSymbol(math2, ams, bin, "\u22CC", "\\rightthreetimes", true);
      defineSymbol(math2, ams, bin, "\u22CF", "\\curlywedge", true);
      defineSymbol(math2, ams, bin, "\u22CE", "\\curlyvee", true);
      defineSymbol(math2, ams, bin, "\u229D", "\\circleddash", true);
      defineSymbol(math2, ams, bin, "\u229B", "\\circledast", true);
      defineSymbol(math2, ams, bin, "\u22C5", "\\centerdot");
      defineSymbol(math2, ams, bin, "\u22BA", "\\intercal", true);
      defineSymbol(math2, ams, bin, "\u22D2", "\\doublecap");
      defineSymbol(math2, ams, bin, "\u22D3", "\\doublecup");
      defineSymbol(math2, ams, bin, "\u22A0", "\\boxtimes", true);
      defineSymbol(math2, ams, rel, "\u21E2", "\\dashrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21E0", "\\dashleftarrow", true);
      defineSymbol(math2, ams, rel, "\u21C7", "\\leftleftarrows", true);
      defineSymbol(math2, ams, rel, "\u21C6", "\\leftrightarrows", true);
      defineSymbol(math2, ams, rel, "\u21DA", "\\Lleftarrow", true);
      defineSymbol(math2, ams, rel, "\u219E", "\\twoheadleftarrow", true);
      defineSymbol(math2, ams, rel, "\u21A2", "\\leftarrowtail", true);
      defineSymbol(math2, ams, rel, "\u21AB", "\\looparrowleft", true);
      defineSymbol(math2, ams, rel, "\u21CB", "\\leftrightharpoons", true);
      defineSymbol(math2, ams, rel, "\u21B6", "\\curvearrowleft", true);
      defineSymbol(math2, ams, rel, "\u21BA", "\\circlearrowleft", true);
      defineSymbol(math2, ams, rel, "\u21B0", "\\Lsh", true);
      defineSymbol(math2, ams, rel, "\u21C8", "\\upuparrows", true);
      defineSymbol(math2, ams, rel, "\u21BF", "\\upharpoonleft", true);
      defineSymbol(math2, ams, rel, "\u21C3", "\\downharpoonleft", true);
      defineSymbol(math2, main, rel, "\u22B6", "\\origof", true);
      defineSymbol(math2, main, rel, "\u22B7", "\\imageof", true);
      defineSymbol(math2, ams, rel, "\u22B8", "\\multimap", true);
      defineSymbol(math2, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
      defineSymbol(math2, ams, rel, "\u21C9", "\\rightrightarrows", true);
      defineSymbol(math2, ams, rel, "\u21C4", "\\rightleftarrows", true);
      defineSymbol(math2, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21A3", "\\rightarrowtail", true);
      defineSymbol(math2, ams, rel, "\u21AC", "\\looparrowright", true);
      defineSymbol(math2, ams, rel, "\u21B7", "\\curvearrowright", true);
      defineSymbol(math2, ams, rel, "\u21BB", "\\circlearrowright", true);
      defineSymbol(math2, ams, rel, "\u21B1", "\\Rsh", true);
      defineSymbol(math2, ams, rel, "\u21CA", "\\downdownarrows", true);
      defineSymbol(math2, ams, rel, "\u21BE", "\\upharpoonright", true);
      defineSymbol(math2, ams, rel, "\u21C2", "\\downharpoonright", true);
      defineSymbol(math2, ams, rel, "\u21DD", "\\rightsquigarrow", true);
      defineSymbol(math2, ams, rel, "\u21DD", "\\leadsto");
      defineSymbol(math2, ams, rel, "\u21DB", "\\Rrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21BE", "\\restriction");
      defineSymbol(math2, main, textord, "\u2018", "`");
      defineSymbol(math2, main, textord, "$", "\\$");
      defineSymbol(symbols_text, main, textord, "$", "\\$");
      defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
      defineSymbol(math2, main, textord, "%", "\\%");
      defineSymbol(symbols_text, main, textord, "%", "\\%");
      defineSymbol(math2, main, textord, "_", "\\_");
      defineSymbol(symbols_text, main, textord, "_", "\\_");
      defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
      defineSymbol(math2, main, textord, "\u2220", "\\angle", true);
      defineSymbol(math2, main, textord, "\u221E", "\\infty", true);
      defineSymbol(math2, main, textord, "\u2032", "\\prime");
      defineSymbol(math2, main, textord, "\u25B3", "\\triangle");
      defineSymbol(math2, main, textord, "\u0393", "\\Gamma", true);
      defineSymbol(math2, main, textord, "\u0394", "\\Delta", true);
      defineSymbol(math2, main, textord, "\u0398", "\\Theta", true);
      defineSymbol(math2, main, textord, "\u039B", "\\Lambda", true);
      defineSymbol(math2, main, textord, "\u039E", "\\Xi", true);
      defineSymbol(math2, main, textord, "\u03A0", "\\Pi", true);
      defineSymbol(math2, main, textord, "\u03A3", "\\Sigma", true);
      defineSymbol(math2, main, textord, "\u03A5", "\\Upsilon", true);
      defineSymbol(math2, main, textord, "\u03A6", "\\Phi", true);
      defineSymbol(math2, main, textord, "\u03A8", "\\Psi", true);
      defineSymbol(math2, main, textord, "\u03A9", "\\Omega", true);
      defineSymbol(math2, main, textord, "A", "\u0391");
      defineSymbol(math2, main, textord, "B", "\u0392");
      defineSymbol(math2, main, textord, "E", "\u0395");
      defineSymbol(math2, main, textord, "Z", "\u0396");
      defineSymbol(math2, main, textord, "H", "\u0397");
      defineSymbol(math2, main, textord, "I", "\u0399");
      defineSymbol(math2, main, textord, "K", "\u039A");
      defineSymbol(math2, main, textord, "M", "\u039C");
      defineSymbol(math2, main, textord, "N", "\u039D");
      defineSymbol(math2, main, textord, "O", "\u039F");
      defineSymbol(math2, main, textord, "P", "\u03A1");
      defineSymbol(math2, main, textord, "T", "\u03A4");
      defineSymbol(math2, main, textord, "X", "\u03A7");
      defineSymbol(math2, main, textord, "\xAC", "\\neg", true);
      defineSymbol(math2, main, textord, "\xAC", "\\lnot");
      defineSymbol(math2, main, textord, "\u22A4", "\\top");
      defineSymbol(math2, main, textord, "\u22A5", "\\bot");
      defineSymbol(math2, main, textord, "\u2205", "\\emptyset");
      defineSymbol(math2, ams, textord, "\u2205", "\\varnothing");
      defineSymbol(math2, main, mathord, "\u03B1", "\\alpha", true);
      defineSymbol(math2, main, mathord, "\u03B2", "\\beta", true);
      defineSymbol(math2, main, mathord, "\u03B3", "\\gamma", true);
      defineSymbol(math2, main, mathord, "\u03B4", "\\delta", true);
      defineSymbol(math2, main, mathord, "\u03F5", "\\epsilon", true);
      defineSymbol(math2, main, mathord, "\u03B6", "\\zeta", true);
      defineSymbol(math2, main, mathord, "\u03B7", "\\eta", true);
      defineSymbol(math2, main, mathord, "\u03B8", "\\theta", true);
      defineSymbol(math2, main, mathord, "\u03B9", "\\iota", true);
      defineSymbol(math2, main, mathord, "\u03BA", "\\kappa", true);
      defineSymbol(math2, main, mathord, "\u03BB", "\\lambda", true);
      defineSymbol(math2, main, mathord, "\u03BC", "\\mu", true);
      defineSymbol(math2, main, mathord, "\u03BD", "\\nu", true);
      defineSymbol(math2, main, mathord, "\u03BE", "\\xi", true);
      defineSymbol(math2, main, mathord, "\u03BF", "\\omicron", true);
      defineSymbol(math2, main, mathord, "\u03C0", "\\pi", true);
      defineSymbol(math2, main, mathord, "\u03C1", "\\rho", true);
      defineSymbol(math2, main, mathord, "\u03C3", "\\sigma", true);
      defineSymbol(math2, main, mathord, "\u03C4", "\\tau", true);
      defineSymbol(math2, main, mathord, "\u03C5", "\\upsilon", true);
      defineSymbol(math2, main, mathord, "\u03D5", "\\phi", true);
      defineSymbol(math2, main, mathord, "\u03C7", "\\chi", true);
      defineSymbol(math2, main, mathord, "\u03C8", "\\psi", true);
      defineSymbol(math2, main, mathord, "\u03C9", "\\omega", true);
      defineSymbol(math2, main, mathord, "\u03B5", "\\varepsilon", true);
      defineSymbol(math2, main, mathord, "\u03D1", "\\vartheta", true);
      defineSymbol(math2, main, mathord, "\u03D6", "\\varpi", true);
      defineSymbol(math2, main, mathord, "\u03F1", "\\varrho", true);
      defineSymbol(math2, main, mathord, "\u03C2", "\\varsigma", true);
      defineSymbol(math2, main, mathord, "\u03C6", "\\varphi", true);
      defineSymbol(math2, main, bin, "\u2217", "*");
      defineSymbol(math2, main, bin, "+", "+");
      defineSymbol(math2, main, bin, "\u2212", "-");
      defineSymbol(math2, main, bin, "\u22C5", "\\cdot", true);
      defineSymbol(math2, main, bin, "\u2218", "\\circ");
      defineSymbol(math2, main, bin, "\xF7", "\\div", true);
      defineSymbol(math2, main, bin, "\xB1", "\\pm", true);
      defineSymbol(math2, main, bin, "\xD7", "\\times", true);
      defineSymbol(math2, main, bin, "\u2229", "\\cap", true);
      defineSymbol(math2, main, bin, "\u222A", "\\cup", true);
      defineSymbol(math2, main, bin, "\u2216", "\\setminus");
      defineSymbol(math2, main, bin, "\u2227", "\\land");
      defineSymbol(math2, main, bin, "\u2228", "\\lor");
      defineSymbol(math2, main, bin, "\u2227", "\\wedge", true);
      defineSymbol(math2, main, bin, "\u2228", "\\vee", true);
      defineSymbol(math2, main, textord, "\u221A", "\\surd");
      defineSymbol(math2, main, symbols_open, "\u27E8", "\\langle", true);
      defineSymbol(math2, main, symbols_open, "\u2223", "\\lvert");
      defineSymbol(math2, main, symbols_open, "\u2225", "\\lVert");
      defineSymbol(math2, main, symbols_close, "?", "?");
      defineSymbol(math2, main, symbols_close, "!", "!");
      defineSymbol(math2, main, symbols_close, "\u27E9", "\\rangle", true);
      defineSymbol(math2, main, symbols_close, "\u2223", "\\rvert");
      defineSymbol(math2, main, symbols_close, "\u2225", "\\rVert");
      defineSymbol(math2, main, rel, "=", "=");
      defineSymbol(math2, main, rel, ":", ":");
      defineSymbol(math2, main, rel, "\u2248", "\\approx", true);
      defineSymbol(math2, main, rel, "\u2245", "\\cong", true);
      defineSymbol(math2, main, rel, "\u2265", "\\ge");
      defineSymbol(math2, main, rel, "\u2265", "\\geq", true);
      defineSymbol(math2, main, rel, "\u2190", "\\gets");
      defineSymbol(math2, main, rel, ">", "\\gt", true);
      defineSymbol(math2, main, rel, "\u2208", "\\in", true);
      defineSymbol(math2, main, rel, "\uE020", "\\@not");
      defineSymbol(math2, main, rel, "\u2282", "\\subset", true);
      defineSymbol(math2, main, rel, "\u2283", "\\supset", true);
      defineSymbol(math2, main, rel, "\u2286", "\\subseteq", true);
      defineSymbol(math2, main, rel, "\u2287", "\\supseteq", true);
      defineSymbol(math2, ams, rel, "\u2288", "\\nsubseteq", true);
      defineSymbol(math2, ams, rel, "\u2289", "\\nsupseteq", true);
      defineSymbol(math2, main, rel, "\u22A8", "\\models");
      defineSymbol(math2, main, rel, "\u2190", "\\leftarrow", true);
      defineSymbol(math2, main, rel, "\u2264", "\\le");
      defineSymbol(math2, main, rel, "\u2264", "\\leq", true);
      defineSymbol(math2, main, rel, "<", "\\lt", true);
      defineSymbol(math2, main, rel, "\u2192", "\\rightarrow", true);
      defineSymbol(math2, main, rel, "\u2192", "\\to");
      defineSymbol(math2, ams, rel, "\u2271", "\\ngeq", true);
      defineSymbol(math2, ams, rel, "\u2270", "\\nleq", true);
      defineSymbol(math2, main, spacing, "\xA0", "\\ ");
      defineSymbol(math2, main, spacing, "\xA0", "\\space");
      defineSymbol(math2, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(symbols_text, main, spacing, "\xA0", "\\ ");
      defineSymbol(symbols_text, main, spacing, "\xA0", " ");
      defineSymbol(symbols_text, main, spacing, "\xA0", "\\space");
      defineSymbol(symbols_text, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(math2, main, spacing, null, "\\nobreak");
      defineSymbol(math2, main, spacing, null, "\\allowbreak");
      defineSymbol(math2, main, punct, ",", ",");
      defineSymbol(math2, main, punct, ";", ";");
      defineSymbol(math2, ams, bin, "\u22BC", "\\barwedge", true);
      defineSymbol(math2, ams, bin, "\u22BB", "\\veebar", true);
      defineSymbol(math2, main, bin, "\u2299", "\\odot", true);
      defineSymbol(math2, main, bin, "\u2295", "\\oplus", true);
      defineSymbol(math2, main, bin, "\u2297", "\\otimes", true);
      defineSymbol(math2, main, textord, "\u2202", "\\partial", true);
      defineSymbol(math2, main, bin, "\u2298", "\\oslash", true);
      defineSymbol(math2, ams, bin, "\u229A", "\\circledcirc", true);
      defineSymbol(math2, ams, bin, "\u22A1", "\\boxdot", true);
      defineSymbol(math2, main, bin, "\u25B3", "\\bigtriangleup");
      defineSymbol(math2, main, bin, "\u25BD", "\\bigtriangledown");
      defineSymbol(math2, main, bin, "\u2020", "\\dagger");
      defineSymbol(math2, main, bin, "\u22C4", "\\diamond");
      defineSymbol(math2, main, bin, "\u22C6", "\\star");
      defineSymbol(math2, main, bin, "\u25C3", "\\triangleleft");
      defineSymbol(math2, main, bin, "\u25B9", "\\triangleright");
      defineSymbol(math2, main, symbols_open, "{", "\\{");
      defineSymbol(symbols_text, main, textord, "{", "\\{");
      defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
      defineSymbol(math2, main, symbols_close, "}", "\\}");
      defineSymbol(symbols_text, main, textord, "}", "\\}");
      defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
      defineSymbol(math2, main, symbols_open, "{", "\\lbrace");
      defineSymbol(math2, main, symbols_close, "}", "\\rbrace");
      defineSymbol(math2, main, symbols_open, "[", "\\lbrack", true);
      defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
      defineSymbol(math2, main, symbols_close, "]", "\\rbrack", true);
      defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
      defineSymbol(math2, main, symbols_open, "(", "\\lparen", true);
      defineSymbol(math2, main, symbols_close, ")", "\\rparen", true);
      defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
      defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
      defineSymbol(math2, main, symbols_open, "\u230A", "\\lfloor", true);
      defineSymbol(math2, main, symbols_close, "\u230B", "\\rfloor", true);
      defineSymbol(math2, main, symbols_open, "\u2308", "\\lceil", true);
      defineSymbol(math2, main, symbols_close, "\u2309", "\\rceil", true);
      defineSymbol(math2, main, textord, "\\", "\\backslash");
      defineSymbol(math2, main, textord, "\u2223", "|");
      defineSymbol(math2, main, textord, "\u2223", "\\vert");
      defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
      defineSymbol(math2, main, textord, "\u2225", "\\|");
      defineSymbol(math2, main, textord, "\u2225", "\\Vert");
      defineSymbol(symbols_text, main, textord, "\u2225", "\\textbardbl");
      defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
      defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
      defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
      defineSymbol(math2, main, rel, "\u2191", "\\uparrow", true);
      defineSymbol(math2, main, rel, "\u21D1", "\\Uparrow", true);
      defineSymbol(math2, main, rel, "\u2193", "\\downarrow", true);
      defineSymbol(math2, main, rel, "\u21D3", "\\Downarrow", true);
      defineSymbol(math2, main, rel, "\u2195", "\\updownarrow", true);
      defineSymbol(math2, main, rel, "\u21D5", "\\Updownarrow", true);
      defineSymbol(math2, main, op, "\u2210", "\\coprod");
      defineSymbol(math2, main, op, "\u22C1", "\\bigvee");
      defineSymbol(math2, main, op, "\u22C0", "\\bigwedge");
      defineSymbol(math2, main, op, "\u2A04", "\\biguplus");
      defineSymbol(math2, main, op, "\u22C2", "\\bigcap");
      defineSymbol(math2, main, op, "\u22C3", "\\bigcup");
      defineSymbol(math2, main, op, "\u222B", "\\int");
      defineSymbol(math2, main, op, "\u222B", "\\intop");
      defineSymbol(math2, main, op, "\u222C", "\\iint");
      defineSymbol(math2, main, op, "\u222D", "\\iiint");
      defineSymbol(math2, main, op, "\u220F", "\\prod");
      defineSymbol(math2, main, op, "\u2211", "\\sum");
      defineSymbol(math2, main, op, "\u2A02", "\\bigotimes");
      defineSymbol(math2, main, op, "\u2A01", "\\bigoplus");
      defineSymbol(math2, main, op, "\u2A00", "\\bigodot");
      defineSymbol(math2, main, op, "\u222E", "\\oint");
      defineSymbol(math2, main, op, "\u222F", "\\oiint");
      defineSymbol(math2, main, op, "\u2230", "\\oiiint");
      defineSymbol(math2, main, op, "\u2A06", "\\bigsqcup");
      defineSymbol(math2, main, op, "\u222B", "\\smallint");
      defineSymbol(symbols_text, main, inner, "\u2026", "\\textellipsis");
      defineSymbol(math2, main, inner, "\u2026", "\\mathellipsis");
      defineSymbol(symbols_text, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math2, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math2, main, inner, "\u22EF", "\\@cdots", true);
      defineSymbol(math2, main, inner, "\u22F1", "\\ddots", true);
      defineSymbol(math2, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(math2, main, accent, "\u02CA", "\\acute");
      defineSymbol(math2, main, accent, "\u02CB", "\\grave");
      defineSymbol(math2, main, accent, "\xA8", "\\ddot");
      defineSymbol(math2, main, accent, "~", "\\tilde");
      defineSymbol(math2, main, accent, "\u02C9", "\\bar");
      defineSymbol(math2, main, accent, "\u02D8", "\\breve");
      defineSymbol(math2, main, accent, "\u02C7", "\\check");
      defineSymbol(math2, main, accent, "^", "\\hat");
      defineSymbol(math2, main, accent, "\u20D7", "\\vec");
      defineSymbol(math2, main, accent, "\u02D9", "\\dot");
      defineSymbol(math2, main, accent, "\u02DA", "\\mathring");
      defineSymbol(math2, main, mathord, "\uE131", "\\@imath");
      defineSymbol(math2, main, mathord, "\uE237", "\\@jmath");
      defineSymbol(math2, main, textord, "\u0131", "\u0131");
      defineSymbol(math2, main, textord, "\u0237", "\u0237");
      defineSymbol(symbols_text, main, textord, "\u0131", "\\i", true);
      defineSymbol(symbols_text, main, textord, "\u0237", "\\j", true);
      defineSymbol(symbols_text, main, textord, "\xDF", "\\ss", true);
      defineSymbol(symbols_text, main, textord, "\xE6", "\\ae", true);
      defineSymbol(symbols_text, main, textord, "\u0153", "\\oe", true);
      defineSymbol(symbols_text, main, textord, "\xF8", "\\o", true);
      defineSymbol(symbols_text, main, textord, "\xC6", "\\AE", true);
      defineSymbol(symbols_text, main, textord, "\u0152", "\\OE", true);
      defineSymbol(symbols_text, main, textord, "\xD8", "\\O", true);
      defineSymbol(symbols_text, main, accent, "\u02CA", "\\'");
      defineSymbol(symbols_text, main, accent, "\u02CB", "\\`");
      defineSymbol(symbols_text, main, accent, "\u02C6", "\\^");
      defineSymbol(symbols_text, main, accent, "\u02DC", "\\~");
      defineSymbol(symbols_text, main, accent, "\u02C9", "\\=");
      defineSymbol(symbols_text, main, accent, "\u02D8", "\\u");
      defineSymbol(symbols_text, main, accent, "\u02D9", "\\.");
      defineSymbol(symbols_text, main, accent, "\u02DA", "\\r");
      defineSymbol(symbols_text, main, accent, "\u02C7", "\\v");
      defineSymbol(symbols_text, main, accent, "\xA8", '\\"');
      defineSymbol(symbols_text, main, accent, "\u02DD", "\\H");
      defineSymbol(symbols_text, main, accent, "\u25EF", "\\textcircled");
      var ligatures = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol(symbols_text, main, textord, "\u2013", "--", true);
      defineSymbol(symbols_text, main, textord, "\u2013", "\\textendash");
      defineSymbol(symbols_text, main, textord, "\u2014", "---", true);
      defineSymbol(symbols_text, main, textord, "\u2014", "\\textemdash");
      defineSymbol(symbols_text, main, textord, "\u2018", "`", true);
      defineSymbol(symbols_text, main, textord, "\u2018", "\\textquoteleft");
      defineSymbol(symbols_text, main, textord, "\u2019", "'", true);
      defineSymbol(symbols_text, main, textord, "\u2019", "\\textquoteright");
      defineSymbol(symbols_text, main, textord, "\u201C", "``", true);
      defineSymbol(symbols_text, main, textord, "\u201C", "\\textquotedblleft");
      defineSymbol(symbols_text, main, textord, "\u201D", "''", true);
      defineSymbol(symbols_text, main, textord, "\u201D", "\\textquotedblright");
      defineSymbol(math2, main, textord, "\xB0", "\\degree", true);
      defineSymbol(symbols_text, main, textord, "\xB0", "\\degree");
      defineSymbol(symbols_text, main, textord, "\xB0", "\\textdegree", true);
      defineSymbol(math2, main, textord, "\xA3", "\\pounds");
      defineSymbol(math2, main, textord, "\xA3", "\\mathsterling", true);
      defineSymbol(symbols_text, main, textord, "\xA3", "\\pounds");
      defineSymbol(symbols_text, main, textord, "\xA3", "\\textsterling", true);
      defineSymbol(math2, ams, textord, "\u2720", "\\maltese");
      defineSymbol(symbols_text, ams, textord, "\u2720", "\\maltese");
      var mathTextSymbols = '0123456789/@."';
      for (var i2 = 0; i2 < mathTextSymbols.length; i2++) {
        var ch = mathTextSymbols.charAt(i2);
        defineSymbol(math2, main, textord, ch, ch);
      }
      var textSymbols = '0123456789!@*()-=+";:?/.,';
      for (var _i = 0; _i < textSymbols.length; _i++) {
        var _ch = textSymbols.charAt(_i);
        defineSymbol(symbols_text, main, textord, _ch, _ch);
      }
      var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (var _i2 = 0; _i2 < letters.length; _i2++) {
        var _ch2 = letters.charAt(_i2);
        defineSymbol(math2, main, mathord, _ch2, _ch2);
        defineSymbol(symbols_text, main, textord, _ch2, _ch2);
      }
      defineSymbol(math2, ams, textord, "C", "\u2102");
      defineSymbol(symbols_text, ams, textord, "C", "\u2102");
      defineSymbol(math2, ams, textord, "H", "\u210D");
      defineSymbol(symbols_text, ams, textord, "H", "\u210D");
      defineSymbol(math2, ams, textord, "N", "\u2115");
      defineSymbol(symbols_text, ams, textord, "N", "\u2115");
      defineSymbol(math2, ams, textord, "P", "\u2119");
      defineSymbol(symbols_text, ams, textord, "P", "\u2119");
      defineSymbol(math2, ams, textord, "Q", "\u211A");
      defineSymbol(symbols_text, ams, textord, "Q", "\u211A");
      defineSymbol(math2, ams, textord, "R", "\u211D");
      defineSymbol(symbols_text, ams, textord, "R", "\u211D");
      defineSymbol(math2, ams, textord, "Z", "\u2124");
      defineSymbol(symbols_text, ams, textord, "Z", "\u2124");
      defineSymbol(math2, main, mathord, "h", "\u210E");
      defineSymbol(symbols_text, main, mathord, "h", "\u210E");
      var wideChar = "";
      for (var _i3 = 0; _i3 < letters.length; _i3++) {
        var _ch3 = letters.charAt(_i3);
        wideChar = String.fromCharCode(55349, 56320 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        if (_i3 < 26) {
          wideChar = String.fromCharCode(55349, 56632 + _i3);
          defineSymbol(math2, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56476 + _i3);
          defineSymbol(math2, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
        }
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol(math2, main, mathord, "k", wideChar);
      defineSymbol(symbols_text, main, textord, "k", wideChar);
      for (var _i4 = 0; _i4 < 10; _i4++) {
        var _ch4 = _i4.toString();
        wideChar = String.fromCharCode(55349, 57294 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(symbols_text, main, textord, _ch4, wideChar);
      }
      var extraLatin = "\xC7\xD0\xDE\xE7\xFE";
      for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
        var _ch5 = extraLatin.charAt(_i5);
        defineSymbol(math2, main, mathord, _ch5, _ch5);
        defineSymbol(symbols_text, main, textord, _ch5, _ch5);
      }
      var wideLatinLetterData = [
        ["mathbf", "textbf", "Main-Bold"],
        ["mathbf", "textbf", "Main-Bold"],
        ["mathnormal", "textit", "Math-Italic"],
        ["mathnormal", "textit", "Math-Italic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        ["mathscr", "textscr", "Script-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["", "", ""],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["mathbb", "textbb", "AMS-Regular"],
        ["", "", ""],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        ["", "", ""],
        ["", "", ""],
        ["mathtt", "texttt", "Typewriter-Regular"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      var wideNumeralData = [
        ["mathbf", "textbf", "Main-Bold"],
        ["", "", ""],
        ["mathsf", "textsf", "SansSerif-Regular"],
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        ["mathtt", "texttt", "Typewriter-Regular"]
      ];
      var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
        var H2 = wideChar2.charCodeAt(0);
        var L2 = wideChar2.charCodeAt(1);
        var codePoint = (H2 - 55296) * 1024 + (L2 - 56320) + 65536;
        var j2 = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          var i3 = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData[i3][2], wideLatinLetterData[i3][j2]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          var _i6 = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData[_i6][2], wideNumeralData[_i6][j2]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new src_ParseError("Unsupported character: " + wideChar2);
        }
      };
      var sizeStyleMap = [
        [1, 1, 1],
        [2, 1, 1],
        [3, 1, 1],
        [4, 2, 1],
        [5, 2, 1],
        [6, 3, 1],
        [7, 4, 2],
        [8, 6, 3],
        [9, 7, 6],
        [10, 8, 7],
        [11, 10, 9]
      ];
      var sizeMultipliers = [
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      var sizeAtStyle = function sizeAtStyle2(size2, style) {
        return style.size < 2 ? size2 : sizeStyleMap[size2 - 1][style.size - 1];
      };
      var Options = /* @__PURE__ */ function() {
        function Options2(data) {
          this.style = void 0;
          this.color = void 0;
          this.size = void 0;
          this.textSize = void 0;
          this.phantom = void 0;
          this.font = void 0;
          this.fontFamily = void 0;
          this.fontWeight = void 0;
          this.fontShape = void 0;
          this.sizeMultiplier = void 0;
          this.maxSize = void 0;
          this.minRuleThickness = void 0;
          this._fontMetrics = void 0;
          this.style = data.style;
          this.color = data.color;
          this.size = data.size || Options2.BASESIZE;
          this.textSize = data.textSize || this.size;
          this.phantom = !!data.phantom;
          this.font = data.font || "";
          this.fontFamily = data.fontFamily || "";
          this.fontWeight = data.fontWeight || "";
          this.fontShape = data.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data.maxSize;
          this.minRuleThickness = data.minRuleThickness;
          this._fontMetrics = void 0;
        }
        var _proto = Options2.prototype;
        _proto.extend = function extend3(extension2) {
          var data = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (var key2 in extension2) {
            if (extension2.hasOwnProperty(key2)) {
              data[key2] = extension2[key2];
            }
          }
          return new Options2(data);
        };
        _proto.havingStyle = function havingStyle(style) {
          if (this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: sizeAtStyle(this.textSize, style)
            });
          }
        };
        _proto.havingCrampedStyle = function havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        };
        _proto.havingSize = function havingSize(size2) {
          if (this.size === size2 && this.textSize === size2) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size: size2,
              textSize: size2,
              sizeMultiplier: sizeMultipliers[size2 - 1]
            });
          }
        };
        _proto.havingBaseStyle = function havingBaseStyle(style) {
          style = style || this.style.text();
          var wantSize = sizeAtStyle(Options2.BASESIZE, style);
          if (this.size === wantSize && this.textSize === Options2.BASESIZE && this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: wantSize
            });
          }
        };
        _proto.havingBaseSizing = function havingBaseSizing() {
          var size2;
          switch (this.style.id) {
            case 4:
            case 5:
              size2 = 3;
              break;
            case 6:
            case 7:
              size2 = 1;
              break;
            default:
              size2 = 6;
          }
          return this.extend({
            style: this.style.text(),
            size: size2
          });
        };
        _proto.withColor = function withColor(color2) {
          return this.extend({
            color: color2
          });
        };
        _proto.withPhantom = function withPhantom() {
          return this.extend({
            phantom: true
          });
        };
        _proto.withFont = function withFont(font) {
          return this.extend({
            font
          });
        };
        _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        };
        _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        };
        _proto.withTextFontShape = function withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        };
        _proto.sizingClasses = function sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        };
        _proto.baseSizingClasses = function baseSizingClasses() {
          if (this.size !== Options2.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + Options2.BASESIZE];
          } else {
            return [];
          }
        };
        _proto.fontMetrics = function fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics(this.size);
          }
          return this._fontMetrics;
        };
        _proto.getColor = function getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        };
        return Options2;
      }();
      Options.BASESIZE = 6;
      var src_Options = Options;
      var ptPerUnit = {
        "pt": 1,
        "mm": 7227 / 2540,
        "cm": 7227 / 254,
        "in": 72.27,
        "bp": 803 / 800,
        "pc": 12,
        "dd": 1238 / 1157,
        "cc": 14856 / 1157,
        "nd": 685 / 642,
        "nc": 1370 / 107,
        "sp": 1 / 65536,
        "px": 803 / 800
      };
      var relativeUnit = {
        "ex": true,
        "em": true,
        "mu": true
      };
      var validUnit = function validUnit2(unit) {
        if (typeof unit !== "string") {
          unit = unit.unit;
        }
        return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
      };
      var calculateSize = function calculateSize2(sizeValue, options) {
        var scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options.fontMetrics().cssEmPerMu;
        } else {
          var unitOptions;
          if (options.style.isTight()) {
            unitOptions = options.havingStyle(options.style.text());
          } else {
            unitOptions = options;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options) {
            scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options.maxSize);
      };
      var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
        if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
          value = src_symbols[mode][value].replace;
        }
        return {
          value,
          metrics: getCharacterMetrics(value, fontName, mode)
        };
      };
      var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
        var lookup = lookupSymbol(value, fontName, mode);
        var metrics = lookup.metrics;
        value = lookup.value;
        var symbolNode;
        if (metrics) {
          var italic = metrics.italic;
          if (mode === "text" || options && options.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
        }
        if (options) {
          symbolNode.maxFontSize = options.sizeMultiplier;
          if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          var color2 = options.getColor();
          if (color2) {
            symbolNode.style.color = color2;
          }
        }
        return symbolNode;
      };
      var mathsym = function mathsym2(value, mode, options, classes) {
        if (classes === void 0) {
          classes = [];
        }
        if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
          return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
        } else if (value === "\\" || src_symbols[mode][value].font === "main") {
          return makeSymbol(value, "Main-Regular", mode, options, classes);
        } else {
          return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
        }
      };
      var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
        if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      };
      var makeOrd = function makeOrd2(group, options, type) {
        var mode = group.mode;
        var text3 = group.text;
        var classes = ["mord"];
        var isFont = mode === "math" || mode === "text" && options.font;
        var fontOrFamily = isFont ? options.font : options.fontFamily;
        if (text3.charCodeAt(0) === 55349) {
          var _wideCharacterFont = wideCharacterFont(text3, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
          return makeSymbol(text3, wideFontName, mode, options, classes.concat(wideFontClass));
        } else if (fontOrFamily) {
          var fontName;
          var fontClasses;
          if (fontOrFamily === "boldsymbol") {
            var fontData = boldsymbol(text3, mode, options, classes, type);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
            fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
          }
          if (lookupSymbol(text3, fontName, mode).metrics) {
            return makeSymbol(text3, fontName, mode, options, classes.concat(fontClasses));
          } else if (ligatures.hasOwnProperty(text3) && fontName.substr(0, 10) === "Typewriter") {
            var parts = [];
            for (var i3 = 0; i3 < text3.length; i3++) {
              parts.push(makeSymbol(text3[i3], fontName, mode, options, classes.concat(fontClasses)));
            }
            return makeFragment(parts);
          }
        }
        if (type === "mathord") {
          return makeSymbol(text3, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
        } else if (type === "textord") {
          var font = src_symbols[mode][text3] && src_symbols[mode][text3].font;
          if (font === "ams") {
            var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
            return makeSymbol(text3, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
          } else if (font === "main" || !font) {
            var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
            return makeSymbol(text3, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
          } else {
            var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
            return makeSymbol(text3, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type + " in makeOrd");
        }
      };
      var canCombine = function canCombine2(prev, next) {
        if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return false;
        }
        if (prev.classes.length === 1) {
          var cls = prev.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (var style in prev.style) {
          if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return false;
          }
        }
        for (var _style in next.style) {
          if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
            return false;
          }
        }
        return true;
      };
      var tryCombineChars = function tryCombineChars2(chars) {
        for (var i3 = 0; i3 < chars.length - 1; i3++) {
          var prev = chars[i3];
          var next = chars[i3 + 1];
          if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
            prev.text += next.text;
            prev.height = Math.max(prev.height, next.height);
            prev.depth = Math.max(prev.depth, next.depth);
            prev.italic = next.italic;
            chars.splice(i3 + 1, 1);
            i3--;
          }
        }
        return chars;
      };
      var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
        var height = 0;
        var depth = 0;
        var maxFontSize = 0;
        for (var i3 = 0; i3 < elem.children.length; i3++) {
          var child4 = elem.children[i3];
          if (child4.height > height) {
            height = child4.height;
          }
          if (child4.depth > depth) {
            depth = child4.depth;
          }
          if (child4.maxFontSize > maxFontSize) {
            maxFontSize = child4.maxFontSize;
          }
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      };
      var makeSpan = function makeSpan2(classes, children, options, style) {
        var span = new Span(classes, children, options, style);
        sizeElementFromChildren(span);
        return span;
      };
      var makeSvgSpan = function makeSvgSpan2(classes, children, options, style) {
        return new Span(classes, children, options, style);
      };
      var makeLineSpan = function makeLineSpan2(className, options, thickness) {
        var line = makeSpan([className], [], options);
        line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
        line.style.borderBottomWidth = line.height + "em";
        line.maxFontSize = 1;
        return line;
      };
      var makeAnchor = function makeAnchor2(href, classes, children, options) {
        var anchor2 = new Anchor(href, classes, children, options);
        sizeElementFromChildren(anchor2);
        return anchor2;
      };
      var makeFragment = function makeFragment2(children) {
        var fragment = new DocumentFragment(children);
        sizeElementFromChildren(fragment);
        return fragment;
      };
      var wrapFragment = function wrapFragment2(group, options) {
        if (group instanceof DocumentFragment) {
          return makeSpan([], [group], options);
        }
        return group;
      };
      var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
        if (params.positionType === "individualShift") {
          var oldChildren = params.children;
          var children = [oldChildren[0]];
          var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
          var currPos = _depth;
          for (var i3 = 1; i3 < oldChildren.length; i3++) {
            var diff = -oldChildren[i3].shift - currPos - oldChildren[i3].elem.depth;
            var size2 = diff - (oldChildren[i3 - 1].elem.height + oldChildren[i3 - 1].elem.depth);
            currPos = currPos + diff;
            children.push({
              type: "kern",
              size: size2
            });
            children.push(oldChildren[i3]);
          }
          return {
            children,
            depth: _depth
          };
        }
        var depth;
        if (params.positionType === "top") {
          var bottom = params.positionData;
          for (var _i6 = 0; _i6 < params.children.length; _i6++) {
            var child4 = params.children[_i6];
            bottom -= child4.type === "kern" ? child4.size : child4.elem.height + child4.elem.depth;
          }
          depth = bottom;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          var firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      };
      var makeVList = function makeVList2(params, options) {
        var _getVListChildrenAndD = getVListChildrenAndDepth(params), children = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
        var pstrutSize = 0;
        for (var i3 = 0; i3 < children.length; i3++) {
          var child4 = children[i3];
          if (child4.type === "elem") {
            var elem = child4.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        var pstrut = makeSpan(["pstrut"], []);
        pstrut.style.height = pstrutSize + "em";
        var realChildren = [];
        var minPos = depth;
        var maxPos = depth;
        var currPos = depth;
        for (var _i22 = 0; _i22 < children.length; _i22++) {
          var _child = children[_i22];
          if (_child.type === "kern") {
            currPos += _child.size;
          } else {
            var _elem = _child.elem;
            var classes = _child.wrapperClasses || [];
            var style = _child.wrapperStyle || {};
            var childWrap = makeSpan(classes, [pstrut, _elem], void 0, style);
            childWrap.style.top = -pstrutSize - currPos - _elem.depth + "em";
            if (_child.marginLeft) {
              childWrap.style.marginLeft = _child.marginLeft;
            }
            if (_child.marginRight) {
              childWrap.style.marginRight = _child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += _elem.height + _elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos = Math.max(maxPos, currPos);
        }
        var vlist = makeSpan(["vlist"], realChildren);
        vlist.style.height = maxPos + "em";
        var rows;
        if (minPos < 0) {
          var emptySpan = makeSpan([], []);
          var depthStrut = makeSpan(["vlist"], [emptySpan]);
          depthStrut.style.height = -minPos + "em";
          var topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200B")]);
          rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan(["vlist-r"], [vlist])];
        }
        var vtable = makeSpan(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos;
        vtable.depth = -minPos;
        return vtable;
      };
      var makeGlue = function makeGlue2(measurement, options) {
        var rule = makeSpan(["mspace"], [], options);
        var size2 = calculateSize(measurement, options);
        rule.style.marginRight = size2 + "em";
        return rule;
      };
      var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
        var baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        var fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      };
      var fontMap = {
        "mathbf": {
          variant: "bold",
          fontName: "Main-Bold"
        },
        "mathrm": {
          variant: "normal",
          fontName: "Main-Regular"
        },
        "textit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathnormal": {
          variant: "italic",
          fontName: "Math-Italic"
        },
        "mathbb": {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        "mathcal": {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        "mathfrak": {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        "mathscr": {
          variant: "script",
          fontName: "Script-Regular"
        },
        "mathsf": {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        "mathtt": {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      var svgData = {
        vec: ["vec", 0.471, 0.714],
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      var staticSvg = function staticSvg2(value, options) {
        var _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
        var path3 = new PathNode(pathName);
        var svgNode = new SvgNode([path3], {
          "width": width + "em",
          "height": height + "em",
          "style": "width:" + width + "em",
          "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
          "preserveAspectRatio": "xMinYMin"
        });
        var span = makeSvgSpan(["overlay"], [svgNode], options);
        span.height = height;
        span.style.height = height + "em";
        span.style.width = width + "em";
        return span;
      };
      var buildCommon = {
        fontMap,
        makeSymbol,
        mathsym,
        makeSpan,
        makeSvgSpan,
        makeLineSpan,
        makeAnchor,
        makeFragment,
        wrapFragment,
        makeVList,
        makeOrd,
        makeGlue,
        staticSvg,
        svgData,
        tryCombineChars
      };
      var thinspace = {
        number: 3,
        unit: "mu"
      };
      var mediumspace = {
        number: 4,
        unit: "mu"
      };
      var thickspace = {
        number: 5,
        unit: "mu"
      };
      var spacings = {
        mord: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          minner: thinspace
        },
        mbin: {
          mord: mediumspace,
          mop: mediumspace,
          mopen: mediumspace,
          minner: mediumspace
        },
        mrel: {
          mord: thickspace,
          mop: thickspace,
          mopen: thickspace,
          minner: thickspace
        },
        mopen: {},
        mclose: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mpunct: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          mopen: thinspace,
          mclose: thinspace,
          mpunct: thinspace,
          minner: thinspace
        },
        minner: {
          mord: thinspace,
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          mopen: thinspace,
          mpunct: thinspace,
          minner: thinspace
        }
      };
      var tightSpacings = {
        mord: {
          mop: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace
        },
        mpunct: {},
        minner: {
          mop: thinspace
        }
      };
      var _functions = {};
      var _htmlGroupBuilders = {};
      var _mathmlGroupBuilders = {};
      function defineFunction(_ref) {
        var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder2 = _ref.htmlBuilder, mathmlBuilder2 = _ref.mathmlBuilder;
        var data = {
          type,
          numArgs: props.numArgs,
          argTypes: props.argTypes,
          allowedInArgument: !!props.allowedInArgument,
          allowedInText: !!props.allowedInText,
          allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
          numOptionalArgs: props.numOptionalArgs || 0,
          infix: !!props.infix,
          primitive: !!props.primitive,
          handler
        };
        for (var i3 = 0; i3 < names.length; ++i3) {
          _functions[names[i3]] = data;
        }
        if (type) {
          if (htmlBuilder2) {
            _htmlGroupBuilders[type] = htmlBuilder2;
          }
          if (mathmlBuilder2) {
            _mathmlGroupBuilders[type] = mathmlBuilder2;
          }
        }
      }
      function defineFunctionBuilders(_ref2) {
        var type = _ref2.type, htmlBuilder2 = _ref2.htmlBuilder, mathmlBuilder2 = _ref2.mathmlBuilder;
        defineFunction({
          type,
          names: [],
          props: {
            numArgs: 0
          },
          handler: function handler() {
            throw new Error("Should never be called.");
          },
          htmlBuilder: htmlBuilder2,
          mathmlBuilder: mathmlBuilder2
        });
      }
      var normalizeArgument = function normalizeArgument2(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      };
      var ordargument = function ordargument2(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      };
      var buildHTML_makeSpan = buildCommon.makeSpan;
      var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
      var styleMap = {
        "display": src_Style.DISPLAY,
        "text": src_Style.TEXT,
        "script": src_Style.SCRIPT,
        "scriptscript": src_Style.SCRIPTSCRIPT
      };
      var DomEnum = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      var buildExpression = function buildExpression2(expression, options, isRealGroup, surrounding) {
        if (surrounding === void 0) {
          surrounding = [null, null];
        }
        var groups = [];
        for (var i3 = 0; i3 < expression.length; i3++) {
          var output = buildGroup(expression[i3], options);
          if (output instanceof DocumentFragment) {
            var children = output.children;
            groups.push.apply(groups, children);
          } else {
            groups.push(output);
          }
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        var glueOptions = options;
        if (expression.length === 1) {
          var node5 = expression[0];
          if (node5.type === "sizing") {
            glueOptions = options.havingSize(node5.size);
          } else if (node5.type === "styling") {
            glueOptions = options.havingStyle(styleMap[node5.style]);
          }
        }
        var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
        var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
        var isRoot = isRealGroup === "root";
        traverseNonSpaceNodes(groups, function(node6, prev) {
          var prevType = prev.classes[0];
          var type = node6.classes[0];
          if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
            prev.classes[0] = "mord";
          } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
            node6.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes(groups, function(node6, prev) {
          var prevType = getTypeOfDomTree(prev);
          var type = getTypeOfDomTree(node6);
          var space2 = prevType && type ? node6.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
          if (space2) {
            return buildCommon.makeGlue(space2, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      };
      var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes2, callback, prev, next, isRoot) {
        if (next) {
          nodes2.push(next);
        }
        var i3 = 0;
        for (; i3 < nodes2.length; i3++) {
          var node5 = nodes2[i3];
          var partialGroup = checkPartialGroup(node5);
          if (partialGroup) {
            traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
            continue;
          }
          var nonspace = !node5.hasClass("mspace");
          if (nonspace) {
            var result2 = callback(node5, prev.node);
            if (result2) {
              if (prev.insertAfter) {
                prev.insertAfter(result2);
              } else {
                nodes2.unshift(result2);
                i3++;
              }
            }
          }
          if (nonspace) {
            prev.node = node5;
          } else if (isRoot && node5.hasClass("newline")) {
            prev.node = buildHTML_makeSpan(["leftmost"]);
          }
          prev.insertAfter = function(index3) {
            return function(n2) {
              nodes2.splice(index3 + 1, 0, n2);
              i3++;
            };
          }(i3);
        }
        if (next) {
          nodes2.pop();
        }
      };
      var checkPartialGroup = function checkPartialGroup2(node5) {
        if (node5 instanceof DocumentFragment || node5 instanceof Anchor || node5 instanceof Span && node5.hasClass("enclosing")) {
          return node5;
        }
        return null;
      };
      var getOutermostNode = function getOutermostNode2(node5, side) {
        var partialGroup = checkPartialGroup(node5);
        if (partialGroup) {
          var children = partialGroup.children;
          if (children.length) {
            if (side === "right") {
              return getOutermostNode2(children[children.length - 1], "right");
            } else if (side === "left") {
              return getOutermostNode2(children[0], "left");
            }
          }
        }
        return node5;
      };
      var getTypeOfDomTree = function getTypeOfDomTree2(node5, side) {
        if (!node5) {
          return null;
        }
        if (side) {
          node5 = getOutermostNode(node5, side);
        }
        return DomEnum[node5.classes[0]] || null;
      };
      var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
        var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
        return buildHTML_makeSpan(classes.concat(moreClasses));
      };
      var buildGroup = function buildGroup2(group, options, baseOptions) {
        if (!group) {
          return buildHTML_makeSpan();
        }
        if (_htmlGroupBuilders[group.type]) {
          var groupNode = _htmlGroupBuilders[group.type](group, options);
          if (baseOptions && options.size !== baseOptions.size) {
            groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
            var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildHTMLUnbreakable(children, options) {
        var body = buildHTML_makeSpan(["base"], children, options);
        var strut = buildHTML_makeSpan(["strut"]);
        strut.style.height = body.height + body.depth + "em";
        strut.style.verticalAlign = -body.depth + "em";
        body.children.unshift(strut);
        return body;
      }
      function buildHTML(tree, options) {
        var tag = null;
        if (tree.length === 1 && tree[0].type === "tag") {
          tag = tree[0].tag;
          tree = tree[0].body;
        }
        var expression = buildExpression(tree, options, "root");
        var eqnNum;
        if (expression.length === 2 && expression[1].hasClass("tag")) {
          eqnNum = expression.pop();
        }
        var children = [];
        var parts = [];
        for (var i3 = 0; i3 < expression.length; i3++) {
          parts.push(expression[i3]);
          if (expression[i3].hasClass("mbin") || expression[i3].hasClass("mrel") || expression[i3].hasClass("allowbreak")) {
            var nobreak = false;
            while (i3 < expression.length - 1 && expression[i3 + 1].hasClass("mspace") && !expression[i3 + 1].hasClass("newline")) {
              i3++;
              parts.push(expression[i3]);
              if (expression[i3].hasClass("nobreak")) {
                nobreak = true;
              }
            }
            if (!nobreak) {
              children.push(buildHTMLUnbreakable(parts, options));
              parts = [];
            }
          } else if (expression[i3].hasClass("newline")) {
            parts.pop();
            if (parts.length > 0) {
              children.push(buildHTMLUnbreakable(parts, options));
              parts = [];
            }
            children.push(expression[i3]);
          }
        }
        if (parts.length > 0) {
          children.push(buildHTMLUnbreakable(parts, options));
        }
        var tagChild;
        if (tag) {
          tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
          tagChild.classes = ["tag"];
          children.push(tagChild);
        } else if (eqnNum) {
          children.push(eqnNum);
        }
        var htmlNode = buildHTML_makeSpan(["katex-html"], children);
        htmlNode.setAttribute("aria-hidden", "true");
        if (tagChild) {
          var strut = tagChild.children[0];
          strut.style.height = htmlNode.height + htmlNode.depth + "em";
          strut.style.verticalAlign = -htmlNode.depth + "em";
        }
        return htmlNode;
      }
      function newDocumentFragment(children) {
        return new DocumentFragment(children);
      }
      var MathNode = /* @__PURE__ */ function() {
        function MathNode2(type, children, classes) {
          this.type = void 0;
          this.attributes = void 0;
          this.children = void 0;
          this.classes = void 0;
          this.type = type;
          this.attributes = {};
          this.children = children || [];
          this.classes = classes || [];
        }
        var _proto = MathNode2.prototype;
        _proto.setAttribute = function setAttribute(name, value) {
          this.attributes[name] = value;
        };
        _proto.getAttribute = function getAttribute(name) {
          return this.attributes[name];
        };
        _proto.toNode = function toNode() {
          var node5 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node5.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node5.className = createClass(this.classes);
          }
          for (var i3 = 0; i3 < this.children.length; i3++) {
            node5.appendChild(this.children[i3].toNode());
          }
          return node5;
        };
        _proto.toMarkup = function toMarkup() {
          var markup = "<" + this.type;
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
          }
          markup += ">";
          for (var i3 = 0; i3 < this.children.length; i3++) {
            markup += this.children[i3].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        };
        _proto.toText = function toText() {
          return this.children.map(function(child4) {
            return child4.toText();
          }).join("");
        };
        return MathNode2;
      }();
      var TextNode2 = /* @__PURE__ */ function() {
        function TextNode3(text3) {
          this.text = void 0;
          this.text = text3;
        }
        var _proto2 = TextNode3.prototype;
        _proto2.toNode = function toNode() {
          return document.createTextNode(this.text);
        };
        _proto2.toMarkup = function toMarkup() {
          return utils.escape(this.toText());
        };
        _proto2.toText = function toText() {
          return this.text;
        };
        return TextNode3;
      }();
      var SpaceNode = /* @__PURE__ */ function() {
        function SpaceNode2(width) {
          this.width = void 0;
          this.character = void 0;
          this.width = width;
          if (width >= 0.05555 && width <= 0.05556) {
            this.character = "\u200A";
          } else if (width >= 0.1666 && width <= 0.1667) {
            this.character = "\u2009";
          } else if (width >= 0.2222 && width <= 0.2223) {
            this.character = "\u2005";
          } else if (width >= 0.2777 && width <= 0.2778) {
            this.character = "\u2005\u200A";
          } else if (width >= -0.05556 && width <= -0.05555) {
            this.character = "\u200A\u2063";
          } else if (width >= -0.1667 && width <= -0.1666) {
            this.character = "\u2009\u2063";
          } else if (width >= -0.2223 && width <= -0.2222) {
            this.character = "\u205F\u2063";
          } else if (width >= -0.2778 && width <= -0.2777) {
            this.character = "\u2005\u2063";
          } else {
            this.character = null;
          }
        }
        var _proto3 = SpaceNode2.prototype;
        _proto3.toNode = function toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            var node5 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node5.setAttribute("width", this.width + "em");
            return node5;
          }
        };
        _proto3.toMarkup = function toMarkup() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + this.width + 'em"/>';
          }
        };
        _proto3.toText = function toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        };
        return SpaceNode2;
      }();
      var mathMLTree = {
        MathNode,
        TextNode: TextNode2,
        SpaceNode,
        newDocumentFragment
      };
      var makeText = function makeText2(text3, mode, options) {
        if (src_symbols[mode][text3] && src_symbols[mode][text3].replace && text3.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text3) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
          text3 = src_symbols[mode][text3].replace;
        }
        return new mathMLTree.TextNode(text3);
      };
      var makeRow = function makeRow2(body) {
        if (body.length === 1) {
          return body[0];
        } else {
          return new mathMLTree.MathNode("mrow", body);
        }
      };
      var getVariant = function getVariant2(group, options) {
        if (options.fontFamily === "texttt") {
          return "monospace";
        } else if (options.fontFamily === "textsf") {
          if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options.fontShape === "textit") {
          return "italic";
        } else if (options.fontWeight === "textbf") {
          return "bold";
        }
        var font = options.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        var mode = group.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        var text3 = group.text;
        if (utils.contains(["\\imath", "\\jmath"], text3)) {
          return null;
        }
        if (src_symbols[mode][text3] && src_symbols[mode][text3].replace) {
          text3 = src_symbols[mode][text3].replace;
        }
        var fontName = buildCommon.fontMap[font].fontName;
        if (getCharacterMetrics(text3, fontName, mode)) {
          return buildCommon.fontMap[font].variant;
        }
        return null;
      };
      var buildMathML_buildExpression = function buildExpression2(expression, options, isOrdgroup) {
        if (expression.length === 1) {
          var group = buildMathML_buildGroup(expression[0], options);
          if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
            group.setAttribute("lspace", "0em");
            group.setAttribute("rspace", "0em");
          }
          return [group];
        }
        var groups = [];
        var lastGroup;
        for (var i3 = 0; i3 < expression.length; i3++) {
          var _group = buildMathML_buildGroup(expression[i3], options);
          if (_group instanceof MathNode && lastGroup instanceof MathNode) {
            if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              var _lastGroup$children;
              (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);
              continue;
            } else if (_group.type === "mn" && lastGroup.type === "mn") {
              var _lastGroup$children2;
              (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);
              continue;
            } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
              var child4 = _group.children[0];
              if (child4 instanceof TextNode2 && child4.text === ".") {
                var _lastGroup$children3;
                (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);
                continue;
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              var lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode2 && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                var _child = _group.children[0];
                if (_child instanceof TextNode2 && _child.text.length > 0) {
                  _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(_group);
          lastGroup = _group;
        }
        return groups;
      };
      var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
        return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
      };
      var buildMathML_buildGroup = function buildGroup2(group, options) {
        if (!group) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group.type]) {
          var result2 = _mathmlGroupBuilders[group.type](group, options);
          return result2;
        } else {
          throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
        var expression = buildMathML_buildExpression(tree, options);
        var wrapper;
        if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
          wrapper = expression[0];
        } else {
          wrapper = new mathMLTree.MathNode("mrow", expression);
        }
        var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
        annotation.setAttribute("encoding", "application/x-tex");
        var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
        var math3 = new mathMLTree.MathNode("math", [semantics]);
        math3.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
        if (isDisplayMode) {
          math3.setAttribute("display", "block");
        }
        var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
        return buildCommon.makeSpan([wrapperClass], [math3]);
      }
      var optionsFromSettings = function optionsFromSettings2(settings) {
        return new src_Options({
          style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      };
      var displayWrap = function displayWrap2(node5, settings) {
        if (settings.displayMode) {
          var classes = ["katex-display"];
          if (settings.leqno) {
            classes.push("leqno");
          }
          if (settings.fleqn) {
            classes.push("fleqn");
          }
          node5 = buildCommon.makeSpan(classes, [node5]);
        }
        return node5;
      };
      var buildTree2 = function buildTree3(tree, expression, settings) {
        var options = optionsFromSettings(settings);
        var katexNode;
        if (settings.output === "mathml") {
          return buildMathML(tree, expression, options, settings.displayMode, true);
        } else if (settings.output === "html") {
          var htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        } else {
          var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
          var _htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
        }
        return displayWrap(katexNode, settings);
      };
      var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
        var options = optionsFromSettings(settings);
        var htmlNode = buildHTML(tree, options);
        var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        return displayWrap(katexNode, settings);
      };
      var stretchyCodePoint = {
        widehat: "^",
        widecheck: "\u02C7",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "\u2190",
        underleftarrow: "\u2190",
        xleftarrow: "\u2190",
        overrightarrow: "\u2192",
        underrightarrow: "\u2192",
        xrightarrow: "\u2192",
        underbrace: "\u23DF",
        overbrace: "\u23DE",
        overgroup: "\u23E0",
        undergroup: "\u23E1",
        overleftrightarrow: "\u2194",
        underleftrightarrow: "\u2194",
        xleftrightarrow: "\u2194",
        Overrightarrow: "\u21D2",
        xRightarrow: "\u21D2",
        overleftharpoon: "\u21BC",
        xleftharpoonup: "\u21BC",
        overrightharpoon: "\u21C0",
        xrightharpoonup: "\u21C0",
        xLeftarrow: "\u21D0",
        xLeftrightarrow: "\u21D4",
        xhookleftarrow: "\u21A9",
        xhookrightarrow: "\u21AA",
        xmapsto: "\u21A6",
        xrightharpoondown: "\u21C1",
        xleftharpoondown: "\u21BD",
        xrightleftharpoons: "\u21CC",
        xleftrightharpoons: "\u21CB",
        xtwoheadleftarrow: "\u219E",
        xtwoheadrightarrow: "\u21A0",
        xlongequal: "=",
        xtofrom: "\u21C4",
        xrightleftarrows: "\u21C4",
        xrightequilibrium: "\u21CC",
        xleftequilibrium: "\u21CB",
        "\\cdrightarrow": "\u2192",
        "\\cdleftarrow": "\u2190",
        "\\cdlongequal": "="
      };
      var mathMLnode = function mathMLnode2(label2) {
        var node5 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label2.replace(/^\\/, "")])]);
        node5.setAttribute("stretchy", "true");
        return node5;
      };
      var katexImagesData = {
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      var groupLength = function groupLength2(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      };
      var svgSpan = function svgSpan2(group, options) {
        function buildSvgSpan_() {
          var viewBoxWidth = 4e5;
          var label2 = group.label.substr(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label2)) {
            var grp = group;
            var numChars = groupLength(grp.base);
            var viewBoxHeight;
            var pathName;
            var _height;
            if (numChars > 5) {
              if (label2 === "widehat" || label2 === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                _height = 0.42;
                pathName = label2 + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                _height = 0.34;
                pathName = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label2 === "widehat" || label2 === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label2 + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            var path3 = new PathNode(pathName);
            var svgNode = new SvgNode([path3], {
              "width": "100%",
              "height": _height + "em",
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              "preserveAspectRatio": "none"
            });
            return {
              span: buildCommon.makeSvgSpan([], [svgNode], options),
              minWidth: 0,
              height: _height
            };
          } else {
            var spans = [];
            var data = katexImagesData[label2];
            var paths = data[0], _minWidth = data[1], _viewBoxHeight = data[2];
            var _height2 = _viewBoxHeight / 1e3;
            var numSvgChildren = paths.length;
            var widthClasses;
            var aligns;
            if (numSvgChildren === 1) {
              var align1 = data[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
            }
            for (var i3 = 0; i3 < numSvgChildren; i3++) {
              var _path = new PathNode(paths[i3]);
              var _svgNode = new SvgNode([_path], {
                "width": "400em",
                "height": _height2 + "em",
                "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                "preserveAspectRatio": aligns[i3] + " slice"
              });
              var _span = buildCommon.makeSvgSpan([widthClasses[i3]], [_svgNode], options);
              if (numSvgChildren === 1) {
                return {
                  span: _span,
                  minWidth: _minWidth,
                  height: _height2
                };
              } else {
                _span.style.height = _height2 + "em";
                spans.push(_span);
              }
            }
            return {
              span: buildCommon.makeSpan(["stretchy"], spans, options),
              minWidth: _minWidth,
              height: _height2
            };
          }
        }
        var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
        span.height = height;
        span.style.height = height + "em";
        if (minWidth > 0) {
          span.style.minWidth = minWidth + "em";
        }
        return span;
      };
      var encloseSpan = function encloseSpan2(inner2, label2, topPad, bottomPad, options) {
        var img;
        var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label2)) {
          img = buildCommon.makeSpan(["stretchy", label2], [], options);
          if (label2 === "fbox") {
            var color2 = options.color && options.getColor();
            if (color2) {
              img.style.borderColor = color2;
            }
          }
        } else {
          var lines = [];
          if (/^[bx]cancel$/.test(label2)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "0",
              "x2": "100%",
              "y2": "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label2)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "100%",
              "x2": "100%",
              "y2": "0",
              "stroke-width": "0.046em"
            }));
          }
          var svgNode = new SvgNode(lines, {
            "width": "100%",
            "height": totalHeight + "em"
          });
          img = buildCommon.makeSvgSpan([], [svgNode], options);
        }
        img.height = totalHeight;
        img.style.height = totalHeight + "em";
        return img;
      };
      var stretchy = {
        encloseSpan,
        mathMLnode,
        svgSpan
      };
      function assertNodeType(node5, type) {
        if (!node5 || node5.type !== type) {
          throw new Error("Expected node of type " + type + ", but got " + (node5 ? "node of type " + node5.type : String(node5)));
        }
        return node5;
      }
      function assertSymbolNodeType(node5) {
        var typedNode = checkSymbolNodeType(node5);
        if (!typedNode) {
          throw new Error("Expected node of symbol group type, but got " + (node5 ? "node of type " + node5.type : String(node5)));
        }
        return typedNode;
      }
      function checkSymbolNodeType(node5) {
        if (node5 && (node5.type === "atom" || NON_ATOMS.hasOwnProperty(node5.type))) {
          return node5;
        }
        return null;
      }
      var htmlBuilder = function htmlBuilder2(grp, options) {
        var base2;
        var group;
        var supSubGroup;
        if (grp && grp.type === "supsub") {
          group = assertNodeType(grp.base, "accent");
          base2 = group.base;
          grp.base = base2;
          supSubGroup = assertSpan(buildGroup(grp, options));
          grp.base = group;
        } else {
          group = assertNodeType(grp, "accent");
          base2 = group.base;
        }
        var body = buildGroup(base2, options.havingCrampedStyle());
        var mustShift = group.isShifty && utils.isCharacterBox(base2);
        var skew = 0;
        if (mustShift) {
          var baseChar = utils.getBaseElem(base2);
          var baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
          skew = assertSymbolDomNode(baseGroup).skew;
        }
        var clearance = Math.min(body.height, options.fontMetrics().xHeight);
        var accentBody;
        if (!group.isStretchy) {
          var accent2;
          var width;
          if (group.label === "\\vec") {
            accent2 = buildCommon.staticSvg("vec", options);
            width = buildCommon.svgData.vec[1];
          } else {
            accent2 = buildCommon.makeOrd({
              mode: group.mode,
              text: group.label
            }, options, "textord");
            accent2 = assertSymbolDomNode(accent2);
            accent2.italic = 0;
            width = accent2.width;
          }
          accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
          var accentFull = group.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body.height;
          }
          var left = skew;
          if (!accentFull) {
            left -= width / 2;
          }
          accentBody.style.left = left + "em";
          if (group.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options);
        } else {
          accentBody = stretchy.svgSpan(group, options);
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + 2 * skew + "em)",
                marginLeft: 2 * skew + "em"
              } : void 0
            }]
          }, options);
        }
        var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      };
      var mathmlBuilder = function mathmlBuilder2(group, options) {
        var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
        var node5 = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
        node5.setAttribute("accent", "true");
        return node5;
      };
      var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent2) {
        return "\\" + accent2;
      }).join("|"));
      defineFunction({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: function handler(context, args) {
          var base2 = normalizeArgument(args[0]);
          var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
          var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context.parser.mode,
            label: context.funcName,
            isStretchy,
            isShifty,
            base: base2
          };
        },
        htmlBuilder,
        mathmlBuilder
      });
      defineFunction({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["primitive"]
        },
        handler: function handler(context, args) {
          var base2 = args[0];
          var mode = context.parser.mode;
          if (mode === "math") {
            context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context.funcName,
            isStretchy: false,
            isShifty: true,
            base: base2
          };
        },
        htmlBuilder,
        mathmlBuilder
      });
      defineFunction({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var base2 = args[0];
          return {
            type: "accentUnder",
            mode: parser2.mode,
            label: funcName,
            base: base2
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var innerGroup = buildGroup(group.base, options);
          var accentBody = stretchy.svgSpan(group, options);
          var kern = group.label === "\\utilde" ? 0.12 : 0;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var accentNode = stretchy.mathMLnode(group.label);
          var node5 = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
          node5.setAttribute("accentunder", "true");
          return node5;
        }
      });
      var paddedNode = function paddedNode2(group) {
        var node5 = new mathMLTree.MathNode("mpadded", group ? [group] : []);
        node5.setAttribute("width", "+0.6em");
        node5.setAttribute("lspace", "0.3em");
        return node5;
      };
      defineFunction({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          return {
            type: "xArrow",
            mode: parser2.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var style = options.style;
          var newOptions = options.havingStyle(style.sup());
          var upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
          var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          var lowerGroup;
          if (group.below) {
            newOptions = options.havingStyle(style.sub());
            lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          var arrowBody = stretchy.svgSpan(group, options);
          var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          var vlist;
          if (lowerGroup) {
            var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var arrowNode = stretchy.mathMLnode(group.label);
          arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var node5;
          if (group.body) {
            var upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
            if (group.below) {
              var lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
              node5 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node5 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group.below) {
            var _lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
            node5 = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
          } else {
            node5 = paddedNode();
            node5 = new mathMLTree.MathNode("mover", [arrowNode, node5]);
          }
          return node5;
        }
      });
      var cdArrowFunctionName = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        "A": "\\uparrow",
        "V": "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      var newCell = function newCell2() {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      };
      var isStartOfArrow = function isStartOfArrow2(node5) {
        return node5.type === "textord" && node5.text === "@";
      };
      var isLabelEnd = function isLabelEnd2(node5, endChar) {
        return (node5.type === "mathord" || node5.type === "atom") && node5.text === endChar;
      };
      function cdArrow(arrowChar, labels, parser2) {
        var funcName = cdArrowFunctionName[arrowChar];
        switch (funcName) {
          case "\\\\cdrightarrow":
          case "\\\\cdleftarrow":
            return parser2.callFunction(funcName, [labels[0]], [labels[1]]);
          case "\\uparrow":
          case "\\downarrow": {
            var leftLabel = parser2.callFunction("\\\\cdleft", [labels[0]], []);
            var bareArrow = {
              type: "atom",
              text: funcName,
              mode: "math",
              family: "rel"
            };
            var sizedArrow = parser2.callFunction("\\Big", [bareArrow], []);
            var rightLabel = parser2.callFunction("\\\\cdright", [labels[1]], []);
            var arrowGroup = {
              type: "ordgroup",
              mode: "math",
              body: [leftLabel, sizedArrow, rightLabel]
            };
            return parser2.callFunction("\\\\cdparent", [arrowGroup], []);
          }
          case "\\\\cdlongequal":
            return parser2.callFunction("\\\\cdlongequal", [], []);
          case "\\Vert": {
            var arrow2 = {
              type: "textord",
              text: "\\Vert",
              mode: "math"
            };
            return parser2.callFunction("\\Big", [arrow2], []);
          }
          default:
            return {
              type: "textord",
              text: " ",
              mode: "math"
            };
        }
      }
      function parseCD(parser2) {
        var parsedRows = [];
        parser2.gullet.beginGroup();
        parser2.gullet.macros.set("\\cr", "\\\\\\relax");
        parser2.gullet.beginGroup();
        while (true) {
          parsedRows.push(parser2.parseExpression(false, "\\\\"));
          parser2.gullet.endGroup();
          parser2.gullet.beginGroup();
          var next = parser2.fetch().text;
          if (next === "&" || next === "\\\\") {
            parser2.consume();
          } else if (next === "\\end") {
            if (parsedRows[parsedRows.length - 1].length === 0) {
              parsedRows.pop();
            }
            break;
          } else {
            throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser2.nextToken);
          }
        }
        var row = [];
        var body = [row];
        for (var i3 = 0; i3 < parsedRows.length; i3++) {
          var rowNodes = parsedRows[i3];
          var cell = newCell();
          for (var j2 = 0; j2 < rowNodes.length; j2++) {
            if (!isStartOfArrow(rowNodes[j2])) {
              cell.body.push(rowNodes[j2]);
            } else {
              row.push(cell);
              j2 += 1;
              var arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
              var labels = new Array(2);
              labels[0] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              labels[1] = {
                type: "ordgroup",
                mode: "math",
                body: []
              };
              if ("=|.".indexOf(arrowChar) > -1)
                ;
              else if ("<>AV".indexOf(arrowChar) > -1) {
                for (var labelNum = 0; labelNum < 2; labelNum++) {
                  var inLabel = true;
                  for (var k2 = j2 + 1; k2 < rowNodes.length; k2++) {
                    if (isLabelEnd(rowNodes[k2], arrowChar)) {
                      inLabel = false;
                      j2 = k2;
                      break;
                    }
                    if (isStartOfArrow(rowNodes[k2])) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k2]);
                    }
                    labels[labelNum].body.push(rowNodes[k2]);
                  }
                  if (inLabel) {
                    throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
                  }
                }
              } else {
                throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
              }
              var arrow2 = cdArrow(arrowChar, labels, parser2);
              var wrappedArrow = {
                type: "styling",
                body: [arrow2],
                mode: "math",
                style: "display"
              };
              row.push(wrappedArrow);
              cell = newCell();
            }
          }
          if (i3 % 2 === 0) {
            row.push(cell);
          } else {
            row.shift();
          }
          row = [];
          body.push(row);
        }
        parser2.gullet.endGroup();
        parser2.gullet.endGroup();
        var cols = new Array(body[0].length).fill({
          type: "align",
          align: "c",
          pregap: 0.25,
          postgap: 0.25
        });
        return {
          type: "array",
          mode: "math",
          body,
          arraystretch: 1,
          addJot: true,
          rowGaps: [null],
          cols,
          colSeparationType: "CD",
          hLinesBeforeRow: new Array(body.length + 1).fill([])
        };
      }
      defineFunction({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          return {
            type: "cdlabel",
            mode: parser2.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var newOptions = options.havingStyle(options.style.sup());
          var label2 = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
          label2.classes.push("cd-label-" + group.side);
          label2.style.bottom = 0.8 - label2.depth + "em";
          label2.height = 0;
          label2.depth = 0;
          return label2;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var label2 = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
          label2 = new mathMLTree.MathNode("mpadded", [label2]);
          label2.setAttribute("width", "0");
          if (group.side === "left") {
            label2.setAttribute("lspace", "-1width");
          }
          label2.setAttribute("voffset", "0.7em");
          label2 = new mathMLTree.MathNode("mstyle", [label2]);
          label2.setAttribute("displaystyle", "false");
          label2.setAttribute("scriptlevel", "1");
          return label2;
        }
      });
      defineFunction({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          return {
            type: "cdlabelparent",
            mode: parser2.mode,
            fragment: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
          parent.classes.push("cd-vert-arrow");
          return parent;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
        }
      });
      defineFunction({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          var arg = assertNodeType(args[0], "ordgroup");
          var group = arg.body;
          var number = "";
          for (var i3 = 0; i3 < group.length; i3++) {
            var node5 = assertNodeType(group[i3], "textord");
            number += node5.text;
          }
          var code2 = parseInt(number);
          if (isNaN(code2)) {
            throw new src_ParseError("\\@char has non-numeric argument " + number);
          }
          return {
            type: "textord",
            mode: parser2.mode,
            text: String.fromCharCode(code2)
          };
        }
      });
      var color_htmlBuilder = function htmlBuilder2(group, options) {
        var elements = buildExpression(group.body, options.withColor(group.color), false);
        return buildCommon.makeFragment(elements);
      };
      var color_mathmlBuilder = function mathmlBuilder2(group, options) {
        var inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
        var node5 = new mathMLTree.MathNode("mstyle", inner2);
        node5.setAttribute("mathcolor", group.color);
        return node5;
      };
      defineFunction({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          var color2 = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "color",
            mode: parser2.mode,
            color: color2,
            body: ordargument(body)
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
          var color2 = assertNodeType(args[0], "color-token").color;
          parser2.gullet.macros.set("\\current@color", color2);
          var body = parser2.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser2.mode,
            color: color2,
            body
          };
        },
        htmlBuilder: color_htmlBuilder,
        mathmlBuilder: color_mathmlBuilder
      });
      defineFunction({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 1,
          argTypes: ["size"],
          allowedInText: true
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser;
          var size2 = optArgs[0];
          var newLine = !parser2.settings.displayMode || !parser2.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return {
            type: "cr",
            mode: parser2.mode,
            newLine,
            size: size2 && assertNodeType(size2, "size").value
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var span = buildCommon.makeSpan(["mspace"], [], options);
          if (group.newLine) {
            span.classes.push("newline");
            if (group.size) {
              span.style.marginTop = calculateSize(group.size, options) + "em";
            }
          }
          return span;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mspace");
          if (group.newLine) {
            node5.setAttribute("linebreak", "newline");
            if (group.size) {
              node5.setAttribute("height", calculateSize(group.size, options) + "em");
            }
          }
          return node5;
        }
      });
      var globalMap = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      var checkControlSequence = function checkControlSequence2(tok) {
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new src_ParseError("Expected a control sequence", tok);
        }
        return name;
      };
      var getRHS = function getRHS2(parser2) {
        var tok = parser2.gullet.popToken();
        if (tok.text === "=") {
          tok = parser2.gullet.popToken();
          if (tok.text === " ") {
            tok = parser2.gullet.popToken();
          }
        }
        return tok;
      };
      var letCommand = function letCommand2(parser2, name, tok, global2) {
        var macro = parser2.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            unexpandable: !parser2.gullet.isExpandable(tok.text)
          };
        }
        parser2.gullet.macros.set(name, macro, global2);
      };
      defineFunction({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          parser2.consumeSpaces();
          var token = parser2.fetch();
          if (globalMap[token.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token.text = globalMap[token.text];
            }
            return assertNodeType(parser2.parseFunction(), "internal");
          }
          throw new src_ParseError("Invalid token after macro prefix", token);
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref2) {
          var parser2 = _ref2.parser, funcName = _ref2.funcName;
          var tok = parser2.gullet.popToken();
          var name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          var numArgs = 0;
          var insert;
          var delimiters2 = [[]];
          while (parser2.gullet.future().text !== "{") {
            tok = parser2.gullet.popToken();
            if (tok.text === "#") {
              if (parser2.gullet.future().text === "{") {
                insert = parser2.gullet.future();
                delimiters2[numArgs].push("{");
                break;
              }
              tok = parser2.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new src_ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new src_ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters2.push([]);
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Expected a macro definition");
            } else {
              delimiters2[numArgs].push(tok.text);
            }
          }
          var _parser$gullet$consum = parser2.gullet.consumeArg(), tokens = _parser$gullet$consum.tokens;
          if (insert) {
            tokens.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens = parser2.gullet.expandTokens(tokens);
            tokens.reverse();
          }
          parser2.gullet.macros.set(name, {
            tokens,
            numArgs,
            delimiters: delimiters2
          }, funcName === globalMap[funcName]);
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref3) {
          var parser2 = _ref3.parser, funcName = _ref3.funcName;
          var name = checkControlSequence(parser2.gullet.popToken());
          parser2.gullet.consumeSpaces();
          var tok = getRHS(parser2);
          letCommand(parser2, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref4) {
          var parser2 = _ref4.parser, funcName = _ref4.funcName;
          var name = checkControlSequence(parser2.gullet.popToken());
          var middle = parser2.gullet.popToken();
          var tok = parser2.gullet.popToken();
          letCommand(parser2, name, tok, funcName === "\\\\globalfuture");
          parser2.gullet.pushToken(tok);
          parser2.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      var getMetrics = function getMetrics2(symbol, font, mode) {
        var replace4 = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
        var metrics = getCharacterMetrics(replace4 || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      };
      var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
        var newOptions = options.havingBaseStyle(toStyle);
        var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
        var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      };
      var centerSpan = function centerSpan2(span, options, style) {
        var newOptions = options.havingBaseStyle(style);
        var shift2 = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = shift2 + "em";
        span.height -= shift2;
        span.depth += shift2;
      };
      var makeSmallDelim = function makeSmallDelim2(delim, style, center, options, mode, classes) {
        var text3 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
        var span = styleWrap(text3, style, options, classes);
        if (center) {
          centerSpan(span, options, style);
        }
        return span;
      };
      var mathrmSize = function mathrmSize2(value, size2, mode, options) {
        return buildCommon.makeSymbol(value, "Size" + size2 + "-Regular", mode, options);
      };
      var makeLargeDelim = function makeLargeDelim2(delim, size2, center, options, mode, classes) {
        var inner2 = mathrmSize(delim, size2, mode, options);
        var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size2], [inner2], options), src_Style.TEXT, options, classes);
        if (center) {
          centerSpan(span, options, src_Style.TEXT);
        }
        return span;
      };
      var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
        var sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      };
      var makeInner = function makeInner2(ch2, height, options) {
        var width = fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)][4].toFixed(3) : fontMetricsData["Size1-Regular"][ch2.charCodeAt(0)][4].toFixed(3);
        var path3 = new PathNode("inner", innerPath(ch2, Math.round(1e3 * height)));
        var svgNode = new SvgNode([path3], {
          "width": width + "em",
          "height": height + "em",
          "style": "width:" + width + "em",
          "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
          "preserveAspectRatio": "xMinYMin"
        });
        var span = buildCommon.makeSvgSpan([], [svgNode], options);
        span.height = height;
        span.style.height = height + "em";
        span.style.width = width + "em";
        return {
          type: "elem",
          elem: span
        };
      };
      var lapInEms = 8e-3;
      var lap = {
        type: "kern",
        size: -1 * lapInEms
      };
      var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
      var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
        var top2;
        var middle;
        var repeat2;
        var bottom;
        top2 = repeat2 = bottom = delim;
        middle = null;
        var font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat2 = bottom = "\u23D0";
        } else if (delim === "\\Uparrow") {
          repeat2 = bottom = "\u2016";
        } else if (delim === "\\downarrow") {
          top2 = repeat2 = "\u23D0";
        } else if (delim === "\\Downarrow") {
          top2 = repeat2 = "\u2016";
        } else if (delim === "\\updownarrow") {
          top2 = "\\uparrow";
          repeat2 = "\u23D0";
          bottom = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top2 = "\\Uparrow";
          repeat2 = "\u2016";
          bottom = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat2 = "\u2223";
        } else if (utils.contains(doubleVerts, delim)) {
          repeat2 = "\u2225";
        } else if (delim === "[" || delim === "\\lbrack") {
          top2 = "\u23A1";
          repeat2 = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
        } else if (delim === "]" || delim === "\\rbrack") {
          top2 = "\u23A4";
          repeat2 = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
        } else if (delim === "\\lfloor" || delim === "\u230A") {
          repeat2 = top2 = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
        } else if (delim === "\\lceil" || delim === "\u2308") {
          top2 = "\u23A1";
          repeat2 = bottom = "\u23A2";
          font = "Size4-Regular";
        } else if (delim === "\\rfloor" || delim === "\u230B") {
          repeat2 = top2 = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
        } else if (delim === "\\rceil" || delim === "\u2309") {
          top2 = "\u23A4";
          repeat2 = bottom = "\u23A5";
          font = "Size4-Regular";
        } else if (delim === "(" || delim === "\\lparen") {
          top2 = "\u239B";
          repeat2 = "\u239C";
          bottom = "\u239D";
          font = "Size4-Regular";
        } else if (delim === ")" || delim === "\\rparen") {
          top2 = "\u239E";
          repeat2 = "\u239F";
          bottom = "\u23A0";
          font = "Size4-Regular";
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top2 = "\u23A7";
          middle = "\u23A8";
          bottom = "\u23A9";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top2 = "\u23AB";
          middle = "\u23AC";
          bottom = "\u23AD";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "\u27EE") {
          top2 = "\u23A7";
          bottom = "\u23A9";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "\u27EF") {
          top2 = "\u23AB";
          bottom = "\u23AD";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "\u23B0") {
          top2 = "\u23A7";
          bottom = "\u23AD";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "\u23B1") {
          top2 = "\u23AB";
          bottom = "\u23A9";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        }
        var topMetrics = getMetrics(top2, font, mode);
        var topHeightTotal = topMetrics.height + topMetrics.depth;
        var repeatMetrics = getMetrics(repeat2, font, mode);
        var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        var bottomMetrics = getMetrics(bottom, font, mode);
        var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        var middleHeightTotal = 0;
        var middleFactor = 1;
        if (middle !== null) {
          var middleMetrics = getMetrics(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        var axisHeight = options.fontMetrics().axisHeight;
        if (center) {
          axisHeight *= options.sizeMultiplier;
        }
        var depth = realHeightTotal / 2 - axisHeight;
        var stack = [];
        stack.push(makeGlyphSpan(bottom, font, mode));
        stack.push(lap);
        if (middle === null) {
          var innerHeight2 = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
          stack.push(makeInner(repeat2, innerHeight2, options));
        } else {
          var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
          stack.push(makeInner(repeat2, _innerHeight, options));
          stack.push(lap);
          stack.push(makeGlyphSpan(middle, font, mode));
          stack.push(lap);
          stack.push(makeInner(repeat2, _innerHeight, options));
        }
        stack.push(lap);
        stack.push(makeGlyphSpan(top2, font, mode));
        var newOptions = options.havingBaseStyle(src_Style.TEXT);
        var inner2 = buildCommon.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
      };
      var vbPad = 80;
      var emPad = 0.08;
      var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraViniculum, options) {
        var path3 = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
        var pathNode = new PathNode(sqrtName, path3);
        var svg = new SvgNode([pathNode], {
          "width": "400em",
          "height": height + "em",
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
      };
      var makeSqrtImage = function makeSqrtImage2(height, options) {
        var newOptions = options.havingBaseSizing();
        var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        var sizeMultiplier = newOptions.sizeMultiplier;
        var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
        var span;
        var spanHeight = 0;
        var texHeight = 0;
        var viewBoxHeight = 0;
        var advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad;
          if (height < 1) {
            sizeMultiplier = 1;
          } else if (height < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraViniculum + emPad) / sizeMultiplier;
          texHeight = (1 + extraViniculum) / sizeMultiplier;
          span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
          texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
          span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height + extraViniculum + emPad;
          texHeight = height + extraViniculum;
          viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad;
          span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = spanHeight + "em";
        return {
          span,
          advanceWidth,
          ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
        };
      };
      var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
      var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
      var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
      var makeSizedDelim = function makeSizedDelim2(delim, size2, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size2, false, options, mode, classes);
        } else if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size2], false, options, mode, classes);
        } else {
          throw new src_ParseError("Illegal delimiter: '" + delim + "'");
        }
      };
      var stackNeverDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      var stackAlwaysDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "stack"
      }];
      var stackLargeDelimiterSequence = [{
        type: "small",
        style: src_Style.SCRIPTSCRIPT
      }, {
        type: "small",
        style: src_Style.SCRIPT
      }, {
        type: "small",
        style: src_Style.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      var delimTypeToFont = function delimTypeToFont2(type) {
        if (type.type === "small") {
          return "Main-Regular";
        } else if (type.type === "large") {
          return "Size" + type.size + "-Regular";
        } else if (type.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type.type + "' here.");
        }
      };
      var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
        var start4 = Math.min(2, 3 - options.style.size);
        for (var i3 = start4; i3 < sequence.length; i3++) {
          if (sequence[i3].type === "stack") {
            break;
          }
          var metrics = getMetrics(delim, delimTypeToFont(sequence[i3]), "math");
          var heightDepth = metrics.height + metrics.depth;
          if (sequence[i3].type === "small") {
            var newOptions = options.havingBaseStyle(sequence[i3].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height) {
            return sequence[i3];
          }
        }
        return sequence[sequence.length - 1];
      };
      var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        var sequence;
        if (utils.contains(stackNeverDelimiters, delim)) {
          sequence = stackNeverDelimiterSequence;
        } else if (utils.contains(stackLargeDelimiters, delim)) {
          sequence = stackLargeDelimiterSequence;
        } else {
          sequence = stackAlwaysDelimiterSequence;
        }
        var delimType = traverseSequence(delim, height, sequence, options);
        if (delimType.type === "small") {
          return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
        } else if (delimType.type === "large") {
          return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
        } else {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
      };
      var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
        var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
        var delimiterFactor = 901;
        var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
        var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
        var totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
        return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
      };
      var delimiter = {
        sqrtImage: makeSqrtImage,
        sizedDelim: makeSizedDelim,
        sizeToMaxHeight,
        customSizedDelim: makeCustomSizedDelim,
        leftRightDelim: makeLeftRightDelim
      };
      var delimiterSizes = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      function checkDelimiter(delim, context) {
        var symDelim = checkSymbolNodeType(delim);
        if (symDelim && utils.contains(delimiters, symDelim.text)) {
          return symDelim;
        } else if (symDelim) {
          throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
        } else {
          throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
        }
      }
      defineFunction({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: function handler(context, args) {
          var delim = checkDelimiter(args[0], context);
          return {
            type: "delimsizing",
            mode: context.parser.mode,
            size: delimiterSizes[context.funcName].size,
            mclass: delimiterSizes[context.funcName].mclass,
            delim: delim.text
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          if (group.delim === ".") {
            return buildCommon.makeSpan([group.mclass]);
          }
          return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
        },
        mathmlBuilder: function mathmlBuilder2(group) {
          var children = [];
          if (group.delim !== ".") {
            children.push(makeText(group.delim, group.mode));
          }
          var node5 = new mathMLTree.MathNode("mo", children);
          if (group.mclass === "mopen" || group.mclass === "mclose") {
            node5.setAttribute("fence", "true");
          } else {
            node5.setAttribute("fence", "false");
          }
          node5.setAttribute("stretchy", "true");
          node5.setAttribute("minsize", delimiter.sizeToMaxHeight[group.size] + "em");
          node5.setAttribute("maxsize", delimiter.sizeToMaxHeight[group.size] + "em");
          return node5;
        }
      });
      function assertParsed(group) {
        if (!group.body) {
          throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
      }
      defineFunction({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context, args) {
          var color2 = context.parser.gullet.macros.get("\\current@color");
          if (color2 && typeof color2 !== "string") {
            throw new src_ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context.parser.mode,
            delim: checkDelimiter(args[0], context).text,
            color: color2
          };
        }
      });
      defineFunction({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context, args) {
          var delim = checkDelimiter(args[0], context);
          var parser2 = context.parser;
          ++parser2.leftrightDepth;
          var body = parser2.parseExpression(false);
          --parser2.leftrightDepth;
          parser2.expect("\\right", false);
          var right = assertNodeType(parser2.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser2.mode,
            body,
            left: delim.text,
            right: right.delim,
            rightColor: right.color
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          assertParsed(group);
          var inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
          var innerHeight2 = 0;
          var innerDepth = 0;
          var hadMiddle = false;
          for (var i3 = 0; i3 < inner2.length; i3++) {
            if (inner2[i3].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight2 = Math.max(inner2[i3].height, innerHeight2);
              innerDepth = Math.max(inner2[i3].depth, innerDepth);
            }
          }
          innerHeight2 *= options.sizeMultiplier;
          innerDepth *= options.sizeMultiplier;
          var leftDelim;
          if (group.left === ".") {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter.leftRightDelim(group.left, innerHeight2, innerDepth, options, group.mode, ["mopen"]);
          }
          inner2.unshift(leftDelim);
          if (hadMiddle) {
            for (var _i6 = 1; _i6 < inner2.length; _i6++) {
              var middleDelim = inner2[_i6];
              var isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner2[_i6] = delimiter.leftRightDelim(isMiddle.delim, innerHeight2, innerDepth, isMiddle.options, group.mode, []);
              }
            }
          }
          var rightDelim;
          if (group.right === ".") {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
            rightDelim = delimiter.leftRightDelim(group.right, innerHeight2, innerDepth, colorOptions, group.mode, ["mclose"]);
          }
          inner2.push(rightDelim);
          return buildCommon.makeSpan(["minner"], inner2, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          assertParsed(group);
          var inner2 = buildMathML_buildExpression(group.body, options);
          if (group.left !== ".") {
            var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
            leftNode.setAttribute("fence", "true");
            inner2.unshift(leftNode);
          }
          if (group.right !== ".") {
            var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group.rightColor) {
              rightNode.setAttribute("mathcolor", group.rightColor);
            }
            inner2.push(rightNode);
          }
          return makeRow(inner2);
        }
      });
      defineFunction({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(context, args) {
          var delim = checkDelimiter(args[0], context);
          if (!context.parser.leftrightDepth) {
            throw new src_ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context.parser.mode,
            delim: delim.text
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var middleDelim;
          if (group.delim === ".") {
            middleDelim = makeNullDelimiter(options, []);
          } else {
            middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
            var isMiddle = {
              delim: group.delim,
              options
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
          var middleNode = new mathMLTree.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }
      });
      var enclose_htmlBuilder = function htmlBuilder2(group, options) {
        var inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
        var label2 = group.label.substr(1);
        var scale = options.sizeMultiplier;
        var img;
        var imgShift = 0;
        var isSingleChar = utils.isCharacterBox(group.body);
        if (label2 === "sout") {
          img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options.fontMetrics().xHeight;
        } else if (label2 === "phase") {
          var lineWeight = calculateSize({
            number: 0.6,
            unit: "pt"
          }, options);
          var clearance = calculateSize({
            number: 0.35,
            unit: "ex"
          }, options);
          var newOptions = options.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
          inner2.style.paddingLeft = angleHeight / 2 + lineWeight + "em";
          var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
          var path3 = phasePath(viewBoxHeight);
          var svgNode = new SvgNode([new PathNode("phase", path3)], {
            "width": "400em",
            "height": viewBoxHeight / 1e3 + "em",
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
          img.style.height = angleHeight + "em";
          imgShift = inner2.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label2)) {
            if (!isSingleChar) {
              inner2.classes.push("cancel-pad");
            }
          } else if (label2 === "angl") {
            inner2.classes.push("anglpad");
          } else {
            inner2.classes.push("boxpad");
          }
          var topPad = 0;
          var bottomPad = 0;
          var ruleThickness = 0;
          if (/box/.test(label2)) {
            ruleThickness = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
            topPad = options.fontMetrics().fboxsep + (label2 === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label2 === "angl") {
            ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner2.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy.encloseSpan(inner2, label2, topPad, bottomPad, options);
          if (/fbox|boxed|fcolorbox/.test(label2)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = ruleThickness + "em";
          } else if (label2 === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = ruleThickness + "em";
            img.style.borderRightWidth = ruleThickness + "em";
          }
          imgShift = inner2.depth + bottomPad;
          if (group.backgroundColor) {
            img.style.backgroundColor = group.backgroundColor;
            if (group.borderColor) {
              img.style.borderColor = group.borderColor;
            }
          }
        }
        var vlist;
        if (group.backgroundColor) {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner2,
                shift: 0
              }
            ]
          }, options);
        } else {
          var classes = /cancel|phase/.test(label2) ? ["svg-align"] : [];
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              {
                type: "elem",
                elem: inner2,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes
              }
            ]
          }, options);
        }
        if (/cancel/.test(label2)) {
          vlist.height = inner2.height;
          vlist.depth = inner2.depth;
        }
        if (/cancel/.test(label2) && !isSingleChar) {
          return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
        } else {
          return buildCommon.makeSpan(["mord"], [vlist], options);
        }
      };
      var enclose_mathmlBuilder = function mathmlBuilder2(group, options) {
        var fboxsep = 0;
        var node5 = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
        switch (group.label) {
          case "\\cancel":
            node5.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node5.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node5.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node5.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node5.setAttribute("notation", "box");
            break;
          case "\\angl":
            node5.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
            node5.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node5.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node5.setAttribute("lspace", fboxsep + "pt");
            node5.setAttribute("voffset", fboxsep + "pt");
            if (group.label === "\\fcolorbox") {
              var thk = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
              node5.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
            }
            break;
          case "\\xcancel":
            node5.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group.backgroundColor) {
          node5.setAttribute("mathbackground", group.backgroundColor);
        }
        return node5;
      };
      defineFunction({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var color2 = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            backgroundColor: color2,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler: function handler(_ref2, args, optArgs) {
          var parser2 = _ref2.parser, funcName = _ref2.funcName;
          var borderColor = assertNodeType(args[0], "color-token").color;
          var backgroundColor = assertNodeType(args[1], "color-token").color;
          var body = args[2];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser2 = _ref3.parser;
          return {
            type: "enclose",
            mode: parser2.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref4, args) {
          var parser2 = _ref4.parser, funcName = _ref4.funcName;
          var body = args[0];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            body
          };
        },
        htmlBuilder: enclose_htmlBuilder,
        mathmlBuilder: enclose_mathmlBuilder
      });
      defineFunction({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler: function handler(_ref5, args) {
          var parser2 = _ref5.parser;
          return {
            type: "enclose",
            mode: parser2.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      var _environments = {};
      function defineEnvironment(_ref) {
        var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder2 = _ref.htmlBuilder, mathmlBuilder2 = _ref.mathmlBuilder;
        var data = {
          type,
          numArgs: props.numArgs || 0,
          allowedInText: false,
          numOptionalArgs: 0,
          handler
        };
        for (var i3 = 0; i3 < names.length; ++i3) {
          _environments[names[i3]] = data;
        }
        if (htmlBuilder2) {
          _htmlGroupBuilders[type] = htmlBuilder2;
        }
        if (mathmlBuilder2) {
          _mathmlGroupBuilders[type] = mathmlBuilder2;
        }
      }
      function getHLines(parser2) {
        var hlineInfo = [];
        parser2.consumeSpaces();
        var nxt = parser2.fetch().text;
        while (nxt === "\\hline" || nxt === "\\hdashline") {
          parser2.consume();
          hlineInfo.push(nxt === "\\hdashline");
          parser2.consumeSpaces();
          nxt = parser2.fetch().text;
        }
        return hlineInfo;
      }
      var validateAmsEnvironmentContext = function validateAmsEnvironmentContext2(context) {
        var settings = context.parser.settings;
        if (!settings.displayMode) {
          throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
        }
      };
      function parseArray(parser2, _ref, style) {
        var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType, addEqnNum = _ref.addEqnNum, singleRow = _ref.singleRow, emptySingleRow = _ref.emptySingleRow, maxNumCols = _ref.maxNumCols, leqno = _ref.leqno;
        parser2.gullet.beginGroup();
        if (!singleRow) {
          parser2.gullet.macros.set("\\cr", "\\\\\\relax");
        }
        if (!arraystretch) {
          var stretch = parser2.gullet.expandMacroAsText("\\arraystretch");
          if (stretch == null) {
            arraystretch = 1;
          } else {
            arraystretch = parseFloat(stretch);
            if (!arraystretch || arraystretch < 0) {
              throw new src_ParseError("Invalid \\arraystretch: " + stretch);
            }
          }
        }
        parser2.gullet.beginGroup();
        var row = [];
        var body = [row];
        var rowGaps = [];
        var hLinesBeforeRow = [];
        hLinesBeforeRow.push(getHLines(parser2));
        while (true) {
          var cell = parser2.parseExpression(false, singleRow ? "\\end" : "\\\\");
          parser2.gullet.endGroup();
          parser2.gullet.beginGroup();
          cell = {
            type: "ordgroup",
            mode: parser2.mode,
            body: cell
          };
          if (style) {
            cell = {
              type: "styling",
              mode: parser2.mode,
              style,
              body: [cell]
            };
          }
          row.push(cell);
          var next = parser2.fetch().text;
          if (next === "&") {
            if (maxNumCols && row.length === maxNumCols) {
              if (singleRow || colSeparationType) {
                throw new src_ParseError("Too many tab characters: &", parser2.nextToken);
              } else {
                parser2.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
              }
            }
            parser2.consume();
          } else if (next === "\\end") {
            if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
              body.pop();
            }
            if (hLinesBeforeRow.length < body.length + 1) {
              hLinesBeforeRow.push([]);
            }
            break;
          } else if (next === "\\\\") {
            parser2.consume();
            var size2 = void 0;
            if (parser2.gullet.future().text !== " ") {
              size2 = parser2.parseSizeGroup(true);
            }
            rowGaps.push(size2 ? size2.value : null);
            hLinesBeforeRow.push(getHLines(parser2));
            row = [];
            body.push(row);
          } else {
            throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser2.nextToken);
          }
        }
        parser2.gullet.endGroup();
        parser2.gullet.endGroup();
        return {
          type: "array",
          mode: parser2.mode,
          addJot,
          arraystretch,
          body,
          cols,
          rowGaps,
          hskipBeforeAndAfter,
          hLinesBeforeRow,
          colSeparationType,
          addEqnNum,
          leqno
        };
      }
      function dCellStyle(envName) {
        if (envName.substr(0, 1) === "d") {
          return "display";
        } else {
          return "text";
        }
      }
      var array_htmlBuilder = function htmlBuilder2(group, options) {
        var r2;
        var c2;
        var nr = group.body.length;
        var hLinesBeforeRow = group.hLinesBeforeRow;
        var nc = 0;
        var body = new Array(nr);
        var hlines = [];
        var ruleThickness = Math.max(options.fontMetrics().arrayRuleWidth, options.minRuleThickness);
        var pt = 1 / options.fontMetrics().ptPerEm;
        var arraycolsep = 5 * pt;
        if (group.colSeparationType && group.colSeparationType === "small") {
          var localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
        }
        var baselineskip = group.colSeparationType === "CD" ? calculateSize({
          number: 3,
          unit: "ex"
        }, options) : 12 * pt;
        var jot = 3 * pt;
        var arrayskip = group.arraystretch * baselineskip;
        var arstrutHeight = 0.7 * arrayskip;
        var arstrutDepth = 0.3 * arrayskip;
        var totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (var i3 = 0; i3 < hlinesInGap.length; ++i3) {
            if (i3 > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i3]
            });
          }
        }
        setHLinePos(hLinesBeforeRow[0]);
        for (r2 = 0; r2 < group.body.length; ++r2) {
          var inrow = group.body[r2];
          var height = arstrutHeight;
          var depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          var outrow = new Array(inrow.length);
          for (c2 = 0; c2 < inrow.length; ++c2) {
            var elt = buildGroup(inrow[c2], options);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height < elt.height) {
              height = elt.height;
            }
            outrow[c2] = elt;
          }
          var rowGap = group.rowGaps[r2];
          var gap = 0;
          if (rowGap) {
            gap = calculateSize(rowGap, options);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group.addJot) {
            depth += jot;
          }
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body[r2] = outrow;
          setHLinePos(hLinesBeforeRow[r2 + 1]);
        }
        var offset2 = totalHeight / 2 + options.fontMetrics().axisHeight;
        var colDescriptions = group.cols || [];
        var cols = [];
        var colSep;
        var colDescrNum;
        var eqnNumSpans = [];
        if (group.addEqnNum) {
          for (r2 = 0; r2 < nr; ++r2) {
            var rw = body[r2];
            var shift2 = rw.pos - offset2;
            var eqnTag = buildCommon.makeSpan(["eqn-num"], [], options);
            eqnTag.depth = rw.depth;
            eqnTag.height = rw.height;
            eqnNumSpans.push({
              type: "elem",
              elem: eqnTag,
              shift: shift2
            });
          }
        }
        for (c2 = 0, colDescrNum = 0; c2 < nc || colDescrNum < colDescriptions.length; ++c2, ++colDescrNum) {
          var colDescr = colDescriptions[colDescrNum] || {};
          var firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              var lineType = colDescr.separator === "|" ? "solid" : "dashed";
              var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
              separator.style.height = totalHeight + "em";
              separator.style.borderRightWidth = ruleThickness + "em";
              separator.style.borderRightStyle = lineType;
              separator.style.margin = "0 -" + ruleThickness / 2 + "em";
              separator.style.verticalAlign = -(totalHeight - offset2) + "em";
              cols.push(separator);
            } else {
              throw new src_ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c2 >= nc) {
            continue;
          }
          var sepwidth = void 0;
          if (c2 > 0 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = sepwidth + "em";
              cols.push(colSep);
            }
          }
          var col = [];
          for (r2 = 0; r2 < nr; ++r2) {
            var row = body[r2];
            var elem = row[c2];
            if (!elem) {
              continue;
            }
            var _shift = row.pos - offset2;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({
              type: "elem",
              elem,
              shift: _shift
            });
          }
          col = buildCommon.makeVList({
            positionType: "individualShift",
            children: col
          }, options);
          col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c2 < nc - 1 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = sepwidth + "em";
              cols.push(colSep);
            }
          }
        }
        body = buildCommon.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
          var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
          var vListElems = [{
            type: "elem",
            elem: body,
            shift: 0
          }];
          while (hlines.length > 0) {
            var hline = hlines.pop();
            var lineShift = hline.pos - offset2;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line,
                shift: lineShift
              });
            }
          }
          body = buildCommon.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options);
        }
        if (!group.addEqnNum) {
          return buildCommon.makeSpan(["mord"], [body], options);
        } else {
          var eqnNumCol = buildCommon.makeVList({
            positionType: "individualShift",
            children: eqnNumSpans
          }, options);
          eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
          return buildCommon.makeFragment([body, eqnNumCol]);
        }
      };
      var alignMap = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      var array_mathmlBuilder = function mathmlBuilder2(group, options) {
        var tbl = [];
        var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
        var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i3 = 0; i3 < group.body.length; i3++) {
          var rw = group.body[i3];
          var row = [];
          for (var j2 = 0; j2 < rw.length; j2++) {
            row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j2], options)]));
          }
          if (group.addEqnNum) {
            row.unshift(glue);
            row.push(glue);
            if (group.leqno) {
              row.unshift(tag);
            } else {
              row.push(tag);
            }
          }
          tbl.push(new mathMLTree.MathNode("mtr", row));
        }
        var table2 = new mathMLTree.MathNode("mtable", tbl);
        var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
        table2.setAttribute("rowspacing", gap.toFixed(4) + "em");
        var menclose = "";
        var align = "";
        if (group.cols && group.cols.length > 0) {
          var cols = group.cols;
          var columnLines = "";
          var prevTypeWasAlign = false;
          var iStart = 0;
          var iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (var _i6 = iStart; _i6 < iEnd; _i6++) {
            if (cols[_i6].type === "align") {
              align += alignMap[cols[_i6].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[_i6].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[_i6].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table2.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table2.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group.colSeparationType === "align") {
          var _cols = group.cols || [];
          var spacing2 = "";
          for (var _i22 = 1; _i22 < _cols.length; _i22++) {
            spacing2 += _i22 % 2 ? "0em " : "1em ";
          }
          table2.setAttribute("columnspacing", spacing2.trim());
        } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
          table2.setAttribute("columnspacing", "0em");
        } else if (group.colSeparationType === "small") {
          table2.setAttribute("columnspacing", "0.2778em");
        } else if (group.colSeparationType === "CD") {
          table2.setAttribute("columnspacing", "0.5em");
        } else {
          table2.setAttribute("columnspacing", "1em");
        }
        var rowLines = "";
        var hlines = group.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (var _i32 = 1; _i32 < hlines.length - 1; _i32++) {
          rowLines += hlines[_i32].length === 0 ? "none " : hlines[_i32][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table2.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table2 = new mathMLTree.MathNode("menclose", [table2]);
          table2.setAttribute("notation", menclose.trim());
        }
        if (group.arraystretch && group.arraystretch < 1) {
          table2 = new mathMLTree.MathNode("mstyle", [table2]);
          table2.setAttribute("scriptlevel", "1");
        }
        return table2;
      };
      var alignedHandler = function alignedHandler2(context, args) {
        if (context.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext(context);
        }
        var cols = [];
        var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
        var res2 = parseArray(context.parser, {
          cols,
          addJot: true,
          addEqnNum: context.envName === "align" || context.envName === "alignat",
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: context.envName === "split" ? 2 : void 0,
          leqno: context.parser.settings.leqno
        }, "display");
        var numMaths;
        var numCols = 0;
        var emptyGroup = {
          type: "ordgroup",
          mode: context.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          var arg0 = "";
          for (var i3 = 0; i3 < args[0].body.length; i3++) {
            var textord2 = assertNodeType(args[0].body[i3], "textord");
            arg0 += textord2.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        var isAligned = !numCols;
        res2.body.forEach(function(row) {
          for (var _i42 = 1; _i42 < row.length; _i42 += 2) {
            var styling = assertNodeType(row[_i42], "styling");
            var ordgroup = assertNodeType(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            var curMaths = row.length / 2;
            if (numMaths < curMaths) {
              throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
            }
          } else if (numCols < row.length) {
            numCols = row.length;
          }
        });
        for (var _i52 = 0; _i52 < numCols; ++_i52) {
          var align = "r";
          var pregap = 0;
          if (_i52 % 2 === 1) {
            align = "l";
          } else if (_i52 > 0 && isAligned) {
            pregap = 1;
          }
          cols[_i52] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res2.colSeparationType = isAligned ? "align" : "alignat";
        return res2;
      };
      defineEnvironment({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler: function handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node5 = assertSymbolNodeType(nde);
            var ca = node5.text;
            if ("lcr".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            } else if (ca === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca, nde);
          });
          var res2 = {
            cols,
            hskipBeforeAndAfter: true,
            maxNumCols: cols.length
          };
          return parseArray(context.parser, res2, dCellStyle(context.envName));
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          var delimiters2 = {
            "matrix": null,
            "pmatrix": ["(", ")"],
            "bmatrix": ["[", "]"],
            "Bmatrix": ["\\{", "\\}"],
            "vmatrix": ["|", "|"],
            "Vmatrix": ["\\Vert", "\\Vert"]
          }[context.envName.replace("*", "")];
          var colAlign = "c";
          var payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context.envName.charAt(context.envName.length - 1) === "*") {
            var parser2 = context.parser;
            parser2.consumeSpaces();
            if (parser2.fetch().text === "[") {
              parser2.consume();
              parser2.consumeSpaces();
              colAlign = parser2.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new src_ParseError("Expected l or c or r", parser2.nextToken);
              }
              parser2.consume();
              parser2.consumeSpaces();
              parser2.expect("]");
              parser2.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          var res2 = parseArray(context.parser, payload, dCellStyle(context.envName));
          var numCols = Math.max.apply(Math, [0].concat(res2.body.map(function(row) {
            return row.length;
          })));
          res2.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters2 ? {
            type: "leftright",
            mode: context.mode,
            body: [res2],
            left: delimiters2[0],
            right: delimiters2[1],
            rightColor: void 0
          } : res2;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          var payload = {
            arraystretch: 0.5
          };
          var res2 = parseArray(context.parser, payload, "script");
          res2.colSeparationType = "small";
          return res2;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler: function handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node5 = assertSymbolNodeType(nde);
            var ca = node5.text;
            if ("lc".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            }
            throw new src_ParseError("Unknown column alignment: " + ca, nde);
          });
          if (cols.length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          var res2 = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res2 = parseArray(context.parser, res2, "script");
          if (res2.body.length > 0 && res2.body[0].length > 1) {
            throw new src_ParseError("{subarray} can contain only one column");
          }
          return res2;
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          var payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 1
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          var res2 = parseArray(context.parser, payload, dCellStyle(context.envName));
          return {
            type: "leftright",
            mode: context.mode,
            body: [res2],
            left: context.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: void 0
          };
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          if (utils.contains(["gather", "gather*"], context.envName)) {
            validateAmsEnvironmentContext(context);
          }
          var res2 = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            addEqnNum: context.envName === "gather",
            emptySingleRow: true,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res2, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler,
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          validateAmsEnvironmentContext(context);
          var res2 = {
            addEqnNum: context.envName === "equation",
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res2, "display");
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineEnvironment({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler: function handler(context) {
          validateAmsEnvironmentContext(context);
          return parseCD(context.parser);
        },
        htmlBuilder: array_htmlBuilder,
        mathmlBuilder: array_mathmlBuilder
      });
      defineFunction({
        type: "text",
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler: function handler(context, args) {
          throw new src_ParseError(context.funcName + " valid only within array environment");
        }
      });
      var environments = _environments;
      var src_environments = environments;
      defineFunction({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new src_ParseError("Invalid environment name", nameGroup);
          }
          var envName = "";
          for (var i3 = 0; i3 < nameGroup.body.length; ++i3) {
            envName += assertNodeType(nameGroup.body[i3], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!src_environments.hasOwnProperty(envName)) {
              throw new src_ParseError("No such environment: " + envName, nameGroup);
            }
            var env = src_environments[envName];
            var _parser$parseArgument = parser2.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
            var context = {
              mode: parser2.mode,
              envName,
              parser: parser2
            };
            var result2 = env.handler(context, _args, optArgs);
            parser2.expect("\\end", false);
            var endNameToken = parser2.nextToken;
            var end3 = assertNodeType(parser2.parseFunction(), "environment");
            if (end3.name !== envName) {
              throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end3.name + "}", endNameToken);
            }
            return result2;
          }
          return {
            type: "environment",
            mode: parser2.mode,
            name: envName,
            nameGroup
          };
        }
      });
      var mclass_makeSpan = buildCommon.makeSpan;
      function mclass_htmlBuilder(group, options) {
        var elements = buildExpression(group.body, options, true);
        return mclass_makeSpan([group.mclass], elements, options);
      }
      function mclass_mathmlBuilder(group, options) {
        var node5;
        var inner2 = buildMathML_buildExpression(group.body, options);
        if (group.mclass === "minner") {
          return mathMLTree.newDocumentFragment(inner2);
        } else if (group.mclass === "mord") {
          if (group.isCharacterBox) {
            node5 = inner2[0];
            node5.type = "mi";
          } else {
            node5 = new mathMLTree.MathNode("mi", inner2);
          }
        } else {
          if (group.isCharacterBox) {
            node5 = inner2[0];
            node5.type = "mo";
          } else {
            node5 = new mathMLTree.MathNode("mo", inner2);
          }
          if (group.mclass === "mbin") {
            node5.attributes.lspace = "0.22em";
            node5.attributes.rspace = "0.22em";
          } else if (group.mclass === "mpunct") {
            node5.attributes.lspace = "0em";
            node5.attributes.rspace = "0.17em";
          } else if (group.mclass === "mopen" || group.mclass === "mclose") {
            node5.attributes.lspace = "0em";
            node5.attributes.rspace = "0em";
          }
        }
        return node5;
      }
      defineFunction({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: "m" + funcName.substr(5),
            body: ordargument(body),
            isCharacterBox: utils.isCharacterBox(body)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      var binrelClass = function binrelClass2(arg) {
        var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
          return "m" + atom.family;
        } else {
          return "mord";
        }
      };
      defineFunction({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[1]),
            isCharacterBox: utils.isCharacterBox(args[1])
          };
        }
      });
      defineFunction({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref3, args) {
          var parser2 = _ref3.parser, funcName = _ref3.funcName;
          var baseArg = args[1];
          var shiftedArg = args[0];
          var mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass(baseArg);
          } else {
            mclass = "mrel";
          }
          var baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument(baseArg)
          };
          var supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils.isCharacterBox(supsub)
          };
        },
        htmlBuilder: mclass_htmlBuilder,
        mathmlBuilder: mclass_mathmlBuilder
      });
      var font_htmlBuilder = function htmlBuilder2(group, options) {
        var font = group.font;
        var newOptions = options.withFont(font);
        return buildGroup(group.body, newOptions);
      };
      var font_mathmlBuilder = function mathmlBuilder2(group, options) {
        var font = group.font;
        var newOptions = options.withFont(font);
        return buildMathML_buildGroup(group.body, newOptions);
      };
      var fontAliases = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction({
        type: "font",
        names: [
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var body = normalizeArgument(args[0]);
          var func = funcName;
          if (func in fontAliases) {
            func = fontAliases[func];
          }
          return {
            type: "font",
            mode: parser2.mode,
            font: func.slice(1),
            body
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      defineFunction({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          var body = args[0];
          var isCharacterBox2 = utils.isCharacterBox(body);
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: binrelClass(body),
            body: [{
              type: "font",
              mode: parser2.mode,
              font: "boldsymbol",
              body
            }],
            isCharacterBox: isCharacterBox2
          };
        }
      });
      defineFunction({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser2 = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
          var mode = parser2.mode;
          var body = parser2.parseExpression(true, breakOnTokenText);
          var style = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style,
            body: {
              type: "ordgroup",
              mode: parser2.mode,
              body
            }
          };
        },
        htmlBuilder: font_htmlBuilder,
        mathmlBuilder: font_mathmlBuilder
      });
      var adjustStyle = function adjustStyle2(size2, originalStyle) {
        var style = originalStyle;
        if (size2 === "display") {
          style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
        } else if (size2 === "text" && style.size === src_Style.DISPLAY.size) {
          style = src_Style.TEXT;
        } else if (size2 === "script") {
          style = src_Style.SCRIPT;
        } else if (size2 === "scriptscript") {
          style = src_Style.SCRIPTSCRIPT;
        }
        return style;
      };
      var genfrac_htmlBuilder = function htmlBuilder2(group, options) {
        var style = adjustStyle(group.size, options.style);
        var nstyle = style.fracNum();
        var dstyle = style.fracDen();
        var newOptions;
        newOptions = options.havingStyle(nstyle);
        var numerm = buildGroup(group.numer, newOptions, options);
        if (group.continued) {
          var hStrut = 8.5 / options.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options.havingStyle(dstyle);
        var denomm = buildGroup(group.denom, newOptions, options);
        var rule;
        var ruleWidth;
        var ruleSpacing;
        if (group.hasBarLine) {
          if (group.barSize) {
            ruleWidth = calculateSize(group.barSize, options);
            rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
          } else {
            rule = buildCommon.makeLineSpan("frac-line", options);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options.fontMetrics().defaultRuleThickness;
        }
        var numShift;
        var clearance;
        var denomShift;
        if (style.size === src_Style.DISPLAY.size || group.size === "display") {
          numShift = options.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom2;
        }
        var frac;
        if (!rule) {
          var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        } else {
          var axisHeight = options.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          var midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        }
        newOptions = options.havingStyle(style);
        frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
        var delimSize;
        if (style.size === src_Style.DISPLAY.size) {
          delimSize = options.fontMetrics().delim1;
        } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
          delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options.fontMetrics().delim2;
        }
        var leftDelim;
        var rightDelim;
        if (group.leftDelim == null) {
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
        }
        if (group.continued) {
          rightDelim = buildCommon.makeSpan([]);
        } else if (group.rightDelim == null) {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
        }
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
      };
      var genfrac_mathmlBuilder = function mathmlBuilder2(group, options) {
        var node5 = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
        if (!group.hasBarLine) {
          node5.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          var ruleWidth = calculateSize(group.barSize, options);
          node5.setAttribute("linethickness", ruleWidth + "em");
        }
        var style = adjustStyle(group.size, options.style);
        if (style.size !== options.style.size) {
          node5 = new mathMLTree.MathNode("mstyle", [node5]);
          var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
          node5.setAttribute("displaystyle", isDisplay);
          node5.setAttribute("scriptlevel", "0");
        }
        if (group.leftDelim != null || group.rightDelim != null) {
          var withDelims = [];
          if (group.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node5);
          if (group.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow(withDelims);
        }
        return node5;
      };
      defineFunction({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          "\\\\bracefrac",
          "\\\\brackfrac"
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var numer = args[0];
          var denom = args[1];
          var hasBarLine;
          var leftDelim = null;
          var rightDelim = null;
          var size2 = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size2 = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size2 = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser2.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size: size2,
            barSize: null
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          _ref2.funcName;
          var numer = args[0];
          var denom = args[1];
          return {
            type: "genfrac",
            mode: parser2.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }
      });
      defineFunction({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler: function handler(_ref3) {
          var parser2 = _ref3.parser, funcName = _ref3.funcName, token = _ref3.token;
          var replaceWith2;
          switch (funcName) {
            case "\\over":
              replaceWith2 = "\\frac";
              break;
            case "\\choose":
              replaceWith2 = "\\binom";
              break;
            case "\\atop":
              replaceWith2 = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith2 = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith2 = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser2.mode,
            replaceWith: replaceWith2,
            token
          };
        }
      });
      var stylArray = ["display", "text", "script", "scriptscript"];
      var delimFromValue = function delimFromValue2(delimString) {
        var delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      };
      defineFunction({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler: function handler(_ref4, args) {
          var parser2 = _ref4.parser;
          var numer = args[4];
          var denom = args[5];
          var leftNode = normalizeArgument(args[0]);
          var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
          var rightNode = normalizeArgument(args[1]);
          var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
          var barNode = assertNodeType(args[2], "size");
          var hasBarLine;
          var barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          var size2 = "auto";
          var styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              var textOrd = assertNodeType(styl.body[0], "textord");
              size2 = stylArray[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType(styl, "textord");
            size2 = stylArray[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser2.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size: size2
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      defineFunction({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler: function handler(_ref5, args) {
          var parser2 = _ref5.parser;
          _ref5.funcName;
          var token = _ref5.token;
          return {
            type: "infix",
            mode: parser2.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType(args[0], "size").value,
            token
          };
        }
      });
      defineFunction({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: function handler(_ref6, args) {
          var parser2 = _ref6.parser;
          _ref6.funcName;
          var numer = args[0];
          var barSize = assert(assertNodeType(args[1], "infix").size);
          var denom = args[2];
          var hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser2.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        },
        htmlBuilder: genfrac_htmlBuilder,
        mathmlBuilder: genfrac_mathmlBuilder
      });
      var horizBrace_htmlBuilder = function htmlBuilder2(grp, options) {
        var style = options.style;
        var supSubGroup;
        var group;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
          group = assertNodeType(grp.base, "horizBrace");
        } else {
          group = assertNodeType(grp, "horizBrace");
        }
        var body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
        var braceBody = stretchy.svgSpan(group, options);
        var vlist;
        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: body.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body
            }]
          }, options);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options);
          }
        }
        return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
      };
      var horizBrace_mathmlBuilder = function mathmlBuilder2(group, options) {
        var accentNode = stretchy.mathMLnode(group.label);
        return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
      };
      defineFunction({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          return {
            type: "horizBrace",
            mode: parser2.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: horizBrace_htmlBuilder,
        mathmlBuilder: horizBrace_mathmlBuilder
      });
      defineFunction({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          var body = args[1];
          var href = assertNodeType(args[0], "url").url;
          if (!parser2.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser2.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser2.mode,
            href,
            body: ordargument(body)
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, false);
          return buildCommon.makeAnchor(group.href, [], elements, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var math3 = buildExpressionRow(group.body, options);
          if (!(math3 instanceof MathNode)) {
            math3 = new MathNode("mrow", [math3]);
          }
          math3.setAttribute("href", group.href);
          return math3;
        }
      });
      defineFunction({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          var href = assertNodeType(args[0], "url").url;
          if (!parser2.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser2.formatUnsupportedCmd("\\url");
          }
          var chars = [];
          for (var i3 = 0; i3 < href.length; i3++) {
            var c2 = href[i3];
            if (c2 === "~") {
              c2 = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c2
            });
          }
          var body = {
            type: "text",
            mode: parser2.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser2.mode,
            href,
            body: ordargument(body)
          };
        }
      });
      defineFunction({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          return {
            type: "hbox",
            mode: parser2.mode,
            body: ordargument(args[0])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
        }
      });
      defineFunction({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          _ref.token;
          var value = assertNodeType(args[0], "raw").string;
          var body = args[1];
          if (parser2.settings.strict) {
            parser2.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          var trustContext;
          var attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value;
              trustContext = {
                command: "\\htmlClass",
                class: value
              };
              break;
            case "\\htmlId":
              attributes.id = value;
              trustContext = {
                command: "\\htmlId",
                id: value
              };
              break;
            case "\\htmlStyle":
              attributes.style = value;
              trustContext = {
                command: "\\htmlStyle",
                style: value
              };
              break;
            case "\\htmlData": {
              var data = value.split(",");
              for (var i3 = 0; i3 < data.length; i3++) {
                var keyVal = data[i3].split("=");
                if (keyVal.length !== 2) {
                  throw new src_ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser2.settings.isTrusted(trustContext)) {
            return parser2.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser2.mode,
            attributes,
            body: ordargument(body)
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options, false);
          var classes = ["enclosing"];
          if (group.attributes.class) {
            classes.push.apply(classes, group.attributes.class.trim().split(/\s+/));
          }
          var span = buildCommon.makeSpan(classes, elements, options);
          for (var attr in group.attributes) {
            if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group.attributes[attr]);
            }
          }
          return span;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return buildExpressionRow(group.body, options);
        }
      });
      defineFunction({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          return {
            type: "htmlmathml",
            mode: parser2.mode,
            html: ordargument(args[0]),
            mathml: ordargument(args[1])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.html, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return buildExpressionRow(group.mathml, options);
        }
      });
      var sizeData = function sizeData2(str) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
          return {
            number: +str,
            unit: "bp"
          };
        } else {
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
          if (!match) {
            throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
          }
          var data = {
            number: +(match[1] + match[2]),
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
          }
          return data;
        }
      };
      defineFunction({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser;
          var width = {
            number: 0,
            unit: "em"
          };
          var height = {
            number: 0.9,
            unit: "em"
          };
          var totalheight = {
            number: 0,
            unit: "em"
          };
          var alt = "";
          if (optArgs[0]) {
            var attributeStr = assertNodeType(optArgs[0], "raw").string;
            var attributes = attributeStr.split(",");
            for (var i3 = 0; i3 < attributes.length; i3++) {
              var keyVal = attributes[i3].split("=");
              if (keyVal.length === 2) {
                var str = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str;
                    break;
                  case "width":
                    width = sizeData(str);
                    break;
                  case "height":
                    height = sizeData(str);
                    break;
                  case "totalheight":
                    totalheight = sizeData(str);
                    break;
                  default:
                    throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          var src = assertNodeType(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser2.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser2.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser2.mode,
            alt,
            width,
            height,
            totalheight,
            src
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var height = calculateSize(group.height, options);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
            depth = Number(depth.toFixed(2));
          }
          var width = 0;
          if (group.width.number > 0) {
            width = calculateSize(group.width, options);
          }
          var style = {
            height: height + depth + "em"
          };
          if (width > 0) {
            style.width = width + "em";
          }
          if (depth > 0) {
            style.verticalAlign = -depth + "em";
          }
          var node5 = new Img(group.src, group.alt, style);
          node5.height = height;
          node5.depth = depth;
          return node5;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mglyph", []);
          node5.setAttribute("alt", group.alt);
          var height = calculateSize(group.height, options);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
            depth = depth.toFixed(2);
            node5.setAttribute("valign", "-" + depth + "em");
          }
          node5.setAttribute("height", height + depth + "em");
          if (group.width.number > 0) {
            var width = calculateSize(group.width, options);
            node5.setAttribute("width", width + "em");
          }
          node5.setAttribute("src", group.src);
          return node5;
        }
      });
      defineFunction({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var size2 = assertNodeType(args[0], "size");
          if (parser2.settings.strict) {
            var mathFunction = funcName[1] === "m";
            var muUnit = size2.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size2.value.unit + " units"));
              }
              if (parser2.mode !== "math") {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser2.mode,
            dimension: size2.value
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.makeGlue(group.dimension, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var dimension = calculateSize(group.dimension, options);
          return new mathMLTree.SpaceNode(dimension);
        }
      });
      defineFunction({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "lap",
            mode: parser2.mode,
            alignment: funcName.slice(5),
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var inner2;
          if (group.alignment === "clap") {
            inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
            inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
          } else {
            inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
          }
          var fix = buildCommon.makeSpan(["fix"], []);
          var node5 = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
          var strut = buildCommon.makeSpan(["strut"]);
          strut.style.height = node5.height + node5.depth + "em";
          strut.style.verticalAlign = -node5.depth + "em";
          node5.children.unshift(strut);
          node5 = buildCommon.makeSpan(["thinbox"], [node5], options);
          return buildCommon.makeSpan(["mord", "vbox"], [node5], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          if (group.alignment !== "rlap") {
            var offset2 = group.alignment === "llap" ? "-1" : "-0.5";
            node5.setAttribute("lspace", offset2 + "width");
          }
          node5.setAttribute("width", "0px");
          return node5;
        }
      });
      defineFunction({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler: function handler(_ref, args) {
          var funcName = _ref.funcName, parser2 = _ref.parser;
          var outerMode = parser2.mode;
          parser2.switchMode("math");
          var close3 = funcName === "\\(" ? "\\)" : "$";
          var body = parser2.parseExpression(false, close3);
          parser2.expect(close3);
          parser2.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser2.mode,
            style: "text",
            body
          };
        }
      });
      defineFunction({
        type: "text",
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler: function handler(context, args) {
          throw new src_ParseError("Mismatched " + context.funcName);
        }
      });
      var chooseMathStyle = function chooseMathStyle2(group, options) {
        switch (options.style.size) {
          case src_Style.DISPLAY.size:
            return group.display;
          case src_Style.TEXT.size:
            return group.text;
          case src_Style.SCRIPT.size:
            return group.script;
          case src_Style.SCRIPTSCRIPT.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          return {
            type: "mathchoice",
            mode: parser2.mode,
            display: ordargument(args[0]),
            text: ordargument(args[1]),
            script: ordargument(args[2]),
            scriptscript: ordargument(args[3])
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var body = chooseMathStyle(group, options);
          var elements = buildExpression(body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var body = chooseMathStyle(group, options);
          return buildExpressionRow(body, options);
        }
      });
      var assembleSupSub = function assembleSupSub2(base2, supGroup, subGroup, options, style, slant, baseShift) {
        base2 = buildCommon.makeSpan([], [base2]);
        var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        var sub;
        var sup;
        if (supGroup) {
          var elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
          sup = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          var _elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
          sub = {
            elem: _elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
          };
        }
        var finalGroup;
        if (sup && sub) {
          var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base2.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub.elem,
              marginLeft: -slant + "em"
            }, {
              type: "kern",
              size: sub.kern
            }, {
              type: "elem",
              elem: base2
            }, {
              type: "kern",
              size: sup.kern
            }, {
              type: "elem",
              elem: sup.elem,
              marginLeft: slant + "em"
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else if (sub) {
          var top2 = base2.height - baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top2,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub.elem,
              marginLeft: -slant + "em"
            }, {
              type: "kern",
              size: sub.kern
            }, {
              type: "elem",
              elem: base2
            }]
          }, options);
        } else if (sup) {
          var _bottom = base2.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: _bottom,
            children: [{
              type: "elem",
              elem: base2
            }, {
              type: "kern",
              size: sup.kern
            }, {
              type: "elem",
              elem: sup.elem,
              marginLeft: slant + "em"
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else {
          return base2;
        }
        var parts = [finalGroup];
        if (sub && slant !== 0 && !subIsSingleCharacter) {
          var spacer = buildCommon.makeSpan(["mspace"], [], options);
          spacer.style.marginRight = slant + "em";
          parts.unshift(spacer);
        }
        return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
      };
      var noSuccessor = ["\\smallint"];
      var op_htmlBuilder = function htmlBuilder2(grp, options) {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "op");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "op");
        }
        var style = options.style;
        var large = false;
        if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
          large = true;
        }
        var base2;
        if (group.symbol) {
          var fontName = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if (group.name === "\\oiint" || group.name === "\\oiiint") {
            stash = group.name.substr(1);
            group.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            var italic = base2.italic;
            var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
            base2 = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base2,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options);
            group.name = "\\" + stash;
            base2.classes.unshift("mop");
            base2.italic = italic;
          }
        } else if (group.body) {
          var inner2 = buildExpression(group.body, options, true);
          if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
            base2 = inner2[0];
            base2.classes[0] = "mop";
          } else {
            base2 = buildCommon.makeSpan(["mop"], inner2, options);
          }
        } else {
          var output = [];
          for (var i3 = 1; i3 < group.name.length; i3++) {
            output.push(buildCommon.mathsym(group.name[i3], group.mode, options));
          }
          base2 = buildCommon.makeSpan(["mop"], output, options);
        }
        var baseShift = 0;
        var slant = 0;
        if ((base2 instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
          baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
          slant = base2.italic;
        }
        if (hasLimits) {
          return assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
        } else {
          if (baseShift) {
            base2.style.position = "relative";
            base2.style.top = baseShift + "em";
          }
          return base2;
        }
      };
      var op_mathmlBuilder = function mathmlBuilder2(group, options) {
        var node5;
        if (group.symbol) {
          node5 = new MathNode("mo", [makeText(group.name, group.mode)]);
          if (utils.contains(noSuccessor, group.name)) {
            node5.setAttribute("largeop", "false");
          }
        } else if (group.body) {
          node5 = new MathNode("mo", buildMathML_buildExpression(group.body, options));
        } else {
          node5 = new MathNode("mi", [new TextNode2(group.name.slice(1))]);
          var operator = new MathNode("mo", [makeText("\u2061", "text")]);
          if (group.parentIsSupSub) {
            node5 = new MathNode("mrow", [node5, operator]);
          } else {
            node5 = newDocumentFragment([node5, operator]);
          }
        }
        return node5;
      };
      var singleCharBigOps = {
        "\u220F": "\\prod",
        "\u2210": "\\coprod",
        "\u2211": "\\sum",
        "\u22C0": "\\bigwedge",
        "\u22C1": "\\bigvee",
        "\u22C2": "\\bigcap",
        "\u22C3": "\\bigcup",
        "\u2A00": "\\bigodot",
        "\u2A01": "\\bigoplus",
        "\u2A02": "\\bigotimes",
        "\u2A04": "\\biguplus",
        "\u2A06": "\\bigsqcup"
      };
      defineFunction({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps[fName];
          }
          return {
            type: "op",
            mode: parser2.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          var body = args[0];
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument(body)
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      var singleCharIntegrals = {
        "\u222B": "\\int",
        "\u222C": "\\iint",
        "\u222D": "\\iiint",
        "\u222E": "\\oint",
        "\u222F": "\\oiint",
        "\u2230": "\\oiiint"
      };
      defineFunction({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref3) {
          var parser2 = _ref3.parser, funcName = _ref3.funcName;
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref4) {
          var parser2 = _ref4.parser, funcName = _ref4.funcName;
          return {
            type: "op",
            mode: parser2.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      defineFunction({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
        props: {
          numArgs: 0
        },
        handler: function handler(_ref5) {
          var parser2 = _ref5.parser, funcName = _ref5.funcName;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals[fName];
          }
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: op_htmlBuilder,
        mathmlBuilder: op_mathmlBuilder
      });
      var builtinMacros = {};
      var macros = builtinMacros;
      function defineMacro(name, body) {
        builtinMacros[name] = body;
      }
      defineMacro("\\noexpand", function(context) {
        var t2 = context.popToken();
        if (context.isExpandable(t2.text)) {
          t2.noexpand = true;
          t2.treatAsRelax = true;
        }
        return {
          tokens: [t2],
          numArgs: 0
        };
      });
      defineMacro("\\expandafter", function(context) {
        var t2 = context.popToken();
        context.expandOnce(true);
        return {
          tokens: [t2],
          numArgs: 0
        };
      });
      defineMacro("\\@firstoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro("\\@secondoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro("\\@ifnextchar", function(context) {
        var args = context.consumeArgs(3);
        context.consumeSpaces();
        var nextToken = context.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro("\\TextOrMath", function(context) {
        var args = context.consumeArgs(2);
        if (context.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      var digitToNumber = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      defineMacro("\\char", function(context) {
        var token = context.popToken();
        var base2;
        var number = "";
        if (token.text === "'") {
          base2 = 8;
          token = context.popToken();
        } else if (token.text === '"') {
          base2 = 16;
          token = context.popToken();
        } else if (token.text === "`") {
          token = context.popToken();
          if (token.text[0] === "\\") {
            number = token.text.charCodeAt(1);
          } else if (token.text === "EOF") {
            throw new src_ParseError("\\char` missing argument");
          } else {
            number = token.text.charCodeAt(0);
          }
        } else {
          base2 = 10;
        }
        if (base2) {
          number = digitToNumber[token.text];
          if (number == null || number >= base2) {
            throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
          }
          var digit;
          while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
            number *= base2;
            number += digit;
            context.popToken();
          }
        }
        return "\\@char{" + number + "}";
      });
      var newcommand = function newcommand2(context, existsOK, nonexistsOK) {
        var arg = context.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new src_ParseError("\\newcommand's first argument must be a macro name");
        }
        var name = arg[0].text;
        var exists = context.isDefined(name);
        if (exists && !existsOK) {
          throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        var numArgs = 0;
        arg = context.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          var argText = "";
          var token = context.expandNextToken();
          while (token.text !== "]" && token.text !== "EOF") {
            argText += token.text;
            token = context.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new src_ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context.consumeArg().tokens;
        }
        context.macros.set(name, {
          tokens: arg,
          numArgs
        });
        return "";
      };
      defineMacro("\\newcommand", function(context) {
        return newcommand(context, false, true);
      });
      defineMacro("\\renewcommand", function(context) {
        return newcommand(context, true, false);
      });
      defineMacro("\\providecommand", function(context) {
        return newcommand(context, true, true);
      });
      defineMacro("\\message", function(context) {
        var arg = context.consumeArgs(1)[0];
        console.log(arg.reverse().map(function(token) {
          return token.text;
        }).join(""));
        return "";
      });
      defineMacro("\\errmessage", function(context) {
        var arg = context.consumeArgs(1)[0];
        console.error(arg.reverse().map(function(token) {
          return token.text;
        }).join(""));
        return "";
      });
      defineMacro("\\show", function(context) {
        var tok = context.popToken();
        var name = tok.text;
        console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
        return "";
      });
      defineMacro("\\bgroup", "{");
      defineMacro("\\egroup", "}");
      defineMacro("~", "\\nobreakspace");
      defineMacro("\\lq", "`");
      defineMacro("\\rq", "'");
      defineMacro("\\aa", "\\r a");
      defineMacro("\\AA", "\\r A");
      defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
      defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
      defineMacro("\u212C", "\\mathscr{B}");
      defineMacro("\u2130", "\\mathscr{E}");
      defineMacro("\u2131", "\\mathscr{F}");
      defineMacro("\u210B", "\\mathscr{H}");
      defineMacro("\u2110", "\\mathscr{I}");
      defineMacro("\u2112", "\\mathscr{L}");
      defineMacro("\u2133", "\\mathscr{M}");
      defineMacro("\u211B", "\\mathscr{R}");
      defineMacro("\u212D", "\\mathfrak{C}");
      defineMacro("\u210C", "\\mathfrak{H}");
      defineMacro("\u2128", "\\mathfrak{Z}");
      defineMacro("\\Bbbk", "\\Bbb{k}");
      defineMacro("\xB7", "\\cdotp");
      defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro("\\mathstrut", "\\vphantom{(}");
      defineMacro("\\underbar", "\\underline{\\text{#1}}");
      defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
      defineMacro("\\ne", "\\neq");
      defineMacro("\u2260", "\\neq");
      defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
      defineMacro("\u2209", "\\notin");
      defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
      defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
      defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
      defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
      defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
      defineMacro("\u27C2", "\\perp");
      defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro("\u220C", "\\notni");
      defineMacro("\u231C", "\\ulcorner");
      defineMacro("\u231D", "\\urcorner");
      defineMacro("\u231E", "\\llcorner");
      defineMacro("\u231F", "\\lrcorner");
      defineMacro("\xA9", "\\copyright");
      defineMacro("\xAE", "\\textregistered");
      defineMacro("\uFE0F", "\\textregistered");
      defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro("\u22EE", "\\vdots");
      defineMacro("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro("\\varDelta", "\\mathit{\\Delta}");
      defineMacro("\\varTheta", "\\mathit{\\Theta}");
      defineMacro("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro("\\varXi", "\\mathit{\\Xi}");
      defineMacro("\\varPi", "\\mathit{\\Pi}");
      defineMacro("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro("\\varPhi", "\\mathit{\\Phi}");
      defineMacro("\\varPsi", "\\mathit{\\Psi}");
      defineMacro("\\varOmega", "\\mathit{\\Omega}");
      defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
      defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      var dotsByToken = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        "\\mathbin": "\\dotsb",
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        "\\DOTSX": "\\dotsx"
      };
      defineMacro("\\dots", function(context) {
        var thedots = "\\dotso";
        var next = context.expandAfterFuture().text;
        if (next in dotsByToken) {
          thedots = dotsByToken[next];
        } else if (next.substr(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next in src_symbols.math) {
          if (utils.contains(["bin", "rel"], src_symbols.math[next].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      var spaceAfterDots = {
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        "$": true,
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro("\\dotso", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\dotsc", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots && next !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\cdots", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro("\\dotsb", "\\cdots");
      defineMacro("\\dotsm", "\\cdots");
      defineMacro("\\dotsi", "\\!\\cdots");
      defineMacro("\\dotsx", "\\ldots\\,");
      defineMacro("\\DOTSI", "\\relax");
      defineMacro("\\DOTSB", "\\relax");
      defineMacro("\\DOTSX", "\\relax");
      defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro("\\thinspace", "\\,");
      defineMacro("\\>", "\\mskip{4mu}");
      defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro("\\medspace", "\\:");
      defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro("\\thickspace", "\\;");
      defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro("\\negthinspace", "\\!");
      defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro("\\enspace", "\\kern.5em ");
      defineMacro("\\enskip", "\\hskip.5em\\relax");
      defineMacro("\\quad", "\\hskip1em\\relax");
      defineMacro("\\qquad", "\\hskip2em\\relax");
      defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro("\\tag@literal", function(context) {
        if (context.macros.get("\\df@tag")) {
          throw new src_ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
      defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}");
      defineMacro("\\newline", "\\\\\\relax");
      defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
      var latexRaiseA = fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1] + "em";
      defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro("\\@hspace", "\\hskip #1\\relax");
      defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro("\\ordinarycolon", ":");
      defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
      defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
      defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
      defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
      defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
      defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
      defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
      defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
      defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
      defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
      defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
      defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
      defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
      defineMacro("\u2237", "\\dblcolon");
      defineMacro("\u2239", "\\eqcolon");
      defineMacro("\u2254", "\\coloneqq");
      defineMacro("\u2255", "\\eqqcolon");
      defineMacro("\u2A74", "\\Coloneqq");
      defineMacro("\\ratio", "\\vcentcolon");
      defineMacro("\\coloncolon", "\\dblcolon");
      defineMacro("\\colonequals", "\\coloneqq");
      defineMacro("\\coloncolonequals", "\\Coloneqq");
      defineMacro("\\equalscolon", "\\eqqcolon");
      defineMacro("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro("\\colonminus", "\\coloneq");
      defineMacro("\\coloncolonminus", "\\Coloneq");
      defineMacro("\\minuscolon", "\\eqcolon");
      defineMacro("\\minuscoloncolon", "\\Eqcolon");
      defineMacro("\\coloncolonapprox", "\\Colonapprox");
      defineMacro("\\coloncolonsim", "\\Colonsim");
      defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
      defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
      defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
      defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
      defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
      defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
      defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
      defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
      defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
      defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
      defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
      defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
      defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
      defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
      defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
      defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
      defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
      defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
      defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
      defineMacro("\u27E6", "\\llbracket");
      defineMacro("\u27E7", "\\rrbracket");
      defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
      defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
      defineMacro("\u2983", "\\lBrace");
      defineMacro("\u2984", "\\rBrace");
      defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
      defineMacro("\u29B5", "\\minuso");
      defineMacro("\\darr", "\\downarrow");
      defineMacro("\\dArr", "\\Downarrow");
      defineMacro("\\Darr", "\\Downarrow");
      defineMacro("\\lang", "\\langle");
      defineMacro("\\rang", "\\rangle");
      defineMacro("\\uarr", "\\uparrow");
      defineMacro("\\uArr", "\\Uparrow");
      defineMacro("\\Uarr", "\\Uparrow");
      defineMacro("\\N", "\\mathbb{N}");
      defineMacro("\\R", "\\mathbb{R}");
      defineMacro("\\Z", "\\mathbb{Z}");
      defineMacro("\\alef", "\\aleph");
      defineMacro("\\alefsym", "\\aleph");
      defineMacro("\\Alpha", "\\mathrm{A}");
      defineMacro("\\Beta", "\\mathrm{B}");
      defineMacro("\\bull", "\\bullet");
      defineMacro("\\Chi", "\\mathrm{X}");
      defineMacro("\\clubs", "\\clubsuit");
      defineMacro("\\cnums", "\\mathbb{C}");
      defineMacro("\\Complex", "\\mathbb{C}");
      defineMacro("\\Dagger", "\\ddagger");
      defineMacro("\\diamonds", "\\diamondsuit");
      defineMacro("\\empty", "\\emptyset");
      defineMacro("\\Epsilon", "\\mathrm{E}");
      defineMacro("\\Eta", "\\mathrm{H}");
      defineMacro("\\exist", "\\exists");
      defineMacro("\\harr", "\\leftrightarrow");
      defineMacro("\\hArr", "\\Leftrightarrow");
      defineMacro("\\Harr", "\\Leftrightarrow");
      defineMacro("\\hearts", "\\heartsuit");
      defineMacro("\\image", "\\Im");
      defineMacro("\\infin", "\\infty");
      defineMacro("\\Iota", "\\mathrm{I}");
      defineMacro("\\isin", "\\in");
      defineMacro("\\Kappa", "\\mathrm{K}");
      defineMacro("\\larr", "\\leftarrow");
      defineMacro("\\lArr", "\\Leftarrow");
      defineMacro("\\Larr", "\\Leftarrow");
      defineMacro("\\lrarr", "\\leftrightarrow");
      defineMacro("\\lrArr", "\\Leftrightarrow");
      defineMacro("\\Lrarr", "\\Leftrightarrow");
      defineMacro("\\Mu", "\\mathrm{M}");
      defineMacro("\\natnums", "\\mathbb{N}");
      defineMacro("\\Nu", "\\mathrm{N}");
      defineMacro("\\Omicron", "\\mathrm{O}");
      defineMacro("\\plusmn", "\\pm");
      defineMacro("\\rarr", "\\rightarrow");
      defineMacro("\\rArr", "\\Rightarrow");
      defineMacro("\\Rarr", "\\Rightarrow");
      defineMacro("\\real", "\\Re");
      defineMacro("\\reals", "\\mathbb{R}");
      defineMacro("\\Reals", "\\mathbb{R}");
      defineMacro("\\Rho", "\\mathrm{P}");
      defineMacro("\\sdot", "\\cdot");
      defineMacro("\\sect", "\\S");
      defineMacro("\\spades", "\\spadesuit");
      defineMacro("\\sub", "\\subset");
      defineMacro("\\sube", "\\subseteq");
      defineMacro("\\supe", "\\supseteq");
      defineMacro("\\Tau", "\\mathrm{T}");
      defineMacro("\\thetasym", "\\vartheta");
      defineMacro("\\weierp", "\\wp");
      defineMacro("\\Zeta", "\\mathrm{Z}");
      defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro("\\Bra", "\\left\\langle#1\\right|");
      defineMacro("\\Ket", "\\left|#1\\right\\rangle");
      defineMacro("\\angln", "{\\angl n}");
      defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro("\\gray", "\\textcolor{gray}{#1}");
      defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
      var operatorname_htmlBuilder = function htmlBuilder2(grp, options) {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "operatorname");
        }
        var base2;
        if (group.body.length > 0) {
          var body = group.body.map(function(child5) {
            var childText = child5.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child5.mode,
                text: childText
              };
            } else {
              return child5;
            }
          });
          var expression = buildExpression(body, options.withFont("mathrm"), true);
          for (var i3 = 0; i3 < expression.length; i3++) {
            var child4 = expression[i3];
            if (child4 instanceof SymbolNode) {
              child4.text = child4.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base2 = buildCommon.makeSpan(["mop"], expression, options);
        } else {
          base2 = buildCommon.makeSpan(["mop"], [], options);
        }
        if (hasLimits) {
          return assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
        } else {
          return base2;
        }
      };
      var operatorname_mathmlBuilder = function mathmlBuilder2(group, options) {
        var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
        var isAllString = true;
        for (var i3 = 0; i3 < expression.length; i3++) {
          var node5 = expression[i3];
          if (node5 instanceof mathMLTree.SpaceNode)
            ;
          else if (node5 instanceof mathMLTree.MathNode) {
            switch (node5.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              case "mo": {
                var child4 = node5.children[0];
                if (node5.children.length === 1 && child4 instanceof mathMLTree.TextNode) {
                  child4.text = child4.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          var word = expression.map(function(node6) {
            return node6.toText();
          }).join("");
          expression = [new mathMLTree.TextNode(word)];
        }
        var identifier = new mathMLTree.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal");
        var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
        if (group.parentIsSupSub) {
          return new mathMLTree.MathNode("mrow", [identifier, operator]);
        } else {
          return mathMLTree.newDocumentFragment([identifier, operator]);
        }
      };
      defineFunction({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "operatorname",
            mode: parser2.mode,
            body: ordargument(body),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        },
        htmlBuilder: operatorname_htmlBuilder,
        mathmlBuilder: operatorname_mathmlBuilder
      });
      defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders({
        type: "ordgroup",
        htmlBuilder: function htmlBuilder2(group, options) {
          if (group.semisimple) {
            return buildCommon.makeFragment(buildExpression(group.body, options, false));
          }
          return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return buildExpressionRow(group.body, options, true);
        }
      });
      defineFunction({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          var body = args[0];
          return {
            type: "overline",
            mode: parser2.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var innerGroup = buildGroup(group.body, options.havingCrampedStyle());
          var line = buildCommon.makeLineSpan("overline-line", options);
          var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node5 = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
          node5.setAttribute("accent", "true");
          return node5;
        }
      });
      defineFunction({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          var body = args[0];
          return {
            type: "phantom",
            mode: parser2.mode,
            body: ordargument(body)
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options.withPhantom(), false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(group.body, options);
          return new mathMLTree.MathNode("mphantom", inner2);
        }
      });
      defineFunction({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref2, args) {
          var parser2 = _ref2.parser;
          var body = args[0];
          return {
            type: "hphantom",
            mode: parser2.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var node5 = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
          node5.height = 0;
          node5.depth = 0;
          if (node5.children) {
            for (var i3 = 0; i3 < node5.children.length; i3++) {
              node5.children[i3].height = 0;
              node5.children[i3].depth = 0;
            }
          }
          node5 = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node5
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [node5], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(ordargument(group.body), options);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node5 = new mathMLTree.MathNode("mpadded", [phantom]);
          node5.setAttribute("height", "0px");
          node5.setAttribute("depth", "0px");
          return node5;
        }
      });
      defineFunction({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref3, args) {
          var parser2 = _ref3.parser;
          var body = args[0];
          return {
            type: "vphantom",
            mode: parser2.mode,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
          var fix = buildCommon.makeSpan(["fix"], []);
          return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(ordargument(group.body), options);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node5 = new mathMLTree.MathNode("mpadded", [phantom]);
          node5.setAttribute("width", "0px");
          return node5;
        }
      });
      defineFunction({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          var amount = assertNodeType(args[0], "size").value;
          var body = args[1];
          return {
            type: "raisebox",
            mode: parser2.mode,
            dy: amount,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var body = buildGroup(group.body, options);
          var dy = calculateSize(group.dy, options);
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          var dy = group.dy.number + group.dy.unit;
          node5.setAttribute("voffset", dy);
          return node5;
        }
      });
      defineFunction({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          argTypes: ["size", "size", "size"]
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser;
          var shift2 = optArgs[0];
          var width = assertNodeType(args[0], "size");
          var height = assertNodeType(args[1], "size");
          return {
            type: "rule",
            mode: parser2.mode,
            shift: shift2 && assertNodeType(shift2, "size").value,
            width: width.value,
            height: height.value
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
          var width = calculateSize(group.width, options);
          var height = calculateSize(group.height, options);
          var shift2 = group.shift ? calculateSize(group.shift, options) : 0;
          rule.style.borderRightWidth = width + "em";
          rule.style.borderTopWidth = height + "em";
          rule.style.bottom = shift2 + "em";
          rule.width = width;
          rule.height = height + shift2;
          rule.depth = -shift2;
          rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
          return rule;
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var width = calculateSize(group.width, options);
          var height = calculateSize(group.height, options);
          var shift2 = group.shift ? calculateSize(group.shift, options) : 0;
          var color2 = options.color && options.getColor() || "black";
          var rule = new mathMLTree.MathNode("mspace");
          rule.setAttribute("mathbackground", color2);
          rule.setAttribute("width", width + "em");
          rule.setAttribute("height", height + "em");
          var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
          if (shift2 >= 0) {
            wrapper.setAttribute("height", "+" + shift2 + "em");
          } else {
            wrapper.setAttribute("height", shift2 + "em");
            wrapper.setAttribute("depth", "+" + -shift2 + "em");
          }
          wrapper.setAttribute("voffset", shift2 + "em");
          return wrapper;
        }
      });
      function sizingGroup(value, options, baseOptions) {
        var inner2 = buildExpression(value, options, false);
        var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
        for (var i3 = 0; i3 < inner2.length; i3++) {
          var pos = inner2[i3].classes.indexOf("sizing");
          if (pos < 0) {
            Array.prototype.push.apply(inner2[i3].classes, options.sizingClasses(baseOptions));
          } else if (inner2[i3].classes[pos + 1] === "reset-size" + options.size) {
            inner2[i3].classes[pos + 1] = "reset-size" + baseOptions.size;
          }
          inner2[i3].height *= multiplier;
          inner2[i3].depth *= multiplier;
        }
        return buildCommon.makeFragment(inner2);
      }
      var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      var sizing_htmlBuilder = function htmlBuilder2(group, options) {
        var newOptions = options.havingSize(group.size);
        return sizingGroup(group.body, newOptions, options);
      };
      defineFunction({
        type: "sizing",
        names: sizeFuncs,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser2 = _ref.parser;
          var body = parser2.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser2.mode,
            size: sizeFuncs.indexOf(funcName) + 1,
            body
          };
        },
        htmlBuilder: sizing_htmlBuilder,
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var newOptions = options.havingSize(group.size);
          var inner2 = buildMathML_buildExpression(group.body, newOptions);
          var node5 = new mathMLTree.MathNode("mstyle", inner2);
          node5.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
          return node5;
        }
      });
      defineFunction({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser;
          var smashHeight = false;
          var smashDepth = false;
          var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
          if (tbArg) {
            var letter = "";
            for (var i3 = 0; i3 < tbArg.body.length; ++i3) {
              var node5 = tbArg.body[i3];
              letter = node5.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          var body = args[0];
          return {
            type: "smash",
            mode: parser2.mode,
            body,
            smashHeight,
            smashDepth
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var node5 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
          if (!group.smashHeight && !group.smashDepth) {
            return node5;
          }
          if (group.smashHeight) {
            node5.height = 0;
            if (node5.children) {
              for (var i3 = 0; i3 < node5.children.length; i3++) {
                node5.children[i3].height = 0;
              }
            }
          }
          if (group.smashDepth) {
            node5.depth = 0;
            if (node5.children) {
              for (var _i6 = 0; _i6 < node5.children.length; _i6++) {
                node5.children[_i6].depth = 0;
              }
            }
          }
          var smashedNode = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node5
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [smashedNode], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
          if (group.smashHeight) {
            node5.setAttribute("height", "0px");
          }
          if (group.smashDepth) {
            node5.setAttribute("depth", "0px");
          }
          return node5;
        }
      });
      defineFunction({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler: function handler(_ref, args, optArgs) {
          var parser2 = _ref.parser;
          var index3 = optArgs[0];
          var body = args[0];
          return {
            type: "sqrt",
            mode: parser2.mode,
            body,
            index: index3
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var inner2 = buildGroup(group.body, options.havingCrampedStyle());
          if (inner2.height === 0) {
            inner2.height = options.fontMetrics().xHeight;
          }
          inner2 = buildCommon.wrapFragment(inner2, options);
          var metrics = options.fontMetrics();
          var theta = metrics.defaultRuleThickness;
          var phi = theta;
          if (options.style.id < src_Style.TEXT.id) {
            phi = options.fontMetrics().xHeight;
          }
          var lineClearance = theta + phi / 4;
          var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
          var _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
          var delimDepth = img.height - ruleWidth;
          if (delimDepth > inner2.height + inner2.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
          }
          var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
          inner2.style.paddingLeft = advanceWidth + "em";
          var body = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner2,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner2.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options);
          if (!group.index) {
            return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
          } else {
            var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
            var rootm = buildGroup(group.index, newOptions, options);
            var toShift = 0.6 * (body.height - body.depth);
            var rootVList = buildCommon.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options);
            var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
            return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
          }
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var body = group.body, index3 = group.index;
          return index3 ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index3, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
        }
      });
      var styling_styleMap = {
        "display": src_Style.DISPLAY,
        "text": src_Style.TEXT,
        "script": src_Style.SCRIPT,
        "scriptscript": src_Style.SCRIPTSCRIPT
      };
      defineFunction({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler: function handler(_ref, args) {
          var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser2 = _ref.parser;
          var body = parser2.parseExpression(true, breakOnTokenText);
          var style = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser2.mode,
            style,
            body
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var newStyle = styling_styleMap[group.style];
          var newOptions = options.havingStyle(newStyle).withFont("");
          return sizingGroup(group.body, newOptions, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var newStyle = styling_styleMap[group.style];
          var newOptions = options.havingStyle(newStyle);
          var inner2 = buildMathML_buildExpression(group.body, newOptions);
          var node5 = new mathMLTree.MathNode("mstyle", inner2);
          var styleAttributes = {
            "display": ["0", "true"],
            "text": ["0", "false"],
            "script": ["1", "false"],
            "scriptscript": ["2", "false"]
          };
          var attr = styleAttributes[group.style];
          node5.setAttribute("scriptlevel", attr[0]);
          node5.setAttribute("displaystyle", attr[1]);
          return node5;
        }
      });
      var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
        var base2 = group.base;
        if (!base2) {
          return null;
        } else if (base2.type === "op") {
          var delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
          return delegate ? op_htmlBuilder : null;
        } else if (base2.type === "operatorname") {
          var _delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
          return _delegate ? operatorname_htmlBuilder : null;
        } else if (base2.type === "accent") {
          return utils.isCharacterBox(base2.base) ? htmlBuilder : null;
        } else if (base2.type === "horizBrace") {
          var isSup = !group.sub;
          return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
        } else {
          return null;
        }
      };
      defineFunctionBuilders({
        type: "supsub",
        htmlBuilder: function htmlBuilder2(group, options) {
          var builderDelegate = htmlBuilderDelegate(group, options);
          if (builderDelegate) {
            return builderDelegate(group, options);
          }
          var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
          var base2 = buildGroup(valueBase, options);
          var supm;
          var subm;
          var metrics = options.fontMetrics();
          var supShift = 0;
          var subShift = 0;
          var isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
          if (valueSup) {
            var newOptions = options.havingStyle(options.style.sup());
            supm = buildGroup(valueSup, newOptions, options);
            if (!isCharacterBox2) {
              supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          if (valueSub) {
            var _newOptions = options.havingStyle(options.style.sub());
            subm = buildGroup(valueSub, _newOptions, options);
            if (!isCharacterBox2) {
              subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          var minSupShift;
          if (options.style === src_Style.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          var multiplier = options.sizeMultiplier;
          var marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
          var marginLeft = null;
          if (subm) {
            var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
            if (base2 instanceof SymbolNode || isOiint) {
              marginLeft = -base2.italic + "em";
            }
          }
          var supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            var ruleWidth = metrics.defaultRuleThickness;
            var maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            var vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            var _vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: _vlistElem
            }, options);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          var mclass = getTypeOfDomTree(base2, "right") || "mord";
          return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var isBrace = false;
          var isOver;
          var isSup;
          if (group.base && group.base.type === "horizBrace") {
            isSup = !!group.sup;
            if (isSup === group.base.isOver) {
              isBrace = true;
              isOver = group.base.isOver;
            }
          }
          if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
            group.base.parentIsSupSub = true;
          }
          var children = [buildMathML_buildGroup(group.base, options)];
          if (group.sub) {
            children.push(buildMathML_buildGroup(group.sub, options));
          }
          if (group.sup) {
            children.push(buildMathML_buildGroup(group.sup, options));
          }
          var nodeType2;
          if (isBrace) {
            nodeType2 = isOver ? "mover" : "munder";
          } else if (!group.sub) {
            var base2 = group.base;
            if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
              nodeType2 = "mover";
            } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
              nodeType2 = "mover";
            } else {
              nodeType2 = "msup";
            }
          } else if (!group.sup) {
            var _base = group.base;
            if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
              nodeType2 = "munder";
            } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === src_Style.DISPLAY)) {
              nodeType2 = "munder";
            } else {
              nodeType2 = "msub";
            }
          } else {
            var _base2 = group.base;
            if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
              nodeType2 = "munderover";
            } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || _base2.limits)) {
              nodeType2 = "munderover";
            } else {
              nodeType2 = "msubsup";
            }
          }
          return new mathMLTree.MathNode(nodeType2, children);
        }
      });
      defineFunctionBuilders({
        type: "atom",
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
          if (group.family === "bin") {
            var variant = getVariant(group, options);
            if (variant === "bold-italic") {
              node5.setAttribute("mathvariant", variant);
            }
          } else if (group.family === "punct") {
            node5.setAttribute("separator", "true");
          } else if (group.family === "open" || group.family === "close") {
            node5.setAttribute("stretchy", "false");
          }
          return node5;
        }
      });
      var defaultVariant = {
        "mi": "italic",
        "mn": "normal",
        "mtext": "normal"
      };
      defineFunctionBuilders({
        type: "mathord",
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.makeOrd(group, options, "mathord");
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5 = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
          var variant = getVariant(group, options) || "italic";
          if (variant !== defaultVariant[node5.type]) {
            node5.setAttribute("mathvariant", variant);
          }
          return node5;
        }
      });
      defineFunctionBuilders({
        type: "textord",
        htmlBuilder: function htmlBuilder2(group, options) {
          return buildCommon.makeOrd(group, options, "textord");
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var text3 = makeText(group.text, group.mode, options);
          var variant = getVariant(group, options) || "normal";
          var node5;
          if (group.mode === "text") {
            node5 = new mathMLTree.MathNode("mtext", [text3]);
          } else if (/[0-9]/.test(group.text)) {
            node5 = new mathMLTree.MathNode("mn", [text3]);
          } else if (group.text === "\\prime") {
            node5 = new mathMLTree.MathNode("mo", [text3]);
          } else {
            node5 = new mathMLTree.MathNode("mi", [text3]);
          }
          if (variant !== defaultVariant[node5.type]) {
            node5.setAttribute("mathvariant", variant);
          }
          return node5;
        }
      });
      var cssSpace = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      var regularSpace = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders({
        type: "spacing",
        htmlBuilder: function htmlBuilder2(group, options) {
          if (regularSpace.hasOwnProperty(group.text)) {
            var className = regularSpace[group.text].className || "";
            if (group.mode === "text") {
              var ord = buildCommon.makeOrd(group, options, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
            }
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var node5;
          if (regularSpace.hasOwnProperty(group.text)) {
            node5 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return new mathMLTree.MathNode("mspace");
          } else {
            throw new src_ParseError('Unknown type of space "' + group.text + '"');
          }
          return node5;
        }
      });
      var pad = function pad2() {
        var padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders({
        type: "tag",
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
          table2.setAttribute("width", "100%");
          return table2;
        }
      });
      var textFontFamilies = {
        "\\text": void 0,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      var textFontWeights = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      var textFontShapes = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      var optionsWithFont = function optionsWithFont2(group, options) {
        var font = group.font;
        if (!font) {
          return options;
        } else if (textFontFamilies[font]) {
          return options.withTextFontFamily(textFontFamilies[font]);
        } else if (textFontWeights[font]) {
          return options.withTextFontWeight(textFontWeights[font]);
        } else {
          return options.withTextFontShape(textFontShapes[font]);
        }
      };
      defineFunction({
        type: "text",
        names: [
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          "\\textbf",
          "\\textmd",
          "\\textit",
          "\\textup"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser, funcName = _ref.funcName;
          var body = args[0];
          return {
            type: "text",
            mode: parser2.mode,
            body: ordargument(body),
            font: funcName
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var newOptions = optionsWithFont(group, options);
          var inner2 = buildExpression(group.body, newOptions, true);
          return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var newOptions = optionsWithFont(group, options);
          return buildExpressionRow(group.body, newOptions);
        }
      });
      defineFunction({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          return {
            type: "underline",
            mode: parser2.mode,
            body: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var innerGroup = buildGroup(group.body, options);
          var line = buildCommon.makeLineSpan("underline-line", options);
          var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node5 = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
          node5.setAttribute("accentunder", "true");
          return node5;
        }
      });
      defineFunction({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          allowedInText: false
        },
        handler: function handler(_ref, args) {
          var parser2 = _ref.parser;
          return {
            type: "vcenter",
            mode: parser2.mode,
            body: args[0]
          };
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var body = buildGroup(group.body, options);
          var axisHeight = options.fontMetrics().axisHeight;
          var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
        }
      });
      defineFunction({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: function handler(context, args, optArgs) {
          throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder: function htmlBuilder2(group, options) {
          var text3 = makeVerb(group);
          var body = [];
          var newOptions = options.havingStyle(options.style.text());
          for (var i3 = 0; i3 < text3.length; i3++) {
            var c2 = text3[i3];
            if (c2 === "~") {
              c2 = "\\textasciitilde";
            }
            body.push(buildCommon.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
        },
        mathmlBuilder: function mathmlBuilder2(group, options) {
          var text3 = new mathMLTree.TextNode(makeVerb(group));
          var node5 = new mathMLTree.MathNode("mtext", [text3]);
          node5.setAttribute("mathvariant", "monospace");
          return node5;
        }
      });
      var makeVerb = function makeVerb2(group) {
        return group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
      };
      var functions = _functions;
      var src_functions = functions;
      var SourceLocation = /* @__PURE__ */ function() {
        function SourceLocation2(lexer, start4, end3) {
          this.lexer = void 0;
          this.start = void 0;
          this.end = void 0;
          this.lexer = lexer;
          this.start = start4;
          this.end = end3;
        }
        SourceLocation2.range = function range(first, second) {
          if (!second) {
            return first && first.loc;
          } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
            return null;
          } else {
            return new SourceLocation2(first.loc.lexer, first.loc.start, second.loc.end);
          }
        };
        return SourceLocation2;
      }();
      var Token = /* @__PURE__ */ function() {
        function Token2(text3, loc) {
          this.text = void 0;
          this.loc = void 0;
          this.noexpand = void 0;
          this.treatAsRelax = void 0;
          this.text = text3;
          this.loc = loc;
        }
        var _proto = Token2.prototype;
        _proto.range = function range(endToken, text3) {
          return new Token2(text3, SourceLocation.range(this, endToken));
        };
        return Token2;
      }();
      var spaceRegexString = "[ \r\n	]";
      var controlWordRegexString = "\\\\[a-zA-Z@]+";
      var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
      var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
      var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
      var combiningDiacriticalMarkString = "[\u0300-\u036F]";
      var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
      var tokenRegexString = "(" + spaceRegexString + "+)|" + (controlSpaceRegexString + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");
      var Lexer = /* @__PURE__ */ function() {
        function Lexer2(input2, settings) {
          this.input = void 0;
          this.settings = void 0;
          this.tokenRegex = void 0;
          this.catcodes = void 0;
          this.input = input2;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString, "g");
          this.catcodes = {
            "%": 14,
            "~": 13
          };
        }
        var _proto = Lexer2.prototype;
        _proto.setCatcode = function setCatcode(char, code2) {
          this.catcodes[char] = code2;
        };
        _proto.lex = function lex() {
          var input2 = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input2.length) {
            return new Token("EOF", new SourceLocation(this, pos, pos));
          }
          var match = this.tokenRegex.exec(input2);
          if (match === null || match.index !== pos) {
            throw new src_ParseError("Unexpected character: '" + input2[pos] + "'", new Token(input2[pos], new SourceLocation(this, pos, pos + 1)));
          }
          var text3 = match[6] || match[3] || (match[2] ? "\\ " : " ");
          if (this.catcodes[text3] === 14) {
            var nlIndex = input2.indexOf("\n", this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input2.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token(text3, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        };
        return Lexer2;
      }();
      var Namespace = /* @__PURE__ */ function() {
        function Namespace2(builtins, globalMacros) {
          if (builtins === void 0) {
            builtins = {};
          }
          if (globalMacros === void 0) {
            globalMacros = {};
          }
          this.current = void 0;
          this.builtins = void 0;
          this.undefStack = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        var _proto = Namespace2.prototype;
        _proto.beginGroup = function beginGroup() {
          this.undefStack.push({});
        };
        _proto.endGroup = function endGroup() {
          if (this.undefStack.length === 0) {
            throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          var undefs = this.undefStack.pop();
          for (var undef in undefs) {
            if (undefs.hasOwnProperty(undef)) {
              if (undefs[undef] === void 0) {
                delete this.current[undef];
              } else {
                this.current[undef] = undefs[undef];
              }
            }
          }
        };
        _proto.has = function has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        };
        _proto.get = function get5(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        };
        _proto.set = function set3(name, value, global2) {
          if (global2 === void 0) {
            global2 = false;
          }
          if (global2) {
            for (var i3 = 0; i3 < this.undefStack.length; i3++) {
              delete this.undefStack[i3][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value;
            }
          } else {
            var top2 = this.undefStack[this.undefStack.length - 1];
            if (top2 && !top2.hasOwnProperty(name)) {
              top2[name] = this.current[name];
            }
          }
          this.current[name] = value;
        };
        return Namespace2;
      }();
      var implicitCommands = {
        "\\relax": true,
        "^": true,
        "_": true,
        "\\limits": true,
        "\\nolimits": true
      };
      var MacroExpander = /* @__PURE__ */ function() {
        function MacroExpander2(input2, settings, mode) {
          this.settings = void 0;
          this.expansionCount = void 0;
          this.lexer = void 0;
          this.macros = void 0;
          this.stack = void 0;
          this.mode = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input2);
          this.macros = new Namespace(macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        var _proto = MacroExpander2.prototype;
        _proto.feed = function feed(input2) {
          this.lexer = new Lexer(input2, this.settings);
        };
        _proto.switchMode = function switchMode(newMode) {
          this.mode = newMode;
        };
        _proto.beginGroup = function beginGroup() {
          this.macros.beginGroup();
        };
        _proto.endGroup = function endGroup() {
          this.macros.endGroup();
        };
        _proto.future = function future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        };
        _proto.popToken = function popToken() {
          this.future();
          return this.stack.pop();
        };
        _proto.pushToken = function pushToken(token) {
          this.stack.push(token);
        };
        _proto.pushTokens = function pushTokens(tokens) {
          var _this$stack;
          (_this$stack = this.stack).push.apply(_this$stack, tokens);
        };
        _proto.scanArgument = function scanArgument(isOptional) {
          var start4;
          var end3;
          var tokens;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start4 = this.popToken();
            var _this$consumeArg = this.consumeArg(["]"]);
            tokens = _this$consumeArg.tokens;
            end3 = _this$consumeArg.end;
          } else {
            var _this$consumeArg2 = this.consumeArg();
            tokens = _this$consumeArg2.tokens;
            start4 = _this$consumeArg2.start;
            end3 = _this$consumeArg2.end;
          }
          this.pushToken(new Token("EOF", end3.loc));
          this.pushTokens(tokens);
          return start4.range(end3, "");
        };
        _proto.consumeSpaces = function consumeSpaces() {
          for (; ; ) {
            var token = this.future();
            if (token.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        };
        _proto.consumeArg = function consumeArg(delims) {
          var tokens = [];
          var isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          var start4 = this.future();
          var tok;
          var depth = 0;
          var match = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new src_ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                ++match;
                if (match === delims.length) {
                  tokens.splice(-match, match);
                  break;
                }
              } else {
                match = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start4.text === "{" && tokens[tokens.length - 1].text === "}") {
            tokens.pop();
            tokens.shift();
          }
          tokens.reverse();
          return {
            tokens,
            start: start4,
            end: tok
          };
        };
        _proto.consumeArgs = function consumeArgs(numArgs, delimiters2) {
          if (delimiters2) {
            if (delimiters2.length !== numArgs + 1) {
              throw new src_ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters2[0];
            for (var i3 = 0; i3 < delims.length; i3++) {
              var tok = this.popToken();
              if (delims[i3] !== tok.text) {
                throw new src_ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          var args = [];
          for (var _i6 = 0; _i6 < numArgs; _i6++) {
            args.push(this.consumeArg(delimiters2 && delimiters2[_i6 + 1]).tokens);
          }
          return args;
        };
        _proto.expandOnce = function expandOnce(expandableOnly) {
          var topToken = this.popToken();
          var name = topToken.text;
          var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new src_ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return topToken;
          }
          this.expansionCount++;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
          var tokens = expansion.tokens;
          var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens = tokens.slice();
            for (var i3 = tokens.length - 1; i3 >= 0; --i3) {
              var tok = tokens[i3];
              if (tok.text === "#") {
                if (i3 === 0) {
                  throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens[--i3];
                if (tok.text === "#") {
                  tokens.splice(i3 + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  var _tokens;
                  (_tokens = tokens).splice.apply(_tokens, [i3, 2].concat(args[+tok.text - 1]));
                } else {
                  throw new src_ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens);
          return tokens;
        };
        _proto.expandAfterFuture = function expandAfterFuture() {
          this.expandOnce();
          return this.future();
        };
        _proto.expandNextToken = function expandNextToken() {
          for (; ; ) {
            var expanded = this.expandOnce();
            if (expanded instanceof Token) {
              if (expanded.text === "\\relax" || expanded.treatAsRelax) {
                this.stack.pop();
              } else {
                return this.stack.pop();
              }
            }
          }
          throw new Error();
        };
        _proto.expandMacro = function expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
        };
        _proto.expandTokens = function expandTokens(tokens) {
          var output = [];
          var oldStackLength = this.stack.length;
          this.pushTokens(tokens);
          while (this.stack.length > oldStackLength) {
            var expanded = this.expandOnce(true);
            if (expanded instanceof Token) {
              if (expanded.treatAsRelax) {
                expanded.noexpand = false;
                expanded.treatAsRelax = false;
              }
              output.push(this.stack.pop());
            }
          }
          return output;
        };
        _proto.expandMacroAsText = function expandMacroAsText(name) {
          var tokens = this.expandMacro(name);
          if (tokens) {
            return tokens.map(function(token) {
              return token.text;
            }).join("");
          } else {
            return tokens;
          }
        };
        _proto._getExpansion = function _getExpansion(name) {
          var definition2 = this.macros.get(name);
          if (definition2 == null) {
            return definition2;
          }
          if (name.length === 1) {
            var catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          var expansion = typeof definition2 === "function" ? definition2(this) : definition2;
          if (typeof expansion === "string") {
            var numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              var stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            var bodyLexer = new Lexer(expansion, this.settings);
            var tokens = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens.push(tok);
              tok = bodyLexer.lex();
            }
            tokens.reverse();
            var expanded = {
              tokens,
              numArgs
            };
            return expanded;
          }
          return expansion;
        };
        _proto.isDefined = function isDefined(name) {
          return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        };
        _proto.isExpandable = function isExpandable(name) {
          var macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
        };
        return MacroExpander2;
      }();
      var unicodeAccents = {
        "\u0301": {
          "text": "\\'",
          "math": "\\acute"
        },
        "\u0300": {
          "text": "\\`",
          "math": "\\grave"
        },
        "\u0308": {
          "text": '\\"',
          "math": "\\ddot"
        },
        "\u0303": {
          "text": "\\~",
          "math": "\\tilde"
        },
        "\u0304": {
          "text": "\\=",
          "math": "\\bar"
        },
        "\u0306": {
          "text": "\\u",
          "math": "\\breve"
        },
        "\u030C": {
          "text": "\\v",
          "math": "\\check"
        },
        "\u0302": {
          "text": "\\^",
          "math": "\\hat"
        },
        "\u0307": {
          "text": "\\.",
          "math": "\\dot"
        },
        "\u030A": {
          "text": "\\r",
          "math": "\\mathring"
        },
        "\u030B": {
          "text": "\\H"
        }
      };
      var unicodeSymbols = {
        "\xE1": "a\u0301",
        "\xE0": "a\u0300",
        "\xE4": "a\u0308",
        "\u01DF": "a\u0308\u0304",
        "\xE3": "a\u0303",
        "\u0101": "a\u0304",
        "\u0103": "a\u0306",
        "\u1EAF": "a\u0306\u0301",
        "\u1EB1": "a\u0306\u0300",
        "\u1EB5": "a\u0306\u0303",
        "\u01CE": "a\u030C",
        "\xE2": "a\u0302",
        "\u1EA5": "a\u0302\u0301",
        "\u1EA7": "a\u0302\u0300",
        "\u1EAB": "a\u0302\u0303",
        "\u0227": "a\u0307",
        "\u01E1": "a\u0307\u0304",
        "\xE5": "a\u030A",
        "\u01FB": "a\u030A\u0301",
        "\u1E03": "b\u0307",
        "\u0107": "c\u0301",
        "\u010D": "c\u030C",
        "\u0109": "c\u0302",
        "\u010B": "c\u0307",
        "\u010F": "d\u030C",
        "\u1E0B": "d\u0307",
        "\xE9": "e\u0301",
        "\xE8": "e\u0300",
        "\xEB": "e\u0308",
        "\u1EBD": "e\u0303",
        "\u0113": "e\u0304",
        "\u1E17": "e\u0304\u0301",
        "\u1E15": "e\u0304\u0300",
        "\u0115": "e\u0306",
        "\u011B": "e\u030C",
        "\xEA": "e\u0302",
        "\u1EBF": "e\u0302\u0301",
        "\u1EC1": "e\u0302\u0300",
        "\u1EC5": "e\u0302\u0303",
        "\u0117": "e\u0307",
        "\u1E1F": "f\u0307",
        "\u01F5": "g\u0301",
        "\u1E21": "g\u0304",
        "\u011F": "g\u0306",
        "\u01E7": "g\u030C",
        "\u011D": "g\u0302",
        "\u0121": "g\u0307",
        "\u1E27": "h\u0308",
        "\u021F": "h\u030C",
        "\u0125": "h\u0302",
        "\u1E23": "h\u0307",
        "\xED": "i\u0301",
        "\xEC": "i\u0300",
        "\xEF": "i\u0308",
        "\u1E2F": "i\u0308\u0301",
        "\u0129": "i\u0303",
        "\u012B": "i\u0304",
        "\u012D": "i\u0306",
        "\u01D0": "i\u030C",
        "\xEE": "i\u0302",
        "\u01F0": "j\u030C",
        "\u0135": "j\u0302",
        "\u1E31": "k\u0301",
        "\u01E9": "k\u030C",
        "\u013A": "l\u0301",
        "\u013E": "l\u030C",
        "\u1E3F": "m\u0301",
        "\u1E41": "m\u0307",
        "\u0144": "n\u0301",
        "\u01F9": "n\u0300",
        "\xF1": "n\u0303",
        "\u0148": "n\u030C",
        "\u1E45": "n\u0307",
        "\xF3": "o\u0301",
        "\xF2": "o\u0300",
        "\xF6": "o\u0308",
        "\u022B": "o\u0308\u0304",
        "\xF5": "o\u0303",
        "\u1E4D": "o\u0303\u0301",
        "\u1E4F": "o\u0303\u0308",
        "\u022D": "o\u0303\u0304",
        "\u014D": "o\u0304",
        "\u1E53": "o\u0304\u0301",
        "\u1E51": "o\u0304\u0300",
        "\u014F": "o\u0306",
        "\u01D2": "o\u030C",
        "\xF4": "o\u0302",
        "\u1ED1": "o\u0302\u0301",
        "\u1ED3": "o\u0302\u0300",
        "\u1ED7": "o\u0302\u0303",
        "\u022F": "o\u0307",
        "\u0231": "o\u0307\u0304",
        "\u0151": "o\u030B",
        "\u1E55": "p\u0301",
        "\u1E57": "p\u0307",
        "\u0155": "r\u0301",
        "\u0159": "r\u030C",
        "\u1E59": "r\u0307",
        "\u015B": "s\u0301",
        "\u1E65": "s\u0301\u0307",
        "\u0161": "s\u030C",
        "\u1E67": "s\u030C\u0307",
        "\u015D": "s\u0302",
        "\u1E61": "s\u0307",
        "\u1E97": "t\u0308",
        "\u0165": "t\u030C",
        "\u1E6B": "t\u0307",
        "\xFA": "u\u0301",
        "\xF9": "u\u0300",
        "\xFC": "u\u0308",
        "\u01D8": "u\u0308\u0301",
        "\u01DC": "u\u0308\u0300",
        "\u01D6": "u\u0308\u0304",
        "\u01DA": "u\u0308\u030C",
        "\u0169": "u\u0303",
        "\u1E79": "u\u0303\u0301",
        "\u016B": "u\u0304",
        "\u1E7B": "u\u0304\u0308",
        "\u016D": "u\u0306",
        "\u01D4": "u\u030C",
        "\xFB": "u\u0302",
        "\u016F": "u\u030A",
        "\u0171": "u\u030B",
        "\u1E7D": "v\u0303",
        "\u1E83": "w\u0301",
        "\u1E81": "w\u0300",
        "\u1E85": "w\u0308",
        "\u0175": "w\u0302",
        "\u1E87": "w\u0307",
        "\u1E98": "w\u030A",
        "\u1E8D": "x\u0308",
        "\u1E8B": "x\u0307",
        "\xFD": "y\u0301",
        "\u1EF3": "y\u0300",
        "\xFF": "y\u0308",
        "\u1EF9": "y\u0303",
        "\u0233": "y\u0304",
        "\u0177": "y\u0302",
        "\u1E8F": "y\u0307",
        "\u1E99": "y\u030A",
        "\u017A": "z\u0301",
        "\u017E": "z\u030C",
        "\u1E91": "z\u0302",
        "\u017C": "z\u0307",
        "\xC1": "A\u0301",
        "\xC0": "A\u0300",
        "\xC4": "A\u0308",
        "\u01DE": "A\u0308\u0304",
        "\xC3": "A\u0303",
        "\u0100": "A\u0304",
        "\u0102": "A\u0306",
        "\u1EAE": "A\u0306\u0301",
        "\u1EB0": "A\u0306\u0300",
        "\u1EB4": "A\u0306\u0303",
        "\u01CD": "A\u030C",
        "\xC2": "A\u0302",
        "\u1EA4": "A\u0302\u0301",
        "\u1EA6": "A\u0302\u0300",
        "\u1EAA": "A\u0302\u0303",
        "\u0226": "A\u0307",
        "\u01E0": "A\u0307\u0304",
        "\xC5": "A\u030A",
        "\u01FA": "A\u030A\u0301",
        "\u1E02": "B\u0307",
        "\u0106": "C\u0301",
        "\u010C": "C\u030C",
        "\u0108": "C\u0302",
        "\u010A": "C\u0307",
        "\u010E": "D\u030C",
        "\u1E0A": "D\u0307",
        "\xC9": "E\u0301",
        "\xC8": "E\u0300",
        "\xCB": "E\u0308",
        "\u1EBC": "E\u0303",
        "\u0112": "E\u0304",
        "\u1E16": "E\u0304\u0301",
        "\u1E14": "E\u0304\u0300",
        "\u0114": "E\u0306",
        "\u011A": "E\u030C",
        "\xCA": "E\u0302",
        "\u1EBE": "E\u0302\u0301",
        "\u1EC0": "E\u0302\u0300",
        "\u1EC4": "E\u0302\u0303",
        "\u0116": "E\u0307",
        "\u1E1E": "F\u0307",
        "\u01F4": "G\u0301",
        "\u1E20": "G\u0304",
        "\u011E": "G\u0306",
        "\u01E6": "G\u030C",
        "\u011C": "G\u0302",
        "\u0120": "G\u0307",
        "\u1E26": "H\u0308",
        "\u021E": "H\u030C",
        "\u0124": "H\u0302",
        "\u1E22": "H\u0307",
        "\xCD": "I\u0301",
        "\xCC": "I\u0300",
        "\xCF": "I\u0308",
        "\u1E2E": "I\u0308\u0301",
        "\u0128": "I\u0303",
        "\u012A": "I\u0304",
        "\u012C": "I\u0306",
        "\u01CF": "I\u030C",
        "\xCE": "I\u0302",
        "\u0130": "I\u0307",
        "\u0134": "J\u0302",
        "\u1E30": "K\u0301",
        "\u01E8": "K\u030C",
        "\u0139": "L\u0301",
        "\u013D": "L\u030C",
        "\u1E3E": "M\u0301",
        "\u1E40": "M\u0307",
        "\u0143": "N\u0301",
        "\u01F8": "N\u0300",
        "\xD1": "N\u0303",
        "\u0147": "N\u030C",
        "\u1E44": "N\u0307",
        "\xD3": "O\u0301",
        "\xD2": "O\u0300",
        "\xD6": "O\u0308",
        "\u022A": "O\u0308\u0304",
        "\xD5": "O\u0303",
        "\u1E4C": "O\u0303\u0301",
        "\u1E4E": "O\u0303\u0308",
        "\u022C": "O\u0303\u0304",
        "\u014C": "O\u0304",
        "\u1E52": "O\u0304\u0301",
        "\u1E50": "O\u0304\u0300",
        "\u014E": "O\u0306",
        "\u01D1": "O\u030C",
        "\xD4": "O\u0302",
        "\u1ED0": "O\u0302\u0301",
        "\u1ED2": "O\u0302\u0300",
        "\u1ED6": "O\u0302\u0303",
        "\u022E": "O\u0307",
        "\u0230": "O\u0307\u0304",
        "\u0150": "O\u030B",
        "\u1E54": "P\u0301",
        "\u1E56": "P\u0307",
        "\u0154": "R\u0301",
        "\u0158": "R\u030C",
        "\u1E58": "R\u0307",
        "\u015A": "S\u0301",
        "\u1E64": "S\u0301\u0307",
        "\u0160": "S\u030C",
        "\u1E66": "S\u030C\u0307",
        "\u015C": "S\u0302",
        "\u1E60": "S\u0307",
        "\u0164": "T\u030C",
        "\u1E6A": "T\u0307",
        "\xDA": "U\u0301",
        "\xD9": "U\u0300",
        "\xDC": "U\u0308",
        "\u01D7": "U\u0308\u0301",
        "\u01DB": "U\u0308\u0300",
        "\u01D5": "U\u0308\u0304",
        "\u01D9": "U\u0308\u030C",
        "\u0168": "U\u0303",
        "\u1E78": "U\u0303\u0301",
        "\u016A": "U\u0304",
        "\u1E7A": "U\u0304\u0308",
        "\u016C": "U\u0306",
        "\u01D3": "U\u030C",
        "\xDB": "U\u0302",
        "\u016E": "U\u030A",
        "\u0170": "U\u030B",
        "\u1E7C": "V\u0303",
        "\u1E82": "W\u0301",
        "\u1E80": "W\u0300",
        "\u1E84": "W\u0308",
        "\u0174": "W\u0302",
        "\u1E86": "W\u0307",
        "\u1E8C": "X\u0308",
        "\u1E8A": "X\u0307",
        "\xDD": "Y\u0301",
        "\u1EF2": "Y\u0300",
        "\u0178": "Y\u0308",
        "\u1EF8": "Y\u0303",
        "\u0232": "Y\u0304",
        "\u0176": "Y\u0302",
        "\u1E8E": "Y\u0307",
        "\u0179": "Z\u0301",
        "\u017D": "Z\u030C",
        "\u1E90": "Z\u0302",
        "\u017B": "Z\u0307",
        "\u03AC": "\u03B1\u0301",
        "\u1F70": "\u03B1\u0300",
        "\u1FB1": "\u03B1\u0304",
        "\u1FB0": "\u03B1\u0306",
        "\u03AD": "\u03B5\u0301",
        "\u1F72": "\u03B5\u0300",
        "\u03AE": "\u03B7\u0301",
        "\u1F74": "\u03B7\u0300",
        "\u03AF": "\u03B9\u0301",
        "\u1F76": "\u03B9\u0300",
        "\u03CA": "\u03B9\u0308",
        "\u0390": "\u03B9\u0308\u0301",
        "\u1FD2": "\u03B9\u0308\u0300",
        "\u1FD1": "\u03B9\u0304",
        "\u1FD0": "\u03B9\u0306",
        "\u03CC": "\u03BF\u0301",
        "\u1F78": "\u03BF\u0300",
        "\u03CD": "\u03C5\u0301",
        "\u1F7A": "\u03C5\u0300",
        "\u03CB": "\u03C5\u0308",
        "\u03B0": "\u03C5\u0308\u0301",
        "\u1FE2": "\u03C5\u0308\u0300",
        "\u1FE1": "\u03C5\u0304",
        "\u1FE0": "\u03C5\u0306",
        "\u03CE": "\u03C9\u0301",
        "\u1F7C": "\u03C9\u0300",
        "\u038E": "\u03A5\u0301",
        "\u1FEA": "\u03A5\u0300",
        "\u03AB": "\u03A5\u0308",
        "\u1FE9": "\u03A5\u0304",
        "\u1FE8": "\u03A5\u0306",
        "\u038F": "\u03A9\u0301",
        "\u1FFA": "\u03A9\u0300"
      };
      var Parser = /* @__PURE__ */ function() {
        function Parser2(input2, settings) {
          this.mode = void 0;
          this.gullet = void 0;
          this.settings = void 0;
          this.leftrightDepth = void 0;
          this.nextToken = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander(input2, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        var _proto = Parser2.prototype;
        _proto.expect = function expect(text3, consume) {
          if (consume === void 0) {
            consume = true;
          }
          if (this.fetch().text !== text3) {
            throw new src_ParseError("Expected '" + text3 + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        };
        _proto.consume = function consume() {
          this.nextToken = null;
        };
        _proto.fetch = function fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        };
        _proto.switchMode = function switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        };
        _proto.parse = function parse4() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          var parse5 = this.parseExpression(false);
          this.expect("EOF");
          if (!this.settings.globalGroup) {
            this.gullet.endGroup();
          }
          return parse5;
        };
        _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
          var body = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            var lex = this.fetch();
            if (Parser2.endOfExpression.indexOf(lex.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
              break;
            }
            var atom = this.parseAtom(breakOnTokenText);
            if (!atom) {
              break;
            } else if (atom.type === "internal") {
              continue;
            }
            body.push(atom);
          }
          if (this.mode === "text") {
            this.formLigatures(body);
          }
          return this.handleInfixNodes(body);
        };
        _proto.handleInfixNodes = function handleInfixNodes(body) {
          var overIndex = -1;
          var funcName;
          for (var i3 = 0; i3 < body.length; i3++) {
            if (body[i3].type === "infix") {
              if (overIndex !== -1) {
                throw new src_ParseError("only one infix operator per group", body[i3].token);
              }
              overIndex = i3;
              funcName = body[i3].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            var numerNode;
            var denomNode;
            var numerBody = body.slice(0, overIndex);
            var denomBody = body.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            var node5;
            if (funcName === "\\\\abovefrac") {
              node5 = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
            } else {
              node5 = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node5];
          } else {
            return body;
          }
        };
        _proto.handleSupSubscript = function handleSupSubscript(name) {
          var symbolToken = this.fetch();
          var symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          var group = this.parseGroup(name);
          if (!group) {
            throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group;
        };
        _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text3) {
          var textordArray = [];
          for (var i3 = 0; i3 < text3.length; i3++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text3[i3]
            });
          }
          var textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          var colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        };
        _proto.parseAtom = function parseAtom(breakOnTokenText) {
          var base2 = this.parseGroup("atom", breakOnTokenText);
          if (this.mode === "text") {
            return base2;
          }
          var superscript;
          var subscript;
          while (true) {
            this.consumeSpaces();
            var lex = this.fetch();
            if (lex.text === "\\limits" || lex.text === "\\nolimits") {
              if (base2 && base2.type === "op") {
                var limits = lex.text === "\\limits";
                base2.limits = limits;
                base2.alwaysHandleSupSub = true;
              } else if (base2 && base2.type === "operatorname") {
                if (base2.alwaysHandleSupSub) {
                  base2.limits = lex.text === "\\limits";
                }
              } else {
                throw new src_ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if (lex.text === "^") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex.text === "_") {
              if (subscript) {
                throw new src_ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex.text === "'") {
              if (superscript) {
                throw new src_ParseError("Double superscript", lex);
              }
              var prime = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              var primes = [prime];
              this.consume();
              while (this.fetch().text === "'") {
                primes.push(prime);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes
              };
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base: base2,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base2;
          }
        };
        _proto.parseFunction = function parseFunction(breakOnTokenText, name) {
          var token = this.fetch();
          var func = token.text;
          var funcData = src_functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
          }
          var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        };
        _proto.callFunction = function callFunction(name, args, optArgs, token, breakOnTokenText) {
          var context = {
            funcName: name,
            parser: this,
            token,
            breakOnTokenText
          };
          var func = src_functions[name];
          if (func && func.handler) {
            return func.handler(context, args, optArgs);
          } else {
            throw new src_ParseError("No function handler for " + name);
          }
        };
        _proto.parseArguments = function parseArguments(func, funcData) {
          var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          var args = [];
          var optArgs = [];
          for (var i3 = 0; i3 < totalArgs; i3++) {
            var argType = funcData.argTypes && funcData.argTypes[i3];
            var isOptional = i3 < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || funcData.type === "sqrt" && i3 === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new src_ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        };
        _proto.parseGroupOfType = function parseGroupOfType(name, type, optional) {
          switch (type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox": {
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
              } : null;
            }
            case "raw": {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
            case "primitive": {
              if (optional) {
                throw new src_ParseError("A primitive argument cannot be optional");
              }
              var _group = this.parseGroup(name);
              if (_group == null) {
                throw new src_ParseError("Expected group as " + name, this.fetch());
              }
              return _group;
            }
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional);
            default:
              throw new src_ParseError("Unknown group type as " + name, this.fetch());
          }
        };
        _proto.consumeSpaces = function consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        };
        _proto.parseStringGroup = function parseStringGroup(modeName, optional) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str;
          return argToken;
        };
        _proto.parseRegexGroup = function parseRegexGroup(regex2, modeName) {
          var firstToken = this.fetch();
          var lastToken = firstToken;
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex2.test(str + nextToken.text)) {
            lastToken = nextToken;
            str += lastToken.text;
            this.consume();
          }
          if (str === "") {
            throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str);
        };
        _proto.parseColorGroup = function parseColorGroup(optional) {
          var res2 = this.parseStringGroup("color", optional);
          if (res2 == null) {
            return null;
          }
          var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res2.text);
          if (!match) {
            throw new src_ParseError("Invalid color: '" + res2.text + "'", res2);
          }
          var color2 = match[0];
          if (/^[0-9a-f]{6}$/i.test(color2)) {
            color2 = "#" + color2;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color: color2
          };
        };
        _proto.parseSizeGroup = function parseSizeGroup(optional) {
          var res2;
          var isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional && this.gullet.future().text !== "{") {
            res2 = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res2 = this.parseStringGroup("size", optional);
          }
          if (!res2) {
            return null;
          }
          if (!optional && res2.text.length === 0) {
            res2.text = "0pt";
            isBlank = true;
          }
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res2.text);
          if (!match) {
            throw new src_ParseError("Invalid size: '" + res2.text + "'", res2);
          }
          var data = {
            number: +(match[1] + match[2]),
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new src_ParseError("Invalid unit: '" + data.unit + "'", res2);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data,
            isBlank
          };
        };
        _proto.parseUrlGroup = function parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          var res2 = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res2 == null) {
            return null;
          }
          var url = res2.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        };
        _proto.parseArgumentGroup = function parseArgumentGroup(optional, mode) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          var result2 = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result2;
        };
        _proto.parseGroup = function parseGroup(name, breakOnTokenText) {
          var firstToken = this.fetch();
          var text3 = firstToken.text;
          var result2;
          if (text3 === "{" || text3 === "\\begingroup") {
            this.consume();
            var groupEnd = text3 === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, groupEnd);
            var lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result2 = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation.range(firstToken, lastToken),
              body: expression,
              semisimple: text3 === "\\begingroup" || void 0
            };
          } else {
            result2 = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result2 == null && text3[0] === "\\" && !implicitCommands.hasOwnProperty(text3)) {
              if (this.settings.throwOnError) {
                throw new src_ParseError("Undefined control sequence: " + text3, firstToken);
              }
              result2 = this.formatUnsupportedCmd(text3);
              this.consume();
            }
          }
          return result2;
        };
        _proto.formLigatures = function formLigatures(group) {
          var n2 = group.length - 1;
          for (var i3 = 0; i3 < n2; ++i3) {
            var a2 = group[i3];
            var v2 = a2.text;
            if (v2 === "-" && group[i3 + 1].text === "-") {
              if (i3 + 1 < n2 && group[i3 + 2].text === "-") {
                group.splice(i3, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a2, group[i3 + 2]),
                  text: "---"
                });
                n2 -= 2;
              } else {
                group.splice(i3, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a2, group[i3 + 1]),
                  text: "--"
                });
                n2 -= 1;
              }
            }
            if ((v2 === "'" || v2 === "`") && group[i3 + 1].text === v2) {
              group.splice(i3, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a2, group[i3 + 1]),
                text: v2 + v2
              });
              n2 -= 1;
            }
          }
        };
        _proto.parseSymbol = function parseSymbol() {
          var nucleus = this.fetch();
          var text3 = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text3)) {
            this.consume();
            var arg = text3.slice(5);
            var star3 = arg.charAt(0) === "*";
            if (star3) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star: star3
            };
          }
          if (unicodeSymbols.hasOwnProperty(text3[0]) && !src_symbols[this.mode][text3[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text3[0] + '" used in math mode', nucleus);
            }
            text3 = unicodeSymbols[text3[0]] + text3.substr(1);
          }
          var match = combiningDiacriticalMarksEndRegex.exec(text3);
          if (match) {
            text3 = text3.substring(0, match.index);
            if (text3 === "i") {
              text3 = "\u0131";
            } else if (text3 === "j") {
              text3 = "\u0237";
            }
          }
          var symbol;
          if (src_symbols[this.mode][text3]) {
            if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text3) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text3[0] + '" used in math mode', nucleus);
            }
            var group = src_symbols[this.mode][text3].group;
            var loc = SourceLocation.range(nucleus);
            var s2;
            if (ATOMS.hasOwnProperty(group)) {
              var family2 = group;
              s2 = {
                type: "atom",
                mode: this.mode,
                family: family2,
                loc,
                text: text3
              };
            } else {
              s2 = {
                type: group,
                mode: this.mode,
                loc,
                text: text3
              };
            }
            symbol = s2;
          } else if (text3.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint(text3.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text3[0] + '"' + (" (" + text3.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text3[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(nucleus),
              text: text3
            };
          } else {
            return null;
          }
          this.consume();
          if (match) {
            for (var i3 = 0; i3 < match[0].length; i3++) {
              var accent2 = match[0][i3];
              if (!unicodeAccents[accent2]) {
                throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
              }
              var command = unicodeAccents[accent2][this.mode];
              if (!command) {
                throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                base: symbol
              };
            }
          }
          return symbol;
        };
        return Parser2;
      }();
      Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      var parseTree = function parseTree2(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        var parser2 = new Parser(toParse, settings);
        delete parser2.gullet.macros.current["\\df@tag"];
        var tree = parser2.parse();
        delete parser2.gullet.macros.current["\\current@color"];
        delete parser2.gullet.macros.current["\\color"];
        if (parser2.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new src_ParseError("\\tag works only in display equations");
          }
          parser2.gullet.feed("\\df@tag");
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser2.parse()
          }];
        }
        return tree;
      };
      var src_parseTree = parseTree;
      var render = function render2(expression, baseNode, options) {
        baseNode.textContent = "";
        var node5 = renderToDomTree(expression, options).toNode();
        baseNode.appendChild(node5);
      };
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
          render = function render2() {
            throw new src_ParseError("KaTeX doesn't work in quirks mode.");
          };
        }
      }
      var renderToString = function renderToString2(expression, options) {
        var markup = renderToDomTree(expression, options).toMarkup();
        return markup;
      };
      var generateParseTree = function generateParseTree2(expression, options) {
        var settings = new Settings(options);
        return src_parseTree(expression, settings);
      };
      var renderError = function renderError2(error, expression, options) {
        if (options.throwOnError || !(error instanceof src_ParseError)) {
          throw error;
        }
        var node5 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        node5.setAttribute("title", error.toString());
        node5.setAttribute("style", "color:" + options.errorColor);
        return node5;
      };
      var renderToDomTree = function renderToDomTree2(expression, options) {
        var settings = new Settings(options);
        try {
          var tree = src_parseTree(expression, settings);
          return buildTree2(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
        var settings = new Settings(options);
        try {
          var tree = src_parseTree(expression, settings);
          return buildHTMLTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      var katex2 = {
        version: "0.13.13",
        render,
        renderToString,
        ParseError: src_ParseError,
        __parse: generateParseTree,
        __renderToDomTree: renderToDomTree,
        __renderToHTMLTree: renderToHTMLTree,
        __setFontMetrics: setFontMetrics,
        __defineSymbol: defineSymbol,
        __defineMacro: defineMacro,
        __domTree: {
          Span,
          Anchor,
          SymbolNode,
          SvgNode,
          PathNode,
          LineNode
        }
      };
      var katex_webpack = katex2;
      __webpack_exports__ = __webpack_exports__.default;
      return __webpack_exports__;
    }();
  });
})(katex$1);
var katex = katex$1.exports;
function collapseMathCmd(outerView, dir, requireOnBorder, requireEmptySelection = true) {
  return (innerState, dispatch3) => {
    let outerState = outerView.state;
    let { to: outerTo, from: outerFrom } = outerState.selection;
    let { to: innerTo, from: innerFrom } = innerState.selection;
    if (requireEmptySelection && innerTo !== innerFrom) {
      return false;
    }
    let currentPos = dir > 0 ? innerTo : innerFrom;
    if (requireOnBorder) {
      let nodeSize2 = innerState.doc.nodeSize - 2;
      if (dir > 0 && currentPos < nodeSize2) {
        return false;
      }
      if (dir < 0 && currentPos > 0) {
        return false;
      }
    }
    if (dispatch3) {
      let targetPos = dir > 0 ? outerTo : outerFrom;
      outerView.dispatch(outerState.tr.setSelection(TextSelection.create(outerState.doc, targetPos)));
      outerView.focus();
    }
    return true;
  };
}
class MathView {
  constructor(node5, view, getPos, options = {}, mathPluginKey, onDestroy) {
    this._node = node5;
    this._outerView = view;
    this._getPos = getPos;
    this._onDestroy = onDestroy && onDestroy.bind(this);
    this._mathPluginKey = mathPluginKey;
    this.cursorSide = "start";
    this._isEditing = false;
    this._katexOptions = Object.assign({ globalGroup: true, throwOnError: false }, options.katexOptions);
    this._tagName = options.tagName || this._node.type.name.replace("_", "-");
    this.dom = document.createElement(this._tagName);
    this.dom.classList.add("math-node");
    this._mathRenderElt = document.createElement("span");
    this._mathRenderElt.textContent = "";
    this._mathRenderElt.classList.add("math-render");
    this.dom.appendChild(this._mathRenderElt);
    this._mathSrcElt = document.createElement("span");
    this._mathSrcElt.classList.add("math-src");
    this.dom.appendChild(this._mathSrcElt);
    this.dom.addEventListener("click", () => this.ensureFocus());
    this.renderMath();
  }
  destroy() {
    this.closeEditor(false);
    if (this._mathRenderElt) {
      this._mathRenderElt.remove();
      delete this._mathRenderElt;
    }
    if (this._mathSrcElt) {
      this._mathSrcElt.remove();
      delete this._mathSrcElt;
    }
    this.dom.remove();
  }
  ensureFocus() {
    if (this._innerView && this._outerView.hasFocus()) {
      this._innerView.focus();
    }
  }
  update(node5, decorations) {
    if (!node5.sameMarkup(this._node))
      return false;
    this._node = node5;
    if (this._innerView) {
      let state = this._innerView.state;
      let start4 = node5.content.findDiffStart(state.doc.content);
      if (start4 != null) {
        let diff = node5.content.findDiffEnd(state.doc.content);
        if (diff) {
          let { a: endA, b: endB } = diff;
          let overlap = start4 - Math.min(endA, endB);
          if (overlap > 0) {
            endA += overlap;
            endB += overlap;
          }
          this._innerView.dispatch(state.tr.replace(start4, endB, node5.slice(start4, endA)).setMeta("fromOutside", true));
        }
      }
    }
    if (!this._isEditing) {
      this.renderMath();
    }
    return true;
  }
  updateCursorPos(state) {
    const pos = this._getPos();
    const size2 = this._node.nodeSize;
    const inPmSelection = state.selection.from < pos + size2 && pos < state.selection.to;
    if (!inPmSelection) {
      this.cursorSide = pos < state.selection.from ? "end" : "start";
    }
  }
  selectNode() {
    if (!this._outerView.editable) {
      return;
    }
    this.dom.classList.add("ProseMirror-selectednode");
    if (!this._isEditing) {
      this.openEditor();
    }
  }
  deselectNode() {
    this.dom.classList.remove("ProseMirror-selectednode");
    if (this._isEditing) {
      this.closeEditor();
    }
  }
  stopEvent(event) {
    return this._innerView !== void 0 && event.target !== void 0 && this._innerView.dom.contains(event.target);
  }
  ignoreMutation() {
    return true;
  }
  renderMath() {
    if (!this._mathRenderElt) {
      return;
    }
    let content3 = this._node.content.content;
    let texString = "";
    if (content3.length > 0 && content3[0].textContent !== null) {
      texString = content3[0].textContent.trim();
    }
    if (texString.length < 1) {
      this.dom.classList.add("empty-math");
      while (this._mathRenderElt.firstChild) {
        this._mathRenderElt.firstChild.remove();
      }
      return;
    } else {
      this.dom.classList.remove("empty-math");
    }
    try {
      katex.render(texString, this._mathRenderElt, this._katexOptions);
      this._mathRenderElt.classList.remove("parse-error");
      this.dom.setAttribute("title", "");
    } catch (err2) {
      if (err2 instanceof katex$1.exports.ParseError) {
        console.error(err2);
        this._mathRenderElt.classList.add("parse-error");
        this.dom.setAttribute("title", err2.toString());
      } else {
        throw err2;
      }
    }
  }
  dispatchInner(tr) {
    if (!this._innerView) {
      return;
    }
    let { state, transactions } = this._innerView.state.applyTransaction(tr);
    this._innerView.updateState(state);
    if (!tr.getMeta("fromOutside")) {
      let outerTr = this._outerView.state.tr, offsetMap = StepMap.offset(this._getPos() + 1);
      for (let i2 = 0; i2 < transactions.length; i2++) {
        let steps = transactions[i2].steps;
        for (let j2 = 0; j2 < steps.length; j2++) {
          let mapped = steps[j2].map(offsetMap);
          if (!mapped) {
            throw Error("step discarded!");
          }
          outerTr.step(mapped);
        }
      }
      if (outerTr.docChanged)
        this._outerView.dispatch(outerTr);
    }
  }
  openEditor() {
    var _a;
    if (this._innerView) {
      throw Error("inner view should not exist!");
    }
    this._innerView = new EditorView$1(this._mathSrcElt, {
      state: EditorState.create({
        doc: this._node,
        plugins: [keymap$1({
          "Tab": (state, dispatch3) => {
            if (dispatch3) {
              dispatch3(state.tr.insertText("	"));
            }
            return true;
          },
          "Backspace": chainCommands(deleteSelection, (state, dispatch3, tr_inner) => {
            if (!state.selection.empty) {
              return false;
            }
            if (this._node.textContent.length > 0) {
              return false;
            }
            this._outerView.dispatch(this._outerView.state.tr.insertText(""));
            this._outerView.focus();
            return true;
          }),
          "Ctrl-Backspace": (state, dispatch3, tr_inner) => {
            this._outerView.dispatch(this._outerView.state.tr.insertText(""));
            this._outerView.focus();
            return true;
          },
          "Enter": chainCommands(newlineInCode, collapseMathCmd(this._outerView, 1, false)),
          "Ctrl-Enter": collapseMathCmd(this._outerView, 1, false),
          "ArrowLeft": collapseMathCmd(this._outerView, -1, true),
          "ArrowRight": collapseMathCmd(this._outerView, 1, true),
          "ArrowUp": collapseMathCmd(this._outerView, -1, true),
          "ArrowDown": collapseMathCmd(this._outerView, 1, true)
        })]
      }),
      dispatchTransaction: this.dispatchInner.bind(this)
    });
    let innerState = this._innerView.state;
    this._innerView.focus();
    let maybePos = (_a = this._mathPluginKey.getState(this._outerView.state)) === null || _a === void 0 ? void 0 : _a.prevCursorPos;
    if (maybePos === null || maybePos === void 0) {
      console.error("[prosemirror-math] Error:  Unable to fetch math plugin state from key.");
    }
    let prevCursorPos = maybePos !== null && maybePos !== void 0 ? maybePos : 0;
    let innerPos = prevCursorPos <= this._getPos() ? 0 : this._node.nodeSize - 2;
    this._innerView.dispatch(innerState.tr.setSelection(TextSelection.create(innerState.doc, innerPos)));
    this._isEditing = true;
  }
  closeEditor(render = true) {
    if (this._innerView) {
      this._innerView.destroy();
      this._innerView = void 0;
    }
    if (render) {
      this.renderMath();
    }
    this._isEditing = false;
  }
}
const MATH_PLUGIN_KEY = new PluginKey("prosemirror-math");
function createMathView(displayMode) {
  return (node5, view, getPos) => {
    let pluginState = MATH_PLUGIN_KEY.getState(view.state);
    if (!pluginState) {
      throw new Error("no math plugin!");
    }
    let nodeViews = pluginState.activeNodeViews;
    let nodeView2 = new MathView(node5, view, getPos, { katexOptions: { displayMode, macros: pluginState.macros } }, MATH_PLUGIN_KEY, () => {
      nodeViews.splice(nodeViews.indexOf(nodeView2));
    });
    nodeViews.push(nodeView2);
    return nodeView2;
  };
}
let mathPluginSpec = {
  key: MATH_PLUGIN_KEY,
  state: {
    init(config2, instance) {
      return {
        macros: {},
        activeNodeViews: [],
        prevCursorPos: 0
      };
    },
    apply(tr, value, oldState, newState) {
      return {
        activeNodeViews: value.activeNodeViews,
        macros: value.macros,
        prevCursorPos: oldState.selection.from
      };
    }
  },
  props: {
    nodeViews: {
      "math_inline": createMathView(false),
      "math_display": createMathView(true)
    }
  }
};
const mathPlugin = new Plugin(mathPluginSpec);
const mathBackspaceCmd = (state, dispatch3) => {
  let { $from } = state.selection;
  let nodeBefore = $from.nodeBefore;
  if (!nodeBefore) {
    return false;
  }
  if (nodeBefore.type.name == "math_inline") {
    let index3 = $from.index($from.depth);
    let $beforePos = state.doc.resolve($from.posAtIndex(index3 - 1));
    if (dispatch3) {
      dispatch3(state.tr.setSelection(new NodeSelection($beforePos)));
    }
    return true;
  } else if (nodeBefore.type.name == "math_block") {
    return false;
  }
  return false;
};
const REGEX_INLINE_MATH_DOLLARS = /\$(.+)\$/;
(() => {
  try {
    return new RegExp("(?<!\\\\)\\$(.+)(?<!\\\\)\\$");
  } catch (e3) {
    return REGEX_INLINE_MATH_DOLLARS;
  }
})();
const REGEX_BLOCK_MATH_DOLLARS = /\$\$\s+$/;
function makeInlineMathInputRule(pattern, nodeType2, getAttrs) {
  return new InputRule(pattern, (state, match, start4, end3) => {
    let $start = state.doc.resolve(start4);
    let index3 = $start.index();
    let $end = state.doc.resolve(end3);
    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.parent.canReplaceWith(index3, $end.index(), nodeType2)) {
      return null;
    }
    return state.tr.replaceRangeWith(start4, end3, nodeType2.create(attrs, nodeType2.schema.text(match[1])));
  });
}
function makeBlockMathInputRule(pattern, nodeType2, getAttrs) {
  return new InputRule(pattern, (state, match, start4, end3) => {
    let $start = state.doc.resolve(start4);
    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType2))
      return null;
    let tr = state.tr.delete(start4, end3).setBlockType(start4, start4, nodeType2, attrs);
    return tr.setSelection(NodeSelection.create(tr.doc, tr.mapping.map($start.pos - 1)));
  });
}
const checkSelection = (arg) => {
  let { from: from5, to: to2 } = arg.selection;
  let content3 = arg.selection.content().content;
  let result2 = [];
  content3.descendants((node5, pos, parent) => {
    if (node5.type.name == "text") {
      return false;
    }
    if (node5.type.name.startsWith("math_")) {
      result2.push({
        start: Math.max(from5 + pos - 1, 0),
        end: from5 + pos + node5.nodeSize - 1
      });
      return false;
    }
    return true;
  });
  return DecorationSet$1.create(arg.doc, result2.map(({ start: start4, end: end3 }) => Decoration$1.node(start4, end3, { class: "math-select" })));
};
const mathSelectPlugin = new Plugin({
  state: {
    init(config2, partialState) {
      return checkSelection(partialState);
    },
    apply(tr, oldState) {
      if (!tr.selection || !tr.selectionSet) {
        return oldState;
      }
      let sel = checkSelection(tr);
      return sel;
    }
  },
  props: {
    decorations: (state) => {
      return mathSelectPlugin.getState(state);
    }
  }
});
class ProseMirrorTextSerializer {
  constructor(fns, base2) {
    this.nodes = Object.assign(Object.assign({}, base2 === null || base2 === void 0 ? void 0 : base2.nodes), fns.nodes);
    this.marks = Object.assign(Object.assign({}, base2 === null || base2 === void 0 ? void 0 : base2.marks), fns.marks);
  }
  serializeFragment(fragment) {
    let blockSeparator = "\n\n";
    let leafText = void 0;
    let text3 = "";
    let separated = true;
    let from5 = 0;
    let to2 = fragment.size;
    fragment.nodesBetween(from5, to2, (node5, pos) => {
      var _a;
      let serialized = this.serializeNode(node5);
      if (serialized !== null) {
        text3 += serialized;
        return false;
      }
      if (node5.isText) {
        text3 += ((_a = node5.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from5, pos) - pos, to2 - pos)) || "";
        separated = !blockSeparator;
      } else if (node5.isLeaf && leafText) {
        text3 += leafText;
        separated = !blockSeparator;
      } else if (!separated && node5.isBlock) {
        text3 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text3;
  }
  serializeSlice(slice5) {
    return this.serializeFragment(slice5.content);
  }
  serializeNode(node5) {
    let nodeSerializer = this.nodes[node5.type.name];
    if (nodeSerializer !== void 0) {
      return nodeSerializer(node5);
    } else {
      return null;
    }
  }
}
new ProseMirrorTextSerializer({
  nodes: {
    "math_inline": (node5) => `$${node5.textContent}$`,
    "math_display": (node5) => `

$$
${node5.textContent}
$$`
  }
});
var syntax$1 = {};
var tokenizeMathFlow = {};
tokenizeMathFlow.tokenize = tokenizeMathFenced;
tokenizeMathFlow.concrete = true;
var prefixSize = prefixSize_1;
var createSpace = factorySpace$h;
function tokenizeMathFenced(effects, ok3, nok) {
  var self2 = this;
  var initialPrefix = prefixSize(this.events, "linePrefix");
  var sizeOpen = 0;
  return start4;
  function start4(code2) {
    if (code2 !== 36)
      throw new Error("expected `$`");
    effects.enter("mathFlow");
    effects.enter("mathFlowFence");
    effects.enter("mathFlowFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("mathFlowFenceSequence");
    return sizeOpen < 2 ? nok(code2) : createSpace(effects, metaOpen, "whitespace")(code2);
  }
  function metaOpen(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      return openAfter(code2);
    }
    effects.enter("mathFlowFenceMeta");
    effects.enter("chunkString", { contentType: "string" });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      effects.exit("chunkString");
      effects.exit("mathFlowFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 36)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("mathFlowFence");
    return self2.interrupt ? ok3(code2) : content3(code2);
  }
  function content3(code2) {
    if (code2 === null) {
      return after2(code2);
    }
    if (code2 === -5 || code2 === -4 || code2 === -3) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return effects.attempt({ tokenize: tokenizeClosingFence, partial: true }, after2, initialPrefix ? createSpace(effects, content3, "linePrefix", initialPrefix + 1) : content3);
    }
    effects.enter("mathFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
      effects.exit("mathFlowValue");
      return content3(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after2(code2) {
    effects.exit("mathFlow");
    return ok3(code2);
  }
  function tokenizeClosingFence(effects2, ok4, nok2) {
    var size2 = 0;
    return createSpace(effects2, closingPrefixAfter, "linePrefix", 4);
    function closingPrefixAfter(code2) {
      effects2.enter("mathFlowFence");
      effects2.enter("mathFlowFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === 36) {
        effects2.consume(code2);
        size2++;
        return closingSequence;
      }
      if (size2 < sizeOpen)
        return nok2(code2);
      effects2.exit("mathFlowFenceSequence");
      return createSpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
        effects2.exit("mathFlowFence");
        return ok4(code2);
      }
      return nok2(code2);
    }
  }
}
var tokenizeMathText$1 = {};
tokenizeMathText$1.tokenize = tokenizeMathText;
tokenizeMathText$1.resolve = resolveMathText;
tokenizeMathText$1.previous = previous;
function resolveMathText(events) {
  var tailExitIndex = events.length - 4;
  var headEnterIndex = 3;
  var index3;
  var enter2;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events[index3][1].type === "mathTextData") {
        events[tailExitIndex][1].type = "mathTextPadding";
        events[headEnterIndex][1].type = "mathTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index3 !== tailExitIndex && events[index3][1].type !== "lineEnding") {
        enter2 = index3;
      }
    } else if (index3 === tailExitIndex || events[index3][1].type === "lineEnding") {
      events[enter2][1].type = "mathTextData";
      if (index3 !== enter2 + 2) {
        events[enter2][1].end = events[index3 - 1][1].end;
        events.splice(enter2 + 2, index3 - enter2 - 2);
        tailExitIndex -= index3 - enter2 - 2;
        index3 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeMathText(effects, ok3, nok) {
  var self2 = this;
  var sizeOpen = 0;
  var size2;
  var token;
  return start4;
  function start4(code2) {
    if (code2 !== 36)
      throw new Error("expected `$`");
    if (!previous.call(self2, self2.previous)) {
      throw new Error("expected correct previous");
    }
    effects.enter("mathText");
    effects.enter("mathTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("mathTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 36) {
      token = effects.enter("mathTextSequence");
      size2 = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (code2 === -5 || code2 === -4 || code2 === -3) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("mathTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 36 || code2 === -5 || code2 === -4 || code2 === -3) {
      effects.exit("mathTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data;
  }
  function closingSequence(code2) {
    if (code2 === 36) {
      effects.consume(code2);
      size2++;
      return closingSequence;
    }
    if (size2 === sizeOpen) {
      effects.exit("mathTextSequence");
      effects.exit("mathText");
      return ok3(code2);
    }
    token.type = "mathTextData";
    return data(code2);
  }
}
syntax$1.flow = { 36: tokenizeMathFlow };
syntax$1.text = { 36: tokenizeMathText$1 };
var micromarkExtensionMath = syntax$1;
var fromMarkdown$1 = {};
fromMarkdown$1.enter = {
  mathFlow: enterMathFlow,
  mathFlowFenceMeta: enterMathFlowMeta,
  mathText: enterMathText
};
fromMarkdown$1.exit = {
  mathFlow: exitMathFlow,
  mathFlowFence: exitMathFlowFence,
  mathFlowFenceMeta: exitMathFlowMeta,
  mathFlowValue: exitMathData,
  mathText: exitMathText,
  mathTextData: exitMathData
};
function enterMathFlow(token) {
  this.enter({
    type: "math",
    meta: null,
    value: "",
    data: {
      hName: "div",
      hProperties: { className: ["math", "math-display"] },
      hChildren: [{ type: "text", value: "" }]
    }
  }, token);
}
function enterMathFlowMeta() {
  this.buffer();
}
function exitMathFlowMeta() {
  var data = this.resume();
  this.stack[this.stack.length - 1].meta = data;
}
function exitMathFlowFence() {
  if (this.getData("mathFlowInside"))
    return;
  this.buffer();
  this.setData("mathFlowInside", true);
}
function exitMathFlow(token) {
  var data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
  var node5 = this.exit(token);
  node5.value = data;
  node5.data.hChildren[0].value = data;
  this.setData("mathFlowInside");
}
function enterMathText(token) {
  this.enter({
    type: "inlineMath",
    value: "",
    data: {
      hName: "span",
      hProperties: { className: ["math", "math-inline"] },
      hChildren: [{ type: "text", value: "" }]
    }
  }, token);
  this.buffer();
}
function exitMathText(token) {
  var data = this.resume();
  var node5 = this.exit(token);
  node5.value = data;
  node5.data.hChildren[0].value = data;
}
function exitMathData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
var toMarkdown$1 = {};
toMarkdown$1.unsafe = [
  { character: "\r", inConstruct: ["mathFlowMeta"] },
  { character: "\r", inConstruct: ["mathFlowMeta"] },
  { character: "$", inConstruct: ["mathFlowMeta", "phrasing"] },
  { atBreak: true, character: "$", after: "\\$" }
];
toMarkdown$1.handlers = { math: math$2, inlineMath };
inlineMath.peek = inlineMathPeek;
var repeat = repeatString;
var streak = longestStreak_1;
var safe = safe_1;
function math$2(node5, _2, context) {
  var raw = node5.value || "";
  var fence = repeat("$", Math.max(streak(raw, "$") + 1, 2));
  var exit2 = context.enter("mathFlow");
  var value = fence;
  var subexit;
  if (node5.meta) {
    subexit = context.enter("mathFlowMeta");
    value += safe(context, node5.meta, { before: "$", after: " ", encode: ["$"] });
    subexit();
  }
  value += "\n";
  if (raw) {
    value += raw + "\n";
  }
  value += fence;
  exit2();
  return value;
}
function inlineMath(node5) {
  var value = node5.value || "";
  var size2 = 1;
  var pad = "";
  var sequence;
  while (new RegExp("(^|[^$])" + repeat("\\$", size2) + "([^$]|$)").test(value)) {
    size2++;
  }
  if (/[^ \r\n]/.test(value) && (/[ \r\n$]/.test(value.charAt(0)) || /[ \r\n$]/.test(value.charAt(value.length - 1)))) {
    pad = " ";
  }
  sequence = repeat("$", size2);
  return sequence + pad + value + pad + sequence;
}
function inlineMathPeek() {
  return "$";
}
var syntax = micromarkExtensionMath;
var fromMarkdown = fromMarkdown$1;
var toMarkdown = toMarkdown$1;
var warningIssued;
var remarkMath = math$1;
function math$1() {
  var data = this.data();
  if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
    warningIssued = true;
    console.warn("[remark-math] Warning: please upgrade to remark 13 to use this plugin");
  }
  add3("micromarkExtensions", syntax);
  add3("fromMarkdownExtensions", fromMarkdown);
  add3("toMarkdownExtensions", toMarkdown);
  function add3(field, value) {
    if (data[field])
      data[field].push(value);
    else
      data[field] = [value];
  }
}
const mathInline = createNode$1(() => {
  const id2 = "math_inline";
  return {
    id: id2,
    schema: {
      group: "inline math",
      content: "text*",
      inline: true,
      atom: true,
      parseDOM: [{ tag: "math-inline" }],
      toDOM: () => ["math-inline", { class: "math-node" }, 0]
    },
    parser: {
      match: (node5) => node5.type === "inlineMath",
      runner: (state, node5, type) => {
        state.openNode(type);
        state.addText(node5.value);
        state.closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        let text3 = "";
        node5.forEach((n2) => {
          text3 += n2.text;
        });
        state.addNode("inlineMath", void 0, text3);
      }
    },
    inputRules: (nodeType2) => [makeInlineMathInputRule(REGEX_INLINE_MATH_DOLLARS, nodeType2)]
  };
});
const mathDisplay = createNode$1(() => {
  const id2 = "math_display";
  return {
    id: id2,
    schema: {
      group: "block math",
      content: "text*",
      atom: true,
      code: true,
      parseDOM: [{ tag: "math-display" }],
      toDOM: () => ["math-display", { class: "math-node" }, 0]
    },
    parser: {
      match: (node5) => node5.type === "math",
      runner: (state, node5, type) => {
        state.openNode(type);
        state.addText(node5.value);
        state.closeNode();
      }
    },
    serializer: {
      match: (node5) => node5.type.name === id2,
      runner: (state, node5) => {
        let text3 = "";
        node5.forEach((n2) => {
          text3 += n2.text;
        });
        state.addNode("math", void 0, text3);
      }
    },
    inputRules: (nodeType2) => [makeBlockMathInputRule(REGEX_BLOCK_MATH_DOLLARS, nodeType2)]
  };
});
const nodes = AtomList.create([mathInline(), mathDisplay()]);
const keys = keymap$1({
  Backspace: chainCommands(deleteSelection, mathBackspaceCmd, joinBackward, selectNodeBackward)
});
const math = [remarkPluginFactory(remarkMath), prosePluginFactory([mathPlugin, keys]), ...nodes];
export { Editor as E, emoji as a, listener as b, commonmark as c, defaultValueCtx as d, editorViewOptionsCtx as e, clipboard$1 as f, tooltip as g, history as h, listenerCtx as l, math as m, slash as s, table as t };
