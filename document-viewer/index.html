<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>Document Viewer for TagSpaces</title>
    <link rel="stylesheet" href="../libs/bootstrap5/bootstrap.min.css" />
    <link rel="stylesheet" href="../common/common.css" />
    <style>
      html,
      body {
        overflow: auto;
        background-color: var(--default-background-color);
      }
      #documentContent {
        height: 100%;
        padding: 20px;
        max-width: 1280px;
        width: 100%;
        margin: 0 auto;
        font-size: var(--default-text-size);
        color: var(--text-color);
        background-color: var(--background-color);
        /* box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); */
      }
      #documentContent img {
        max-width: 100%;
        height: auto;
      }
      .odt-table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
      }
      .odt-table td {
        border: 1px solid #ccc;
        padding: 8px;
      }
    </style>
    <script src="../libs/jszip/jszip.min.js"></script>
    <script src="../libs/jszip-utils/jszip-utils.min.js"></script>
    <script src="libs/mammoth/mammoth.browser.min.js"></script>
    <script src="../libs/mark.js/mark.min.js"></script>
    <script src="../libs/dompurify/dist/purify.min.js"></script>
    <script src="../libs/bootstrap5/bootstrap.bundle.min.js"></script>
    <script src="../libs/i18next/i18next.min.js"></script>
    <script src="../common/common.js"></script>
    <script>
      const filePath = getParameterByName('file');
      let locale = getParameterByName('locale') || 'en';
      if (locale === 'en') locale = 'en_US';
      const encrypted = getParameterByName('encrypted');

      document.addEventListener('readystatechange', () => {
        if (document.readyState === 'complete') {
          insertAboutDialog(
            'https://docs.tagspaces.org/extensions/document-viewer',
          );
          insertPrintMenuItem();
          insertToggleFindMenuItem();
          insertZoomContentMenuItem();
          insertExportAsHTMLFunctionality();
          initI18N(locale, 'ns.extension.json');

          if (encrypted) {
            document.getElementById('encyptedMessage').style.display = 'block';
          } else {
            loadDocument();
          }

          setupZoomLogic();
        }
      });

      function loadDocument() {
        const isOdt = extractFileExtension(filePath) === '.odt';

        JSZipUtils.getBinaryContent(filePath, async (err, data) => {
          if (err) {
            console.error('Error loading file:', err);
            return;
          }

          if (isOdt) {
            renderODT(data);
          } else {
            // Existing DOCX logic with Mammoth
            const options = {
              convertImage: mammoth.images.imgElement((image) => {
                return image.read('base64').then((imageBuffer) => {
                  return {
                    src: 'data:' + image.contentType + ';base64,' + imageBuffer,
                  };
                });
              }),
            };
            mammoth
              .convertToHtml({ arrayBuffer: data }, options)
              .then(displayDocument)
              .done();
          }
        });
      }

      let odtStyleMap = {};

      /**
       * Leverages JSZip to read content.xml
       */
      async function renderODT(data) {
        try {
          const zip = await JSZip.loadAsync(data);
          const contentXml = await zip.file('content.xml').async('string');
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(contentXml, 'text/xml');

          // 1. Pre-parse styles to find bold/italic definitions
          odtStyleMap = parseOdtStyles(xmlDoc);

          let html = '';
          const body = xmlDoc.getElementsByTagName('office:text')[0];

          if (body) {
            for (let node of body.childNodes) {
              html += await processOdtNode(node, zip);
            }
          }

          displayDocument({ value: html });
        } catch (e) {
          console.error('ODT parsing failed:', e);
          document.getElementById('documentContent').innerHTML =
            'Failed to parse ODT file.';
        }
      }

      /**
       * Scans <office:automatic-styles> to create a map of text formatting
       */
      function parseOdtStyles(xmlDoc) {
        const styleMap = {};
        const autoStyles = xmlDoc.getElementsByTagName(
          'office:automatic-styles',
        )[0];
        if (!autoStyles) return styleMap;

        const styles = autoStyles.getElementsByTagName('style:style');
        for (let style of styles) {
          const name = style.getAttribute('style:name');
          const textProps = style.getElementsByTagName(
            'style:text-properties',
          )[0];

          if (textProps) {
            styleMap[name] = {
              bold: textProps.getAttribute('fo:font-weight') === 'bold',
              italic: textProps.getAttribute('fo:font-style') === 'italic',
              underline:
                textProps.getAttribute('style:text-underline-style') ===
                  'solid' ||
                textProps.getAttribute('style:text-underline-type') !== null,
            };
          }
        }
        return styleMap;
      }

      async function processOdtNode(node, zip) {
        const nodeName = node.nodeName;

        // Text Nodes
        if (node.nodeType === 3) {
          return node.textContent;
        }

        // Heading
        if (nodeName === 'text:h') {
          const level = node.getAttribute('text:outline-level') || 1;
          let content = await processChildNodes(node, zip);
          return `<h${level}>${content}</h${level}>`;
        }

        // Paragraph
        if (nodeName === 'text:p') {
          let content = await processChildNodes(node, zip);
          return `<p>${content}</p>`;
        }

        // Span (The primary container for bold/italic)
        if (nodeName === 'text:span') {
          const styleName = node.getAttribute('text:style-name');
          let content = await processChildNodes(node, zip);

          if (odtStyleMap[styleName]) {
            const s = odtStyleMap[styleName];
            if (s.bold) content = `<strong>${content}</strong>`;
            if (s.italic) content = `<em>${content}</em>`;
            if (s.underline) content = `<u>${content}</u>`;
          }
          return `<span>${content}</span>`;
        }

        // Line Break
        if (nodeName === 'text:line-break') {
          return '<br/>';
        }

        // Multiple Spaces
        if (nodeName === 'text:s') {
          const count = parseInt(node.getAttribute('text:c') || '1');
          return '&nbsp;'.repeat(count);
        }

        // Table
        if (nodeName === 'table:table') {
          let tableHtml = '<table class="odt-table">';
          const rows = node.getElementsByTagName('table:table-row');
          for (let row of rows) {
            tableHtml += '<tr>';
            const cells = row.getElementsByTagName('table:table-cell');
            for (let cell of cells) {
              // Tables can contain paragraphs, so we process children
              let cellContent = await processChildNodes(cell, zip);
              tableHtml += `<td>${cellContent}</td>`;
            }
            tableHtml += '</tr>';
          }
          return tableHtml + '</table>';
        }

        // Image Handling
        if (nodeName === 'draw:frame') {
          const imgNode = node.getElementsByTagName('draw:image')[0];
          if (imgNode) {
            const imgPath = imgNode.getAttribute('xlink:href');
            const imgFile = zip.file(imgPath.replace('./', '')); // Fix paths
            if (imgFile) {
              const base64 = await imgFile.async('base64');
              const ext = imgPath.split('.').pop();
              return `<img src="data:image/${ext};base64,${base64}" />`;
            }
          }
        }

        return '';
      }

      /**
       * Helper to process all children of a node recursively
       */
      async function processChildNodes(node, zip) {
        let html = '';
        if (node.childNodes) {
          for (let child of node.childNodes) {
            html += await processOdtNode(child, zip);
          }
        }
        return html;
      }

      function displayDocument(result) {
        const content = result.value;
        const documentContent = document.getElementById('documentContent');
        documentContent.innerHTML = sanitizeContent(content);
        handleLinks(documentContent);
        initFindToolbar();
      }

      function setupZoomLogic() {
        const documentContent = document.getElementById('documentContent');
        let extSettings = loadExtSettings('documentViewerSettings');
        let zoomLevel = 100;

        if (extSettings && extSettings.zoomLevel) {
          zoomLevel = Math.min(Math.max(extSettings.zoomLevel, 30), 500);
          documentContent.style.zoom = zoomLevel + '%';
        }

        document
          .getElementById('zoomInButton')
          .addEventListener('click', (e) => {
            e.stopPropagation();
            zoomLevel = Math.min(zoomLevel + 10, 500);
            applyZoom();
          });

        document
          .getElementById('zoomOutButton')
          .addEventListener('click', (e) => {
            e.stopPropagation();
            zoomLevel = Math.max(zoomLevel - 10, 30);
            applyZoom();
          });

        document
          .getElementById('zoomResetButton')
          .addEventListener('click', (e) => {
            zoomLevel = 100;
            applyZoom();
          });

        function applyZoom() {
          saveExtSettings('documentViewerSettings', { zoomLevel });
          documentContent.style.zoom = zoomLevel + '%';
        }
      }
    </script>
  </head>
  <body>
    <div id="findToolbarPlaceholder"></div>
    <div
      id="encyptedMessage"
      data-i18n="encryptedFileUseDownload"
      style="display: none; text-align: center; padding: 20px"
    ></div>
    <div id="documentContent"></div>
    <div id="aboutDialogPlaceholder"></div>
    <div id="extFabMenu" class="btn-group dropup-center dropup">
      <button
        type="button"
        class="btn btn-primary btn-lg"
        data-bs-toggle="dropdown"
        aria-expanded="false"
      >
        <svg
          class="bi"
          width="24"
          height="24"
          focusable="false"
          aria-hidden="true"
        >
          <path
            d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
          ></path>
        </svg>
      </button>
      <ul class="dropdown-menu">
        <li id="zoomContentMenuItemPlaceholder"></li>
        <li><hr class="dropdown-divider" /></li>
        <li id="exportAsHTMLMenuItemPlaceholder"></li>
        <li id="toggleFindMenuItemPlaceholder"></li>
        <li id="printMenuItemPlaceholder"></li>
        <li><hr class="dropdown-divider" /></li>
        <li id="aboutMenuItemPlaceholder"></li>
      </ul>
    </div>
  </body>
</html>
